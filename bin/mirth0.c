#define MIRTH_DEBUG 0
/* MIRTH HEADER */
// #line 3 "src/mirth.h"

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
#define MIRTH_WINDOWS 1
#elif defined(__linux__)
#define MIRTH_LINUX 1
#elif defined(__APPLE__)
#define MIRTH_MACOS 1
#else
#error "Platform not supported."
#endif

#if defined(__x86_64__) || defined(_M_X64)
#define MIRTH_AMD64
#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)
#define MIRTH_I386
#elif defined(__aarch64__) || defined(_M_ARM64)
#define MIRTH_ARM64
#else
#error "Architecture not supported."
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <float.h>

extern void* malloc(size_t);
extern void* calloc(size_t, size_t);
extern void* realloc(void*, size_t);
extern void* memset(void*, int, size_t);
extern void* memcpy(void*, const void*, size_t);
extern int memcmp(const void*, const void*, size_t);
extern int strcmp(const char*, const char*);
extern size_t strlen(const char*);
extern void free(void*);
extern int read(int, void*, size_t);
extern int write(int, const char*, size_t);
extern int close(int);
extern int open(const char*, int, ...);
extern void exit(int);
extern int sprintf (char * s, const char * format, ...);

typedef uint16_t TAG;
#define REFS_FLAG 	 0x8000
#define TUP_FLAG 	 0x4000
#define TUP_LEN_MASK 0x3FFF
#define TUP_LEN_MAX  0x3FFF

#define TAG_INT 1
#define TAG_PTR 1
#define TAG_STR (2 | REFS_FLAG)
#define TAG_FNPTR 3
#define TAG_F32 4
#define TAG_F64 5
#define TAG_TUP_NIL TUP_FLAG
#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)
#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (n))

typedef uint32_t REFS;
typedef uint64_t USIZE;
typedef void (*FNPTR)(void);

typedef union DATA {
	USIZE usize;
	uint64_t u64;
	uint32_t u32;
	uint16_t u16;
	uint8_t u8;
	int64_t i64;
	int32_t i32;
	int16_t i16;
	int8_t i8;
	float f32;
	double f64;
	void* ptr;
	FNPTR fnptr;
	REFS* refs;
	struct TUP* tup;
	struct STR* str;
} DATA;

typedef struct VAL {
	DATA data;
	TAG tag;
} VAL;

#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))

#define VREFS(v)  (*(v).data.refs)
#define VVAL(v)   (v)
#define VINT(v)   ((v).data.i64)
#define VI64(v)   ((v).data.i64)
#define VU64(v)   ((v).data.u64)
#define VBOOL(v)  ((_Bool)((v).data.u64))
#define VF32(v)   ((v).data.f32)
#define VF64(v)   ((v).data.f64)
#define VPTR(v)   ((v).data.ptr)
#define VFNPTR(v) ((v).data.fnptr)
#define VSTR(v)   ((v).data.str)
#define VTUP(v)   ((v).data.tup)
#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))

#define HAS_REFS(v) ((v).tag & REFS_FLAG)
#define IS_VAL(v)   (1)
#define IS_INT(v)   ((v).tag == TAG_INT)
#define IS_I64(v)   ((v).tag == TAG_INT)
#define IS_U64(v)   ((v).tag == TAG_INT)
#define IS_BOOL(v)  ((v).tag == TAG_INT)
#define IS_F32(v)   ((v).tag == TAG_F32)
#define IS_F64(v)   ((v).tag == TAG_F64)
#define IS_PTR(v)   ((v).tag == TAG_PTR)
#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)
#define IS_STR(v)   ((v).tag == TAG_STR)
#define IS_TUP(v)   ((v).tag & TUP_FLAG)
#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))

#define MKVAL(x)   (x)
#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})
#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKBOOL(x)  ((VAL){.tag=TAG_INT, .data={.u64=(x)}})
#define MKF32(x)   ((VAL){.tag=TAG_F32, .data={.f32=(x)}})
#define MKF64(x)   ((VAL){.tag=TAG_F64, .data={.f64=(x)}})
#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})
#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})
#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})
#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})
#define MKNIL_C	         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}
#define MKNIL      ((VAL)MKNIL_C)

#define STRLIT(x,n) \
	do { \
		static VAL mval = {0}; \
		if (!mval.tag) mval = mkstr(x,n); \
		incref(mval); \
		push_value(mval); \
	} while(0)

typedef uint16_t TUPLEN;
typedef struct TUP {
	REFS refs;
	TUPLEN cap;
	TUPLEN size;
	VAL cells[];
} TUP;

typedef struct STR {
	REFS refs;
	USIZE cap;
	USIZE size;
	char data[];
} STR;

#define STACK_MAX 0x80000
static USIZE stack_counter = STACK_MAX;
static VAL stack [STACK_MAX] = {0};
static USIZE rstack_counter = STACK_MAX;
static VAL rstack [STACK_MAX] = {0};

static int global_argc;
static char** global_argv;

static void push_value(VAL v);
static void mp_primZ_debug(void);
static void mp_primZ_rdebug(void);

#if MIRTH_DEBUG
	typedef struct LOC {
		FNPTR fnptr;
		const char* word;
		const char* path;
		USIZE line, col;
		const char* atom;
	} LOC;
	static USIZE fstack_counter = 0;
	static LOC fstack [STACK_MAX] = {
		{
			.fnptr=(void(*)(void))0,
			.word="<word>",
			.path="<path>",
			.line=0, .col=0,
			.atom="<atom>"
		},
	};

	#define WORD_ENTER(_f,_w,_p,_l,_c) \
		do { \
			fstack[fstack_counter].fnptr = (_f); \
			fstack[fstack_counter].word = (_w); \
			fstack[fstack_counter].path = (_p); \
			fstack[fstack_counter].line = (_l); \
			fstack[fstack_counter].col = (_c); \
			fstack[fstack_counter].atom = ""; \
			fstack_counter++; \
		} while(0)

	#define WORD_ATOM(_l,_c,_n) \
		do { \
			if (fstack_counter > 0) { \
				fstack[fstack_counter-1].line = (_l); \
				fstack[fstack_counter-1].col = (_c); \
				fstack[fstack_counter-1].atom = (_n); \
			} \
		} while(0)

	#define WORD_EXIT(_f) \
		do { \
			if ((fstack_counter == 0) || (fstack[fstack_counter-1].fnptr != (_f))) { \
				TRACE("mismatched WORD_EXIT, expected " #_f "\n"); \
				exit(1); \
			} \
			fstack_counter--; \
		} while(0)
	#define PRIM_ENTER(_f,_w) WORD_ENTER(_f,_w,__FILE__,__LINE__,1)
	#define PRIM_EXIT(_f) WORD_EXIT(_f)
#else
	#define PRIM_ENTER(_f,_w)
	#define PRIM_EXIT(_f)
#endif

#define TRACE(x) write(2,x,strlen(x))
#define _STR(x) #x
#define STR(x) _STR(x)

#define EXPECT(test,msg) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			mp_primZ_debug(); \
			mp_primZ_rdebug(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT1(test,msg,v1) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			mp_primZ_debug(); \
			mp_primZ_rdebug(); \
			exit(1); \
		} \
	} while(0)

#define EXPECT2(test,msg,v1,v2) \
	do { \
		if (!(test)) { \
			TRACE(msg "\n"); \
			push_value(v1); \
			push_value(v2); \
			mp_primZ_debug(); \
			mp_primZ_rdebug(); \
			exit(1); \
		} \
	} while(0)

#define ASSERT(test) \
	EXPECT(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")")
#define ASSERT1(test,v) \
	EXPECT1(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v)
#define ASSERT2(test,v1,v2) \
	EXPECT2(test, __FILE__ ":" STR(__LINE__) ": error: assertion failed (" #test ")", v1, v2)

#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)
#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)
static void free_value(VAL v) {
	ASSERT(HAS_REFS(v));
	ASSERT(VREFS(v) == 0);
	ASSERT1(IS_TUP(v)||IS_STR(v), v);
	if (IS_TUP(v)) {
		TUP* tup = VTUP(v);
		ASSERT(tup);
		for (TUPLEN i = 0; i < tup->size; i++) {
			decref(tup->cells[i]);
		}
		free(tup);
	} else if (IS_STR(v)) {
		STR* str = VSTR(v);
		ASSERT(str);
		free(str);
	}
}

static void value_uncons(VAL val, VAL* tail, VAL* head) {
	if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		ASSERT1((len > 0) && tup, val);
		VAL tailval = MKTUP(tup, len-1);
		VAL headval = tup->cells[len-1];
		if (len == 1) {
			incref(headval);
			decref(val);
			tailval = MKNIL;
		} else {
			if (tup->refs == 1) {
				for (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }
				memset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));
				tup->size = len-1;
			} else {
				incref(headval);
			}
			if (len == 2) {
				VAL ptval = tup->cells[0];
				if (!IS_TUP(ptval)) {
					incref(ptval);
					decref(tailval);
					tailval = ptval;
				}
			}
		}
		*tail = tailval;
		*head = headval;
	} else {
		*tail = MKNIL;
		*head = val;
	}
}

static uint64_t value_u64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VU64(v);
}

static int64_t value_i64 (VAL v) {
	ASSERT1(IS_INT(v),v);
	return VI64(v);
}

static float value_f32 (VAL v) {
	ASSERT1(IS_F32(v), v);
	return VF32(v);
}

static double value_f64 (VAL v) {
	ASSERT1(IS_F64(v), v);
	return VF64(v);
}

static void* value_ptr (VAL v) {
	ASSERT1(IS_PTR(v),v);
	return VPTR(v);
}

static FNPTR value_fnptr (VAL v) {
	ASSERT1(IS_FNPTR(v),v);
	return VFNPTR(v);
}

#define pop_u8() ((uint8_t)pop_u64())
#define pop_u16() ((uint16_t)pop_u64())
#define pop_u32() ((uint32_t)pop_u64())
#define pop_u64() (value_u64(pop_value()))
#define pop_i8() ((int8_t)pop_i64())
#define pop_i16() ((int16_t)pop_i64())
#define pop_i32() ((int32_t)pop_i64())
#define pop_i64() (value_i64(pop_value()))
#define pop_usize() (pop_u64())
#define pop_f32() (value_f32(pop_value()))
#define pop_f64() (value_f64(pop_value()))
#define pop_bool() ((bool)pop_u64())
#define pop_ptr() (value_ptr(pop_value()))
#define pop_fnptr() (value_fnptr(pop_value()))

#define push_u64(v) push_value(MKU64(v))
#define push_i64(v) push_value(MKI64(v))
#define push_usize(v) push_u64((uint64_t)(v))
#define push_bool(b) push_u64((uint64_t)((bool)(b)))
#define push_u8(b) push_u64((uint64_t)(b))
#define push_u16(b) push_u64((uint64_t)(b))
#define push_u32(b) push_u64((uint64_t)(b))
#define push_i8(b) push_i64((int64_t)(b))
#define push_i16(b) push_i64((int64_t)(b))
#define push_i32(b) push_i64((int64_t)(b))
#define push_f32(f) push_value(MKF32(f))
#define push_f64(f) push_value(MKF64(f))
#define push_ptr(p) push_value(MKPTR(p))
#define push_fnptr(p) push_value(MKFNPTR(p))

static void push_value(VAL x) {
	ASSERT(stack_counter > 0);
	stack[--stack_counter] = x;
}

static VAL top_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter];
}

static VAL pop_value(void) {
	ASSERT(stack_counter < STACK_MAX);
	return stack[stack_counter++];
}

static void push_resource(VAL x) {
	ASSERT(rstack_counter > 0);
	rstack[--rstack_counter] = x;
}

static VAL top_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter];
}

static VAL pop_resource(void) {
	ASSERT(rstack_counter < STACK_MAX);
	return rstack[rstack_counter++];
}

// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.
static TUP* tup_new (TUPLEN cap_hint) {
	if (cap_hint < 3) cap_hint = 3;
	if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
	TUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
	ASSERT(new_tup);
	new_tup->refs = 1;
	new_tup->cap = cap_hint;
	return new_tup;
}

// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.
// Consume old_tup and copy its elements over to the new tuple.
static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {
	ASSERT(old_tup);
	if (cap_hint < old_tup->size) cap_hint = old_tup->size;
	if (old_tup->refs == 1) {
		if (cap_hint < 3) cap_hint = 3;
		if (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;
		TUPLEN old_cap = old_tup->cap;
		TUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);
		ASSERT(new_tup);
		if (old_cap < cap_hint) {
			memset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));
		}
		new_tup->cap = cap_hint;
		return new_tup;
	} else {
		TUP* new_tup = tup_new(cap_hint);
		for (TUPLEN i = 0; i < old_tup->size; i++) {
			VAL v = old_tup->cells[i];
			new_tup->cells[i] = v;
			incref(v);
		}
		new_tup->size = old_tup->size;
		old_tup->refs--;
		return new_tup;
	}
}

static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {
	if (IS_TUP(tail) && HAS_REFS(tail)) {
		TUPLEN tail_len = VTUPLEN(tail);
		TUP *tail_tup = VTUP(tail);
		ASSERT1(tail_tup, tail);
		ASSERT1(tail_len <= tail_tup->size, tail);
		if (tail_len < tail_tup->size) {
			ASSERT1(tail_tup->refs >= 1, tail);
			if (tail_tup->refs == 1) {
				decref(tail_tup->cells[tail_len]);
				tail_tup->cells[tail_len] = head;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				VAL *cmp = &tail_tup->cells[tail_len];
				if (VALEQ(*cmp, head)) {
					decref(head);
					return MKTUP(tail_tup, tail_len+1);
				} else {
					if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
					TUP* new_tup = tup_new(cap_hint);
					for (TUPLEN i = 0; i < tail_len; i++) {
						VAL v = tail_tup->cells[i];
						new_tup->cells[i] = v;
						incref(v);
					}
					new_tup->cells[tail_len] = head;
					new_tup->size = tail_len+1;
					tail_tup->refs--;
					return MKTUP(new_tup, tail_len+1);
				}
			}
		} else {
			ASSERT1(tail_len < TUP_LEN_MAX, tail);
			ASSERT1(tail_len <= tail_tup->cap, tail);
			if (tail_len < tail_tup->cap) {
				tail_tup->cells[tail_len] = head;
				tail_tup->size = tail_len+1;
				return MKTUP(tail_tup, tail_len+1);
			} else {
				if (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;
				TUP* new_tup = tup_resize(tail_tup, cap_hint);
				ASSERT(tail_len < new_tup->cap);
				new_tup->size = tail_len+1;
				new_tup->cells[tail_len] = head;
				return MKTUP(new_tup, tail_len+1);
			}
		}
	} else if (IS_TUP(tail)) { // cons onto nil
		ASSERT(IS_NIL(tail));
		if (IS_TUP(head)) {
			TUP* tup = tup_new(cap_hint);
			tup->size = 1;
			tup->cells[0] = head;
			return MKTUP(tup,1);
		} else { // non-tup value pretends to be unary tuple
			return head;
		}
	} else { // cons onto non-tup value pretending to be unary tuple
		TUP* tup = tup_new(cap_hint);
		tup->size = 2;
		tup->cells[0] = tail;
		tup->cells[1] = head;
		return MKTUP(tup,2);
	}
}
static VAL mkcons(VAL tail, VAL head) {
	VAL v = mkcons_hint(tail,head,3);
	return v;
}

static VAL lpop(VAL* stk) {
	VAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);
	*stk=lcar; return lcdr;
}
static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }
#define LPOP(v) push_value(lpop(&(v)))
#define LPUSH(v) lpush(&(v),pop_value())
#define LPOPR(v) push_resource(lpop(&(v)))
#define LPUSHR(v) lpush(&(v),pop_resource())

static STR* str_alloc (USIZE cap) {
	ASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));
	EXPECT(str, "failed to allocate string");
	str->refs = 1;
	str->cap = cap;
	return str;
}

static VAL mkstr (const char* data, USIZE size) {
	ASSERT(data);
	ASSERT(size <= SIZE_MAX - sizeof(STR) - 4);
	STR* str = str_alloc(size);
	str->size = size;
	memcpy(str->data, data, (size_t)size);
	return MKSTR(str);
}

static void do_uncons(void) {
	VAL val, tail, head;
	val = pop_value();
	value_uncons(val, &tail, &head);
	push_value(tail);
	push_value(head);
}

static USIZE get_data_tag(VAL v) {
	if (IS_TUP(v)) {
		ASSERT(VTUPLEN(v) > 0);
		return VU64(VTUP(v)->cells[0]);
	} else {
		return VU64(v);
	}
}

static USIZE get_top_data_tag(void) {
	return get_data_tag(top_value());
}

static USIZE get_top_resource_data_tag(void) {
	return get_data_tag(top_resource());
}

static int str_cmp_(STR* s1, STR* s2) {
	ASSERT(s1 && s2);
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	USIZE n = (n1 < n2 ? n1 : n2);
	ASSERT(n < SIZE_MAX);
	int r = memcmp(s1->data, s2->data, (size_t)n);
	if (r) return r;
	if (n1 < n2) return -1;
	if (n1 > n2) return 1;
	return 0;
}

static void run_value(VAL v) {
	if (IS_TUP(v)) {
		VAL h = VTUP(v)->cells[0];
		ASSERT(IS_FNPTR(h));
		push_value(v);
		VFNPTR(h)();
	} else {
		ASSERT(IS_FNPTR(v));
		VFNPTR(v)();
	}
}

static void mp_primZ_id (void) {}
static void mp_primZ_dup (void) {
	PRIM_ENTER(mp_primZ_dup,"prim-dup");
	VAL v = top_value();
	push_value(v);
	incref(v);
	PRIM_EXIT(mp_primZ_dup);
}
static void mp_primZ_drop (void) {
	PRIM_ENTER(mp_primZ_drop,"prim-drop");
	VAL v = pop_value();
	decref(v);
	PRIM_EXIT(mp_primZ_drop);
}

static void mp_primZ_swap (void) {
	PRIM_ENTER(mp_primZ_swap,"prim-swap");
	VAL a = pop_value();
	VAL b = pop_value();
	push_value(a);
	push_value(b);
	PRIM_EXIT(mp_primZ_swap);
}

static void mp_primZ_rswap (void) {
	PRIM_ENTER(mp_primZ_rswap,"prim-rswap");
	VAL a = pop_resource();
	VAL b = pop_resource();
	push_resource(a);
	push_resource(b);
	PRIM_EXIT(mp_primZ_rswap);
}

static void mp_primZ_intZ_add (void) {
	PRIM_ENTER(mp_primZ_intZ_add,"prim-int-add");
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	if (b >= 0) {
		EXPECT(a <= INT64_MAX - b, "integer overflow during addition (too positive)");
	} else {
		EXPECT(a >= INT64_MIN - b, "integer overflow during addition (too negative)");
	}
	push_i64(a + b);
	PRIM_EXIT(mp_primZ_intZ_add);
}
static void mp_primZ_intZ_sub (void) {
	PRIM_ENTER(mp_primZ_intZ_sub,"prim-int-sub");
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	if (b >= 0) {
		EXPECT(a >= INT64_MIN + b, "integer overflow during subtraction (too negative)");
	} else {
		EXPECT(a <= INT64_MAX + b, "integer overflow during subtraction (too positive)");
	}
	push_i64(a - b);
	PRIM_EXIT(mp_primZ_intZ_sub);
}
static void mp_primZ_intZ_mul (void) {
	PRIM_ENTER(mp_primZ_intZ_mul,"prim-int-mul");
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	// overflow checks for multiplication
	push_i64(a * b);
	PRIM_EXIT(mp_primZ_intZ_mul);
}
static void mp_primZ_intZ_div (void) {
	PRIM_ENTER(mp_primZ_intZ_div,"prim-int-div");
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	EXPECT(b != 0, "divide by zero");
	EXPECT(!((b == -1) && (a == INT64_MIN)), "overflow during division");
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) q--;
	push_i64(q);
	PRIM_EXIT(mp_primZ_intZ_div);
}
static void mp_primZ_intZ_mod (void) {
	PRIM_ENTER(mp_primZ_intZ_mod,"prim-int-mod");
	int64_t b = pop_i64();
	int64_t a = pop_i64();
	EXPECT(b != 0, "divide by zero");
	if (b == -1) { push_i64(0); return; }
	int64_t r = a % b;
	int64_t q = a / b;
	if (((a < 0) ^ (b < 0)) && r) r += b;
	push_i64(r);
	PRIM_EXIT(mp_primZ_intZ_mod);
}

static void mp_primZ_intZ_and (void) {
	PRIM_ENTER(mp_primZ_intZ_and,"prim-int-and");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64(a & b);
	PRIM_EXIT(mp_primZ_intZ_and);
}
static void mp_primZ_intZ_or (void) {
	PRIM_ENTER(mp_primZ_intZ_or,"prim-int-or");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64(a | b);
	PRIM_EXIT(mp_primZ_intZ_or);
}
static void mp_primZ_intZ_xor (void) {
	PRIM_ENTER(mp_primZ_intZ_xor,"prim-int-xor");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64(a ^ b);
	PRIM_EXIT(mp_primZ_intZ_xor);
}
static void mp_primZ_intZ_shl (void) {
	PRIM_ENTER(mp_primZ_intZ_shl,"prim-int-shl");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64((b >= 64) ? 0 : (a << b));
	PRIM_EXIT(mp_primZ_intZ_shl);
}
static void mp_primZ_intZ_shr (void) {
	PRIM_ENTER(mp_primZ_intZ_shr,"prim-int-shr");
	uint64_t b = pop_u64();
	uint64_t a = pop_u64();
	push_u64((b >= 64) ? 0 : (a >> b));
	PRIM_EXIT(mp_primZ_intZ_shr);
}

static void mp_primZ_intZ_eq (void) {
	PRIM_ENTER(mp_primZ_intZ_eq,"prim-int-eq");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT1(IS_INT(a), a);
	ASSERT1(IS_INT(b), a);
	push_bool(VINT(a) == VINT(b));
	PRIM_EXIT(mp_primZ_intZ_eq);
}
static void mp_primZ_intZ_lt (void) {
	PRIM_ENTER(mp_primZ_intZ_lt,"prim-int-lt");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT2(IS_INT(a) && IS_INT(b), a, b);
	push_bool(VINT(a) < VINT(b));
	PRIM_EXIT(mp_primZ_intZ_lt);
}

static void mp_primZ_f32Z_toZ_f64 (void) {
	PRIM_ENTER(mp_primZ_f32Z_toZ_f64, "prim-f32-to-f64");
	float x = pop_f32();
	push_f64((double)x);
	PRIM_EXIT(mp_primZ_f32Z_toZ_f64);
}

static void mp_primZ_f64Z_toZ_f32 (void) {
	PRIM_ENTER(mp_primZ_f64Z_toZ_f32, "prim-f64-to-f32");
	double x = pop_f64();
	push_f32((float)x);
	PRIM_EXIT(mp_primZ_f64Z_toZ_f32);
}

static void mp_primZ_intZ_toZ_f32 (void) {
	PRIM_ENTER(mp_primZ_intZ_toZ_f32, "prim-int-to-f32");
	int64_t i = pop_i64();
	push_f32((float)i);
	PRIM_EXIT(mp_primZ_intZ_toZ_f32);
}

static void mp_primZ_f32Z_toZ_int (void) {
	PRIM_ENTER(mp_primZ_f32Z_toZ_int, "prim-f32-to-int");
	float d = pop_f32();
	push_i64((int64_t)d);
	PRIM_EXIT(mp_primZ_f32Z_toZ_int);
}

static void mp_primZ_intZ_toZ_f64 (void) {
	PRIM_ENTER(mp_primZ_intZ_toZ_f64, "prim-int-to-f64");
	int64_t i = pop_i64();
	push_f64((double)i);
	PRIM_EXIT(mp_primZ_intZ_toZ_f64);
}

static void mp_primZ_f64Z_toZ_int (void) {
	PRIM_ENTER(mp_primZ_f64Z_toZ_int, "prim-f64-to-int");
	double d = pop_f64();
	push_i64((int64_t)d);
	PRIM_EXIT(mp_primZ_f64Z_toZ_int);
}

static void mp_primZ_strZ_cmp (void) {
	PRIM_ENTER(mp_primZ_strZ_cmp,"prim-str-cmp");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT2(IS_STR(a) && IS_STR(b), a, b);
	int64_t cmp = str_cmp_(VSTR(a), VSTR(b));
	push_i64(cmp);
	decref(a); decref(b);
	PRIM_EXIT(mp_primZ_strZ_cmp);
}

static void mp_primZ_f32Z_eq (void) {
	PRIM_ENTER(mp_primZ_f32Z_eq,"prim-f32-eq");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT1(IS_F32(a), a);
	ASSERT1(IS_F32(b), a);
	push_bool(VF32(a) == VF32(b));
	PRIM_EXIT(mp_primZ_f32Z_eq);
}
static void mp_primZ_f32Z_lt (void) {
	PRIM_ENTER(mp_primZ_f32Z_lt,"prim-f32-lt");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT2(IS_F32(a) && IS_F32(b), a, b);
	push_bool(VF32(a) < VF32(b));
	PRIM_EXIT(mp_primZ_f32Z_lt);
}

static void mp_primZ_f32Z_add (void) {
	PRIM_ENTER(mp_primZ_f32Z_add,"prim-f32-add");
	double b = pop_f32();
	double a = pop_f32();
	push_f32(a + b);
	PRIM_EXIT(mp_primZ_f32Z_add);
}

static void mp_primZ_f32Z_sub (void) {
	PRIM_ENTER(mp_primZ_f32Z_sub,"prim-f32-sub");
	double b = pop_f32();
	double a = pop_f32();
	push_f32(a - b);
	PRIM_EXIT(mp_primZ_f32Z_sub);
}

static void mp_primZ_f32Z_mul (void) {
	PRIM_ENTER(mp_primZ_f32Z_mul,"prim-f32-mul");
	double b = pop_f32();
	double a = pop_f32();
	push_f32(a * b);
	PRIM_EXIT(mp_primZ_f32Z_mul);
}

static void mp_primZ_f32Z_div (void) {
	PRIM_ENTER(mp_primZ_f32Z_div,"prim-f32-div");
	double b = pop_f32();
	double a = pop_f32();
	push_f32(a / b);
	PRIM_EXIT(mp_primZ_f32Z_div);
}

static void mp_primZ_f32Z_toZ_str (void) {
	PRIM_ENTER(mp_primZ_f32Z_toZ_str, "prim-f32-to-str");
	double d = pop_f32();
	char result[DBL_DIG+32] = {0};
	int len = sprintf(result,"%.*g", DBL_DIG,  d);
	push_value(mkstr(result, len));
	PRIM_EXIT(mp_primZ_f32Z_toZ_str);
}

static void mp_primZ_f64Z_eq (void) {
	PRIM_ENTER(mp_primZ_f64Z_eq,"prim-f64-eq");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT1(IS_F64(a), a);
	ASSERT1(IS_F64(b), a);
	push_bool(VF64(a) == VF64(b));
	PRIM_EXIT(mp_primZ_f64Z_eq);
}
static void mp_primZ_f64Z_lt (void) {
	PRIM_ENTER(mp_primZ_f64Z_lt,"prim-f64-lt");
	VAL b = pop_value();
	VAL a = pop_value();
	ASSERT2(IS_F64(a) && IS_F64(b), a, b);
	push_bool(VF64(a) < VF64(b));
	PRIM_EXIT(mp_primZ_f64Z_lt);
}

static void mp_primZ_f64Z_add (void) {
	PRIM_ENTER(mp_primZ_f64Z_add,"prim-f64-add");
	double b = pop_f64();
	double a = pop_f64();
	push_f64(a + b);
	PRIM_EXIT(mp_primZ_f64Z_add);
}

static void mp_primZ_f64Z_sub (void) {
	PRIM_ENTER(mp_primZ_f64Z_sub,"prim-f64-sub");
	double b = pop_f64();
	double a = pop_f64();
	push_f64(a - b);
	PRIM_EXIT(mp_primZ_f64Z_sub);
}

static void mp_primZ_f64Z_mul (void) {
	PRIM_ENTER(mp_primZ_f64Z_mul,"prim-f64-mul");
	double b = pop_f64();
	double a = pop_f64();
	push_f64(a * b);
	PRIM_EXIT(mp_primZ_f64Z_mul);
}

static void mp_primZ_f64Z_div (void) {
	PRIM_ENTER(mp_primZ_f64Z_div,"prim-f64-div");
	double b = pop_f64();
	double a = pop_f64();
	push_f64(a / b);
	PRIM_EXIT(mp_primZ_f64Z_div);
}

static void mp_primZ_f64Z_toZ_str (void) {
	PRIM_ENTER(mp_primZ_f64Z_toZ_str, "prim-f64-to-str");
	double d = pop_f64();
	char result[DBL_DIG+32] = {0};
	int len = sprintf(result,"%.*g", DBL_DIG,  d);
	push_value(mkstr(result, len));
	PRIM_EXIT(mp_primZ_f64Z_toZ_str);
}

static void mp_primZ_sysZ_argc (void) {
	PRIM_ENTER(mp_primZ_sysZ_argc,"prim-sys-argc");
	push_i64(global_argc);
	PRIM_EXIT(mp_primZ_sysZ_argc);
}
static void mp_primZ_sysZ_argv (void) {
	PRIM_ENTER(mp_primZ_sysZ_argv,"prim-sys-argv");
	push_ptr(global_argv);
	PRIM_EXIT(mp_primZ_sysZ_argv);
}

void int_repr(int64_t y, char** out_ptr, size_t *out_size) {
	static char c[32] = {0};
	memset(c, 0, 32);
	char* p = c+30;
	size_t n = 0;
	uint64_t x;
	if (y < 0) {
		if (y == INT64_MIN) {
			x = 1+(uint64_t)INT64_MAX;
		} else {
			x = (uint64_t)-y;
		}
	} else {
		x = (uint64_t)y;
	}
	do {
		*--p = '0' + (x % 10);
		x /= 10;
		n++;
	} while (x);
	if (y < 0) {
		*--p = '-';
		n++;
	}
	*out_ptr = p;
	*out_size = n;
}

void int_trace_(int64_t y, int fd) {
	char* p; size_t n;
	int_repr(y, &p, &n);
	write(fd, p, n);
}

void mp_primZ_intZ_toZ_str(void) {
	PRIM_ENTER(mp_primZ_intZ_toZ_str,"prim-int-to-str");
	int64_t x = pop_i64();
	bool cache = (0 <= x) && (x <= 255);
	static VAL scache[256] = {0};
	if (cache && scache[x].tag) {
		incref(scache[x]);
		push_value(scache[x]);
	} else {
		char* p; size_t n;
		int_repr(x,&p,&n);
		VAL out = mkstr(p,n);
		push_value(out);
		if (cache) {
			scache[x] = out;
			incref(out);
		}
	}
	PRIM_EXIT(mp_primZ_intZ_toZ_str);
}

void str_trace_(STR* str, int fd) {
	ASSERT(str->size <= SIZE_MAX);
	write(fd, "\"", 1);
	USIZE i0 = 0;
	char xb[4]={'\\','x'};
	USIZE i;
	for (i = 0; i < str->size; i++) {
		const char* c = NULL; size_t n=0;
		uint8_t v=str->data[i];
		switch(v) {
			case '\n': c="\\n"; n=2; break;
			case '\r': c="\\r"; n=2; break;
			case '\t': c="\\t"; n=2; break;
			case '\\': c="\\\\"; n=2; break;
			case '\"': c="\\\""; n=2; break;
			default:
				if (!((' ' <= v) && (v < 0x7F))) {
					xb[2] = '0' + (v&15) + ('A'-'9'-1)*((v&15) > 9);
					xb[3] = '0' + (v/16) + ('A'-'9'-1)*((v/16) > 9);
					c=xb; n=4;
				}
		}
		if ((n > 0) && (i0 < i)) {
			write(fd, str->data+i0, (size_t)(i-i0));
			i0=i+1;
		}
		write(fd, c, n);
	}
	if (i0 < i) write(fd, str->data+i0, (size_t)(i-i0));
	write(fd, "\"", 1);
}

void value_trace_(VAL val, int fd) {
	if (IS_INT(val)) {
		int_trace_(VINT(val), fd);
	} else if (IS_STR(val)) {
		str_trace_(VSTR(val), fd);
	} else if (IS_FNPTR(val)) {
		write(fd, "<fnptr>", 7);
	} else if (IS_TUP(val)) {
		TUPLEN len = VTUPLEN(val);
		TUP* tup = VTUP(val);
		if (VTUPLEN(val) == 0) {
			write(fd, "[]", 2);
		} else {
			write(fd, "[ ", 2);
			for(TUPLEN i = 0; i < len; i++) {
				if (i > 0) write(fd, " ", 1);
				value_trace_(tup->cells[i], fd);
			}
			write(fd, " ]", 2);
		}
	} else {
		TRACE("value cannot be traced");
		exit(1);
	}
}

static void mp_primZ_debug (void) {
	TRACE("??");
	for (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {
		TRACE(" ");
		value_trace_(stack[i], 2);
	}
	TRACE("\n");
}

static void mp_primZ_rdebug (void) {
	#if MIRTH_DEBUG
		TRACE("call stack:\n");
		for (USIZE i = fstack_counter; i --> 1;) {
			TRACE("    ");
			if (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {
				TRACE(fstack[i-1].atom);
				TRACE(" -> ");
			}
			TRACE(fstack[i].word);
			TRACE(" at ");
			TRACE(fstack[i-1].path);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].line, 2);
			TRACE(":");
			int_trace_((int64_t)fstack[i-1].col, 2);
			TRACE("\n");
		}
	#endif
}

static void mp_primZ_panic(void) {
	if ((stack_counter > 0) && IS_STR(top_value())) {
		VAL v = pop_value();
		size_t n = (VSTR(v)->size < 2048) ? (size_t)(VSTR(v)->size) : 2048;
		write(2, VSTR(v)->data, n);
		TRACE("\n");
	} else {
		TRACE("panic!\n");
	}
	mp_primZ_debug();
	mp_primZ_rdebug();
	exit(1);
}

static void mp_primZ_ptrZ_get (void) {
	PRIM_ENTER(mp_primZ_ptrZ_get,"prim-ptr-get");
	VAL vp = pop_value();
	void **p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_ptr(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_ptrZ_get);
}

static void mp_primZ_u8Z_get (void) {
	PRIM_ENTER(mp_primZ_u8Z_get,"prim-u8-get");
	VAL vp = pop_value();
	uint8_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u8(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_u8Z_get);
}

static void mp_primZ_u16Z_get (void) {
	PRIM_ENTER(mp_primZ_u16Z_get,"prim-u16-get");
	VAL vp = pop_value();
	uint16_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u16(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_u16Z_get);
}

static void mp_primZ_u32Z_get (void) {
	PRIM_ENTER(mp_primZ_u32Z_get,"prim-u32-get");
	VAL vp = pop_value();
	uint32_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u32(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_u32Z_get);
}

static void mp_primZ_u64Z_get (void) {
	PRIM_ENTER(mp_primZ_u64Z_get,"prim-u64-get");
	VAL vp = pop_value();
	uint64_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_u64(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_u64Z_get);
}

static void mp_primZ_i8Z_get (void) {
	PRIM_ENTER(mp_primZ_i8Z_get,"prim-i8-get");
	VAL vp = pop_value();
	int8_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i8(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_i8Z_get);
}

static void mp_primZ_i16Z_get (void) {
	PRIM_ENTER(mp_primZ_i16Z_get,"prim-i16-get");
	VAL vp = pop_value();
	int16_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i16(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_i16Z_get);
}

static void mp_primZ_i32Z_get (void) {
	PRIM_ENTER(mp_primZ_i32Z_get,"prim-i32-get");
	VAL vp = pop_value();
	int32_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i32(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_i32Z_get);
}

static void mp_primZ_i64Z_get (void) {
	PRIM_ENTER(mp_primZ_i64Z_get,"prim-i64-get");
	VAL vp = pop_value();
	int64_t *p = value_ptr(vp);
	EXPECT(p, "tried to load from null pointer");
	push_i64(*p);
	decref(vp);
	PRIM_EXIT(mp_primZ_i64Z_get);
}

static void mp_primZ_intZ_set (void) {
	PRIM_ENTER(mp_primZ_intZ_set,"prim-int-set");
	VAL vp = pop_value();
	int64_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i64();
	decref(vp);
	PRIM_EXIT(mp_primZ_intZ_set);
}

static void mp_primZ_ptrZ_set (void) {
	PRIM_ENTER(mp_primZ_ptrZ_set,"prim-ptr-set");
	VAL vp = pop_value();
	void **p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_ptr();
	decref(vp);
	PRIM_EXIT(mp_primZ_ptrZ_set);
}

static void mp_primZ_u8Z_set (void) {
	PRIM_ENTER(mp_primZ_u8Z_set,"prim-u8-set");
	VAL vp = pop_value();
	uint8_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u8();
	decref(vp);
	PRIM_EXIT(mp_primZ_u8Z_set);
}

static void mp_primZ_u16Z_set (void) {
	PRIM_ENTER(mp_primZ_u16Z_set,"prim-u16-set");
	VAL vp = pop_value();
	uint16_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u16();
	decref(vp);
	PRIM_EXIT(mp_primZ_u16Z_set);
}

static void mp_primZ_u32Z_set (void) {
	PRIM_ENTER(mp_primZ_u32Z_set,"prim-u32-set");
	VAL vp = pop_value();
	uint32_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u32();
	decref(vp);
	PRIM_EXIT(mp_primZ_u32Z_set);
}

static void mp_primZ_u64Z_set (void) {
	PRIM_ENTER(mp_primZ_u64Z_set,"prim-u64-set");
	VAL vp = pop_value();
	uint64_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_u64();
	decref(vp);
	PRIM_EXIT(mp_primZ_u64Z_set);
}

static void mp_primZ_i8Z_set (void) {
	PRIM_ENTER(mp_primZ_i8Z_set,"prim-i8-set");
	VAL vp = pop_value();
	int8_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i8();
	decref(vp);
	PRIM_EXIT(mp_primZ_i8Z_set);
}

static void mp_primZ_i16Z_set (void) {
	PRIM_ENTER(mp_primZ_i16Z_set,"prim-i16-set");
	VAL vp = pop_value();
	int16_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i16();
	decref(vp);
	PRIM_EXIT(mp_primZ_i16Z_set);
}

static void mp_primZ_i32Z_set (void) {
	PRIM_ENTER(mp_primZ_i32Z_set,"prim-i32-set");
	VAL vp = pop_value();
	int32_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i32();
	decref(vp);
	PRIM_EXIT(mp_primZ_i32Z_set);
}

static void mp_primZ_i64Z_set (void) {
	PRIM_ENTER(mp_primZ_i64Z_set,"prim-i64-set");
	VAL vp = pop_value();
	int64_t *p = value_ptr(vp);
	EXPECT(p, "tried to write to null pointer");
	*p = pop_i64();
	decref(vp);
	PRIM_EXIT(mp_primZ_i64Z_set);
}


#if defined(MIRTH_WINDOWS)
#define mp_primZ_sysZ_os() push_u64(1)
#elif defined(MIRTH_LINUX)
#define mp_primZ_sysZ_os() push_u64(2)
#elif defined(MIRTH_MACOS)
#define mp_primZ_sysZ_os() push_u64(3)
#else
#define mp_primZ_sysZ_os() push_u64(0)
#endif

#if defined(MIRTH_I386)
#define mp_primZ_sysZ_arch() push_u64(1)
#elif defined(MIRTH_AMD64)
#define mp_primZ_sysZ_arch() push_u64(2)
#elif defined(MIRTH_ARM64)
#define mp_primZ_sysZ_arch() push_u64(3)
#else
#define mp_primZ_sysZ_arch() push_u64(0)
#endif

static void mp_primZ_run (void) {
	PRIM_ENTER(mp_primZ_run,"prim-run");
	VAL f = pop_value();
	run_value(f);
	PRIM_EXIT(mp_primZ_run);
}

static void mp_primZ_ptrZ_nil (void) {
	PRIM_ENTER(mp_primZ_ptrZ_nil,"prim-ptr-nil");
	push_ptr((void*)0);
	PRIM_EXIT(mp_primZ_ptrZ_nil);
}
static void mp_primZ_ptrZ_eq (void) {
	PRIM_ENTER(mp_primZ_ptrZ_eq,"prim-ptr-eq");
	void* a = pop_ptr();
	void* b = pop_ptr();
	push_bool(a == b);
	PRIM_EXIT(mp_primZ_ptrZ_eq);
}
static void mp_primZ_ptrZ_add (void) {
	PRIM_ENTER(mp_primZ_ptrZ_add,"prim-ptr-add");
	VAL vptr = pop_value();
	USIZE n = pop_usize();
	ASSERT1(IS_PTR(vptr), vptr);
	EXPECT(VPTR(vptr), "attempt to add to null pointer");
	char* ptr = (char*)VPTR(vptr);
	push_ptr(ptr + n);
	PRIM_EXIT(mp_primZ_ptrZ_add);
}
#define mp_primZ_ptrZ_sizze() push_u64((uint64_t)sizeof(void*))
static void mp_primZ_ptrZ_alloc (void) {
	PRIM_ENTER(mp_primZ_ptrZ_alloc,"prim-ptr-alloc");
	USIZE n = pop_usize();
	void* p = malloc((size_t)n);
	EXPECT(p, "failed to allocate buffer");
	push_ptr(p);
	PRIM_EXIT(mp_primZ_ptrZ_alloc);
}
static void mp_primZ_ptrZ_realloc (void) {
	PRIM_ENTER(mp_primZ_ptrZ_realloc,"prim-ptr-realloc");
	USIZE n = pop_usize();
	void* p0 = pop_ptr();
	void* p1 = realloc(p0, (size_t)n);
	EXPECT(p1, "failed to reallocate buffer");
	push_ptr(p1);
	PRIM_EXIT(mp_primZ_ptrZ_realloc);
}
static void mp_primZ_ptrZ_free (void) {
	PRIM_ENTER(mp_primZ_ptrZ_free,"prim-ptr-free");
	void* p = pop_ptr();
	free(p);
	PRIM_EXIT(mp_primZ_ptrZ_free);
}

static void mp_primZ_ptrZ_copy (void) {
	PRIM_ENTER(mp_primZ_ptrZ_copy,"prim-ptr-copy");
	VAL vdst = pop_value();
	int64_t ilen = pop_i64();
	VAL vsrc = pop_value();
	ASSERT2(IS_PTR(vsrc) && IS_PTR(vdst), vsrc, vdst);
	void* src = value_ptr(vsrc);
	void* dst = value_ptr(vdst);
	if (src && dst && (ilen > 0)) {
		ASSERT((USIZE)ilen <= SIZE_MAX);
		memcpy(dst, src, (size_t)ilen);
	}
	PRIM_EXIT(mp_primZ_ptrZ_copy);
}

static void mp_primZ_ptrZ_fill (void) {
	PRIM_ENTER(mp_primZ_ptrZ_fill,"prim-ptr-fill");
	VAL vdst = pop_value();
	ASSERT1(IS_PTR(vdst), vdst);
	int64_t ilen = pop_i64();
	uint64_t val = pop_u64();
	void* dst = value_ptr(vdst);
	if (dst && (ilen > 0)) {
		ASSERT((USIZE)ilen <= SIZE_MAX);
		memset(dst, (int)val, (size_t)ilen);
	}
	PRIM_EXIT(mp_primZ_ptrZ_fill);
}

static void mp_primZ_strZ_copy (void) {
	PRIM_ENTER(mp_primZ_strZ_copy,"prim-str-copy");
	USIZE size = pop_usize();
	char* ptr = (char*)pop_ptr();
	ASSERT(size <= SIZE_MAX-sizeof(STR)-4);
	ASSERT(ptr);
	push_value(mkstr(ptr, size));
	PRIM_EXIT(mp_primZ_strZ_copy);
}

static void mp_primZ_strZ_cat (void) {
	PRIM_ENTER(mp_primZ_strZ_cat,"prim-str-cat");
	VAL v2 = pop_value();
	VAL v1 = pop_value();
	ASSERT2(IS_STR(v1) && IS_STR(v2), v1, v2);
	STR* s1 = VSTR(v1);
	STR* s2 = VSTR(v2);
	USIZE m = s1->cap;
	USIZE n1 = s1->size;
	USIZE n2 = s2->size;
	if ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {
		ASSERT(n2 <= SIZE_MAX);
		memcpy(s1->data + n1, s2->data, (size_t)n2);
		s1->size += n2;
		ASSERT(s1->size + 4 <= s1->cap);
		push_value(v1);
		decref(v2);
	} else {
		USIZE m2 = n1 + n2 + 4;
		if ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;
		STR* str = str_alloc(m2);
		str->size = n1+n2;
		ASSERT(n1 <= SIZE_MAX);
		ASSERT(n2 <= SIZE_MAX);
		memcpy(str->data, s1->data, (size_t)n1);
		memcpy(str->data+n1, s2->data, (size_t)n2);
		push_value(MKSTR(str));
		decref(v1);
		decref(v2);
	}
	PRIM_EXIT(mp_primZ_strZ_cat);
}

static void mp_primZ_strZ_base (void) {
	PRIM_ENTER(mp_primZ_strZ_base,"prim-str-base");
	VAL vstr = pop_value();
	ASSERT1(IS_STR(vstr) && VSTR(vstr), vstr);
	push_ptr(VSTR(vstr)->data);
	decref(vstr);
	PRIM_EXIT(mp_primZ_strZ_base);
}

static void mp_primZ_strZ_numZ_bytes (void) {
	PRIM_ENTER(mp_primZ_strZ_numZ_bytes,"prim-str-num-bytes");
	VAL v = pop_value();
	ASSERT(IS_STR(v) && VSTR(v));
	push_usize(VSTR(v)->size);
	decref(v);
	PRIM_EXIT(mp_primZ_strZ_numZ_bytes);
}

static void mp_primZ_packZ_nil (void) {
	PRIM_ENTER(mp_primZ_packZ_nil,"prim-pack-nil");
	push_value(MKNIL);
	PRIM_EXIT(mp_primZ_packZ_nil);
}

static void mp_primZ_packZ_cons (void) {
	PRIM_ENTER(mp_primZ_packZ_cons,"prim-pack-cons");
	VAL cdr = pop_value();
	VAL car = pop_value();
	push_value(mkcons(car,cdr));
	PRIM_EXIT(mp_primZ_packZ_cons);
}

static void mp_primZ_packZ_uncons (void) {
	PRIM_ENTER(mp_primZ_packZ_uncons,"prim-pack-uncons");
	do_uncons();
	PRIM_EXIT(mp_primZ_packZ_uncons);
}

static void mp_primZ_mutZ_get (void) {
	PRIM_ENTER(mp_primZ_mutZ_get,"prim-mut-get");
	VAL mut = pop_value();
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL v = *(VAL*)VPTR(mut);
	EXPECT(v.tag, "tried to read uninitialized value");
	push_value(v);
	incref(v);
	PRIM_EXIT(mp_primZ_mutZ_get);
}
static void mp_primZ_mutZ_set (void) {
	PRIM_ENTER(mp_primZ_mutZ_set,"prim-mut-set");
	VAL mut = pop_value();
	VAL newval = pop_value();
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL oldval = *(VAL*)VPTR(mut);
	*(VAL*)VPTR(mut) = newval;
	if (oldval.tag) {
		decref(oldval);
	}
	decref(mut);
	PRIM_EXIT(mp_primZ_mutZ_set);
}
static void mp_primZ_mutZ_isZ_set (void) {
	PRIM_ENTER(mp_primZ_mutZ_isZ_set,"prim-mut-is-set");
	VAL mut = pop_value();
	ASSERT1(IS_PTR(mut) && VPTR(mut), mut);
	VAL val = *(VAL*)VPTR(mut);
	push_bool(val.tag);
	decref(mut);
	PRIM_EXIT(mp_primZ_mutZ_isZ_set);
}

/* GENERATED C99 */

static VAL lbl_emitZ_debugZ_info = MKNIL_C;
static VAL lbl_inputZ_file = MKNIL_C;
static VAL lbl_outputZ_file = MKNIL_C;
static VAL lbl_entryZ_point = MKNIL_C;
static VAL lbl_packages = MKNIL_C;
static VAL lbl_packageZ_searchZ_paths = MKNIL_C;
static VAL lbl_outputZ_path = MKNIL_C;
static VAL lbl_name = MKNIL_C;
static VAL lbl_flagZ_type = MKNIL_C;
static VAL lbl_argZ_doc = MKNIL_C;
static VAL lbl_doc = MKNIL_C;
static VAL lbl_group = MKNIL_C;
static VAL lbl_options = MKNIL_C;
static VAL lbl_parser = MKNIL_C;
static VAL lbl_argsZ_doc = MKNIL_C;
static VAL lbl_x1 = MKNIL_C;
static VAL lbl_x2 = MKNIL_C;
static VAL lbl_x3 = MKNIL_C;
static VAL lbl_x4 = MKNIL_C;
static VAL lbl_escapeZ_hex = MKNIL_C;
static VAL lbl_sizze = MKNIL_C;
static VAL lbl_base = MKNIL_C;
static VAL lbl_oldZ_sizze = MKNIL_C;
static VAL lbl_fileZ_descriptor = MKNIL_C;
static VAL lbl_owned = MKNIL_C;
static VAL lbl_ZPlusfile = MKNIL_C;
static VAL lbl_ZPlusbuffer = MKNIL_C;
static VAL lbl_length = MKNIL_C;
static VAL lbl_offset = MKNIL_C;
static VAL lbl_ZPlusworld = MKNIL_C;
static VAL lbl_numZ_tests = MKNIL_C;
static VAL lbl_numZ_failed = MKNIL_C;
static VAL lbl_testZ_name = MKNIL_C;
static VAL lbl_testZ_failed = MKNIL_C;
static VAL lbl_ZPlustests = MKNIL_C;
static VAL lbl_colZ_offset = MKNIL_C;
static VAL lbl_argumentZ_parser = MKNIL_C;
static VAL lbl_state = MKNIL_C;
static VAL lbl_docZ_length = MKNIL_C;
static VAL lbl_argv = MKNIL_C;
static VAL lbl_programZ_name = MKNIL_C;
static VAL lbl_argvZ_info = MKNIL_C;
static VAL lbl_parsingZAsk = MKNIL_C;
static VAL lbl_option = MKNIL_C;
static VAL lbl_optionZ_option = MKNIL_C;
static VAL lbl_arg = MKNIL_C;
static VAL lbl_arguments = MKNIL_C;
static VAL lbl_positionalZ_index = MKNIL_C;
static VAL lbl_longestZ_argZ_length = MKNIL_C;
static VAL lbl_error = MKNIL_C;
static VAL lbl_namespace = MKNIL_C;
static VAL lbl_arity = MKNIL_C;
static VAL lbl_std = MKNIL_C;
static VAL lbl_prim = MKNIL_C;
static VAL lbl_bool = MKNIL_C;
static VAL lbl_true = MKNIL_C;
static VAL lbl_false = MKNIL_C;
static VAL lbl_u64 = MKNIL_C;
static VAL lbl_mkZ_u64 = MKNIL_C;
static VAL lbl_u32 = MKNIL_C;
static VAL lbl_mkZ_u32 = MKNIL_C;
static VAL lbl_u16 = MKNIL_C;
static VAL lbl_mkZ_u16 = MKNIL_C;
static VAL lbl_u8 = MKNIL_C;
static VAL lbl_mkZ_u8 = MKNIL_C;
static VAL lbl_i64 = MKNIL_C;
static VAL lbl_mkZ_i64 = MKNIL_C;
static VAL lbl_i32 = MKNIL_C;
static VAL lbl_mkZ_i32 = MKNIL_C;
static VAL lbl_i16 = MKNIL_C;
static VAL lbl_mkZ_i16 = MKNIL_C;
static VAL lbl_i8 = MKNIL_C;
static VAL lbl_mkZ_i8 = MKNIL_C;
static VAL lbl_cchar = MKNIL_C;
static VAL lbl_mkZ_cchar = MKNIL_C;
static VAL lbl_cichar = MKNIL_C;
static VAL lbl_mkZ_cichar = MKNIL_C;
static VAL lbl_cshort = MKNIL_C;
static VAL lbl_mkZ_cshort = MKNIL_C;
static VAL lbl_cint = MKNIL_C;
static VAL lbl_mkZ_cint = MKNIL_C;
static VAL lbl_clong = MKNIL_C;
static VAL lbl_mkZ_clong = MKNIL_C;
static VAL lbl_clonglong = MKNIL_C;
static VAL lbl_mkZ_clonglong = MKNIL_C;
static VAL lbl_cisizze = MKNIL_C;
static VAL lbl_mkZ_cisizze = MKNIL_C;
static VAL lbl_cintptr = MKNIL_C;
static VAL lbl_mkZ_cintptr = MKNIL_C;
static VAL lbl_cuchar = MKNIL_C;
static VAL lbl_mkZ_cuchar = MKNIL_C;
static VAL lbl_cushort = MKNIL_C;
static VAL lbl_mkZ_cushort = MKNIL_C;
static VAL lbl_cuint = MKNIL_C;
static VAL lbl_mkZ_cuint = MKNIL_C;
static VAL lbl_culong = MKNIL_C;
static VAL lbl_mkZ_culong = MKNIL_C;
static VAL lbl_culonglong = MKNIL_C;
static VAL lbl_mkZ_culonglong = MKNIL_C;
static VAL lbl_cusizze = MKNIL_C;
static VAL lbl_mkZ_cusizze = MKNIL_C;
static VAL lbl_cuintptr = MKNIL_C;
static VAL lbl_mkZ_cuintptr = MKNIL_C;
static VAL lbl_cptr = MKNIL_C;
static VAL lbl_mkZ_cptr = MKNIL_C;
static VAL lbl_cconst = MKNIL_C;
static VAL lbl_mkZ_cconst = MKNIL_C;
static VAL lbl_crestrict = MKNIL_C;
static VAL lbl_mkZ_crestrict = MKNIL_C;
static VAL lbl_cvolatile = MKNIL_C;
static VAL lbl_mkZ_cvolatile = MKNIL_C;
static VAL lbl_cvoid = MKNIL_C;
static VAL lbl_mkZ_cvoid = MKNIL_C;
static VAL lbl_numZ_errors = MKNIL_C;
static VAL lbl_numZ_warnings = MKNIL_C;
static VAL lbl_preferZ_inlineZ_defs = MKNIL_C;
static VAL lbl_builtin = MKNIL_C;
static VAL lbl_ZPlusdiagnostics = MKNIL_C;
static VAL lbl_ZPluspropstack = MKNIL_C;
static VAL lbl_errorZ_token = MKNIL_C;
static VAL lbl_severity = MKNIL_C;
static VAL lbl_message = MKNIL_C;
static VAL lbl_location = MKNIL_C;
static VAL lbl_old = MKNIL_C;
static VAL lbl_new = MKNIL_C;
static VAL lbl_label = MKNIL_C;
static VAL lbl_module = MKNIL_C;
static VAL lbl_row = MKNIL_C;
static VAL lbl_col = MKNIL_C;
static VAL lbl_qname = MKNIL_C;
static VAL lbl_type = MKNIL_C;
static VAL lbl_token = MKNIL_C;
static VAL lbl_data = MKNIL_C;
static VAL lbl_field = MKNIL_C;
static VAL lbl_labels = MKNIL_C;
static VAL lbl_withses = MKNIL_C;
static VAL lbl_conses = MKNIL_C;
static VAL lbl_parts = MKNIL_C;
static VAL lbl_x = MKNIL_C;
static VAL lbl_baseZAsk = MKNIL_C;
static VAL lbl_dom = MKNIL_C;
static VAL lbl_cod = MKNIL_C;
static VAL lbl_ctype = MKNIL_C;
static VAL lbl_tags = MKNIL_C;
static VAL lbl_params = MKNIL_C;
static VAL lbl_tag = MKNIL_C;
static VAL lbl_inputs = MKNIL_C;
static VAL lbl_value = MKNIL_C;
static VAL lbl_underlying = MKNIL_C;
static VAL lbl_tagname = MKNIL_C;
static VAL lbl_dataname = MKNIL_C;
static VAL lbl_a = MKNIL_C;
static VAL lbl_head = MKNIL_C;
static VAL lbl_body = MKNIL_C;
static VAL lbl_sigZAsk = MKNIL_C;
static VAL lbl_pattern = MKNIL_C;
static VAL lbl_ctx = MKNIL_C;
static VAL lbl_subst = MKNIL_C;
static VAL lbl_op = MKNIL_C;
static VAL lbl_saved = MKNIL_C;
static VAL lbl_home = MKNIL_C;
static VAL lbl_cases = MKNIL_C;
static VAL lbl_tokenZ_start = MKNIL_C;
static VAL lbl_tokenZ_end = MKNIL_C;
static VAL lbl_outerZ_ctx = MKNIL_C;
static VAL lbl_innerZ_ctx = MKNIL_C;
static VAL lbl_mid = MKNIL_C;
static VAL lbl_atoms = MKNIL_C;
static VAL lbl_args = MKNIL_C;
static VAL lbl_lexerZ_module = MKNIL_C;
static VAL lbl_ZPlusinput = MKNIL_C;
static VAL lbl_lexerZ_row = MKNIL_C;
static VAL lbl_lexerZ_col = MKNIL_C;
static VAL lbl_lexerZ_stack = MKNIL_C;
static VAL lbl_lexerZ_lastZ_token = MKNIL_C;
static VAL lbl_allowZ_typeZ_holes = MKNIL_C;
static VAL lbl_allowZ_implicitZ_typeZ_vars = MKNIL_C;
static VAL lbl_ignoreZ_lastZ_name = MKNIL_C;
static VAL lbl_candidates = MKNIL_C;
static VAL lbl_rejected = MKNIL_C;
static VAL lbl_sort = MKNIL_C;
static VAL lbl_reportZ_ambiguousZ_asZ_warning = MKNIL_C;
static VAL lbl_accum = MKNIL_C;
static VAL lbl_arrow = MKNIL_C;
static VAL lbl_word = MKNIL_C;
static VAL lbl_ZPlusab = MKNIL_C;
static VAL lbl_ZPluspat = MKNIL_C;
static VAL lbl_tok = MKNIL_C;
static VAL lbl_header = MKNIL_C;
static VAL lbl_valueZAsk = MKNIL_C;
static VAL lbl_syn = MKNIL_C;
static VAL lbl_dat = MKNIL_C;
static VAL lbl_ftag = MKNIL_C;
static VAL lbl_untag = MKNIL_C;
static VAL lbl_f = MKNIL_C;
static VAL lbl_hasZ_paren = MKNIL_C;
static VAL lbl_target = MKNIL_C;
static VAL lbl_alias = MKNIL_C;
static VAL lbl_code = MKNIL_C;
static VAL lbl_symbol = MKNIL_C;
static VAL lbl_sig = MKNIL_C;
static VAL lbl_extblock = MKNIL_C;
static VAL lbl_external = MKNIL_C;
static VAL lbl_contents = MKNIL_C;
static VAL lbl_tbl = MKNIL_C;
static VAL lbl_va = MKNIL_C;
static VAL lbl_vx = MKNIL_C;
static VAL lbl_valueZ_type = MKNIL_C;
static VAL lbl_indexZ_type = MKNIL_C;
static VAL lbl_fld = MKNIL_C;
static VAL lbl_checklist = MKNIL_C;
static VAL lbl_w = MKNIL_C;
static VAL lbl_b = MKNIL_C;
static VAL lbl_key = MKNIL_C;
static VAL lbl_spword = MKNIL_C;
static VAL lbl_spkey = MKNIL_C;
static VAL lbl_spmap = MKNIL_C;
static VAL lbl_depth = MKNIL_C;
static VAL lbl_freshZ_counter = MKNIL_C;
static VAL lbl_ZPlusneeds = MKNIL_C;
static VAL lbl_ZPlusmirth = MKNIL_C;
static VAL lbl_ZPlusoutput = MKNIL_C;
static VAL lbl_lbl = MKNIL_C;
static VAL lbl_ext = MKNIL_C;
static VAL lbl_cty = MKNIL_C;
static VAL lbl_outty = MKNIL_C;
static VAL lbl_argZ_index = MKNIL_C;
static VAL lbl_avoidZ_hexdigit = MKNIL_C;
static VAL lbl_localZ_repr = MKNIL_C;
static VAL lbl_localZ_name = MKNIL_C;
static VAL lbl_localZ_resourceZ_name = MKNIL_C;
static VAL lbl_ZPlusx = MKNIL_C;
static VAL lbl_ZPluscore = MKNIL_C;
static VAL lbl_ZPlusstack = MKNIL_C;
static VAL lbl_outZ_type = MKNIL_C;
static VAL lbl_arg2Z_type = MKNIL_C;
static VAL lbl_arg1Z_type = MKNIL_C;
static VAL lbl_precedence = MKNIL_C;
static VAL lbl_operator = MKNIL_C;
static VAL lbl_ZPlusb = MKNIL_C;
static VAL lbl_ZPlusa = MKNIL_C;
static VAL lbl_ZPlusdipped = MKNIL_C;
static VAL lbl_ZPluscond = MKNIL_C;
static VAL lbl_ZPlusarg2 = MKNIL_C;
static VAL lbl_ZPlusarg1 = MKNIL_C;
static VAL lbl_stack = MKNIL_C;
static VAL lbl_ZPlusset = MKNIL_C;
static void mtw_std_either_Either_2_Left (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_std_either_Either_2_Left (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_either_Either_2_Right (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_std_either_Either_2_Right (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_buffer_ZPlusBuffer_ZPlusBuffer (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_base);
	tup->cells[1] = lpop(&lbl_sizze);
	push_resource(MKTUP(tup, 3));
}
static void mtp_std_buffer_ZPlusBuffer_ZPlusBuffer (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_sizze, tup->cells[1]);
	lpush(&lbl_base, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_str_ZPlusStr_ZPlusStr (void) {
	push_resource(pop_value());
}
static void mtp_std_str_ZPlusStr_ZPlusStr (void) {
	VAL val = pop_resource();
	push_value(val);
}
static void mtw_std_list_List_1_Cons (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_std_list_List_1_Cons (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_list_ZPlusList_1_ZPlusList (void) {
	push_resource(pop_value());
}
static void mtp_std_list_ZPlusList_1_ZPlusList (void) {
	VAL val = pop_resource();
	push_value(val);
}
static void mtw_std_list_ZPlusListZPlus_1_ZPlusListZPlus (void) {
	push_resource(pop_value());
}
static void mtp_std_list_ZPlusListZPlus_1_ZPlusListZPlus (void) {
	VAL val = pop_resource();
	push_value(val);
}
static void mtw_std_maybe_Maybe_1_Some (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_std_maybe_Maybe_1_Some (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_input_ZPlusInputOpenState_ZPlusInputOpenState (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = lpop(&lbl_ZPlusbuffer);
	tup->cells[3] = lpop(&lbl_ZPlusfile);
	tup->cells[2] = lpop(&lbl_offset);
	tup->cells[1] = lpop(&lbl_length);
	push_resource(MKTUP(tup, 5));
}
static void mtp_std_input_ZPlusInputOpenState_ZPlusInputOpenState (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_length, tup->cells[1]);
	lpush(&lbl_offset, tup->cells[2]);
	lpush(&lbl_ZPlusfile, tup->cells[3]);
	lpush(&lbl_ZPlusbuffer, tup->cells[4]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_input_ZPlusInput_ZPlusInputOpen (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 2));
}
static void mtp_std_input_ZPlusInput_ZPlusInputOpen (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_input_ZPlusInput_ZPlusInputDone (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 2));
}
static void mtp_std_input_ZPlusInput_ZPlusInputDone (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_output_ZPlusOutput_ZPlusOutput (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_ZPlusbuffer);
	tup->cells[2] = lpop(&lbl_ZPlusfile);
	tup->cells[1] = lpop(&lbl_sizze);
	push_resource(MKTUP(tup, 4));
}
static void mtp_std_output_ZPlusOutput_ZPlusOutput (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_sizze, tup->cells[1]);
	lpush(&lbl_ZPlusfile, tup->cells[2]);
	lpush(&lbl_ZPlusbuffer, tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_file_ZPlusFile_ZPlusFile (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_owned);
	tup->cells[1] = lpop(&lbl_fileZ_descriptor);
	push_resource(MKTUP(tup, 3));
}
static void mtp_std_file_ZPlusFile_ZPlusFile (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_fileZ_descriptor, tup->cells[1]);
	lpush(&lbl_owned, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_file_ZPlusFileZAsk_ZPlusFileOk (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 2));
}
static void mtp_std_file_ZPlusFileZAsk_ZPlusFileOk (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_file_ZPlusFileZAsk_ZPlusFileErr (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 2));
}
static void mtp_std_file_ZPlusFileZAsk_ZPlusFileErr (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtp_std_terminal_Sgr_FGColor (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtp_std_terminal_Sgr_BGColor (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtp_std_terminal_SGRColor_Numbered (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtp_std_terminal_SGRColor_RGB (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_argZ_parser_state_ArgvInfo_ArgvInfo (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_programZ_name);
	tup->cells[1] = lpop(&lbl_argv);
	push_value(MKTUP(tup, 3));
}
static void mtw_argZ_parser_state_CurrentArg_CurrentArg (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_optionZ_option);
	tup->cells[2] = lpop(&lbl_option);
	tup->cells[1] = lpop(&lbl_parsingZAsk);
	push_value(MKTUP(tup, 4));
}
static void mtw_argZ_parser_state_State_1_State (void) {
	TUP* tup = tup_new(7);
	tup->size = 7;
	tup->cells[0] = MKU64(0LL);
	tup->cells[6] = lpop(&lbl_error);
	tup->cells[5] = lpop(&lbl_longestZ_argZ_length);
	tup->cells[4] = lpop(&lbl_positionalZ_index);
	tup->cells[3] = lpop(&lbl_arg);
	tup->cells[2] = lpop(&lbl_argvZ_info);
	tup->cells[1] = lpop(&lbl_arguments);
	push_value(MKTUP(tup, 7));
}
static void mtw_argZ_parser_types_ArgumentParser_1_ArgumentParser (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = lpop(&lbl_doc);
	tup->cells[3] = lpop(&lbl_argsZ_doc);
	tup->cells[2] = lpop(&lbl_parser);
	tup->cells[1] = lpop(&lbl_options);
	push_value(MKTUP(tup, 5));
}
static void mtw_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_state);
	tup->cells[1] = lpop(&lbl_argumentZ_parser);
	push_resource(MKTUP(tup, 3));
}
static void mtp_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_argumentZ_parser, tup->cells[1]);
	lpush(&lbl_state, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_argZ_parser_types_ArgpOptionType_Short (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_argZ_parser_types_ArgpOptionType_Short (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_argZ_parser_types_ArgpOptionType_LongOnly (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_argZ_parser_types_ArgpOptionType_LongOnly (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_argZ_parser_types_ArgpOption_ArgpOption (void) {
	TUP* tup = tup_new(6);
	tup->size = 6;
	tup->cells[0] = MKU64(0LL);
	tup->cells[5] = lpop(&lbl_group);
	tup->cells[4] = lpop(&lbl_doc);
	tup->cells[3] = lpop(&lbl_argZ_doc);
	tup->cells[2] = lpop(&lbl_flagZ_type);
	tup->cells[1] = lpop(&lbl_name);
	push_value(MKTUP(tup, 6));
}
static void mtw_argZ_parser_types_ArgumentParsingError_MissingArg (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_argZ_parser_types_ArgumentParsingError_MissingArg (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_lazzy_Lazzy_1_LazzyReady (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_std_lazzy_Lazzy_1_LazzyReady (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_lazzy_Lazzy_1_LazzyDelay (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_std_lazzy_Lazzy_1_LazzyDelay (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_tycon_Tycon_TYCONz_DATA (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_tycon_Tycon_TYCONz_DATA (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_tycon_Tycon_TYCONz_TABLE (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_tycon_Tycon_TYCONz_TABLE (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_tycon_Tycon_TYCONz_PRIM (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_tycon_Tycon_TYCONz_PRIM (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_data_DataPartial_DataPartial (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_field);
	tup->cells[1] = lpop(&lbl_data);
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_data_DataPartial_DataPartial (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_data, tup->cells[1]);
	lpush(&lbl_field, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_match_Match_Match (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_cases);
	tup->cells[6] = lpop(&lbl_cod);
	tup->cells[5] = lpop(&lbl_dom);
	tup->cells[4] = lpop(&lbl_ctx);
	tup->cells[3] = lpop(&lbl_body);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 8));
}
static void mtp_mirth_match_Match_Match (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_home, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_body, tup->cells[3]);
	lpush(&lbl_ctx, tup->cells[4]);
	lpush(&lbl_dom, tup->cells[5]);
	lpush(&lbl_cod, tup->cells[6]);
	lpush(&lbl_cases, tup->cells[7]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		incref(tup->cells[7]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_match_ZPlusMatch_ZPlusMatch (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_cases);
	tup->cells[6] = lpop(&lbl_cod);
	tup->cells[5] = lpop(&lbl_dom);
	tup->cells[4] = lpop(&lbl_ctx);
	tup->cells[3] = lpop(&lbl_body);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_home);
	push_resource(MKTUP(tup, 8));
}
static void mtp_mirth_match_ZPlusMatch_ZPlusMatch (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_home, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_body, tup->cells[3]);
	lpush(&lbl_ctx, tup->cells[4]);
	lpush(&lbl_dom, tup->cells[5]);
	lpush(&lbl_cod, tup->cells[6]);
	lpush(&lbl_cases, tup->cells[7]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		incref(tup->cells[7]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_match_Case_CASE (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_body);
	tup->cells[1] = lpop(&lbl_pattern);
	push_value(MKTUP(tup, 3));
}
static void mtw_mirth_match_Pattern_Pattern (void) {
	TUP* tup = tup_new(10);
	tup->size = 10;
	tup->cells[0] = MKU64(0LL);
	tup->cells[9] = lpop(&lbl_atoms);
	tup->cells[8] = lpop(&lbl_cod);
	tup->cells[7] = lpop(&lbl_mid);
	tup->cells[6] = lpop(&lbl_saved);
	tup->cells[5] = lpop(&lbl_innerZ_ctx);
	tup->cells[4] = lpop(&lbl_outerZ_ctx);
	tup->cells[3] = lpop(&lbl_tokenZ_end);
	tup->cells[2] = lpop(&lbl_tokenZ_start);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 10));
}
static void mtw_mirth_match_ZPlusPattern_ZPlusPattern (void) {
	push_resource(lpop(&lbl_pattern));
}
static void mtp_mirth_match_ZPlusPattern_ZPlusPattern (void) {
	VAL val = pop_resource();
	lpush(&lbl_pattern, val);
}
static void mtw_mirth_match_PatternAtom_PATATOM (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_op);
	tup->cells[6] = lpop(&lbl_subst);
	tup->cells[5] = lpop(&lbl_cod);
	tup->cells[4] = lpop(&lbl_dom);
	tup->cells[3] = lpop(&lbl_saved);
	tup->cells[2] = lpop(&lbl_ctx);
	tup->cells[1] = lpop(&lbl_token);
	push_value(MKTUP(tup, 8));
}
static void mtw_mirth_match_PatternOp_PatOpTag (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_match_PatternOp_PatOpTag (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_external_ExternalBlockPart_EBPCode (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_external_ExternalBlockPart_EBPCode (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_external_ExternalBlockPart_EBPDef (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_external_ExternalBlockPart_EBPDef (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpPrim (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpPrim (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpWord (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpWord (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpExternal (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpExternal (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpBuffer (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpBuffer (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpVariable (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpVariable (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpField (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpField (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpInt (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpInt (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpF64 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpF64 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpStr (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpStr (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpTag (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpTag (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpMatch (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(11LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpMatch (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpLambda (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpLambda (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpVar (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(13LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpVar (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpBlockPush (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(14LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpBlockPush (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpBlockRun (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(15LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpBlockRun (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpCoerce (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(16LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpCoerce (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpLabelPush (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(17LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpLabelPush (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpLabelPop (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(18LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpLabelPop (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpLabelPushR (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(19LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpLabelPushR (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpLabelPopR (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(20LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpLabelPopR (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpDataGetTag (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(21LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Op_OpDataGetTag (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpDataGetLabel (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(22LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_arrow_Op_OpDataGetLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Op_OpDataSetLabel (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(23LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_arrow_Op_OpDataSetLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Home_HomeMain (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Home_HomeMain (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Home_HomeWord (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_arrow_Home_HomeWord (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Arrow_Arrow (void) {
	TUP* tup = tup_new(8);
	tup->size = 8;
	tup->cells[0] = MKU64(0LL);
	tup->cells[7] = lpop(&lbl_atoms);
	tup->cells[6] = lpop(&lbl_cod);
	tup->cells[5] = lpop(&lbl_dom);
	tup->cells[4] = lpop(&lbl_ctx);
	tup->cells[3] = lpop(&lbl_tokenZ_end);
	tup->cells[2] = lpop(&lbl_tokenZ_start);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 8));
}
static void mtw_mirth_arrow_Atom_Atom (void) {
	TUP* tup = tup_new(9);
	tup->size = 9;
	tup->cells[0] = MKU64(0LL);
	tup->cells[8] = lpop(&lbl_subst);
	tup->cells[7] = lpop(&lbl_cod);
	tup->cells[6] = lpop(&lbl_dom);
	tup->cells[5] = lpop(&lbl_args);
	tup->cells[4] = lpop(&lbl_op);
	tup->cells[3] = lpop(&lbl_ctx);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_home);
	push_value(MKTUP(tup, 9));
}
static void mtp_mirth_arrow_Atom_Atom (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_home, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_ctx, tup->cells[3]);
	lpush(&lbl_op, tup->cells[4]);
	lpush(&lbl_args, tup->cells[5]);
	lpush(&lbl_dom, tup->cells[6]);
	lpush(&lbl_cod, tup->cells[7]);
	lpush(&lbl_subst, tup->cells[8]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		incref(tup->cells[7]);
		incref(tup->cells[8]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_arrow_Lambda_Lambda (void) {
	TUP* tup = tup_new(6);
	tup->size = 6;
	tup->cells[0] = MKU64(0LL);
	tup->cells[5] = lpop(&lbl_body);
	tup->cells[4] = lpop(&lbl_params);
	tup->cells[3] = lpop(&lbl_dom);
	tup->cells[2] = lpop(&lbl_outerZ_ctx);
	tup->cells[1] = lpop(&lbl_token);
	push_value(MKTUP(tup, 6));
}
static void mtw_mirth_type_Type_TPrim (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TPrim (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TMeta (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TMeta (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_THole (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_THole (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TVar (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TVar (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TTable (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TTable (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TData (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TData (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TDataPartial (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TDataPartial (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TTensor (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TTensor (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TMorphism (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TMorphism (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TApp (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(11LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_Type_TApp (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TMut (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TMut (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Type_TValue (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(13LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Type_TValue (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Value_VALUEz_INT (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Value_VALUEz_INT (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Value_VALUEz_F64 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Value_VALUEz_F64 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Value_VALUEz_STR (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Value_VALUEz_STR (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Value_VALUEz_BLOCK (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_Value_VALUEz_BLOCK (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_ZPlusGamma_ZPlusGamma (void) {
	push_resource(lpop(&lbl_token));
}
static void mtp_mirth_type_ZPlusGamma_ZPlusGamma (void) {
	VAL val = pop_resource();
	lpush(&lbl_token, val);
}
static void mtw_mirth_type_StackType_STVar (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_StackType_STVar (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackType_STMeta (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_StackType_STMeta (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackType_STCons (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(5LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_StackType_STCons (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackType_STConsLabel (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(6LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_type_StackType_STConsLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackType_STWith (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(7LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_StackType_STWith (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackType_STWithLabel (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(8LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_type_StackType_STWithLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_ArrowType_ARROWz_TYPE (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_ArrowType_ARROWz_TYPE (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_Subst_SUBSTz_CON (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(1LL);
	tup->cells[3] = pop_value();
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_type_Subst_SUBSTz_CON (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	push_value(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackTypePart_STPCons (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_StackTypePart_STPCons (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackTypePart_STPConsLabel (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_StackTypePart_STPConsLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackTypePart_STPWith (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_StackTypePart_STPWith (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_StackTypePart_STPWithLabel (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(3LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_StackTypePart_STPWithLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CType_IntLike (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_CType_IntLike (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CType_F32Like (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_CType_F32Like (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CType_F64Like (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_CType_F64Like (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CType_PtrLike (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_CType_PtrLike (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CType_FnPtr (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_CType_FnPtr (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CTypeStackPart_CTSPCons (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_CTypeStackPart_CTSPCons (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CTypeStackPart_CTSPConsLabel (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_CTypeStackPart_CTSPConsLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CTypeStackPart_CTSPWith (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_type_CTypeStackPart_CTSPWith (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CTypeStackPart_CTSPWithLabel (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(3LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_type_CTypeStackPart_CTSPWithLabel (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_type_CTypeStack_CTypeStack (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_parts);
	tup->cells[1] = lpop(&lbl_baseZAsk);
	push_value(MKTUP(tup, 3));
}
static void mtw_mirth_type_CTypeArrow_CTypeArrow (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_cod);
	tup->cells[1] = lpop(&lbl_dom);
	push_value(MKTUP(tup, 3));
}
static void mtw_mirth_token_TokenValue_TokenLParen (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLParen (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenRParen (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenRParen (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLSquare (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLSquare (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenRSquare (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenRSquare (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLCurly (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLCurly (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenRCurly (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(11LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenRCurly (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLColon (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLColon (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenRColon (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(13LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenRColon (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenInt (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(14LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenInt (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenF64 (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(15LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenF64 (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenStr (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(16LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenStr (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(17LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenName (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenDName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(18LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenDName (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLabelPop (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(19LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLabelPop (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLabelPush (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(20LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLabelPush (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLabelPopR (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(21LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLabelPopR (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLabelPushR (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(22LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLabelPushR (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLabelGet (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(23LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLabelGet (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_token_TokenValue_TokenLabelSet (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(24LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_token_TokenValue_TokenLabelSet (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_location_Location_Location (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_col);
	tup->cells[2] = lpop(&lbl_row);
	tup->cells[1] = lpop(&lbl_module);
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_location_Location_Location (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_module, tup->cells[1]);
	lpush(&lbl_row, tup->cells[2]);
	lpush(&lbl_col, tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_mirth_Builtin_Builtin (void) {
	TUP* tup = tup_new(62);
	tup->size = 62;
	tup->cells[0] = MKU64(0LL);
	tup->cells[61] = lpop(&lbl_mkZ_cvoid);
	tup->cells[60] = lpop(&lbl_cvoid);
	tup->cells[59] = lpop(&lbl_mkZ_cvolatile);
	tup->cells[58] = lpop(&lbl_cvolatile);
	tup->cells[57] = lpop(&lbl_mkZ_crestrict);
	tup->cells[56] = lpop(&lbl_crestrict);
	tup->cells[55] = lpop(&lbl_mkZ_cconst);
	tup->cells[54] = lpop(&lbl_cconst);
	tup->cells[53] = lpop(&lbl_mkZ_cptr);
	tup->cells[52] = lpop(&lbl_cptr);
	tup->cells[51] = lpop(&lbl_mkZ_cuintptr);
	tup->cells[50] = lpop(&lbl_cuintptr);
	tup->cells[49] = lpop(&lbl_mkZ_cusizze);
	tup->cells[48] = lpop(&lbl_cusizze);
	tup->cells[47] = lpop(&lbl_mkZ_culonglong);
	tup->cells[46] = lpop(&lbl_culonglong);
	tup->cells[45] = lpop(&lbl_mkZ_culong);
	tup->cells[44] = lpop(&lbl_culong);
	tup->cells[43] = lpop(&lbl_mkZ_cuint);
	tup->cells[42] = lpop(&lbl_cuint);
	tup->cells[41] = lpop(&lbl_mkZ_cushort);
	tup->cells[40] = lpop(&lbl_cushort);
	tup->cells[39] = lpop(&lbl_mkZ_cuchar);
	tup->cells[38] = lpop(&lbl_cuchar);
	tup->cells[37] = lpop(&lbl_mkZ_cintptr);
	tup->cells[36] = lpop(&lbl_cintptr);
	tup->cells[35] = lpop(&lbl_mkZ_cisizze);
	tup->cells[34] = lpop(&lbl_cisizze);
	tup->cells[33] = lpop(&lbl_mkZ_clonglong);
	tup->cells[32] = lpop(&lbl_clonglong);
	tup->cells[31] = lpop(&lbl_mkZ_clong);
	tup->cells[30] = lpop(&lbl_clong);
	tup->cells[29] = lpop(&lbl_mkZ_cint);
	tup->cells[28] = lpop(&lbl_cint);
	tup->cells[27] = lpop(&lbl_mkZ_cshort);
	tup->cells[26] = lpop(&lbl_cshort);
	tup->cells[25] = lpop(&lbl_mkZ_cichar);
	tup->cells[24] = lpop(&lbl_cichar);
	tup->cells[23] = lpop(&lbl_mkZ_cchar);
	tup->cells[22] = lpop(&lbl_cchar);
	tup->cells[21] = lpop(&lbl_mkZ_i8);
	tup->cells[20] = lpop(&lbl_i8);
	tup->cells[19] = lpop(&lbl_mkZ_i16);
	tup->cells[18] = lpop(&lbl_i16);
	tup->cells[17] = lpop(&lbl_mkZ_i32);
	tup->cells[16] = lpop(&lbl_i32);
	tup->cells[15] = lpop(&lbl_mkZ_i64);
	tup->cells[14] = lpop(&lbl_i64);
	tup->cells[13] = lpop(&lbl_mkZ_u8);
	tup->cells[12] = lpop(&lbl_u8);
	tup->cells[11] = lpop(&lbl_mkZ_u16);
	tup->cells[10] = lpop(&lbl_u16);
	tup->cells[9] = lpop(&lbl_mkZ_u32);
	tup->cells[8] = lpop(&lbl_u32);
	tup->cells[7] = lpop(&lbl_mkZ_u64);
	tup->cells[6] = lpop(&lbl_u64);
	tup->cells[5] = lpop(&lbl_false);
	tup->cells[4] = lpop(&lbl_true);
	tup->cells[3] = lpop(&lbl_bool);
	tup->cells[2] = lpop(&lbl_prim);
	tup->cells[1] = lpop(&lbl_std);
	push_value(MKTUP(tup, 62));
}
static void mtw_mirth_mirth_ZPlusMirth_ZPlusMirth (void) {
	TUP* tup = tup_new(9);
	tup->size = 9;
	tup->cells[0] = MKU64(0LL);
	tup->cells[8] = lpop(&lbl_ZPluspropstack);
	tup->cells[7] = lpop(&lbl_ZPlusdiagnostics);
	tup->cells[6] = lpop(&lbl_packageZ_searchZ_paths);
	tup->cells[5] = lpop(&lbl_errorZ_token);
	tup->cells[4] = lpop(&lbl_builtin);
	tup->cells[3] = lpop(&lbl_preferZ_inlineZ_defs);
	tup->cells[2] = lpop(&lbl_numZ_warnings);
	tup->cells[1] = lpop(&lbl_numZ_errors);
	push_resource(MKTUP(tup, 9));
}
static void mtp_mirth_mirth_ZPlusMirth_ZPlusMirth (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_numZ_errors, tup->cells[1]);
	lpush(&lbl_numZ_warnings, tup->cells[2]);
	lpush(&lbl_preferZ_inlineZ_defs, tup->cells[3]);
	lpush(&lbl_builtin, tup->cells[4]);
	lpush(&lbl_errorZ_token, tup->cells[5]);
	lpush(&lbl_packageZ_searchZ_paths, tup->cells[6]);
	lpush(&lbl_ZPlusdiagnostics, tup->cells[7]);
	lpush(&lbl_ZPluspropstack, tup->cells[8]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		incref(tup->cells[7]);
		incref(tup->cells[8]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_mirth_Diagnostic_Diagnostic (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_message);
	tup->cells[2] = lpop(&lbl_location);
	tup->cells[1] = lpop(&lbl_severity);
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_mirth_Diagnostic_Diagnostic (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_severity, tup->cells[1]);
	lpush(&lbl_location, tup->cells[2]);
	lpush(&lbl_message, tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_mirth_Prop_1_Prop (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_state);
	tup->cells[1] = lpop(&lbl_label);
	push_value(MKTUP(tup, 3));
}
static void mtw_mirth_mirth_PropState_1_PSReady (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_mirth_PropState_1_PSReady (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_mirth_PropState_1_PSDelay (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_mirth_PropState_1_PSDelay (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_mirth_PropLabel_DataQName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_DataParams (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_DataCType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_TagType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_TableQName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_TypeDefQName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_TypeDefTarget (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_WordQName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_WordType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_WordParams (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_WordArrow (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_BlockArrow (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(11LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_AliasQName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_AliasTarget (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(13LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_ExternalQName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(14LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_ExternalType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(15LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_ExternalCType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(16LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_VariableType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(17LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_FieldQName (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(18LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_FieldValueType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(19LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_mirth_PropLabel_FieldIndexType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(20LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtw_mirth_def_Def_DefAlias (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefAlias (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefModule (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefModule (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefPackage (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefPackage (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefData (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefData (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefTable (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefTable (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefType (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefType (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefTag (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefTag (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefPrim (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefPrim (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefWord (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(8LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefWord (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefBuffer (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(9LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefBuffer (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefVariable (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(10LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefVariable (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefExternal (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(11LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefExternal (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_def_Def_DefField (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(12LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_def_Def_DefField (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_name_Namespace_NAMESPACEz_MODULE (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_name_Namespace_NAMESPACEz_MODULE (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_name_Namespace_NAMESPACEz_TYCON (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_name_Namespace_NAMESPACEz_TYCON (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_name_Namespace_NAMESPACEz_WORD (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_name_Namespace_NAMESPACEz_WORD (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_name_QName_MKQNAME (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_arity);
	tup->cells[2] = lpop(&lbl_name);
	tup->cells[1] = lpop(&lbl_namespace);
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_name_QName_MKQNAME (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_namespace, tup->cells[1]);
	lpush(&lbl_name, tup->cells[2]);
	lpush(&lbl_arity, tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_name_DName_DName (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = pop_value();
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_name_DName_DName (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_value(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_lexer_ZPlusLexer_ZPlusLexer (void) {
	TUP* tup = tup_new(7);
	tup->size = 7;
	tup->cells[0] = MKU64(0LL);
	tup->cells[6] = lpop(&lbl_ZPlusinput);
	tup->cells[5] = lpop(&lbl_lexerZ_lastZ_token);
	tup->cells[4] = lpop(&lbl_lexerZ_stack);
	tup->cells[3] = lpop(&lbl_lexerZ_col);
	tup->cells[2] = lpop(&lbl_lexerZ_row);
	tup->cells[1] = lpop(&lbl_lexerZ_module);
	push_resource(MKTUP(tup, 7));
}
static void mtp_mirth_lexer_ZPlusLexer_ZPlusLexer (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_lexerZ_module, tup->cells[1]);
	lpush(&lbl_lexerZ_row, tup->cells[2]);
	lpush(&lbl_lexerZ_col, tup->cells[3]);
	lpush(&lbl_lexerZ_stack, tup->cells[4]);
	lpush(&lbl_lexerZ_lastZ_token, tup->cells[5]);
	lpush(&lbl_ZPlusinput, tup->cells[6]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = lpop(&lbl_allowZ_implicitZ_typeZ_vars);
	tup->cells[3] = lpop(&lbl_allowZ_typeZ_holes);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_ctx);
	push_resource(MKTUP(tup, 5));
}
static void mtp_mirth_elab_ZPlusTypeElab_ZPlusTypeElab (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_ctx, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_allowZ_typeZ_holes, tup->cells[3]);
	lpush(&lbl_allowZ_implicitZ_typeZ_vars, tup->cells[4]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_ZPlusResolveDef_ZPlusResolveDef (void) {
	TUP* tup = tup_new(7);
	tup->size = 7;
	tup->cells[0] = MKU64(0LL);
	tup->cells[6] = lpop(&lbl_reportZ_ambiguousZ_asZ_warning);
	tup->cells[5] = lpop(&lbl_ignoreZ_lastZ_name);
	tup->cells[4] = lpop(&lbl_rejected);
	tup->cells[3] = lpop(&lbl_candidates);
	tup->cells[2] = lpop(&lbl_token);
	tup->cells[1] = lpop(&lbl_sort);
	push_resource(MKTUP(tup, 7));
}
static void mtp_mirth_elab_ZPlusResolveDef_ZPlusResolveDef (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_sort, tup->cells[1]);
	lpush(&lbl_token, tup->cells[2]);
	lpush(&lbl_candidates, tup->cells[3]);
	lpush(&lbl_rejected, tup->cells[4]);
	lpush(&lbl_ignoreZ_lastZ_name, tup->cells[5]);
	lpush(&lbl_reportZ_ambiguousZ_asZ_warning, tup->cells[6]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(4LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(5LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(6LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(7LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_ZPlusAB_ZPlusAB (void) {
	push_resource(lpop(&lbl_arrow));
}
static void mtp_mirth_elab_ZPlusAB_ZPlusAB (void) {
	VAL val = pop_resource();
	lpush(&lbl_arrow, val);
}
static void mtw_mirth_elab_OpSig_OPSIGz_PUSH (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_OpSig_OPSIGz_PUSH (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_OpSig_OPSIGz_APPLY (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_elab_OpSig_OPSIGz_APPLY (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_SyntaxData_SyntaxData (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_tags);
	tup->cells[1] = lpop(&lbl_header);
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_elab_SyntaxData_SyntaxData (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_header, tup->cells[1]);
	lpush(&lbl_tags, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_SyntaxDataHeader_SyntaxDataHeader (void) {
	push_value(lpop(&lbl_head));
}
static void mtp_mirth_elab_SyntaxDataHeader_SyntaxDataHeader (void) {
	VAL val = pop_value();
	lpush(&lbl_head, val);
}
static void mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_sigZAsk);
	tup->cells[2] = lpop(&lbl_name);
	tup->cells[1] = lpop(&lbl_valueZAsk);
	push_value(MKTUP(tup, 4));
}
static void mtw_mirth_elab_SyntaxDef_SyntaxDef (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(0LL);
	tup->cells[3] = lpop(&lbl_body);
	tup->cells[2] = lpop(&lbl_sigZAsk);
	tup->cells[1] = lpop(&lbl_head);
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_elab_SyntaxDef_SyntaxDef (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_head, tup->cells[1]);
	lpush(&lbl_sigZAsk, tup->cells[2]);
	lpush(&lbl_body, tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_ExternalDeclPart_EDPCode (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_code);
	tup->cells[1] = lpop(&lbl_token);
	push_value(MKTUP(tup, 3));
}
static void mtp_mirth_elab_ExternalDeclPart_EDPCode (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_token, tup->cells[1]);
	lpush(&lbl_code, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_elab_ExternalDeclPart_EDPDef (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(1LL);
	tup->cells[3] = lpop(&lbl_sig);
	tup->cells[2] = lpop(&lbl_symbol);
	tup->cells[1] = lpop(&lbl_head);
	push_value(MKTUP(tup, 4));
}
static void mtp_mirth_elab_ExternalDeclPart_EDPDef (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_head, tup->cells[1]);
	lpush(&lbl_symbol, tup->cells[2]);
	lpush(&lbl_sig, tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_map_KVPair_2_KVPair (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_value);
	tup->cells[1] = lpop(&lbl_key);
	push_value(MKTUP(tup, 3));
}
static void mtw_mirth_specializzer_ZPlusSPCheck_SPCHECK (void) {
	push_resource(lpop(&lbl_checklist));
}
static void mtp_mirth_specializzer_ZPlusSPCheck_SPCHECK (void) {
	VAL val = pop_resource();
	lpush(&lbl_checklist, val);
}
static void mtw_mirth_specializzer_SPCheckItem_SPCHECKz_WORD (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_specializzer_SPCheckItem_SPCHECKz_WORD (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH (void) {
	TUP* tup = tup_new(5);
	tup->size = 5;
	tup->cells[0] = MKU64(0LL);
	tup->cells[4] = lpop(&lbl_spmap);
	tup->cells[3] = lpop(&lbl_spword);
	tup->cells[2] = lpop(&lbl_spkey);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 5));
}
static void mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	lpush(&lbl_spkey, tup->cells[2]);
	lpush(&lbl_spword, tup->cells[3]);
	lpush(&lbl_spmap, tup->cells[4]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_std_set_ZPlusSet_ZPlusSet (void) {
	push_resource(lpop(&lbl_ZPlusbuffer));
}
static void mtp_std_set_ZPlusSet_ZPlusSet (void) {
	VAL val = pop_resource();
	lpush(&lbl_ZPlusbuffer, val);
}
static void mtw_mirth_need_Need_NEEDz_WORD (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(0LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_need_Need_NEEDz_WORD (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_need_Need_NEEDz_BLOCK (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_need_Need_NEEDz_BLOCK (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_need_Need_NEEDz_TAGW (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(2LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_need_Need_NEEDz_TAGW (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_need_Need_NEEDz_TAGP (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(3LL);
	tup->cells[1] = pop_value();
	push_value(MKTUP(tup, 2));
}
static void mtp_mirth_need_Need_NEEDz_TAGP (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_need_ZPlusNeeds_ZPlusNeeds (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_ZPlusset);
	tup->cells[1] = lpop(&lbl_stack);
	push_resource(MKTUP(tup, 3));
}
static void mtp_mirth_need_ZPlusNeeds_ZPlusNeeds (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_stack, tup->cells[1]);
	lpush(&lbl_ZPlusset, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_C99z_Options_C99z_Options (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_emitZ_debugZ_info);
	tup->cells[1] = lpop(&lbl_outputZ_path);
	push_value(MKTUP(tup, 3));
}
static void mtw_mirth_c99_ZPlusC99_ZPlusC99 (void) {
	TUP* tup = tup_new(7);
	tup->size = 7;
	tup->cells[0] = MKU64(0LL);
	tup->cells[6] = lpop(&lbl_ZPlusmirth);
	tup->cells[5] = lpop(&lbl_ZPlusoutput);
	tup->cells[4] = lpop(&lbl_ZPlusneeds);
	tup->cells[3] = lpop(&lbl_freshZ_counter);
	tup->cells[2] = lpop(&lbl_depth);
	tup->cells[1] = lpop(&lbl_options);
	push_resource(MKTUP(tup, 7));
}
static void mtp_mirth_c99_ZPlusC99_ZPlusC99 (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_options, tup->cells[1]);
	lpush(&lbl_depth, tup->cells[2]);
	lpush(&lbl_freshZ_counter, tup->cells[3]);
	lpush(&lbl_ZPlusneeds, tup->cells[4]);
	lpush(&lbl_ZPlusoutput, tup->cells[5]);
	lpush(&lbl_ZPlusmirth, tup->cells[6]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_localZ_name);
	tup->cells[1] = lpop(&lbl_localZ_repr);
	push_resource(MKTUP(tup, 3));
}
static void mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_localZ_repr, tup->cells[1]);
	lpush(&lbl_localZ_name, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource (void) {
	push_resource(lpop(&lbl_localZ_resourceZ_name));
}
static void mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource (void) {
	VAL val = pop_resource();
	lpush(&lbl_localZ_resourceZ_name, val);
}
static void mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 2));
}
static void mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome (void) {
	TUP* tup = tup_new(2);
	tup->size = 2;
	tup->cells[0] = MKU64(1LL);
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 2));
}
static void mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(1LL);
	tup->cells[2] = pop_resource();
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 3));
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	push_resource(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(2LL);
	tup->cells[2] = pop_resource();
	tup->cells[1] = pop_resource();
	push_resource(MKTUP(tup, 3));
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_resource(tup->cells[1]);
	push_resource(tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(3LL);
	tup->cells[3] = pop_resource();
	tup->cells[2] = pop_resource();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 4));
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_resource(tup->cells[2]);
	push_resource(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel (void) {
	TUP* tup = tup_new(4);
	tup->size = 4;
	tup->cells[0] = MKU64(4LL);
	tup->cells[3] = pop_resource();
	tup->cells[2] = pop_resource();
	tup->cells[1] = pop_value();
	push_resource(MKTUP(tup, 4));
}
static void mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	push_value(tup->cells[1]);
	push_resource(tup->cells[2]);
	push_resource(tup->cells[3]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch (void) {
	TUP* tup = tup_new(3);
	tup->size = 3;
	tup->cells[0] = MKU64(0LL);
	tup->cells[2] = lpop(&lbl_ZPlusstack);
	tup->cells[1] = lpop(&lbl_ZPluscore);
	push_resource(MKTUP(tup, 3));
}
static void mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch (void) {
	VAL val = pop_resource();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_ZPluscore, tup->cells[1]);
	lpush(&lbl_ZPlusstack, tup->cells[2]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_c99_C99BinOp_C99BinOp (void) {
	TUP* tup = tup_new(6);
	tup->size = 6;
	tup->cells[0] = MKU64(0LL);
	tup->cells[5] = lpop(&lbl_outZ_type);
	tup->cells[4] = lpop(&lbl_arg2Z_type);
	tup->cells[3] = lpop(&lbl_arg1Z_type);
	tup->cells[2] = lpop(&lbl_precedence);
	tup->cells[1] = lpop(&lbl_operator);
	push_value(MKTUP(tup, 6));
}
static void mtp_mirth_c99_C99BinOp_C99BinOp (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_operator, tup->cells[1]);
	lpush(&lbl_precedence, tup->cells[2]);
	lpush(&lbl_arg1Z_type, tup->cells[3]);
	lpush(&lbl_arg2Z_type, tup->cells[4]);
	lpush(&lbl_outZ_type, tup->cells[5]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mtw_mirth_main_Arguments_Arguments (void) {
	TUP* tup = tup_new(7);
	tup->size = 7;
	tup->cells[0] = MKU64(0LL);
	tup->cells[6] = lpop(&lbl_emitZ_debugZ_info);
	tup->cells[5] = lpop(&lbl_packageZ_searchZ_paths);
	tup->cells[4] = lpop(&lbl_packages);
	tup->cells[3] = lpop(&lbl_entryZ_point);
	tup->cells[2] = lpop(&lbl_outputZ_file);
	tup->cells[1] = lpop(&lbl_inputZ_file);
	push_value(MKTUP(tup, 7));
}
static void mtp_mirth_main_Arguments_Arguments (void) {
	VAL val = pop_value();
	ASSERT1(IS_TUP(val),val);
	TUP* tup = VTUP(val);
	lpush(&lbl_inputZ_file, tup->cells[1]);
	lpush(&lbl_outputZ_file, tup->cells[2]);
	lpush(&lbl_entryZ_point, tup->cells[3]);
	lpush(&lbl_packages, tup->cells[4]);
	lpush(&lbl_packageZ_searchZ_paths, tup->cells[5]);
	lpush(&lbl_emitZ_debugZ_info, tup->cells[6]);
	if (tup->refs > 1) {
		incref(tup->cells[1]);
		incref(tup->cells[2]);
		incref(tup->cells[3]);
		incref(tup->cells[4]);
		incref(tup->cells[5]);
		incref(tup->cells[6]);
		decref(val);
	} else {
		free(tup);
	}
}
static void mbuf_mirth_label_Label_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_var_Var_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_buffer_Buffer_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_word_Word_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_table_Table_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_table_Field_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_data_Data_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_data_Tag_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_external_External_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_external_ExternalBlock_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_variable_Variable_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_arrow_Block_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_typedef_TypeDef_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_type_MetaVar_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_token_Token_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_module_Module_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_alias_Alias_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_name_Name_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_name_HASHz_BUF (void) {
	static uint8_t b[524288] = {0};
	push_ptr(&b);
}
static void mbuf_mirth_package_Package_NUM (void) {
	static uint8_t b[8] = {0};
	push_ptr(&b);
}
size_t strlen (const char *);
static void mext_std_ctypes_CStr_numZ_bytes (void) {
	const char * X2 = (const char *)pop_ptr();
(void)pop_resource();
	size_t Y = strlen(X2);
	push_resource(MKI64(0));
	push_i64((int64_t)(Y));
}
int read (int, void*, size_t);
static void mext_std_posix_externalZ_posixZ_read (void) {
	size_t X3 = (size_t)pop_i64();
	void* X2 = (void*)pop_ptr();
	int X1 = (int)pop_i64();
	int Y = read(X1, X2, X3);
	push_i64((int64_t)(Y));
}
int write (int, const char *, size_t);
static void mext_std_posix_externalZ_posixZ_write (void) {
	size_t X3 = (size_t)pop_i64();
	const char * X2 = (const char *)pop_ptr();
	int X1 = (int)pop_i64();
	int Y = write(X1, X2, X3);
	push_i64((int64_t)(Y));
}
int close (int);
static void mext_std_posix_externalZ_posixZ_close (void) {
	int X1 = (int)pop_i64();
	int Y = close(X1);
	push_i64((int64_t)(Y));
}
void exit (int);
static void mext_std_posix_externalZ_posixZ_exit (void) {
	int X1 = (int)pop_i64();
	exit(X1);
}
int open_internal(const char* path, int flags, int mode) { return open(path, flags, mode); }
int open_internal (const char *, int, int);
static void mext_std_posix_internalZ_posixZ_open (void) {
	int X3 = (int)pop_i64();
	int X2 = (int)pop_i64();
	const char * X1 = (const char *)pop_ptr();
	int Y = open_internal(X1, X2, X3);
	push_i64((int64_t)(Y));
}
int stat (const char *, void*);
static void mext_std_world_posixZ_stat (void) {
	void* X3 = (void*)pop_ptr();
	const char * X2 = (const char *)pop_ptr();
(void)pop_resource();
	int Y = stat(X2, X3);
	push_resource(MKI64(0));
	push_i64((int64_t)(Y));
}
double strtod(const char*, char**);
double string_to_float64(const char* float64_str) {
    return strtod(float64_str, 0);
}
double string_to_float64 (const char *);
static void mext_mirth_lexer_stringz_toz_float64 (void) {
	const char * X1 = (const char *)pop_ptr();
	double Y = string_to_float64(X1);
	push_f64((double)(Y));
}
static void mw_std_either_Either_2_leftZAsk (void);
static void mw_std_byte_Byte_ZToInt (void);
static void mw_std_prim_Int_ZToByte (void);
static void mw_std_byte_Byte_ZToU8 (void);
static void mw_std_prim_U8_ZToByte (void);
static void mw_std_prim_Ptr_ZAtByte (void);
static void mw_std_byte_Byte_ZEqualZEqual (void);
static void mw_std_byte_Byte_ZTo (void);
static void mw_std_byte_Byte_inZ_range (void);
static void mw_std_byte_Byte_isZ_upper (void);
static void mw_std_byte_Byte_isZ_lower (void);
static void mw_std_byte_Byte_isZ_digit (void);
static void mw_std_byte_Byte_isZ_alpha (void);
static void mw_std_byte_Byte_isZ_alnum (void);
static void mw_std_byte_Byte_isZ_printable (void);
static void mw_std_byte_Byte_isZ_hexdigit (void);
static void mw_std_byte_Byte_emitZ_asciiZThen (void);
static void mw_std_byte_Byte_toZ_strZ_unsafe (void);
static void mw_std_byte_Byte_toZ_asciiZ_str (void);
static void mw_std_byte_Byte_isZ_stringZ_end (void);
static void mw_std_byte_Byte_toZ_hexdigits (void);
static void mw_std_byte_oneZ_hexdigitZ_byte (void);
static void mw_std_byte_Byte_isZ_nameZ_byte (void);
static void mw_std_byte_Byte_isZ_sign (void);
static void mw_std_byte_Byte_zzencode (void);
static void mw_std_buffer_ZPlusBuffer_new (void);
static void mw_std_buffer_ZPlusBuffer_resizzeZBang (void);
static void mw_std_buffer_ZPlusBuffer_expandZBang (void);
static void mw_std_buffer_ZPlusBuffer_rdrop (void);
static void mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang (void);
static void mw_std_buffer_ZPlusBuffer_checkZ_spanZBang (void);
static void mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang (void);
static void mw_std_buffer_ZPlusBuffer_ZAtU8 (void);
static void mw_std_buffer_ZPlusBuffer_ZBangU8 (void);
static void mw_std_buffer_ZPlusBuffer_ZBangByte (void);
static void mw_std_buffer_ZPlusBuffer_ZBangStr (void);
static void mw_std_buffer_ZPlusBuffer_ZAtStr (void);
static void mw_std_prim_Ptr_ZBangStrZPlus (void);
static void mw_std_str_ZPlusStr_dupZBang (void);
static void mw_std_str_ZPlusStr_numZ_bytesZAsk (void);
static void mw_std_str_ZPlusStr_lastZ_byte (void);
static void mw_std_str_ZPlusStr_byteZAt (void);
static void mw_std_str_offsetZ_inZ_bounds (void);
static void mw_std_prim_Str_byteZAt (void);
static void mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang (void);
static void mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang (void);
static void mw_std_str_ZPlusStr_pushZ_strZBang (void);
static void mw_std_prim_Str_dropZ_bytes (void);
static void mw_std_prim_Str_fromZ_bytesZ_unsafe (void);
static void mw_std_str_clampZ_sliceZ_offsetZ_sizze (void);
static void mw_std_prim_Str_slice (void);
static void mw_std_prim_Str_dropZ_slice (void);
static void mw_std_prim_Str_takeZ_slice (void);
static void mw_std_str_ZPlusStr_slice (void);
static void mw_std_str_ZPlusStr_offsetZ_slice (void);
static void mw_std_str_ZPlusStr_takeZ_slice (void);
static void mw_std_str_ZPlusStr_dropZ_slice (void);
static void mw_std_str_ZPlusStr_splitZ_byte (void);
static void mw_std_prim_Str_splitZ_byte (void);
static void mw_std_str_ZPlusStr_pushZ_showZ_byteZBang (void);
static void mw_std_prim_Str_showZThen (void);
static void mw_std_list_List_1_ZDivL1 (void);
static void mw_std_list_List_1_ZDivL2 (void);
static void mw_std_list_List_1_emptyZAsk (void);
static void mw_std_list_List_1_ZToListZPlus (void);
static void mw_std_list_List_1_len (void);
static void mw_std_list_List_1_uncons (void);
static void mw_std_list_ListZPlus_1_uncons (void);
static void mw_std_list_List_1_unsnoc (void);
static void mw_std_list_ListZPlus_1_unsnoc (void);
static void mw_std_list_List_1_cat (void);
static void mw_std_list_List_1_first (void);
static void mw_std_list_List_1_last (void);
static void mw_std_list_ListZPlus_1_first (void);
static void mw_std_list_ListZPlus_1_last (void);
static void mw_std_list_List_1_reverse (void);
static void mw_std_prim_Int_range (void);
static void mw_std_maybe_Maybe_1_noneZAsk (void);
static void mw_std_maybe_Maybe_1_someZAsk (void);
static void mw_std_maybe_Maybe_1_ZToBool (void);
static void mw_std_maybe_Maybe_1_ZToList (void);
static void mw_std_maybe_Maybe_1_unwrap (void);
static void mw_std_maybe_Maybe_1_zzip (void);
static void mw_std_prim_Int_ZToOS (void);
static void mw_std_prim_Int_ZToArch (void);
static void mw_std_prim_Int_inZ_range (void);
static void mw_std_prim_Int_ZToU8ZAsk (void);
static void mw_std_prim_Int_ZToU16ZAsk (void);
static void mw_std_prim_Int_ZToU8 (void);
static void mw_std_prim_Int_ZToU16 (void);
static void mw_std_prim_Int_ZToI64 (void);
static void mw_std_prim_Int_ZToNat (void);
static void mw_std_prelude_Sizze_max (void);
static void mw_std_prelude_Sizze_min (void);
static void mw_std_prelude_Offset_min (void);
static void mw_std_prelude_ZAtZAsk (void);
static void mw_std_path_PATHz_SEPARATOR (void);
static void mw_std_path_Path_joinZ_with (void);
static void mw_std_path_Path_join (void);
static void mw_std_byte_Byte_isZ_pathZ_separatorZAsk (void);
static void mw_std_path_Path_splitZ_last (void);
static void mw_std_path_Path_pathZThen (void);
static void mw_std_input_INPUTz_BUFFERz_SIZZE (void);
static void mw_std_input_ZPlusInput_startZBang (void);
static void mw_std_input_ZPlusInput_stopZBang (void);
static void mw_std_input_ZPlusInput_endZBang (void);
static void mw_std_input_ZPlusInput_doneZAsk (void);
static void mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang (void);
static void mw_std_input_ZPlusInput_peek (void);
static void mw_std_input_ZPlusInput_moveZBang (void);
static void mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang (void);
static void mw_std_input_ZPlusInput_readZ_chunkZBang (void);
static void mw_std_input_ZPlusInput_readZ_fileZBang (void);
static void mw_std_output_OUTPUTz_BUFFERz_SIZZE (void);
static void mw_std_output_ZPlusOutput_startZBang (void);
static void mw_std_output_ZPlusOutput_endZBang (void);
static void mw_std_output_ZPlusOutput_offset (void);
static void mw_std_output_ZPlusOutput_flushZBang (void);
static void mw_std_output_ZPlusOutput_capacityZ_total (void);
static void mw_std_output_ZPlusOutput_capacityZ_remaining (void);
static void mw_std_output_ZPlusOutput_fullZAsk (void);
static void mw_std_output_ZPlusOutput_put (void);
static void mw_std_output_ZPlusOutput_putZ_byte (void);
static void mw_std_output_ZPlusOutput_line (void);
static void mw_std_posix_posixZ_openZBang (void);
static void mw_std_file_ZPlusFileZAsk_unwrapZBang (void);
static void mw_std_prim_ZPlusWorld_openZ_fileZBang (void);
static void mw_std_prim_ZPlusWorld_createZ_fileZBang (void);
static void mw_std_prim_ZPlusWorld_stderrZ_file (void);
static void mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC (void);
static void mw_std_file_ZPlusFile_closeZ_fileZBang (void);
static void mw_std_file_ZPlusFile_unsafeZ_writeZBang (void);
static void mw_std_file_ZPlusFile_unsafeZ_readZBang (void);
static void mw_std_file_ZPlusFile_readZ_fileZBang (void);
static void mw_std_prim_ZPlusWorld_traceZ_ (void);
static void mw_std_prim_ZPlusWorld_isZ_directoryZAsk (void);
static void mw_std_world_Sz_IFMT (void);
static void mw_std_world_Sz_IFDIR (void);
static void mw_std_world_Sz_ISDIR (void);
static void mw_std_world_stz_modeZAt (void);
static void mw_std_terminal_SGRColor_showZThen (void);
static void mw_std_terminal_Sgr_emitZThen (void);
static void mw_std_terminal_csiZThen (void);
static void mw_argZ_parser_state_State_1_init (void);
static void mw_argZ_parser_state_State_1_argv (void);
static void mw_argZ_parser_state_State_1_programZ_name (void);
static void mw_argZ_parser_state_State_1_parsingZAsk (void);
static void mw_argZ_parser_state_State_1_parsingZAskZBang (void);
static void mw_argZ_parser_state_State_1_optionZ_option (void);
static void mw_argZ_parser_state_State_1_optionZ_optionZBang (void);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop (void);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_parser (void);
static void mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk (void);
static void mw_argZ_parser_types_ArgumentParsingError_emitZThen (void);
static void mw_argZ_parser_types_ZPlusArgumentParser_1_usage (void);
static void mw_argZ_parser_types_ArgpOption_usageZThen (void);
static void mw_argZ_parser_parse_checkZ_shortZ_flag (void);
static void mw_argZ_parser_parse_checkZ_longZ_flag (void);
static void mw_argZ_parser_parse_parseZ_flags (void);
static void mw_argZ_parser_parse_doZ_positionalZ_option (void);
static void mw_argZ_parser_parse_parseZ_args (void);
static void mw_argZ_parser_parse_readZ_fromZ_argv (void);
static void mw_argZ_parser_parse_argvZ_toZ_str (void);
static void mw_std_lazzy_Lazzy_1_forceZBang (void);
static void mw_mirth_label_Label_index (void);
static void mw_mirth_label_Label_allocZBang (void);
static void mw_mirth_label_Label_name (void);
static void mw_mirth_label_Label_ZToStr (void);
static void mw_mirth_label_Label_ZEqualZEqual (void);
static void mw_mirth_label_Label_newZBang (void);
static void mw_mirth_label_Label_isZ_resourceZ_labelZAsk (void);
static void mw_mirth_var_Var_index (void);
static void mw_mirth_var_Var_allocZBang (void);
static void mw_mirth_var_Var_name (void);
static void mw_mirth_var_Var_type (void);
static void mw_mirth_var_Var_autoZ_runZAsk (void);
static void mw_mirth_var_Var_ZEqualZEqual (void);
static void mw_mirth_var_Var_typeZThen (void);
static void mw_mirth_var_Var_isZ_stackZAsk (void);
static void mw_mirth_var_Var_isZ_physicalZAsk (void);
static void mw_mirth_var_Var_newZBang (void);
static void mw_mirth_var_Var_newZ_autoZ_runZBang (void);
static void mw_std_list_List_1_ZToCtx (void);
static void mw_mirth_var_Ctx_ZToList (void);
static void mw_mirth_var_Ctx0 (void);
static void mw_mirth_var_Ctx1 (void);
static void mw_mirth_var_Ctx2 (void);
static void mw_mirth_var_Ctx3 (void);
static void mw_mirth_var_Ctx_new (void);
static void mw_mirth_var_Ctx_lookup (void);
static void mw_mirth_var_Ctx_freshZ_nameZBang (void);
static void mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang (void);
static void mw_mirth_var_Ctx_freshZ_typeZ_varZBang (void);
static void mw_mirth_var_Ctx_freshZ_varZBang (void);
static void mw_mirth_var_Var_unifyZBang (void);
static void mw_mirth_var_Var_freshen (void);
static void mw_mirth_buffer_Buffer_index (void);
static void mw_mirth_buffer_Buffer_allocZBang (void);
static void mw_mirth_buffer_Buffer_sizze (void);
static void mw_mirth_buffer_Buffer_qname (void);
static void mw_mirth_buffer_Buffer_name (void);
static void mw_mirth_buffer_Buffer_ZEqualZEqual (void);
static void mw_mirth_buffer_Buffer_newZBang (void);
static void mw_mirth_word_Word_index (void);
static void mw_mirth_word_Word_allocZBang (void);
static void mw_mirth_word_Word_qnameZ_soft (void);
static void mw_mirth_word_Word_qnameZ_hard (void);
static void mw_mirth_word_Word_namespaceZ_hard (void);
static void mw_mirth_word_Word_name (void);
static void mw_mirth_word_Word_head (void);
static void mw_mirth_word_Word_sigZAsk (void);
static void mw_mirth_word_Word_body (void);
static void mw_mirth_word_Word_arity (void);
static void mw_mirth_word_Word_params (void);
static void mw_mirth_word_Word_arrow (void);
static void mw_mirth_word_Word_inferringZ_typeZAsk (void);
static void mw_mirth_word_Word_cname (void);
static void mw_mirth_word_Word_ctxZ_type (void);
static void mw_mirth_word_Word_type (void);
static void mw_mirth_word_Word_preferZ_inlineZAsk (void);
static void mw_mirth_word_Word_makeZ_inlineZBang (void);
static void mw_mirth_word_Word_newZBang (void);
static void mw_mirth_word_Word_ZEqualZEqual (void);
static void mw_mirth_word_Word_incZ_numZ_blocksZBang (void);
static void mw_mirth_table_Table_index (void);
static void mw_mirth_table_Table_allocZBang (void);
static void mw_mirth_table_Table_head (void);
static void mw_mirth_table_Table_qnameZ_soft (void);
static void mw_mirth_table_Table_qnameZ_hard (void);
static void mw_mirth_table_Table_name (void);
static void mw_mirth_table_Table_numZ_buffer (void);
static void mw_mirth_table_Table_ZEqualZEqual (void);
static void mw_mirth_table_Field_index (void);
static void mw_mirth_table_Field_allocZBang (void);
static void mw_mirth_table_Field_name (void);
static void mw_mirth_table_Field_qnameZ_soft (void);
static void mw_mirth_table_Field_qnameZ_hard (void);
static void mw_mirth_table_Field_indexZ_type (void);
static void mw_mirth_table_Field_valueZ_type (void);
static void mw_mirth_table_Field_dom (void);
static void mw_mirth_table_Field_cod (void);
static void mw_mirth_table_Field_type (void);
static void mw_mirth_table_Field_ZEqualZEqual (void);
static void mw_mirth_tycon_Tycon_qnameZ_hard (void);
static void mw_mirth_tycon_Tycon_ZEqualZEqual (void);
static void mw_mirth_tycon_Tycon_fullZ_typeZ_fresh (void);
static void mw_mirth_data_Data_index (void);
static void mw_mirth_data_Data_allocZBang (void);
static void mw_mirth_data_Data_headZAsk (void);
static void mw_mirth_data_Data_name (void);
static void mw_mirth_data_Data_qnameZ_soft (void);
static void mw_mirth_data_Data_qnameZ_hard (void);
static void mw_mirth_data_Data_arity (void);
static void mw_mirth_data_Data_params (void);
static void mw_mirth_data_Data_tags (void);
static void mw_mirth_data_Data_ctypeZAsk (void);
static void mw_mirth_data_TYPEz_BOOL (void);
static void mw_mirth_data_TYPEz_U64 (void);
static void mw_mirth_data_TYPEz_U32 (void);
static void mw_mirth_data_TYPEz_U16 (void);
static void mw_mirth_data_TYPEz_U8 (void);
static void mw_mirth_data_TYPEz_I64 (void);
static void mw_mirth_data_TYPEz_I32 (void);
static void mw_mirth_data_TYPEz_I16 (void);
static void mw_mirth_data_TYPEz_I8 (void);
static void mw_mirth_data_makeZ_primZ_dataZBang (void);
static void mw_mirth_data_makeZ_primZ_tagZBang (void);
static void mw_mirth_data_makeZ_primZ_intlikeZBang (void);
static void mw_mirth_data_initZ_dataZBang (void);
static void mw_mirth_data_dataZ_qname (void);
static void mw_mirth_data_dataZ_wordZ_qname (void);
static void mw_mirth_data_Data_ZEqualZEqual (void);
static void mw_mirth_data_Data_numZ_tags (void);
static void mw_mirth_data_Data_addZ_tagZBang (void);
static void mw_mirth_data_Data_isZ_unitZAsk (void);
static void mw_mirth_data_Data_isZ_enumZAsk (void);
static void mw_mirth_data_Data_isZ_transparentZAsk (void);
static void mw_mirth_data_Data_isZ_semiZ_transparentZAsk (void);
static void mw_mirth_data_Data_isZ_resourceZAsk (void);
static void mw_mirth_data_Data_isZ_valueZ_typeZAsk (void);
static void mw_mirth_data_Data_fullZ_type (void);
static void mw_mirth_data_Tag_index (void);
static void mw_mirth_data_Tag_allocZBang (void);
static void mw_mirth_data_Tag_data (void);
static void mw_mirth_data_Tag_qname (void);
static void mw_mirth_data_Tag_name (void);
static void mw_mirth_data_Tag_value (void);
static void mw_mirth_data_Tag_labelZ_inputs (void);
static void mw_mirth_data_Tag_numZ_typeZ_inputs (void);
static void mw_mirth_data_Tag_numZ_resourceZ_inputs (void);
static void mw_mirth_data_Tag_sigZAsk (void);
static void mw_mirth_data_Tag_ctxZ_type (void);
static void mw_mirth_data_Tag_ctx (void);
static void mw_mirth_data_Tag_type (void);
static void mw_mirth_data_Tag_untag (void);
static void mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig (void);
static void mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig (void);
static void mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig (void);
static void mw_mirth_data_Tag_numZ_labelZ_inputs (void);
static void mw_mirth_data_Tag_numZ_totalZ_inputs (void);
static void mw_mirth_data_Tag_isZ_transparentZAsk (void);
static void mw_mirth_data_Tag_isZ_semiZ_transparentZAsk (void);
static void mw_mirth_data_Tag_outputsZ_resourceZAsk (void);
static void mw_mirth_data_Tag_ZEqualZEqual (void);
static void mw_mirth_data_Tag_preferZ_inlineZAsk (void);
static void mw_mirth_data_DataPartial_ZEqualZEqual (void);
static void mw_mirth_match_Match_thaw (void);
static void mw_mirth_match_ZPlusMatch_freezze (void);
static void mw_mirth_match_Match_isZ_exhaustiveZAsk (void);
static void mw_mirth_match_Match_hasZ_defaultZ_caseZAsk (void);
static void mw_mirth_match_Match_scrutineeZ_dataZAsk (void);
static void mw_mirth_match_Match_isZ_transparentZAsk (void);
static void mw_mirth_match_Match_semiZ_transparentZ_tagZAsk (void);
static void mw_mirth_match_ZPlusMatch_addZ_case (void);
static void mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk (void);
static void mw_mirth_match_Case_coversZAsk (void);
static void mw_mirth_match_Case_isZ_defaultZ_caseZAsk (void);
static void mw_mirth_match_Pattern_dom (void);
static void mw_mirth_match_Pattern_thaw (void);
static void mw_mirth_match_Pattern_singleZ_tagZAsk (void);
static void mw_mirth_match_Pattern_isZ_defaultZAsk (void);
static void mw_mirth_match_ZPlusPattern_freezze (void);
static void mw_mirth_match_ZPlusPattern_opZBang (void);
static void mw_mirth_match_ZPlusPattern_underscoreZBang (void);
static void mw_mirth_match_ZPlusPattern_tagZBang (void);
static void mw_mirth_match_Pattern_coversZAsk (void);
static void mw_mirth_match_PatternOp_ZDivPatOpTag (void);
static void mw_mirth_match_PatternOp_ZDivPatOpUnderscore (void);
static void mw_mirth_external_External_index (void);
static void mw_mirth_external_External_allocZBang (void);
static void mw_mirth_external_External_qnameZ_soft (void);
static void mw_mirth_external_External_qnameZ_hard (void);
static void mw_mirth_external_External_name (void);
static void mw_mirth_external_External_arity (void);
static void mw_mirth_external_External_symbol (void);
static void mw_mirth_external_External_head (void);
static void mw_mirth_external_External_sig (void);
static void mw_mirth_external_External_ctxZ_type (void);
static void mw_mirth_external_External_type (void);
static void mw_mirth_external_External_ctype (void);
static void mw_mirth_external_External_ZEqualZEqual (void);
static void mw_mirth_external_ExternalBlock_allocZBang (void);
static void mw_mirth_external_ExternalBlock_parts (void);
static void mw_mirth_variable_Variable_index (void);
static void mw_mirth_variable_Variable_allocZBang (void);
static void mw_mirth_variable_Variable_qname (void);
static void mw_mirth_variable_Variable_name (void);
static void mw_mirth_variable_Variable_type (void);
static void mw_mirth_variable_Variable_ZEqualZEqual (void);
static void mw_mirth_variable_Variable_newZBang (void);
static void mw_mirth_arrow_Block_index (void);
static void mw_mirth_arrow_Block_allocZBang (void);
static void mw_mirth_arrow_Arrow_ctxZ_type (void);
static void mw_mirth_arrow_Arrow_type (void);
static void mw_mirth_arrow_Lambda_cod (void);
static void mw_mirth_arrow_Block_ctx (void);
static void mw_mirth_arrow_Block_token (void);
static void mw_mirth_arrow_Block_dom (void);
static void mw_mirth_arrow_Block_cod (void);
static void mw_mirth_arrow_Block_home (void);
static void mw_mirth_arrow_Block_type (void);
static void mw_mirth_arrow_Block_arrow (void);
static void mw_mirth_arrow_Block_qname (void);
static void mw_mirth_arrow_Block_ZEqualZEqual (void);
static void mw_mirth_arrow_Block_registerZ_homeZBang (void);
static void mw_mirth_arrow_Block_cname (void);
static void mw_mirth_arrow_Block_newZBang (void);
static void mw_mirth_arrow_Block_newZ_deferredZBang_1 (void);
static void mw_mirth_arrow_Block_typecheckZBang (void);
static void mw_mirth_arrow_blockZ_unifyZ_typeZBang (void);
static void mw_mirth_arrow_Block_toZ_runZ_var (void);
static void mw_mirth_arrow_Arrow_toZ_runZ_var (void);
static void mw_mirth_arrow_Atom_toZ_runZ_var (void);
static void mw_mirth_arrow_Arg_ZToStr (void);
static void mw_mirth_arrow_Arg_ZEqualZEqual (void);
static void mw_mirth_arrow_Block_freeZ_vars (void);
static void mw_mirth_arrow_Arrow_freeZ_vars (void);
static void mw_mirth_arrow_Atom_freeZ_vars (void);
static void mw_mirth_arrow_Arg_freeZ_vars (void);
static void mw_mirth_arrow_Op_freeZ_vars (void);
static void mw_mirth_match_Match_freeZ_vars (void);
static void mw_mirth_match_Case_freeZ_vars (void);
static void mw_mirth_arrow_Lambda_freeZ_vars (void);
static void mw_mirth_arrow_Arg_token (void);
static void mw_mirth_typedef_TypeDef_index (void);
static void mw_mirth_typedef_TypeDef_allocZBang (void);
static void mw_mirth_typedef_TypeDef_qnameZ_soft (void);
static void mw_mirth_typedef_TypeDef_qnameZ_hard (void);
static void mw_mirth_typedef_TypeDef_namespace (void);
static void mw_mirth_typedef_TypeDef_name (void);
static void mw_mirth_typedef_TypeDef_target (void);
static void mw_mirth_typedef_TypeDef_ZEqualZEqual (void);
static void mw_mirth_typedef_TypeDef_newZBang (void);
static void mw_mirth_mirth_ZPlusMirth_defZ_typeZBang (void);
static void mw_mirth_type_PrimType_isZ_resourceZAsk (void);
static void mw_mirth_type_PrimType_isZ_physicalZAsk (void);
static void mw_mirth_type_Type_tyconZAsk (void);
static void mw_mirth_type_PrimType_tyconZ_qname (void);
static void mw_mirth_type_Value_tyconZAsk (void);
static void mw_mirth_type_PrimType_ZToInt (void);
static void mw_mirth_type_PrimType_ZEqualZEqual (void);
static void mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang (void);
static void mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang (void);
static void mw_mirth_mirth_ZPlusMirth_initZ_typesZBang (void);
static void mw_mirth_type_TZPlus (void);
static void mw_mirth_type_TZMul (void);
static void mw_mirth_type_TZMulZPlus (void);
static void mw_mirth_type_TZ_ZTo (void);
static void mw_mirth_type_TT (void);
static void mw_mirth_type_T0 (void);
static void mw_mirth_type_T1 (void);
static void mw_mirth_type_T2 (void);
static void mw_mirth_type_T3 (void);
static void mw_mirth_type_Type_errorZAsk (void);
static void mw_mirth_type_Type_morphismZAsk (void);
static void mw_mirth_type_Type_primZAsk (void);
static void mw_mirth_type_Type_metaZEqual (void);
static void mw_mirth_type_Type_isZ_physicalZAsk (void);
static void mw_mirth_type_TYPEz_TYPE (void);
static void mw_mirth_type_TYPEz_STACK (void);
static void mw_mirth_type_TYPEz_RESOURCE (void);
static void mw_mirth_type_TYPEz_INT (void);
static void mw_mirth_type_TYPEz_F32 (void);
static void mw_mirth_type_TYPEz_F64 (void);
static void mw_mirth_type_TYPEz_PTR (void);
static void mw_mirth_type_TYPEz_STR (void);
static void mw_mirth_type_TYPEz_WORLD (void);
static void mw_mirth_type_RESOURCEz_WORLD (void);
static void mw_mirth_type_Type_expand (void);
static void mw_mirth_type_ZPlusGamma_rdrop (void);
static void mw_mirth_type_Type_unifyZ_failedZBang (void);
static void mw_mirth_type_Type_unifyZ_simpleZBang (void);
static void mw_mirth_type_Type_unifyZ_auxZBang (void);
static void mw_mirth_type_Type_unifyZ_errorZBang (void);
static void mw_mirth_type_Type_unifyZBang (void);
static void mw_mirth_type_Value_unifyZBang (void);
static void mw_mirth_type_Value_unifyZ_typeZBang (void);
static void mw_mirth_type_Value_unifyZ_errorZBang (void);
static void mw_mirth_type_Type_unifyZ_blockZBang (void);
static void mw_mirth_type_Type_unify2ZBang (void);
static void mw_mirth_type_PrimType_unifyZBang (void);
static void mw_mirth_data_Data_unifyZBang (void);
static void mw_mirth_data_DataPartial_unifyZBang (void);
static void mw_mirth_table_Table_unifyZBang (void);
static void mw_mirth_type_Type_hasZ_metaZAsk (void);
static void mw_mirth_type_Type_hasZ_meta2ZAsk (void);
static void mw_mirth_type_Value_hasZ_metaZAsk (void);
static void mw_mirth_type_Type_typeZThen (void);
static void mw_mirth_type_Value_type (void);
static void mw_mirth_type_PrimType_typeZThen (void);
static void mw_mirth_type_Type_freshen (void);
static void mw_mirth_type_Type_freshen2 (void);
static void mw_mirth_type_Type_rigidifyZBang (void);
static void mw_mirth_type_Value_rigidifyZBang (void);
static void mw_mirth_type_Type_exceptZ_field (void);
static void mw_mirth_type_MetaVar_index (void);
static void mw_mirth_type_MetaVar_allocZBang (void);
static void mw_mirth_type_MetaVar_typeZAsk (void);
static void mw_mirth_type_MetaVar_hasZ_metaZAsk (void);
static void mw_mirth_type_MetaVar_typeZThen (void);
static void mw_mirth_type_MetaVar_newZBang (void);
static void mw_mirth_type_MetaVar_expand (void);
static void mw_mirth_type_MetaVar_unifyZBang (void);
static void mw_mirth_type_MetaVar_unifyZ_errorZBang (void);
static void mw_mirth_type_MetaVar_ZEqualZEqual (void);
static void mw_mirth_type_MetaVar_freshen (void);
static void mw_mirth_type_typeZ_holeZ_unifyZBang (void);
static void mw_mirth_type_Type_appZ_typeZThenZThen (void);
static void mw_mirth_type_Type_appZ_typeZ_openZThenZThen (void);
static void mw_mirth_type_Resource_ZToType (void);
static void mw_mirth_type_Type_ZToResource (void);
static void mw_mirth_type_Resource_hasZ_metaZAsk (void);
static void mw_mirth_type_Resource_unifyZBang (void);
static void mw_mirth_type_Resource_unifyZ_errorZBang (void);
static void mw_mirth_type_Resource_typeZThen (void);
static void mw_mirth_type_Resource_freshen (void);
static void mw_mirth_type_Resource_rigidifyZBang (void);
static void mw_mirth_type_Resource_exceptZ_field (void);
static void mw_mirth_type_Type_ZToStackType (void);
static void mw_mirth_type_StackType_ZToType (void);
static void mw_mirth_type_StackType_expand (void);
static void mw_mirth_type_StackType_unitZAsk (void);
static void mw_mirth_type_StackType_split4 (void);
static void mw_mirth_type_StackType_base (void);
static void mw_mirth_type_StackType_labelZ_topZAsk (void);
static void mw_mirth_type_StackType_topZ_typeZAsk (void);
static void mw_mirth_type_StackType_topZ_tyconZAsk (void);
static void mw_mirth_type_StackType_topZ_resourceZAsk (void);
static void mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk (void);
static void mw_mirth_type_StackType_topZ_namespaces (void);
static void mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk (void);
static void mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk (void);
static void mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk (void);
static void mw_mirth_type_StackType_hasZ_metaZAsk (void);
static void mw_mirth_type_StackType_unifyZ_failedZBang (void);
static void mw_mirth_type_StackType_unifyZBang (void);
static void mw_mirth_type_StackType_unifyZ_errorZBang (void);
static void mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang (void);
static void mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang (void);
static void mw_mirth_type_StackType_forceZ_consZAskZBang (void);
static void mw_mirth_type_StackType_forceZ_withZAskZBang (void);
static void mw_mirth_type_StackType_domZThen (void);
static void mw_mirth_type_StackType_codZThen (void);
static void mw_mirth_type_StackType_baseZThen (void);
static void mw_mirth_type_StackType_stackZThen (void);
static void mw_mirth_type_StackType_semifreshen (void);
static void mw_mirth_type_StackType_freshen (void);
static void mw_mirth_type_StackType_freshenZ_aux (void);
static void mw_mirth_type_StackType_rigidifyZBang (void);
static void mw_mirth_type_ArrowType_ZToType (void);
static void mw_mirth_type_ArrowType_unpack (void);
static void mw_mirth_type_ArrowType_dom (void);
static void mw_mirth_type_ArrowType_cod (void);
static void mw_mirth_type_ArrowType_unifyZBang (void);
static void mw_mirth_type_ArrowType_unifyZ_errorZBang (void);
static void mw_mirth_type_ArrowType_hasZ_metaZAsk (void);
static void mw_mirth_type_ArrowType_sigZThen (void);
static void mw_mirth_type_ArrowType_semifreshenZ_sig (void);
static void mw_mirth_type_ArrowType_semifreshenZ_aux (void);
static void mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk (void);
static void mw_mirth_type_ArrowType_freshenZ_sig (void);
static void mw_mirth_type_ArrowType_freshenZ_sigZ_aux (void);
static void mw_mirth_type_ArrowType_freshen (void);
static void mw_mirth_type_ArrowType_rigidifyZBang (void);
static void mw_mirth_type_ArrowType_rigidifyZ_sigZBang (void);
static void mw_mirth_type_Subst_nil (void);
static void mw_mirth_type_Subst_cons (void);
static void mw_mirth_type_Subst_hasZ_varZAsk (void);
static void mw_mirth_type_Subst_getZ_var (void);
static void mw_mirth_type_StackTypePart_cons (void);
static void mw_mirth_type_StackType_splitZ_parts (void);
static void mw_mirth_type_CType_cname (void);
static void mw_mirth_type_CType_phantomZAsk (void);
static void mw_mirth_type_Resource_ctype (void);
static void mw_mirth_type_Type_ctype (void);
static void mw_mirth_type_Resource_ctypeZAsk (void);
static void mw_mirth_type_Type_ctypeZAsk (void);
static void mw_mirth_type_Type_ctype1ZAsk (void);
static void mw_mirth_type_PrimType_ctypeZAsk (void);
static void mw_mirth_data_Data_ctype1ZAsk (void);
static void mw_mirth_type_CTypeStackPart_ctype (void);
static void mw_mirth_type_CTypeStackPart_labelZAsk (void);
static void mw_mirth_type_StackTypePart_ctype (void);
static void mw_mirth_type_StackType_baseZ_ctypeZAsk (void);
static void mw_mirth_type_StackType_ctype (void);
static void mw_mirth_type_ArrowType_ctype (void);
static void mw_mirth_prim_Prim_qname (void);
static void mw_mirth_prim_Prim_name (void);
static void mw_mirth_prim_Prim_type (void);
static void mw_mirth_prim_Prim_arity (void);
static void mw_mirth_prim_Prim_ZToInt (void);
static void mw_mirth_prim_Prim_ZEqualZEqual (void);
static void mw_mirth_prim_defZ_primZBang (void);
static void mw_mirth_prim_Prim_ctxZ_typeZBang (void);
static void mw_mirth_prim_initZ_primsZBang (void);
static void mw_mirth_token_TokenValue_noneZAsk (void);
static void mw_mirth_token_TokenValue_commaZAsk (void);
static void mw_mirth_token_TokenValue_lparenZ_openZAsk (void);
static void mw_mirth_token_TokenValue_lparenZAsk (void);
static void mw_mirth_token_TokenValue_rparenZAsk (void);
static void mw_mirth_token_TokenValue_lsquareZ_openZAsk (void);
static void mw_mirth_token_TokenValue_lsquareZAsk (void);
static void mw_mirth_token_TokenValue_rsquareZAsk (void);
static void mw_mirth_token_TokenValue_lcurlyZ_openZAsk (void);
static void mw_mirth_token_TokenValue_lcurlyZAsk (void);
static void mw_mirth_token_TokenValue_rcurlyZAsk (void);
static void mw_mirth_token_TokenValue_lcolonZ_openZAsk (void);
static void mw_mirth_token_TokenValue_lcolonZAsk (void);
static void mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk (void);
static void mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk (void);
static void mw_mirth_token_TokenValue_intZAsk (void);
static void mw_mirth_token_TokenValue_strZAsk (void);
static void mw_mirth_token_TokenValue_nameZAsk (void);
static void mw_mirth_token_TokenValue_dnameZAsk (void);
static void mw_mirth_token_TokenValue_nameZ_orZ_dnameZAsk (void);
static void mw_mirth_token_TokenValue_lastZ_nameZAsk (void);
static void mw_mirth_token_TokenValue_penultimateZ_nameZAsk (void);
static void mw_mirth_token_TokenValue_argZ_endZAsk (void);
static void mw_mirth_token_TokenValue_leftZ_enclosureZAsk (void);
static void mw_mirth_token_TokenValue_rightZ_enclosureZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk (void);
static void mw_mirth_token_TokenValue_sigZ_dashesZAsk (void);
static void mw_mirth_token_TokenValue_arrowZAsk (void);
static void mw_mirth_token_TokenValue_patZ_underscoreZAsk (void);
static void mw_mirth_token_TokenValue_moduleZ_headerZAsk (void);
static void mw_mirth_token_Token_index (void);
static void mw_mirth_token_Token_succ (void);
static void mw_mirth_token_Token_pred (void);
static void mw_mirth_token_Token_allocZBang (void);
static void mw_mirth_token_Token_ZEqualZEqual (void);
static void mw_mirth_token_Token_value (void);
static void mw_mirth_token_Token_module (void);
static void mw_mirth_token_Token_col (void);
static void mw_mirth_token_Token_row (void);
static void mw_mirth_token_Token_noneZAsk (void);
static void mw_mirth_token_Token_commaZAsk (void);
static void mw_mirth_token_Token_lparenZ_openZAsk (void);
static void mw_mirth_token_Token_lparenZAsk (void);
static void mw_mirth_token_Token_rparenZAsk (void);
static void mw_mirth_token_Token_lsquareZ_openZAsk (void);
static void mw_mirth_token_Token_lsquareZAsk (void);
static void mw_mirth_token_Token_rsquareZAsk (void);
static void mw_mirth_token_Token_lcurlyZ_openZAsk (void);
static void mw_mirth_token_Token_lcurlyZAsk (void);
static void mw_mirth_token_Token_rcurlyZAsk (void);
static void mw_mirth_token_Token_lcolonZ_openZAsk (void);
static void mw_mirth_token_Token_lcolonZAsk (void);
static void mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk (void);
static void mw_mirth_token_Token_intZAsk (void);
static void mw_mirth_token_Token_strZAsk (void);
static void mw_mirth_token_Token_nameZAsk (void);
static void mw_mirth_token_Token_dnameZAsk (void);
static void mw_mirth_token_Token_nameZ_orZ_dnameZAsk (void);
static void mw_mirth_token_Token_lastZ_nameZAsk (void);
static void mw_mirth_token_Token_penultimateZ_nameZAsk (void);
static void mw_mirth_token_Token_argZ_endZAsk (void);
static void mw_mirth_token_Token_leftZ_enclosureZAsk (void);
static void mw_mirth_token_Token_rightZ_enclosureZAsk (void);
static void mw_mirth_token_Token_sigZ_typeZ_conZAsk (void);
static void mw_mirth_token_Token_sigZ_typeZ_holeZAsk (void);
static void mw_mirth_token_Token_sigZ_typeZ_varZAsk (void);
static void mw_mirth_token_Token_sigZ_paramZ_nameZAsk (void);
static void mw_mirth_token_Token_sigZ_stackZ_varZAsk (void);
static void mw_mirth_token_Token_sigZ_resourceZ_varZAsk (void);
static void mw_mirth_token_Token_sigZ_resourceZ_conZAsk (void);
static void mw_mirth_token_Token_sigZ_dashesZAsk (void);
static void mw_mirth_token_Token_arrowZAsk (void);
static void mw_mirth_token_Token_patZ_underscoreZAsk (void);
static void mw_mirth_token_Token_moduleZ_headerZAsk (void);
static void mw_mirth_token_Token_canZ_takeZ_argsZAsk (void);
static void mw_mirth_token_Token_allocZ_noneZBang (void);
static void mw_mirth_token_Token_location (void);
static void mw_mirth_token_Token_next (void);
static void mw_mirth_token_Token_prev (void);
static void mw_mirth_token_Token_nextZ_argZ_end (void);
static void mw_mirth_token_Token_hasZ_argsZAsk (void);
static void mw_mirth_token_Token_argsZ_start (void);
static void mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk (void);
static void mw_mirth_token_Token_patternZ_varZAsk (void);
static void mw_mirth_token_Token_argsZ_0 (void);
static void mw_mirth_token_Token_argsZ_1 (void);
static void mw_mirth_token_Token_argsZ_2 (void);
static void mw_mirth_token_Token_argsZ_3 (void);
static void mw_mirth_token_Token_numZ_args (void);
static void mw_mirth_token_Token_args (void);
static void mw_mirth_token_Token_argsZ_endZAsk (void);
static void mw_mirth_token_Token_argsZPlus (void);
static void mw_mirth_token_Token_moduleZ_endZAsk (void);
static void mw_mirth_token_Token_runZ_endZAsk (void);
static void mw_mirth_token_Token_runZ_tokens (void);
static void mw_mirth_token_Token_runZ_length (void);
static void mw_mirth_token_Token_runZ_arrowZAsk (void);
static void mw_mirth_token_Token_sigZ_stackZ_endZAsk (void);
static void mw_mirth_token_Token_sigZ_nextZ_stackZ_end (void);
static void mw_mirth_token_Token_sigZ_hasZ_dashesZAsk (void);
static void mw_mirth_token_Token_patZ_tokens (void);
static void mw_mirth_module_Module_index (void);
static void mw_mirth_module_Module_allocZBang (void);
static void mw_mirth_module_Module_package (void);
static void mw_mirth_module_Module_name (void);
static void mw_mirth_module_Module_qname (void);
static void mw_mirth_module_Module_path (void);
static void mw_mirth_module_Module_start (void);
static void mw_mirth_module_Module_imports (void);
static void mw_mirth_module_Module_ZEqualZEqual (void);
static void mw_mirth_module_Module_prim (void);
static void mw_mirth_module_initZ_modulesZBang (void);
static void mw_mirth_module_Module_newZBang (void);
static void mw_mirth_module_Module_addZ_importZBang (void);
static void mw_mirth_module_Module_sourceZ_path (void);
static void mw_mirth_module_Module_visible (void);
static void mw_std_prim_Int_ZToRow (void);
static void mw_mirth_location_Row_ZToInt (void);
static void mw_mirth_location_Row_showZThen (void);
static void mw_std_prim_Int_ZToCol (void);
static void mw_mirth_location_Col_ZToInt (void);
static void mw_mirth_location_Col_showZThen (void);
static void mw_mirth_location_Location_emitZThen (void);
static void mw_mirth_alias_Alias_index (void);
static void mw_mirth_alias_Alias_allocZBang (void);
static void mw_mirth_alias_Alias_qnameZ_soft (void);
static void mw_mirth_alias_Alias_qnameZ_hard (void);
static void mw_mirth_alias_Alias_namespaceZ_hard (void);
static void mw_mirth_alias_Alias_name (void);
static void mw_mirth_alias_Alias_arity (void);
static void mw_mirth_alias_Alias_target (void);
static void mw_mirth_alias_Alias_ZEqualZEqual (void);
static void mw_mirth_alias_Alias_newZBang (void);
static void mw_mirth_mirth_Builtin_AllocZBang (void);
static void mw_mirth_mirth_ZPlusMirth_InitZBang (void);
static void mw_mirth_mirth_ZPlusMirth_rdrop (void);
static void mw_mirth_mirth_Severity_ZToStr (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang (void);
static void mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang (void);
static void mw_mirth_mirth_ZPlusMirth_errorZBang (void);
static void mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang (void);
static void mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang (void);
static void mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang (void);
static void mw_mirth_mirth_ZPlusMirth_popZ_diagnostics (void);
static void mw_mirth_mirth_Diagnostic_diagnosticZThen (void);
static void mw_mirth_mirth_PropLabel_prop (void);
static void mw_mirth_mirth_PropLabel_prop2 (void);
static void mw_mirth_mirth_PropLabel_prop0_1 (void);
static void mw_mirth_mirth_PropLabel_prop_1 (void);
static void mw_mirth_mirth_PropLabel_prop2_1 (void);
static void mw_mirth_mirth_PropLabel_prop3_1 (void);
static void mw_mirth_mirth_Prop_1_readyZAsk (void);
static void mw_mirth_mirth_Prop_1_tryZ_forceZBang (void);
static void mw_mirth_mirth_Prop_1_forceZBang (void);
static void mw_mirth_mirth_Prop_1_forceZ_orZBang_1 (void);
static void mw_mirth_def_Def_packageZAsk (void);
static void mw_mirth_def_Def_moduleZAsk (void);
static void mw_mirth_def_Def_aliasZAsk (void);
static void mw_mirth_def_Def_dataZAsk (void);
static void mw_mirth_def_Def_tableZAsk (void);
static void mw_mirth_def_Def_typedefZAsk (void);
static void mw_mirth_def_Def_tagZAsk (void);
static void mw_mirth_def_Def_primZAsk (void);
static void mw_mirth_def_Def_wordZAsk (void);
static void mw_mirth_def_Def_bufferZAsk (void);
static void mw_mirth_def_Def_variableZAsk (void);
static void mw_mirth_def_Def_externalZAsk (void);
static void mw_mirth_def_Def_fieldZAsk (void);
static void mw_mirth_def_Def_ZEqualZEqual (void);
static void mw_mirth_def_Def_typecheckZBang (void);
static void mw_mirth_def_Def_callableZAsk (void);
static void mw_mirth_def_Def_definesZ_aZ_typeZAsk (void);
static void mw_mirth_def_Def_exposedZ_tyconZAsk (void);
static void mw_mirth_def_Def_sameZ_resolvedZAsk (void);
static void mw_mirth_def_Def_resolve (void);
static void mw_mirth_def_Def_name (void);
static void mw_mirth_def_Def_arity (void);
static void mw_mirth_def_Def_qnameZ_soft (void);
static void mw_mirth_def_Def_qnameZ_hard (void);
static void mw_mirth_def_Def_asZ_namespaceZAsk (void);
static void mw_mirth_def_Def_register (void);
static void mw_mirth_name_Name_index (void);
static void mw_mirth_name_Name_fromZ_index (void);
static void mw_mirth_name_Name_allocZBang (void);
static void mw_mirth_name_Name_ZToStr (void);
static void mw_mirth_name_Name_defs (void);
static void mw_mirth_name_Name_mangled (void);
static void mw_mirth_name_Name_ZEqualZEqual (void);
static void mw_mirth_name_Hash_ZToInt (void);
static void mw_std_prim_Int_ZToHash (void);
static void mw_mirth_name_HASHz_MAX (void);
static void mw_mirth_name_hashZ_nameZAt (void);
static void mw_mirth_name_hashZ_nameZBang (void);
static void mw_std_prim_Str_hash (void);
static void mw_mirth_name_Hash_next (void);
static void mw_mirth_name_Hash_keepZ_goingZAsk (void);
static void mw_std_prim_Str_ZToName (void);
static void mw_mirth_name_Name_head (void);
static void mw_mirth_name_Name_tailZ_head (void);
static void mw_mirth_name_Name_canZ_beZ_relativeZAsk (void);
static void mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk (void);
static void mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk (void);
static void mw_mirth_name_Name_couldZ_beZ_typeZ_var (void);
static void mw_mirth_name_Name_couldZ_beZ_typeZ_con (void);
static void mw_mirth_name_Name_isZ_typeZ_hole (void);
static void mw_mirth_name_Name_isZ_underscore (void);
static void mw_mirth_name_Name_couldZ_beZ_stackZ_var (void);
static void mw_mirth_name_Name_couldZ_beZ_resourceZ_var (void);
static void mw_mirth_name_Name_couldZ_beZ_resourceZ_con (void);
static void mw_mirth_name_Name_couldZ_beZ_constructor (void);
static void mw_mirth_name_Name_mangleZ_computeZBang (void);
static void mw_mirth_name_Namespace_ZEqualZEqual (void);
static void mw_mirth_name_Namespace_qname (void);
static void mw_mirth_name_Namespace_moduleZAsk (void);
static void mw_mirth_name_Namespace_prim (void);
static void mw_mirth_name_Namespace_ZToStr (void);
static void mw_mirth_name_Namespace_mangled (void);
static void mw_mirth_name_QNAME0 (void);
static void mw_mirth_name_QName_ZEqualZEqual (void);
static void mw_mirth_name_QName_defZ_hardZAsk (void);
static void mw_mirth_name_QName_definedZ_hardZAsk (void);
static void mw_mirth_name_QName_defZ_softZAsk (void);
static void mw_mirth_name_QName_definedZ_softZAsk (void);
static void mw_mirth_name_QName_undefinedZ_softZAsk (void);
static void mw_mirth_name_QName_prim (void);
static void mw_mirth_name_QName_ZToStr (void);
static void mw_mirth_name_QName_toZ_moduleZ_path (void);
static void mw_mirth_name_QName_mangled (void);
static void mw_mirth_name_DName_rootZAsk (void);
static void mw_mirth_name_DName_parts (void);
static void mw_mirth_name_DName_lastZ_name (void);
static void mw_mirth_name_DName_penultimateZ_nameZAsk (void);
static void mw_mirth_name_DName_isZ_relativeZAsk (void);
static void mw_mirth_package_Package_index (void);
static void mw_mirth_package_Package_allocZBang (void);
static void mw_mirth_package_Package_name (void);
static void mw_mirth_package_Package_qname (void);
static void mw_mirth_package_Package_path (void);
static void mw_mirth_package_Package_std (void);
static void mw_mirth_package_initZ_packagesZBang (void);
static void mw_mirth_package_Package_pathZ_orZ_search (void);
static void mw_mirth_package_Package_pathZBang (void);
static void mw_mirth_package_Package_newZBang (void);
static void mw_mirth_package_Package_newZ_orZ_pathZBang (void);
static void mw_mirth_package_Package_find (void);
static void mw_mirth_package_Package_findZ_orZ_newZBang (void);
static void mw_mirth_package_Package_ZEqualZEqual (void);
static void mw_mirth_lexer_lexerZ_stackZ_pushZBang (void);
static void mw_mirth_lexer_lexerZ_stackZ_popZBang (void);
static void mw_mirth_lexer_lexerZ_stackZ_drop (void);
static void mw_mirth_lexer_lexerZ_stackZ_peek (void);
static void mw_mirth_lexer_runZ_lexerZBang (void);
static void mw_mirth_lexer_ZPlusLexer_doneZAsk (void);
static void mw_mirth_lexer_lexerZ_makeZBang (void);
static void mw_mirth_lexer_lexerZ_emitZBang (void);
static void mw_mirth_lexer_lexerZ_nextZBang (void);
static void mw_mirth_lexer_lexerZ_newlineZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_lcolonZBang (void);
static void mw_mirth_lexer_lexerZ_closeZ_colonsZBang (void);
static void mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang (void);
static void mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_lparenZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_rparenZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_lsquareZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_rsquareZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_nameZBang (void);
static void mw_std_str_ZPlusStr_nameZAsk (void);
static void mw_std_str_ZPlusStr_firstZ_byte (void);
static void mw_std_str_ZPlusStr_secondZ_byte (void);
static void mw_std_str_ZPlusStr_thirdZ_byte (void);
static void mw_std_str_ZPlusStr_firstZ_twoZ_bytes (void);
static void mw_std_str_ZPlusStr_dropZ_firstZ_byte (void);
static void mw_std_str_ZPlusStr_dropZ_lastZ_byte (void);
static void mw_std_str_ZPlusStr_labelZ_tokenZAsk (void);
static void mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk (void);
static void mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk (void);
static void mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk (void);
static void mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk (void);
static void mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk (void);
static void mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk (void);
static void mw_std_str_ZPlusStr_dnameZAsk (void);
static void mw_std_str_ZPlusStr_isZ_docZ_startZAsk (void);
static void mw_std_str_ZPlusStr_isZ_floatZAsk (void);
static void mw_std_str_ZPlusStr_floatZ_sign (void);
static void mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float (void);
static void mw_std_str_ZPlusStr_floatZAsk (void);
static void mw_std_str_ZPlusStr_isZ_intZAsk (void);
static void mw_std_str_ZPlusStr_isZ_decZ_intZAsk (void);
static void mw_std_str_ZPlusStr_isZ_hexZ_intZAsk (void);
static void mw_std_str_ZPlusStr_isZ_octZ_intZAsk (void);
static void mw_std_str_ZPlusStr_intZAsk (void);
static void mw_std_str_ZPlusStr_intZ_sign (void);
static void mw_mirth_lexer_byteZ_signZ_valueZ_index (void);
static void mw_std_str_ZPlusStr_decZ_intZAsk (void);
static void mw_std_str_ZPlusStr_hexZ_intZAsk (void);
static void mw_std_str_ZPlusStr_octZ_intZAsk (void);
static void mw_mirth_lexer_hexdigitZ_value (void);
static void mw_mirth_lexer_lexerZ_emitZ_stringZBang (void);
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang (void);
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang (void);
static void mw_mirth_lexer_lexerZ_skipZ_commentZBang (void);
static void mw_mirth_lexer_lexerZ_skipZ_docZBang (void);
static void mw_mirth_lexer_lexerZ_commentZ_endZAsk (void);
static void mw_mirth_lexer_lexerZ_peek (void);
static void mw_mirth_lexer_lexerZ_moveZBang (void);
static void mw_mirth_lexer_lexerZ_location (void);
static void mw_mirth_lexer_lexerZ_emitZ_warningZBang (void);
static void mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_rdrop (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang (void);
static void mw_mirth_elab_resolveZ_defZ_beginZBang (void);
static void mw_mirth_elab_resolveZ_defZ_endZBang (void);
static void mw_mirth_elab_ZPlusResolveDef_rdrop (void);
static void mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous (void);
static void mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown (void);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_arity (void);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers (void);
static void mw_mirth_elab_ZPlusResolveDef_filterZ_roots (void);
static void mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk (void);
static void mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk (void);
static void mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk (void);
static void mw_mirth_name_QName_climbZ_upZ_nameZAsk (void);
static void mw_mirth_name_QName_climbZ_upZ_dnameZAsk (void);
static void mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang (void);
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang (void);
static void mw_mirth_elab_elabZ_typeZ_unifyZBang (void);
static void mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang (void);
static void mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang (void);
static void mw_mirth_elab_abZ_tokenZAt (void);
static void mw_mirth_elab_abZ_tokenZBang (void);
static void mw_mirth_elab_abZ_typeZAt (void);
static void mw_mirth_elab_abZ_typeZBang (void);
static void mw_mirth_elab_abZ_ctxZAt (void);
static void mw_mirth_elab_abZ_homeZAt (void);
static void mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1 (void);
static void mw_mirth_elab_guessZ_initialZ_ctxZ_type (void);
static void mw_mirth_elab_abZ_unifyZ_typeZBang (void);
static void mw_mirth_elab_abZ_atomZBang (void);
static void mw_mirth_elab_abZ_optimizzedZ_snocZBang (void);
static void mw_mirth_elab_atomZ_acceptsZ_argsZAsk (void);
static void mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk (void);
static void mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg (void);
static void mw_mirth_elab_abZ_opZBang (void);
static void mw_mirth_elab_abZ_expandZ_opsigZBang (void);
static void mw_mirth_elab_abZ_intZBang (void);
static void mw_mirth_elab_abZ_f64ZBang (void);
static void mw_mirth_elab_abZ_strZBang (void);
static void mw_mirth_elab_abZ_bufferZBang (void);
static void mw_mirth_elab_abZ_variableZBang (void);
static void mw_mirth_elab_abZ_fieldZBang (void);
static void mw_mirth_elab_abZ_varZBang (void);
static void mw_mirth_elab_abZ_tagZBang (void);
static void mw_mirth_elab_abZ_primZBang (void);
static void mw_mirth_elab_abZ_wordZBang (void);
static void mw_mirth_elab_abZ_externalZBang (void);
static void mw_mirth_elab_abZ_coerceZBang (void);
static void mw_mirth_elab_abZ_labelZ_pushZBang (void);
static void mw_mirth_elab_abZ_labelZ_popZBang (void);
static void mw_mirth_elab_abZ_labelZ_pushZ_rZBang (void);
static void mw_mirth_elab_abZ_labelZ_popZ_rZBang (void);
static void mw_mirth_elab_elabZ_opZ_freshZ_sigZBang (void);
static void mw_mirth_elab_dataZ_getZ_tagZ_type (void);
static void mw_mirth_elab_elabZ_coerceZ_sigZBang (void);
static void mw_mirth_elab_elabZ_blockZ_sigZBang (void);
static void mw_mirth_elab_elabZ_matchZ_sigZBang (void);
static void mw_mirth_elab_elabZ_lambdaZ_sigZBang (void);
static void mw_mirth_elab_elabZ_varZ_sigZBang (void);
static void mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang (void);
static void mw_mirth_elab_elabZ_labelZ_popZ_sigZBang (void);
static void mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang (void);
static void mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang (void);
static void mw_mirth_elab_elabZ_arrowZ_homZBang (void);
static void mw_mirth_elab_elabZ_arrowZ_fwdZBang (void);
static void mw_mirth_elab_elabZ_atomsZBang (void);
static void mw_mirth_elab_elabZ_atomZBang (void);
static void mw_mirth_elab_elabZ_labelZ_getZBang (void);
static void mw_mirth_elab_elabZ_labelZ_setZBang (void);
static void mw_mirth_elab_elabZ_atomZ_blockZBang (void);
static void mw_mirth_elab_elabZ_blockZ_atZBang (void);
static void mw_mirth_elab_elabZ_argsZBang (void);
static void mw_mirth_elab_elabZ_noZ_argsZBang (void);
static void mw_mirth_elab_arityZ_compatibleZAsk (void);
static void mw_mirth_elab_elabZ_atomZ_nameZBang (void);
static void mw_mirth_elab_elabZ_atomZ_dnameZBang (void);
static void mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk (void);
static void mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang (void);
static void mw_mirth_elab_elabZ_atomZ_failedZBang (void);
static void mw_mirth_elab_elabZ_atomZ_defZBang (void);
static void mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang (void);
static void mw_mirth_elab_elabZ_primZBang (void);
static void mw_mirth_elab_elabZ_atomZ_assertZBang (void);
static void mw_mirth_elab_elabZ_atomZ_matchZBang (void);
static void mw_mirth_elab_elabZ_matchZ_atZBang (void);
static void mw_mirth_elab_elabZ_matchZ_casesZBang (void);
static void mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang (void);
static void mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang (void);
static void mw_mirth_elab_elabZ_matchZ_caseZBang (void);
static void mw_mirth_elab_elabZ_patternZBang (void);
static void mw_mirth_elab_elabZ_patternZ_atomZBang (void);
static void mw_mirth_elab_elabZ_expandZ_tensorZBang (void);
static void mw_mirth_elab_elabZ_lambdaZ_paramZAsk (void);
static void mw_mirth_elab_elabZ_atomZ_lambdaZBang (void);
static void mw_mirth_elab_elabZ_matchZ_exhaustiveZBang (void);
static void mw_mirth_elab_elabZ_moduleZBang (void);
static void mw_mirth_elab_elabZ_moduleZ_packageZ_name (void);
static void mw_mirth_elab_elabZ_moduleZ_qname (void);
static void mw_mirth_elab_elabZ_moduleZ_headerZBang (void);
static void mw_mirth_elab_checkZ_moduleZ_path (void);
static void mw_mirth_elab_elabZ_moduleZ_declZBang (void);
static void mw_mirth_elab_loadZ_module (void);
static void mw_mirth_elab_elabZ_moduleZ_importZBang (void);
static void mw_mirth_elab_parseZ_data (void);
static void mw_mirth_elab_parseZ_dataZ_header (void);
static void mw_mirth_elab_parseZ_dataZ_tags (void);
static void mw_mirth_elab_parseZ_dataZ_tag (void);
static void mw_mirth_elab_parseZ_struct (void);
static void mw_mirth_elab_parseZ_structZ_tag (void);
static void mw_mirth_elab_elabZ_dataZBang (void);
static void mw_mirth_elab_elabZ_structZBang (void);
static void mw_mirth_elab_elabZ_dataZ_auxZBang (void);
static void mw_mirth_elab_elabZ_dataZ_headerZBang (void);
static void mw_mirth_elab_elabZ_dataZ_paramsZBang (void);
static void mw_mirth_elab_elabZ_dataZ_tagZBang (void);
static void mw_mirth_elab_dataZ_wordZ_newZBang (void);
static void mw_mirth_elab_elabZ_dataZ_doneZBang (void);
static void mw_mirth_data_Tag_outputZ_type (void);
static void mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field (void);
static void mw_mirth_data_Tag_projectZ_inputZ_label (void);
static void mw_mirth_elab_dataZ_getZ_labelZ_type (void);
static void mw_mirth_elab_dataZ_setZ_labelZ_type (void);
static void mw_mirth_elab_createZ_projectorsZBang (void);
static void mw_mirth_elab_expectZ_tokenZ_arrow (void);
static void mw_mirth_elab_parseZ_alias (void);
static void mw_mirth_elab_elabZ_aliasZBang (void);
static void mw_mirth_elab_elabZ_defZ_missingZBang (void);
static void mw_mirth_elab_elabZ_inlineZBang (void);
static void mw_mirth_elab_parseZ_def (void);
static void mw_mirth_elab_elabZ_defZBang (void);
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang (void);
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang (void);
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang (void);
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang (void);
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang (void);
static void mw_mirth_elab_elabZ_defZ_paramsZBang (void);
static void mw_mirth_elab_elabZ_defZ_bodyZBang (void);
static void mw_mirth_elab_parseZ_externalZ_decl (void);
static void mw_mirth_elab_parseZ_externalZ_declZ_part (void);
static void mw_mirth_elab_elabZ_externalZBang (void);
static void mw_mirth_elab_elabZ_externalZ_blockZ_partZBang (void);
static void mw_mirth_elab_elabZ_externalZ_defZBang (void);
static void mw_mirth_elab_elabZ_defZ_externalZ_ctype (void);
static void mw_mirth_elab_elabZ_defZ_typeZBang (void);
static void mw_mirth_elab_elabZ_bufferZBang (void);
static void mw_mirth_elab_elabZ_variableZBang (void);
static void mw_mirth_elab_elabZ_tableZBang (void);
static void mw_mirth_elab_elabZ_entryZ_point (void);
static void mw_mirth_elab_elabZ_embedZ_strZBang (void);
static void mw_mirth_elab_typecheckZ_everythingZBang (void);
static void mw_mirth_elab_TABLEz_MAXz_COUNT (void);
static void mw_mirth_elab_tableZ_qname (void);
static void mw_mirth_elab_tableZ_wordZ_newZBang (void);
static void mw_mirth_elab_tableZ_newZBang (void);
static void mw_mirth_elab_resolveZ_defZ_namespace (void);
static void mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname (void);
static void mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk (void);
static void mw_mirth_elab_elabZ_defZ_qname (void);
static void mw_mirth_elab_elabZ_defZ_qnameZ_undefined (void);
static void mw_mirth_elab_elabZ_defZ_head (void);
static void mw_mirth_elab_parseZ_field (void);
static void mw_mirth_elab_elabZ_fieldZBang (void);
static void mw_std_map_Map_2_empty (void);
static void mw_std_map_Map_2_insert (void);
static void mw_mirth_specializzer_runZ_specializzerZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_beginZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_endZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_loopZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang (void);
static void mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang (void);
static void mw_mirth_specializzer_SPKey_ZEqualZEqual (void);
static void mw_mirth_specializzer_SPKey_ZToStr (void);
static void mw_mirth_specializzer_SPKey_ZToName (void);
static void mw_mirth_word_Word_spZ_synthed (void);
static void mw_mirth_specializzer_specializzeZ_wordZBang (void);
static void mw_mirth_specializzer_specializzeZ_ctxZ_type (void);
static void mw_mirth_specializzer_synthZ_specializzedZ_wordZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang (void);
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang (void);
static void mw_std_set_SETz_INITIALz_SIZZE (void);
static void mw_std_set_ZPlusSet_new (void);
static void mw_std_set_ZPlusSet_rdrop (void);
static void mw_std_set_ZPlusSet_offsetZ_mask (void);
static void mw_std_set_ZPlusSet_memberZAsk (void);
static void mw_std_set_ZPlusSet_insertZBang (void);
static void mw_mirth_need_Need_ZToNat (void);
static void mw_mirth_need_ZPlusNeeds_new (void);
static void mw_mirth_need_ZPlusNeeds_rdrop (void);
static void mw_mirth_need_Need_neededZAsk (void);
static void mw_mirth_word_Word_neededZAsk (void);
static void mw_mirth_arrow_Block_neededZAsk (void);
static void mw_mirth_data_Tag_wordZ_neededZAsk (void);
static void mw_mirth_data_Tag_patZ_neededZAsk (void);
static void mw_mirth_need_ZPlusNeeds_needZBang (void);
static void mw_mirth_need_ZPlusNeeds_needZ_wordZBang (void);
static void mw_mirth_need_ZPlusNeeds_needZ_blockZBang (void);
static void mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang (void);
static void mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang (void);
static void mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang (void);
static void mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_needZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_argsZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_argZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_blockZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_wordZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_arrowZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_atomZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_opZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_primZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_matchZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_caseZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_patternZBang (void);
static void mw_mirth_need_ZPlusNeeds_runZ_patatomZBang (void);
static void mw_mirth_need_ZPlusNeeds_pushZ_argsZBang (void);
static void mw_mirth_need_ZPlusNeeds_pushZ_argZBang (void);
static void mw_mirth_need_ZPlusNeeds_pushZ_blockZBang (void);
static void mw_mirth_c99_ZPlusC99_put (void);
static void mw_mirth_c99_ZPlusC99_putZ_byte (void);
static void mw_mirth_c99_ZPlusC99_line (void);
static void mw_mirth_c99_c99Z_startZBang (void);
static void mw_mirth_c99_c99Z_endZBang (void);
static void mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang (void);
static void mw_mirth_c99_ZPlusC99_freshZ_natZBang (void);
static void mw_mirth_c99_ZPlusC99_freshZ_nameZBang (void);
static void mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang (void);
static void mw_mirth_c99_runZ_outputZ_c99ZBang (void);
static void mw_mirth_data_Tag_wordZ_cname (void);
static void mw_mirth_data_Tag_patZ_cname (void);
static void mw_mirth_buffer_Buffer_cname (void);
static void mw_mirth_variable_Variable_cname (void);
static void mw_mirth_table_Field_cname (void);
static void mw_mirth_external_External_cname (void);
static void mw_mirth_prim_Prim_cname (void);
static void mw_mirth_c99_ZPlusC99_sigZ_put (void);
static void mw_mirth_c99_c99Z_headerZ_str (void);
static void mw_mirth_c99_c99Z_headerZBang (void);
static void mw_mirth_c99_c99Z_buffersZBang (void);
static void mw_mirth_c99_c99Z_bufferZBang (void);
static void mw_mirth_c99_c99Z_variablesZBang (void);
static void mw_mirth_c99_c99Z_variableZBang (void);
static void mw_mirth_c99_c99Z_tagZ_defsZBang (void);
static void mw_mirth_c99_c99Z_tagZ_defZBang (void);
static void mw_mirth_c99_c99Z_tagZ_labelZ_index (void);
static void mw_mirth_c99_c99Z_tagZ_getZ_labelZBang (void);
static void mw_mirth_c99_c99Z_tagZ_setZ_labelZBang (void);
static void mw_mirth_c99_c99Z_externalZ_blocksZBang (void);
static void mw_mirth_c99_c99Z_externalZ_blockZBang (void);
static void mw_mirth_c99_c99Z_externalZ_defZBang (void);
static void mw_mirth_type_CType_c99Z_popZ_value (void);
static void mw_mirth_type_CType_c99Z_popZ_resource (void);
static void mw_mirth_type_CType_c99Z_popZ_label (void);
static void mw_mirth_type_CType_c99Z_pushZ_value (void);
static void mw_mirth_type_CType_c99Z_pushZ_resource (void);
static void mw_mirth_type_CType_c99Z_pushZ_label (void);
static void mw_mirth_type_CTypeStackPart_c99Z_argZ_name (void);
static void mw_mirth_type_CTypeStackPart_c99Z_pop (void);
static void mw_mirth_type_CTypeStackPart_c99Z_push (void);
static void mw_mirth_c99_ZPlusC99_indent (void);
static void mw_mirth_c99_c99Z_callZBang (void);
static void mw_mirth_c99_c99Z_arrowZBang (void);
static void mw_mirth_c99_c99Z_atomZBang (void);
static void mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk (void);
static void mw_mirth_c99_c99Z_argsZ_opZBang (void);
static void mw_mirth_c99_c99Z_getZ_dataZ_tagZBang (void);
static void mw_mirth_c99_c99Z_wordZBang (void);
static void mw_mirth_data_Tag_valueZ_show (void);
static void mw_mirth_c99_c99Z_tagZ_wordZBang (void);
static void mw_mirth_c99_c99Z_reverseZ_tagZBang (void);
static void mw_mirth_c99_c99Z_labelZ_defsZBang (void);
static void mw_mirth_c99_c99Z_labelZ_defZBang (void);
static void mw_mirth_c99_pushZ_localZ_labelZ_directZBang (void);
static void mw_mirth_c99_pushZ_localZ_labelZBang (void);
static void mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang (void);
static void mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang (void);
static void mw_mirth_c99_popZ_localZ_labelZ_directZBang (void);
static void mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang (void);
static void mw_mirth_c99_c99Z_labelZ_pushZBang (void);
static void mw_mirth_c99_c99Z_labelZ_pushZ_rZBang (void);
static void mw_mirth_c99_c99Z_labelZ_popZBang (void);
static void mw_mirth_c99_c99Z_labelZ_popZ_rZBang (void);
static void mw_mirth_c99_c99Z_intZBang (void);
static void mw_mirth_c99_c99Z_f64ZBang (void);
static void mw_mirth_c99_c99Z_strZBang (void);
static void mw_mirth_c99_ZPlusC99_putZ_cstrZ_long (void);
static void mw_mirth_c99_ZPlusC99_putZ_cstr (void);
static void mw_mirth_c99_c99Z_stringZ_byteZBang (void);
static void mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type (void);
static void mw_mirth_c99_C99ReprType_mkZ_macro (void);
static void mw_mirth_c99_C99ReprType_popZ_macro (void);
static void mw_mirth_c99_C99ReprType_pushZ_macro (void);
static void mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang (void);
static void mw_mirth_c99_ZPlusC99_popZ_localZ_directZBang (void);
static void mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang (void);
static void mw_mirth_c99_ZPlusC99Local_consume (void);
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL (void);
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_I64 (void);
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_U64 (void);
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_BOOL (void);
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_F32 (void);
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_F64 (void);
static void mw_mirth_c99_ZPlusC99Local_consumeZ_as (void);
static void mw_mirth_c99_ZPlusC99Local_dropZ_localZBang (void);
static void mw_mirth_c99_ZPlusC99Local_dupZ_localZBang (void);
static void mw_mirth_c99_ZPlusC99LocalResource_consume (void);
static void mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang (void);
static void mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang (void);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk (void);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk (void);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk (void);
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk (void);
static void mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang (void);
static void mw_mirth_c99_ZPlusC99_startZ_branchZBang (void);
static void mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang (void);
static void mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang (void);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZBang (void);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZBang (void);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZBang (void);
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZBang (void);
static void mw_mirth_c99_ZPlusC99Local_pushZ_localZBang (void);
static void mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang (void);
static void mw_mirth_c99_C99BinOp_Mk (void);
static void mw_mirth_c99_c99Z_primZ_binopZAsk (void);
static void mw_mirth_c99_c99Z_primZBang (void);
static void mw_mirth_c99_c99Z_binopZBang (void);
static void mw_mirth_c99_c99Z_primZ_defaultZBang (void);
static void mw_mirth_c99_c99Z_argsZ_pushZBang (void);
static void mw_mirth_c99_c99Z_argZ_pushZBang (void);
static void mw_mirth_c99_c99Z_argZ_runZBang (void);
static void mw_mirth_c99_c99Z_blockZ_runZBang (void);
static void mw_mirth_c99_ZPlusC99_varZ_put (void);
static void mw_mirth_c99_c99Z_packZ_closureZ_varsZBang (void);
static void mw_mirth_c99_c99Z_popZ_toZ_varZBang (void);
static void mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang (void);
static void mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang (void);
static void mw_mirth_c99_c99Z_blockZ_pushZBang (void);
static void mw_mirth_c99_c99Z_varZBang (void);
static void mw_mirth_c99_c99Z_varZ_runZBang (void);
static void mw_mirth_c99_c99Z_varZ_pushZBang (void);
static void mw_mirth_c99_c99Z_lambdaZBang (void);
static void mw_mirth_c99_c99Z_matchZBang (void);
static void mw_mirth_c99_c99Z_caseZBang (void);
static void mw_mirth_c99_c99Z_wordZ_sigsZBang (void);
static void mw_mirth_c99_c99Z_wordZ_sigZBang (void);
static void mw_mirth_c99_c99Z_blockZ_sigsZBang (void);
static void mw_mirth_c99_c99Z_blockZ_sigZBang (void);
static void mw_mirth_c99_c99Z_fieldZ_sigsZBang (void);
static void mw_mirth_c99_c99Z_fieldZ_sigZBang (void);
static void mw_mirth_c99_c99Z_blockZ_enterZBang (void);
static void mw_mirth_c99_c99Z_blockZ_exitZBang (void);
static void mw_mirth_c99_c99Z_blockZ_defsZBang (void);
static void mw_mirth_c99_c99Z_blockZ_defZBang (void);
static void mw_mirth_c99_c99Z_wordZ_enterZBang (void);
static void mw_mirth_c99_c99Z_wordZ_exitZBang (void);
static void mw_mirth_c99_c99Z_wordZ_defsZBang (void);
static void mw_mirth_c99_c99Z_wordZ_defZBang (void);
static void mw_mirth_c99_c99Z_fieldZ_defsZBang (void);
static void mw_mirth_c99_c99Z_fieldZ_defZBang (void);
static void mw_mirth_c99_c99Z_mainZBang (void);
static void mw_mirth_main_Arguments_default (void);
static void mw_mirth_main_compileZBang (void);
static void mw_mirth_main_parseZ_packageZ_def (void);
static void mw_mirth_main_compilerZ_parseZ_args (void);
static void mw_mirth_main_main (void);
static void mb_mirth_main_main_1 (void);
static void mb_std_list_List_1_for_1_0 (void);
static void mb_std_list_List_1_for_1_1 (void);
static void mb_std_prim_Str_ZToName_2 (void);
static void mb_mirth_mirth_PropLabel_prop2_1_1 (void);
static void mb_mirth_mirth_PropLabel_prop3_1_1 (void);
static void mb_mirth_mirth_PropLabel_prop0_1_1 (void);
static void mb_mirth_elab_abZ_buildZ_homZBang_1_1 (void);
static void mb_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1_2 (void);
static void mb_mirth_elab_dataZ_getZ_labelZ_type_0 (void);
static void mb_mirth_elab_elabZ_blockZ_atZBang_1 (void);
static void mb_mirth_elab_elabZ_aliasZBang_0 (void);
static void mb_mirth_elab_elabZ_aliasZBang_6 (void);
static void mb_mirth_elab_elabZ_defZBang_0 (void);
static void mb_mirth_elab_elabZ_defZBang_2 (void);
static void mb_mirth_elab_elabZ_defZBang_3 (void);
static void mb_mirth_elab_elabZ_defZBang_4 (void);
static void mb_mirth_elab_elabZ_defZ_typeZBang_2 (void);
static void mb_mirth_elab_elabZ_variableZBang_1 (void);
static void mb_mirth_elab_elabZ_fieldZBang_2 (void);
static void mb_mirth_elab_elabZ_fieldZBang_3 (void);
static void mb_mirth_elab_elabZ_dataZ_headerZBang_2 (void);
static void mb_mirth_elab_elabZ_dataZ_tagZBang_1 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_5 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_6 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_7 (void);
static void mb_mirth_elab_elabZ_dataZ_doneZBang_12 (void);
static void mb_mirth_elab_elabZ_defZ_head_3 (void);
static void mb_mirth_elab_createZ_projectorsZBang_0 (void);
static void mb_mirth_elab_createZ_projectorsZBang_1 (void);
static void mb_mirth_elab_createZ_projectorsZBang_2 (void);
static void mb_mirth_elab_createZ_projectorsZBang_3 (void);
static void mb_mirth_elab_createZ_projectorsZBang_4 (void);
static void mb_mirth_elab_createZ_projectorsZBang_5 (void);
static void mb_mirth_elab_createZ_projectorsZBang_6 (void);
static void mb_mirth_elab_createZ_projectorsZBang_7 (void);
static void mb_mirth_elab_createZ_projectorsZBang_8 (void);
static void mb_mirth_elab_createZ_projectorsZBang_9 (void);
static void mb_mirth_elab_createZ_projectorsZBang_10 (void);
static void mb_mirth_elab_createZ_projectorsZBang_11 (void);
static void mb_mirth_elab_createZ_projectorsZBang_13 (void);
static void mb_mirth_elab_createZ_projectorsZBang_17 (void);
static void mb_mirth_elab_elabZ_externalZ_defZBang_2 (void);
static void mb_mirth_elab_elabZ_externalZ_defZBang_4 (void);
static void mb_mirth_specializzer_specializzeZ_wordZBang_1 (void);
static void mb_mirth_specializzer_specializzeZ_wordZBang_2 (void);
static void mb_mirth_specializzer_specializzeZ_wordZBang_3 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_embedZ_strZBangZDot58ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot57ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot24ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot373ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot303ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot221ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot174ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot146ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot116ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot73ZRParen_0 (void);
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot44ZRParen_0 (void);
static void mfld_mirth_label_Label_ZTildename (void);
static void mfld_mirth_var_Var_ZTildename (void);
static void mfld_mirth_var_Var_ZTildetype (void);
static void mfld_mirth_var_Var_ZTildeautoZ_runZAsk (void);
static void mfld_mirth_buffer_Buffer_ZTildehead (void);
static void mfld_mirth_buffer_Buffer_ZTildesizze (void);
static void mfld_mirth_buffer_Buffer_ZTildeqname (void);
static void mfld_mirth_word_Word_ZTildename (void);
static void mfld_mirth_word_Word_ZTildearity (void);
static void mfld_mirth_word_Word_ZTildeqname (void);
static void mfld_mirth_word_Word_ZTildehead (void);
static void mfld_mirth_word_Word_ZTildesigZAsk (void);
static void mfld_mirth_word_Word_ZTildebody (void);
static void mfld_mirth_word_Word_ZTildectxZ_type (void);
static void mfld_mirth_word_Word_ZTildeparams (void);
static void mfld_mirth_word_Word_ZTildearrow (void);
static void mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk (void);
static void mfld_mirth_word_Word_ZTildecname (void);
static void mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk (void);
static void mfld_mirth_word_Word_ZTildenumZ_blocks (void);
static void mfld_mirth_table_Table_ZTildehead (void);
static void mfld_mirth_table_Table_ZTildename (void);
static void mfld_mirth_table_Table_ZTildeqname (void);
static void mfld_mirth_table_Table_ZTildenumZ_buffer (void);
static void mfld_mirth_table_Table_ZTildemaxZ_count (void);
static void mfld_mirth_table_Field_ZTildehead (void);
static void mfld_mirth_table_Field_ZTildename (void);
static void mfld_mirth_table_Field_ZTildeqname (void);
static void mfld_mirth_table_Field_ZTildeindexZ_type (void);
static void mfld_mirth_table_Field_ZTildevalueZ_type (void);
static void mfld_mirth_data_Data_ZTildeheadZAsk (void);
static void mfld_mirth_data_Data_ZTildeqname (void);
static void mfld_mirth_data_Data_ZTildename (void);
static void mfld_mirth_data_Data_ZTildearity (void);
static void mfld_mirth_data_Data_ZTildeparams (void);
static void mfld_mirth_data_Data_ZTildetags (void);
static void mfld_mirth_data_Data_ZTildectypeZAsk (void);
static void mfld_mirth_data_Data_ZTildelastZ_tagZ_value (void);
static void mfld_mirth_data_Data_ZTildeisZ_unitZAsk (void);
static void mfld_mirth_data_Data_ZTildeisZ_enumZAsk (void);
static void mfld_mirth_data_Data_ZTildeisZ_transparentZAsk (void);
static void mfld_mirth_data_Data_ZTildeisZ_semiZ_transparentZAsk (void);
static void mfld_mirth_data_Data_ZTildeisZ_resourceZAsk (void);
static void mfld_mirth_data_Tag_ZTildedata (void);
static void mfld_mirth_data_Tag_ZTildeqname (void);
static void mfld_mirth_data_Tag_ZTildevalue (void);
static void mfld_mirth_data_Tag_ZTildelabelZ_inputs (void);
static void mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs (void);
static void mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs (void);
static void mfld_mirth_data_Tag_ZTildesigZAsk (void);
static void mfld_mirth_data_Tag_ZTildectxZ_type (void);
static void mfld_mirth_data_Tag_ZTildeuntag (void);
static void mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs (void);
static void mfld_mirth_external_External_ZTildename (void);
static void mfld_mirth_external_External_ZTildearity (void);
static void mfld_mirth_external_External_ZTildeqname (void);
static void mfld_mirth_external_External_ZTildesymbol (void);
static void mfld_mirth_external_External_ZTildehead (void);
static void mfld_mirth_external_External_ZTildesig (void);
static void mfld_mirth_external_External_ZTildectxZ_type (void);
static void mfld_mirth_external_External_ZTildectype (void);
static void mfld_mirth_external_ExternalBlock_ZTildetoken (void);
static void mfld_mirth_external_ExternalBlock_ZTildeparts (void);
static void mfld_mirth_variable_Variable_ZTildehead (void);
static void mfld_mirth_variable_Variable_ZTildeqname (void);
static void mfld_mirth_variable_Variable_ZTildetype (void);
static void mfld_mirth_arrow_Block_ZTildectx (void);
static void mfld_mirth_arrow_Block_ZTildetoken (void);
static void mfld_mirth_arrow_Block_ZTildehome (void);
static void mfld_mirth_arrow_Block_ZTildedom (void);
static void mfld_mirth_arrow_Block_ZTildecod (void);
static void mfld_mirth_arrow_Block_ZTildearrow (void);
static void mfld_mirth_arrow_Block_ZTildeqname (void);
static void mfld_mirth_arrow_Block_ZTildehomeZ_index (void);
static void mfld_mirth_arrow_Block_ZTildecname (void);
static void mfld_mirth_arrow_Block_ZTildefreeZ_vars (void);
static void mfld_mirth_typedef_TypeDef_ZTildeheadZAsk (void);
static void mfld_mirth_typedef_TypeDef_ZTildename (void);
static void mfld_mirth_typedef_TypeDef_ZTildeqname (void);
static void mfld_mirth_typedef_TypeDef_ZTildetarget (void);
static void mfld_mirth_type_MetaVar_ZTildetypeZAsk (void);
static void mfld_mirth_prim_Prim_ZTildename (void);
static void mfld_mirth_prim_Prim_ZTildectx (void);
static void mfld_mirth_prim_Prim_ZTildetype (void);
static void mfld_mirth_prim_Prim_ZTildedecl (void);
static void mfld_mirth_prim_Prim_ZTildearity (void);
static void mfld_mirth_token_Token_ZTildevalue (void);
static void mfld_mirth_token_Token_ZTildemodule (void);
static void mfld_mirth_token_Token_ZTilderow (void);
static void mfld_mirth_token_Token_ZTildecol (void);
static void mfld_mirth_module_Module_ZTildepackage (void);
static void mfld_mirth_module_Module_ZTildename (void);
static void mfld_mirth_module_Module_ZTildepath (void);
static void mfld_mirth_module_Module_ZTildestart (void);
static void mfld_mirth_module_Module_ZTildeend (void);
static void mfld_mirth_module_Module_ZTildeimports (void);
static void mfld_mirth_alias_Alias_ZTildehead (void);
static void mfld_mirth_alias_Alias_ZTildename (void);
static void mfld_mirth_alias_Alias_ZTildearity (void);
static void mfld_mirth_alias_Alias_ZTildeqname (void);
static void mfld_mirth_alias_Alias_ZTildetarget (void);
static void mfld_mirth_name_Name_ZTildeStr (void);
static void mfld_mirth_name_Name_ZTildedefs (void);
static void mfld_mirth_name_Name_ZTildemangled (void);
static void mfld_mirth_name_Name_ZTildelabel (void);
static void mfld_mirth_package_Package_ZTildename (void);
static void mfld_mirth_package_Package_ZTildepath (void);
static void mfld_mirth_word_Word_ZTildespZ_checked (void);
static void mfld_mirth_arrow_Block_ZTildespZ_checked (void);
static void mfld_mirth_word_Word_ZTildespZ_synthed (void);
static void mfld_mirth_data_Tag_ZTildewordZ_cname (void);
static void mfld_mirth_data_Tag_ZTildepatZ_cname (void);
static void mfld_mirth_buffer_Buffer_ZTildecname (void);
static void mfld_mirth_variable_Variable_ZTildecname (void);
static void mfld_mirth_table_Field_ZTildecname (void);
static void mfld_mirth_external_External_ZTildecname (void);
static void mfld_mirth_prim_Prim_ZTildecname (void);
static void mfld_mirth_data_Tag_ZTildevalueZ_show (void);
int main (int argc, char** argv) {
	global_argc = argc;
	global_argv = argv;
	VAL v0 = (MKU64(0) /* The World! */);
	push_resource(v0);
	mw_mirth_main_main();
	return 0;
}
static void mfld_mirth_label_Label_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_var_Var_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_var_Var_ZTildetype (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_var_Var_ZTildeautoZ_runZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_buffer_Buffer_ZTildehead (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_buffer_Buffer_ZTildesizze (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_buffer_Buffer_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildearity (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildehead (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildesigZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildebody (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildectxZ_type (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildeparams (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildearrow (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildecname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildenumZ_blocks (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Table_ZTildehead (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Table_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Table_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Table_ZTildenumZ_buffer (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Table_ZTildemaxZ_count (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Field_ZTildehead (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Field_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Field_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Field_ZTildeindexZ_type (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Field_ZTildevalueZ_type (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeheadZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildearity (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeparams (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildetags (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildectypeZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildelastZ_tagZ_value (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeisZ_unitZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeisZ_enumZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeisZ_transparentZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeisZ_semiZ_transparentZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Data_ZTildeisZ_resourceZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildedata (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildevalue (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildelabelZ_inputs (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildesigZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildectxZ_type (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildeuntag (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildearity (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildesymbol (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildehead (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildesig (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildectxZ_type (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildectype (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_ExternalBlock_ZTildetoken (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_ExternalBlock_ZTildeparts (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_variable_Variable_ZTildehead (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_variable_Variable_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_variable_Variable_ZTildetype (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildectx (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildetoken (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildehome (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildedom (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildecod (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildearrow (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildehomeZ_index (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildecname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildefreeZ_vars (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_typedef_TypeDef_ZTildeheadZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_typedef_TypeDef_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_typedef_TypeDef_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_typedef_TypeDef_ZTildetarget (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_type_MetaVar_ZTildetypeZAsk (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_prim_Prim_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_prim_Prim_ZTildectx (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_prim_Prim_ZTildetype (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_prim_Prim_ZTildedecl (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_prim_Prim_ZTildearity (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_token_Token_ZTildevalue (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_token_Token_ZTildemodule (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_token_Token_ZTilderow (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_token_Token_ZTildecol (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_module_Module_ZTildepackage (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_module_Module_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_module_Module_ZTildepath (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_module_Module_ZTildestart (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_module_Module_ZTildeend (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_module_Module_ZTildeimports (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_alias_Alias_ZTildehead (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_alias_Alias_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_alias_Alias_ZTildearity (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_alias_Alias_ZTildeqname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_alias_Alias_ZTildetarget (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_name_Name_ZTildeStr (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_name_Name_ZTildedefs (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_name_Name_ZTildemangled (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_name_Name_ZTildelabel (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_package_Package_ZTildename (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_package_Package_ZTildepath (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildespZ_checked (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_arrow_Block_ZTildespZ_checked (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_word_Word_ZTildespZ_synthed (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildewordZ_cname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildepatZ_cname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_buffer_Buffer_ZTildecname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_variable_Variable_ZTildecname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_table_Field_ZTildecname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_external_External_ZTildecname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_prim_Prim_ZTildecname (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mfld_mirth_data_Tag_ZTildevalueZ_show (void) {
	size_t i = (size_t)pop_u64();
	static struct VAL * p = 0;
	size_t m = 524288;
	if (! p) { p = calloc(m, sizeof *p); }
	EXPECT(i<m, "table grew too big");
	push_ptr(p+i);
}

static void mw_std_either_Either_2_leftZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Left
			mtp_std_either_Either_2_Left();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // Right
			mtp_std_either_Either_2_Right();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_byte_Byte_ZToInt (void) {
}
static void mw_std_prim_Int_ZToByte (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (0LL);
	int64_t v2 = (255LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	push_i64(v2);
	mw_std_prim_Int_inZ_range();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
	} else {
		STRLIT("Int->Byte out of range", 22);
		STRLIT("assertion failed: ", 18);
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		push_value(v5);
		mp_primZ_strZ_cat();
		mp_primZ_panic();
	}
}
static void mw_std_byte_Byte_ZToU8 (void) {
	mw_std_byte_Byte_ZToInt();
	mw_std_prim_Int_ZToU8();
}
static void mw_std_prim_U8_ZToByte (void) {
	mw_std_prim_Int_ZToByte();
}
static void mw_std_prim_Ptr_ZAtByte (void) {
	mp_primZ_u8Z_get();
	mw_std_prim_U8_ZToByte();
}
static void mw_std_byte_Byte_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_std_byte_Byte_ZToInt();
	push_value(v0);
	mw_std_byte_Byte_ZToInt();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_std_byte_Byte_ZTo (void) {
	VAL v0 = pop_value();
	mw_std_byte_Byte_ZToInt();
	push_value(v0);
	mw_std_byte_Byte_ZToInt();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v1) < VI64(v2));
	push_bool(v3);
}
static void mw_std_byte_Byte_inZ_range (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	mw_std_byte_Byte_ZToInt();
	push_value(v1);
	mw_std_byte_Byte_ZToInt();
	push_value(v0);
	mw_std_byte_Byte_ZToInt();
	mw_std_prim_Int_inZ_range();
}
static void mw_std_byte_Byte_isZ_upper (void) {
	uint64_t v0 = (65LL /* B'A' */);
	uint64_t v1 = (90LL /* B'Z' */);
	push_u64(v0);
	push_u64(v1);
	mw_std_byte_Byte_inZ_range();
}
static void mw_std_byte_Byte_isZ_lower (void) {
	uint64_t v0 = (97LL /* B'a' */);
	uint64_t v1 = (122LL /* B'z' */);
	push_u64(v0);
	push_u64(v1);
	mw_std_byte_Byte_inZ_range();
}
static void mw_std_byte_Byte_isZ_digit (void) {
	uint64_t v0 = (48LL /* B'0' */);
	uint64_t v1 = (57LL /* B'9' */);
	push_u64(v0);
	push_u64(v1);
	mw_std_byte_Byte_inZ_range();
}
static void mw_std_byte_Byte_isZ_alpha (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_std_byte_Byte_isZ_upper();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		decref(v2);
		uint64_t v3 = (1LL /* True */);
		push_u64(v3);
	} else {
		mw_std_byte_Byte_isZ_lower();
	}
}
static void mw_std_byte_Byte_isZ_alnum (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_std_byte_Byte_isZ_digit();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		decref(v2);
		uint64_t v3 = (1LL /* True */);
		push_u64(v3);
	} else {
		mw_std_byte_Byte_isZ_alpha();
	}
}
static void mw_std_byte_Byte_isZ_printable (void) {
	uint64_t v0 = (33LL /* B'!' */);
	uint64_t v1 = (126LL /* B'~' */);
	push_u64(v0);
	push_u64(v1);
	mw_std_byte_Byte_inZ_range();
}
static void mw_std_byte_Byte_isZ_hexdigit (void) {
	switch (get_top_data_tag()) {
		case 48LL: { // B'0'
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		case 49LL: { // B'1'
			(void)pop_u64();
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 50LL: { // B'2'
			(void)pop_u64();
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		} break;
		case 51LL: { // B'3'
			(void)pop_u64();
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		} break;
		case 52LL: { // B'4'
			(void)pop_u64();
			uint64_t v4 = (1LL /* True */);
			push_u64(v4);
		} break;
		case 53LL: { // B'5'
			(void)pop_u64();
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		} break;
		case 54LL: { // B'6'
			(void)pop_u64();
			uint64_t v6 = (1LL /* True */);
			push_u64(v6);
		} break;
		case 55LL: { // B'7'
			(void)pop_u64();
			uint64_t v7 = (1LL /* True */);
			push_u64(v7);
		} break;
		case 56LL: { // B'8'
			(void)pop_u64();
			uint64_t v8 = (1LL /* True */);
			push_u64(v8);
		} break;
		case 57LL: { // B'9'
			(void)pop_u64();
			uint64_t v9 = (1LL /* True */);
			push_u64(v9);
		} break;
		case 65LL: { // B'A'
			(void)pop_u64();
			uint64_t v10 = (1LL /* True */);
			push_u64(v10);
		} break;
		case 66LL: { // B'B'
			(void)pop_u64();
			uint64_t v11 = (1LL /* True */);
			push_u64(v11);
		} break;
		case 67LL: { // B'C'
			(void)pop_u64();
			uint64_t v12 = (1LL /* True */);
			push_u64(v12);
		} break;
		case 68LL: { // B'D'
			(void)pop_u64();
			uint64_t v13 = (1LL /* True */);
			push_u64(v13);
		} break;
		case 69LL: { // B'E'
			(void)pop_u64();
			uint64_t v14 = (1LL /* True */);
			push_u64(v14);
		} break;
		case 70LL: { // B'F'
			(void)pop_u64();
			uint64_t v15 = (1LL /* True */);
			push_u64(v15);
		} break;
		case 97LL: { // B'a'
			(void)pop_u64();
			uint64_t v16 = (1LL /* True */);
			push_u64(v16);
		} break;
		case 98LL: { // B'b'
			(void)pop_u64();
			uint64_t v17 = (1LL /* True */);
			push_u64(v17);
		} break;
		case 99LL: { // B'c'
			(void)pop_u64();
			uint64_t v18 = (1LL /* True */);
			push_u64(v18);
		} break;
		case 100LL: { // B'd'
			(void)pop_u64();
			uint64_t v19 = (1LL /* True */);
			push_u64(v19);
		} break;
		case 101LL: { // B'e'
			(void)pop_u64();
			uint64_t v20 = (1LL /* True */);
			push_u64(v20);
		} break;
		case 102LL: { // B'f'
			(void)pop_u64();
			uint64_t v21 = (1LL /* True */);
			push_u64(v21);
		} break;
		default: {
			VAL v22 = pop_value();
			decref(v22);
			uint64_t v23 = (0LL /* False */);
			push_u64(v23);
		} break;
	}
}
static void mw_std_byte_Byte_emitZ_asciiZThen (void) {
	mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
}
static void mw_std_byte_Byte_toZ_strZ_unsafe (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mtw_std_list_List_1_Cons();
	mw_std_prim_Str_fromZ_bytesZ_unsafe();
}
static void mw_std_byte_Byte_toZ_asciiZ_str (void) {
	VAL v0 = pop_value();
	incref(v0);
	uint64_t v1 = (0LL /* BNUL */);
	uint64_t v2 = (127LL /* BDEL */);
	push_value(v0);
	push_value(v0);
	push_u64(v1);
	push_u64(v2);
	mw_std_byte_Byte_inZ_range();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		mw_std_byte_Byte_toZ_strZ_unsafe();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		VAL v4 = pop_value();
		decref(v4);
		uint64_t v5 = (0LL /* None */);
		push_u64(v5);
	}
}
static void mw_std_byte_Byte_isZ_stringZ_end (void) {
	switch (get_top_data_tag()) {
		case 34LL: { // BQUOTE
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		case 10LL: { // BLF
			(void)pop_u64();
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 0LL: { // BNUL
			(void)pop_u64();
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		} break;
		default: {
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} break;
	}
}
static void mw_std_byte_Byte_toZ_hexdigits (void) {
	mw_std_byte_Byte_ZToInt();
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (4LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	mp_primZ_intZ_shr();
	mw_std_byte_oneZ_hexdigitZ_byte();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	int64_t v4 = (15LL);
	uint64_t v5 = (VU64(v3) & ((uint64_t)(v4)));
	push_value(v2);
	push_u64(v5);
	mw_std_byte_oneZ_hexdigitZ_byte();
}
static void mw_std_byte_oneZ_hexdigitZ_byte (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (9LL);
	bool v2 = (v1 < VI64(v0));
	push_value(v0);
	if (v2) {
		int64_t v3 = (55LL);
		push_i64(v3);
	} else {
		int64_t v4 = (48LL);
		push_i64(v4);
	}
	mp_primZ_intZ_add();
	mw_std_prim_Int_ZToByte();
}
static void mw_std_byte_Byte_isZ_nameZ_byte (void) {
	switch (get_top_data_tag()) {
		case 40LL: { // BLPAREN
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		case 41LL: { // BRPAREN
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		case 91LL: { // BLSQUARE
			(void)pop_u64();
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		case 93LL: { // BRSQUARE
			(void)pop_u64();
			uint64_t v3 = (0LL /* False */);
			push_u64(v3);
		} break;
		case 123LL: { // BLCURLY
			(void)pop_u64();
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} break;
		case 125LL: { // BRCURLY
			(void)pop_u64();
			uint64_t v5 = (0LL /* False */);
			push_u64(v5);
		} break;
		case 44LL: { // BCOMMA
			(void)pop_u64();
			uint64_t v6 = (0LL /* False */);
			push_u64(v6);
		} break;
		case 34LL: { // BQUOTE
			(void)pop_u64();
			uint64_t v7 = (0LL /* False */);
			push_u64(v7);
		} break;
		case 58LL: { // BCOLON
			(void)pop_u64();
			uint64_t v8 = (0LL /* False */);
			push_u64(v8);
		} break;
		case 127LL: { // BDEL
			(void)pop_u64();
			uint64_t v9 = (0LL /* False */);
			push_u64(v9);
		} break;
		default: {
			uint64_t v10 = (32LL /* BSPACE */);
			push_u64(v10);
			mw_std_byte_Byte_ZTo();
		} break;
	}
}
static void mw_std_byte_Byte_isZ_sign (void) {
	switch (get_top_data_tag()) {
		case 45LL: { // B'-'
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		case 43LL: { // B'+'
			(void)pop_u64();
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		default: {
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* False */);
			push_u64(v3);
		} break;
	}
}
static void mw_std_byte_Byte_zzencode (void) {
	switch (get_top_data_tag()) {
		case 38LL: { // B'&'
			(void)pop_u64();
			STRLIT("ZAmp", 4);
		} break;
		case 63LL: { // B'?'
			(void)pop_u64();
			STRLIT("ZAsk", 4);
		} break;
		case 64LL: { // B'@'
			(void)pop_u64();
			STRLIT("ZAt", 3);
		} break;
		case 92LL: { // B'\'
			(void)pop_u64();
			STRLIT("ZBSlash", 7);
		} break;
		case 33LL: { // B'!'
			(void)pop_u64();
			STRLIT("ZBang", 5);
		} break;
		case 94LL: { // B'^'
			(void)pop_u64();
			STRLIT("ZCaret", 6);
		} break;
		case 58LL: { // BCOLON
			(void)pop_u64();
			STRLIT("ZColon", 6);
		} break;
		case 44LL: { // BCOMMA
			(void)pop_u64();
			STRLIT("ZComma", 6);
		} break;
		case 47LL: { // B'/'
			(void)pop_u64();
			STRLIT("ZDiv", 4);
		} break;
		case 36LL: { // B'$'
			(void)pop_u64();
			STRLIT("ZDollar", 7);
		} break;
		case 46LL: { // BDOT
			(void)pop_u64();
			STRLIT("ZDot", 4);
		} break;
		case 61LL: { // B'='
			(void)pop_u64();
			STRLIT("ZEqual", 6);
		} break;
		case 35LL: { // BHASH
			(void)pop_u64();
			STRLIT("ZHash", 5);
		} break;
		case 123LL: { // BLCURLY
			(void)pop_u64();
			STRLIT("ZLCurly", 7);
		} break;
		case 40LL: { // BLPAREN
			(void)pop_u64();
			STRLIT("ZLParen", 7);
		} break;
		case 91LL: { // BLSQUARE
			(void)pop_u64();
			STRLIT("ZLSquare", 8);
		} break;
		case 60LL: { // B'<'
			(void)pop_u64();
			STRLIT("ZLess", 5);
		} break;
		case 37LL: { // B'%'
			(void)pop_u64();
			STRLIT("ZMod", 4);
		} break;
		case 42LL: { // B'*'
			(void)pop_u64();
			STRLIT("ZMul", 4);
		} break;
		case 124LL: { // B'|'
			(void)pop_u64();
			STRLIT("ZPipe", 5);
		} break;
		case 43LL: { // B'+'
			(void)pop_u64();
			STRLIT("ZPlus", 5);
		} break;
		case 34LL: { // BQUOTE
			(void)pop_u64();
			STRLIT("ZQuote", 6);
		} break;
		case 125LL: { // BRCURLY
			(void)pop_u64();
			STRLIT("ZRCurly", 7);
		} break;
		case 41LL: { // BRPAREN
			(void)pop_u64();
			STRLIT("ZRParen", 7);
		} break;
		case 93LL: { // BRSQUARE
			(void)pop_u64();
			STRLIT("ZRSquare", 8);
		} break;
		case 59LL: { // B';'
			(void)pop_u64();
			STRLIT("ZThen", 5);
		} break;
		case 39LL: { // BTICK
			(void)pop_u64();
			STRLIT("ZTick", 5);
		} break;
		case 126LL: { // B'~'
			(void)pop_u64();
			STRLIT("ZTilde", 6);
		} break;
		case 62LL: { // B'>'
			(void)pop_u64();
			STRLIT("ZTo", 3);
		} break;
		case 90LL: { // B'Z'
			(void)pop_u64();
			STRLIT("ZZ", 2);
		} break;
		case 45LL: { // B'-'
			(void)pop_u64();
			STRLIT("Z_", 2);
		} break;
		case 122LL: { // B'z'
			(void)pop_u64();
			STRLIT("zz", 2);
		} break;
		case 95LL: { // B'_'
			(void)pop_u64();
			STRLIT("z_", 2);
		} break;
		default: {
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_std_byte_Byte_isZ_alnum();
			VAL v1 = pop_value();
			if (VBOOL(v1)) {
				mw_std_byte_Byte_toZ_strZ_unsafe();
			} else {
				STRLIT("", 0);
				mtw_std_str_ZPlusStr_ZPlusStr();
				STRLIT("Z", 1);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				mw_std_byte_Byte_ZToInt();
				mp_primZ_intZ_toZ_str();
				mw_std_str_ZPlusStr_pushZ_strZBang();
				STRLIT("U", 1);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				mtp_std_str_ZPlusStr_ZPlusStr();
			}
		} break;
	}
}
static void mw_std_buffer_ZPlusBuffer_new (void) {
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = (MKU64(0LL /* +Unsafe */));
	push_value(v0);
	lpush(&lbl_sizze, v0);
	push_resource(v1);
	mp_primZ_ptrZ_alloc();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = pop_value();
	lpush(&lbl_base, v2);
	mtw_std_buffer_ZPlusBuffer_ZPlusBuffer();
	int64_t v3 = (0LL);
	push_i64(v3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang();
}
static void mw_std_buffer_ZPlusBuffer_resizzeZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	lpush(&lbl_oldZ_sizze, v0);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r1 = pop_resource();
	VAL v2 = (MKU64(0LL /* +Unsafe */));
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_resource(v2);
	push_value(v3);
	push_value(v4);
	mp_primZ_ptrZ_realloc();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	push_resource(r1);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v5 = (lpop(&lbl_oldZ_sizze));
	incref(v5);
	push_value(v5);
	lpush(&lbl_oldZ_sizze, v5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	bool v8 = (VI64(v7) < VI64(v6));
	if (v8) {
		VAL v9 = (lpop(&lbl_oldZ_sizze));
		incref(v9);
		push_value(v9);
		lpush(&lbl_oldZ_sizze, v9);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL v10 = (lpop(&lbl_oldZ_sizze));
		push_value(v10);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang();
	} else {
		VAL v11 = (lpop(&lbl_oldZ_sizze));
		decref(v11);
	}
}
static void mw_std_buffer_ZPlusBuffer_expandZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v1) < VI64(v2));
	if (v3) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		int64_t v4 = (2LL);
		VAL v5 = pop_value();
		int64_t v6 = (VI64(v5) * v4);
		push_i64(v6);
		mw_std_prelude_Sizze_max();
		mw_std_buffer_ZPlusBuffer_resizzeZBang();
	} else {
		VAL v7 = pop_value();
		decref(v7);
	}
}
static void mw_std_buffer_ZPlusBuffer_rdrop (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Buffer
			mtp_std_buffer_ZPlusBuffer_ZPlusBuffer();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_base));
	VAL v1 = (MKU64(0LL /* +Unsafe */));
	push_value(v0);
	push_resource(v1);
	mp_primZ_ptrZ_free();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = (lpop(&lbl_sizze));
	decref(v2);
}
static void mw_std_buffer_ZPlusBuffer_eraseZ_spanZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_std_buffer_ZPlusBuffer_checkZ_spanZBang();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v4 = (MKU64(0LL /* +Unsafe */));
	VAL v5 = pop_value();
	push_resource(v4);
	push_value(v5);
	mp_primZ_ptrZ_add();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	int64_t v8 = (0LL);
	push_i64(v8);
	mw_std_prim_Int_ZToU8();
	push_value(v7);
	push_value(v6);
	mp_primZ_ptrZ_fill();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_buffer_ZPlusBuffer_checkZ_spanZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	int64_t v2 = (0LL);
	bool v3 = (VI64(v1) < v2);
	push_value(v1);
	push_value(v0);
	if (v3) {
		uint64_t v4 = (1LL /* True */);
		push_u64(v4);
	} else {
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		incref(v6);
		incref(v5);
		push_value(v6);
		push_value(v5);
		push_value(v6);
		push_value(v5);
		mp_primZ_intZ_add();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		bool v9 = (VI64(v7) < VI64(v8));
		push_bool(v9);
	}
	VAL v10 = pop_value();
	if (VBOOL(v10)) {
		STRLIT("memory access out of bounds", 27);
		mp_primZ_panic();
	} else {
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
}
static void mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_std_buffer_ZPlusBuffer_checkZ_spanZBang();
	VAL v2 = pop_value();
	push_value(v2);
	mp_primZ_intZ_mod();
	int64_t v3 = (0LL);
	VAL v4 = pop_value();
	bool v5 = (VI64(v4) == v3);
	if (v5) {
	} else {
		STRLIT("memory access unaligned", 23);
		mp_primZ_panic();
	}
}
static void mw_std_buffer_ZPlusBuffer_ZAtU8 (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (1LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v2 = (MKU64(0LL /* +Unsafe */));
	VAL v3 = pop_value();
	push_resource(v2);
	push_value(v3);
	mp_primZ_ptrZ_add();
	mp_primZ_u8Z_get();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_buffer_ZPlusBuffer_ZBangU8 (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (1LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	mw_std_buffer_ZPlusBuffer_checkZ_spanZ_alignZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v2 = (MKU64(0LL /* +Unsafe */));
	VAL v3 = pop_value();
	push_resource(v2);
	push_value(v3);
	mp_primZ_ptrZ_add();
	mp_primZ_u8Z_set();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_buffer_ZPlusBuffer_ZBangByte (void) {
	VAL v0 = pop_value();
	mw_std_byte_Byte_ZToU8();
	push_value(v0);
	mw_std_buffer_ZPlusBuffer_ZBangU8();
}
static void mw_std_buffer_ZPlusBuffer_ZBangStr (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v0);
	push_value(v1);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	mw_std_buffer_ZPlusBuffer_checkZ_spanZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v2 = (MKU64(0LL /* +Unsafe */));
	VAL v3 = pop_value();
	push_resource(v2);
	push_value(v3);
	mp_primZ_ptrZ_add();
	mw_std_prim_Ptr_ZBangStrZPlus();
	VAL v4 = pop_value();
	decref(v4);
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_buffer_ZPlusBuffer_ZAtStr (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_std_buffer_ZPlusBuffer_checkZ_spanZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v2 = (MKU64(0LL /* +Unsafe */));
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_resource(v2);
	push_value(v3);
	mp_primZ_ptrZ_add();
	push_value(v4);
	mp_primZ_strZ_copy();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_prim_Ptr_ZBangStrZPlus (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v1);
	push_value(v0);
	push_value(v1);
	mp_primZ_strZ_base();
	push_value(v1);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	incref(v2);
	incref(v4);
	push_value(v3);
	push_value(v2);
	push_value(v4);
	push_value(v2);
	push_value(v4);
	mp_primZ_ptrZ_add();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v6);
	mp_primZ_ptrZ_copy();
	decref(v1);
	push_value(v5);
}
static void mw_std_str_ZPlusStr_dupZBang (void) {
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	push_value(v0);
}
static void mw_std_str_ZPlusStr_numZ_bytesZAsk (void) {
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	VAL v1 = pop_value();
	mtw_std_str_ZPlusStr_ZPlusStr();
	push_value(v1);
}
static void mw_std_str_ZPlusStr_lastZ_byte (void) {
	mw_std_str_ZPlusStr_numZ_bytesZAsk();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_sub();
	mw_std_str_ZPlusStr_byteZAt();
}
static void mw_std_str_ZPlusStr_byteZAt (void) {
	mw_std_str_ZPlusStr_dupZBang();
	mw_std_prim_Str_byteZAt();
}
static void mw_std_str_offsetZ_inZ_bounds (void) {
	VAL v0 = pop_value();
	int64_t v1 = (0LL);
	push_i64(v1);
	push_value(v0);
	mw_std_prim_Int_inZ_range();
}
static void mw_std_prim_Str_byteZAt (void) {
	VAL v0 = pop_value();
	incref(v0);
	incref(v0);
	push_value(v0);
	mp_primZ_strZ_base();
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	push_value(v1);
	mw_std_str_offsetZ_inZ_bounds();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
		VAL v5 = (MKU64(0LL /* +Unsafe */));
		VAL v6 = pop_value();
		push_resource(v5);
		push_value(v6);
		mp_primZ_ptrZ_add();
		mw_std_prim_Ptr_ZAtByte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	} else {
		VAL v7 = pop_value();
		decref(v7);
		VAL v8 = pop_value();
		decref(v8);
		uint64_t v9 = (0LL /* BNUL */);
		push_u64(v9);
	}
	decref(v0);
}
static void mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang (void) {
	mw_std_byte_Byte_toZ_strZ_unsafe();
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang (void) {
	mw_std_byte_Byte_toZ_asciiZ_str();
	mw_std_maybe_Maybe_1_unwrap();
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_std_str_ZPlusStr_pushZ_strZBang (void) {
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mp_primZ_strZ_cat();
	mtw_std_str_ZPlusStr_ZPlusStr();
}
static void mw_std_prim_Str_dropZ_bytes (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	bool v4 = (VI64(v3) < VI64(v2));
	if (v4) {
		uint64_t v5 = (0LL /* False */);
		push_u64(v5);
	} else {
		uint64_t v6 = (1LL /* True */);
		push_u64(v6);
	}
	VAL v7 = pop_value();
	if (VBOOL(v7)) {
		VAL v8 = pop_value();
		decref(v8);
		VAL v9 = pop_value();
		decref(v9);
		STRLIT("", 0);
	} else {
		VAL v10 = pop_value();
		incref(v10);
		incref(v10);
		push_value(v10);
		mp_primZ_strZ_base();
		push_value(v10);
		mp_primZ_strZ_numZ_bytes();
		mw_std_prim_Int_ZToNat();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v12);
		push_value(v11);
		push_value(v13);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v15);
		mp_primZ_ptrZ_add();
		push_value(v14);
		mp_primZ_strZ_copy();
		decref(v10);
	}
}
static void mw_std_prim_Str_fromZ_bytesZ_unsafe (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_std_list_List_1_len();
	mw_std_buffer_ZPlusBuffer_new();
	VAL v1 = pop_value();
	int64_t v2 = (0LL);
	push_i64(v2);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		mw_std_byte_Byte_ZToU8();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v9);
		push_value(v10);
		mw_std_buffer_ZPlusBuffer_ZBangU8();
		int64_t v11 = (1LL);
		push_i64(v11);
		mp_primZ_intZ_add();
		push_value(v8);
		mw_std_list_List_1_uncons();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		push_value(v12);
		push_value(v13);
	}
	VAL v14 = pop_value();
	decref(v14);
	VAL v15 = pop_value();
	decref(v15);
	VAL v16 = pop_value();
	decref(v16);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v17 = (MKU64(0LL /* +Unsafe */));
	push_resource(v17);
	mp_primZ_strZ_copy();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_std_buffer_ZPlusBuffer_rdrop();
}
static void mw_std_str_clampZ_sliceZ_offsetZ_sizze (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v0);
	VAL v2 = pop_value();
	push_value(v0);
	push_value(v2);
	push_value(v0);
	mw_std_prelude_Offset_min();
	VAL v3 = pop_value();
	incref(v3);
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	push_value(v3);
	mw_std_prim_Int_ZToNat();
	VAL v5 = pop_value();
	push_value(v5);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
	push_value(v1);
	mw_std_prelude_Sizze_min();
}
static void mw_std_prim_Str_slice (void) {
	VAL v0 = pop_value();
	incref(v0);
	incref(v0);
	push_value(v0);
	mp_primZ_strZ_base();
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	mw_std_str_clampZ_sliceZ_offsetZ_sizze();
	VAL v3 = pop_value();
	push_value(v2);
	mp_primZ_ptrZ_add();
	push_value(v3);
	mp_primZ_strZ_copy();
	decref(v0);
}
static void mw_std_prim_Str_dropZ_slice (void) {
	VAL r0 = pop_resource();
	mtw_std_str_ZPlusStr_ZPlusStr();
	push_resource(r0);
	mw_std_str_ZPlusStr_dropZ_slice();
	VAL r1 = pop_resource();
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v2 = pop_value();
	decref(v2);
	push_resource(r1);
}
static void mw_std_prim_Str_takeZ_slice (void) {
	VAL r0 = pop_resource();
	mtw_std_str_ZPlusStr_ZPlusStr();
	push_resource(r0);
	mw_std_str_ZPlusStr_takeZ_slice();
	VAL r1 = pop_resource();
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v2 = pop_value();
	decref(v2);
	push_resource(r1);
}
static void mw_std_str_ZPlusStr_slice (void) {
	VAL r0 = pop_resource();
	mw_std_str_ZPlusStr_dupZBang();
	push_resource(r0);
	mw_std_prim_Str_slice();
}
static void mw_std_str_ZPlusStr_offsetZ_slice (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	bool v2 = (VI64(v1) < VI64(v0));
	push_value(v1);
	push_value(v0);
	if (v2) {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v3);
		push_value(v4);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		mw_std_str_ZPlusStr_slice();
	} else {
		VAL v5 = pop_value();
		decref(v5);
		VAL v6 = pop_value();
		decref(v6);
		STRLIT("", 0);
	}
}
static void mw_std_str_ZPlusStr_takeZ_slice (void) {
	int64_t v0 = (0LL);
	VAL v1 = pop_value();
	push_i64(v0);
	push_value(v1);
	mw_std_str_ZPlusStr_slice();
}
static void mw_std_str_ZPlusStr_dropZ_slice (void) {
	VAL r0 = pop_resource();
	mw_std_str_ZPlusStr_numZ_bytesZAsk();
	push_resource(r0);
	mw_std_str_ZPlusStr_slice();
}
static void mw_std_str_ZPlusStr_splitZ_byte (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	int64_t v1 = (0LL);
	push_i64(v1);
	push_i64(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		VAL r3 = pop_resource();
		push_value(v2);
		push_value(v2);
		mw_std_str_ZPlusStr_numZ_bytesZAsk();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		bool v6 = (VI64(v5) < VI64(v4));
		push_resource(r3);
		if (!v6) break;
		VAL v7 = pop_value();
		incref(v7);
		VAL v8 = pop_value();
		VAL r9 = pop_resource();
		push_value(v7);
		mw_std_str_ZPlusStr_byteZAt();
		VAL r10 = pop_resource();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		push_value(v11);
		push_value(v12);
		mw_std_byte_Byte_ZEqualZEqual();
		VAL v13 = pop_value();
		push_resource(r10);
		push_resource(r9);
		push_value(v8);
		push_value(v7);
		if (VBOOL(v13)) {
			VAL v14 = pop_value();
			incref(v14);
			VAL v15 = pop_value();
			VAL r16 = pop_resource();
			VAL v17 = (MKU64(0LL /* +Unsafe */));
			push_value(v14);
			push_value(v15);
			push_value(v14);
			push_resource(v17);
			mw_std_str_ZPlusStr_offsetZ_slice();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +Unsafe
					(void)pop_resource();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			push_resource(r16);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mtw_std_list_List_1_Cons();
			mtw_std_list_ZPlusList_1_ZPlusList();
			int64_t v18 = (1LL);
			push_i64(v18);
			mp_primZ_intZ_add();
			VAL v19 = pop_value();
			incref(v19);
			push_value(v19);
			push_value(v19);
		} else {
			int64_t v20 = (1LL);
			push_i64(v20);
			mp_primZ_intZ_add();
		}
	}
	VAL r21 = pop_resource();
	VAL v22 = (MKU64(0LL /* +Unsafe */));
	push_resource(v22);
	mw_std_str_ZPlusStr_offsetZ_slice();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	push_resource(r21);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusListZPlus_1_ZPlusListZPlus();
	mtp_std_list_ZPlusListZPlus_1_ZPlusListZPlus();
	mw_std_list_List_1_reverse();
	VAL v23 = pop_value();
	VAL v24 = pop_value();
	decref(v24);
	push_value(v23);
}
static void mw_std_prim_Str_splitZ_byte (void) {
	mtw_std_str_ZPlusStr_ZPlusStr();
	mw_std_str_ZPlusStr_splitZ_byte();
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v0 = pop_value();
	decref(v0);
}
static void mw_std_str_ZPlusStr_pushZ_showZ_byteZBang (void) {
	switch (get_top_data_tag()) {
		case 34LL: { // BQUOTE
			(void)pop_u64();
			STRLIT("\\\"", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			uint64_t v0 = (0LL /* False */);
			VAL v1 = (lpop(&lbl_escapeZ_hex));
			decref(v1);
			lpush(&lbl_escapeZ_hex, MKU64(v0));
		} break;
		case 92LL: { // B'\'
			(void)pop_u64();
			STRLIT("\\\\", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			uint64_t v2 = (0LL /* False */);
			VAL v3 = (lpop(&lbl_escapeZ_hex));
			decref(v3);
			lpush(&lbl_escapeZ_hex, MKU64(v2));
		} break;
		case 10LL: { // BLF
			(void)pop_u64();
			STRLIT("\n", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			uint64_t v4 = (0LL /* False */);
			VAL v5 = (lpop(&lbl_escapeZ_hex));
			decref(v5);
			lpush(&lbl_escapeZ_hex, MKU64(v4));
		} break;
		case 13LL: { // BCR
			(void)pop_u64();
			STRLIT("\r", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			uint64_t v6 = (0LL /* False */);
			VAL v7 = (lpop(&lbl_escapeZ_hex));
			decref(v7);
			lpush(&lbl_escapeZ_hex, MKU64(v6));
		} break;
		case 9LL: { // BHT
			(void)pop_u64();
			STRLIT("\t", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			uint64_t v8 = (0LL /* False */);
			VAL v9 = (lpop(&lbl_escapeZ_hex));
			decref(v9);
			lpush(&lbl_escapeZ_hex, MKU64(v8));
		} break;
		default: {
			VAL v10 = pop_value();
			incref(v10);
			uint64_t v11 = (32LL /* BSPACE */);
			uint64_t v12 = (126LL /* B'~' */);
			push_value(v10);
			push_value(v10);
			push_u64(v11);
			push_u64(v12);
			mw_std_byte_Byte_inZ_range();
			VAL v13 = pop_value();
			if (VBOOL(v13)) {
				VAL v14 = (lpop(&lbl_escapeZ_hex));
				incref(v14);
				lpush(&lbl_escapeZ_hex, v14);
				if (VBOOL(v14)) {
					VAL v15 = pop_value();
					incref(v15);
					push_value(v15);
					push_value(v15);
					mw_std_byte_Byte_isZ_hexdigit();
				} else {
					uint64_t v16 = (0LL /* False */);
					push_u64(v16);
				}
				VAL v17 = pop_value();
				if (VBOOL(v17)) {
					uint64_t v18 = (0LL /* False */);
					push_u64(v18);
				} else {
					uint64_t v19 = (1LL /* True */);
					push_u64(v19);
				}
			} else {
				uint64_t v20 = (0LL /* False */);
				push_u64(v20);
			}
			VAL v21 = pop_value();
			if (VBOOL(v21)) {
				mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
				uint64_t v22 = (0LL /* False */);
				VAL v23 = (lpop(&lbl_escapeZ_hex));
				decref(v23);
				lpush(&lbl_escapeZ_hex, MKU64(v22));
			} else {
				STRLIT("\\x", 2);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				mw_std_byte_Byte_toZ_hexdigits();
				VAL v24 = pop_value();
				mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
				push_value(v24);
				mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
				uint64_t v25 = (1LL /* True */);
				VAL v26 = (lpop(&lbl_escapeZ_hex));
				decref(v26);
				lpush(&lbl_escapeZ_hex, MKU64(v25));
			}
		} break;
	}
}
static void mw_std_prim_Str_showZThen (void) {
	STRLIT("\"", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	uint64_t v0 = (0LL /* False */);
	VAL v1 = pop_value();
	incref(v1);
	incref(v1);
	lpush(&lbl_escapeZ_hex, MKU64(v0));
	push_value(v1);
	mp_primZ_strZ_base();
	push_value(v1);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		int64_t v3 = (0LL);
		bool v4 = (v3 < VI64(v2));
		push_value(v2);
		if (!v4) break;
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		incref(v6);
		VAL v7 = (MKU64(0LL /* +Unsafe */));
		push_value(v6);
		push_resource(v7);
		mw_std_prim_Ptr_ZAtByte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_str_ZPlusStr_pushZ_showZ_byteZBang();
		int64_t v8 = (1LL);
		VAL v9 = (MKU64(0LL /* +Unsafe */));
		push_i64(v8);
		push_resource(v9);
		push_value(v6);
		mp_primZ_ptrZ_add();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		int64_t v10 = (1LL);
		push_value(v5);
		push_i64(v10);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
	decref(v1);
	VAL v13 = (lpop(&lbl_escapeZ_hex));
	decref(v13);
	STRLIT("\"", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_std_list_List_1_ZDivL1 (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			switch (get_top_data_tag()) {
				case 0LL: { // Nil
					(void)pop_u64();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				default: {
					VAL v0 = pop_value();
					decref(v0);
					VAL v1 = pop_value();
					decref(v1);
					uint64_t v2 = (0LL /* None */);
					push_u64(v2);
				} break;
			}
		} break;
		default: {
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* None */);
			push_u64(v4);
		} break;
	}
}
static void mw_std_list_List_1_ZDivL2 (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			mw_std_list_List_1_ZDivL1();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v0 = pop_value();
					VAL v1 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v1);
					mp_primZ_packZ_cons();
					push_value(v0);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v2 = pop_value();
					decref(v2);
					uint64_t v3 = (0LL /* None */);
					push_u64(v3);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (0LL /* None */);
			push_u64(v5);
		} break;
	}
}
static void mw_std_list_List_1_emptyZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_std_list_List_1_ZToListZPlus (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			mtw_std_maybe_Maybe_1_Some();
		} break;
	}
}
static void mw_std_list_List_1_len (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		decref(v7);
		int64_t v9 = (1LL);
		push_i64(v9);
		mp_primZ_intZ_add();
		push_value(v8);
		mw_std_list_List_1_uncons();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_std_list_List_1_uncons (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			uint64_t v1 = (0LL /* Nil */);
			push_u64(v0);
			push_u64(v1);
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			VAL v2 = pop_value();
			mtw_std_maybe_Maybe_1_Some();
			push_value(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_list_ListZPlus_1_uncons (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			STRLIT("Nil in List+.uncons", 19);
			mp_primZ_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_list_List_1_unsnoc (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			uint64_t v0 = (0LL /* Nil */);
			uint64_t v1 = (0LL /* None */);
			push_u64(v0);
			push_u64(v1);
		} break;
		default: {
			mw_std_list_ListZPlus_1_unsnoc();
			mtw_std_maybe_Maybe_1_Some();
		} break;
	}
}
static void mw_std_list_ListZPlus_1_unsnoc (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			STRLIT("L0 in List+.unsnoc", 18);
			mp_primZ_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			switch (get_top_data_tag()) {
				case 0LL: { // Nil
					(void)pop_u64();
					uint64_t v0 = (0LL /* Nil */);
					VAL v1 = pop_value();
					push_u64(v0);
					push_value(v1);
				} break;
				default: {
					mw_std_list_ListZPlus_1_unsnoc();
					VAL v2 = pop_value();
					mtw_std_list_List_1_Cons();
					push_value(v2);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_list_List_1_cat (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
		} break;
		default: {
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			mw_std_list_List_1_reverse();
			mw_std_list_List_1_uncons();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			while(1) {
				VAL v4 = pop_value();
				incref(v4);
				push_value(v4);
				push_value(v4);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v5 = pop_value();
				if (!VBOOL(v5)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				push_value(v6);
				push_value(v8);
				mtw_std_list_List_1_Cons();
				push_value(v7);
				mw_std_list_List_1_uncons();
				VAL v9 = pop_value();
				VAL v10 = pop_value();
				push_value(v9);
				push_value(v10);
			}
			VAL v11 = pop_value();
			decref(v11);
			VAL v12 = pop_value();
			decref(v12);
		} break;
	}
}
static void mw_std_list_List_1_first (void) {
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_std_list_ListZPlus_1_first();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_list_List_1_last (void) {
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_std_list_ListZPlus_1_last();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_list_ListZPlus_1_first (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			STRLIT("Nil at List+.first", 18);
			mp_primZ_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_list_ListZPlus_1_last (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			STRLIT("Nil at List+.last", 17);
			mp_primZ_panic();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			mw_std_list_List_1_uncons();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			while(1) {
				VAL v2 = pop_value();
				incref(v2);
				push_value(v2);
				push_value(v2);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v3 = pop_value();
				if (!VBOOL(v3)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v4 = pop_value();
				VAL v5 = pop_value();
				VAL v6 = pop_value();
				decref(v6);
				push_value(v4);
				push_value(v5);
				mw_std_list_List_1_uncons();
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				push_value(v7);
				push_value(v8);
			}
			VAL v9 = pop_value();
			decref(v9);
			VAL v10 = pop_value();
			decref(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_list_List_1_reverse (void) {
	uint64_t v0 = (0LL /* Nil */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v6);
		push_value(v8);
		mtw_std_list_List_1_Cons();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
}
static void mw_std_prim_Int_range (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	while(1) {
		VAL r1 = pop_resource();
		VAL v2 = pop_value();
		VAL v3 = pop_value();
		incref(v3);
		incref(v2);
		bool v4 = (VI64(v2) < VI64(v3));
		push_value(v3);
		push_value(v2);
		if (v4) {
			uint64_t v5 = (0LL /* False */);
			push_u64(v5);
		} else {
			uint64_t v6 = (1LL /* True */);
			push_u64(v6);
		}
		VAL v7 = pop_value();
		push_resource(r1);
		if (!VBOOL(v7)) break;
		VAL r8 = pop_resource();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		incref(v10);
		int64_t v11 = (1LL);
		push_value(v10);
		push_i64(v11);
		mp_primZ_intZ_add();
		push_value(v9);
		push_value(v10);
		push_resource(r8);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
	}
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	push_value(v12);
}
static void mw_std_maybe_Maybe_1_noneZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_maybe_Maybe_1_someZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_maybe_Maybe_1_ZToBool (void) {
	mw_std_maybe_Maybe_1_someZAsk();
}
static void mw_std_maybe_Maybe_1_ZToList (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* Nil */);
			push_u64(v0);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			uint64_t v1 = (0LL /* Nil */);
			push_u64(v1);
			mtw_std_list_List_1_Cons();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_maybe_Maybe_1_unwrap (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("tried to unwrap None", 20);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_maybe_Maybe_1_zzip (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					VAL v4 = pop_value();
					decref(v4);
					uint64_t v5 = (0LL /* None */);
					push_u64(v5);
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v6 = pop_value();
					VAL v7 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v6);
					mp_primZ_packZ_cons();
					push_value(v7);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_prim_Int_ZToOS (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (1LL);
	int64_t v2 = (3LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	push_i64(v2);
	mw_std_prim_Int_inZ_range();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
	} else {
		VAL v4 = pop_value();
		decref(v4);
		uint64_t v5 = (0LL /* OS_UNKNOWN */);
		push_u64(v5);
	}
}
static void mw_std_prim_Int_ZToArch (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (1LL);
	int64_t v2 = (3LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	push_i64(v2);
	mw_std_prim_Int_inZ_range();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
	} else {
		VAL v4 = pop_value();
		decref(v4);
		uint64_t v5 = (0LL /* ARCH_UNKNOWN */);
		push_u64(v5);
	}
}
static void mw_std_prim_Int_inZ_range (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	bool v3 = (VI64(v2) < VI64(v1));
	if (v3) {
		uint64_t v4 = (0LL /* False */);
		push_u64(v4);
	} else {
		uint64_t v5 = (1LL /* True */);
		push_u64(v5);
	}
	bool v6 = (VI64(v0) < VI64(v2));
	if (v6) {
		uint64_t v7 = (0LL /* False */);
		push_u64(v7);
	} else {
		uint64_t v8 = (1LL /* True */);
		push_u64(v8);
	}
	VAL v9 = pop_value();
	if (VBOOL(v9)) {
	} else {
		VAL v10 = pop_value();
		decref(v10);
		uint64_t v11 = (0LL /* False */);
		push_u64(v11);
	}
}
static void mw_std_prim_Int_ZToU8ZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (0LL);
	int64_t v2 = (255LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	push_i64(v2);
	mw_std_prim_Int_inZ_range();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		mtw_std_maybe_Maybe_1_Some();
	} else {
		VAL v4 = pop_value();
		decref(v4);
		uint64_t v5 = (0LL /* None */);
		push_u64(v5);
	}
}
static void mw_std_prim_Int_ZToU16ZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (0LL);
	int64_t v2 = (65535LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	push_i64(v2);
	mw_std_prim_Int_inZ_range();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		mtw_std_maybe_Maybe_1_Some();
	} else {
		VAL v4 = pop_value();
		decref(v4);
		uint64_t v5 = (0LL /* None */);
		push_u64(v5);
	}
}
static void mw_std_prim_Int_ZToU8 (void) {
	mw_std_prim_Int_ZToU8ZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("U8 out of bounds", 16);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_prim_Int_ZToU16 (void) {
	mw_std_prim_Int_ZToU16ZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("U16 out of bounds", 17);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_prim_Int_ZToI64 (void) {
}
static void mw_std_prim_Int_ZToNat (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (0LL);
	bool v2 = (VI64(v0) < v1);
	push_value(v0);
	if (v2) {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	} else {
		uint64_t v4 = (1LL /* True */);
		push_u64(v4);
	}
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
	} else {
		STRLIT("tried to create negative Nat", 28);
		mp_primZ_panic();
		mp_primZ_panic();
	}
}
static void mw_std_prelude_Sizze_max (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	bool v2 = (VI64(v1) < VI64(v0));
	push_value(v1);
	push_value(v0);
	if (v2) {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	} else {
		uint64_t v4 = (1LL /* True */);
		push_u64(v4);
	}
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
		VAL v6 = pop_value();
		decref(v6);
	} else {
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		decref(v8);
		push_value(v7);
	}
}
static void mw_std_prelude_Sizze_min (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	bool v2 = (VI64(v0) < VI64(v1));
	push_value(v1);
	push_value(v0);
	if (v2) {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	} else {
		uint64_t v4 = (1LL /* True */);
		push_u64(v4);
	}
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
		VAL v6 = pop_value();
		decref(v6);
	} else {
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		decref(v8);
		push_value(v7);
	}
}
static void mw_std_prelude_Offset_min (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	bool v2 = (VI64(v0) < VI64(v1));
	push_value(v1);
	push_value(v0);
	if (v2) {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	} else {
		uint64_t v4 = (1LL /* True */);
		push_u64(v4);
	}
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
		VAL v6 = pop_value();
		decref(v6);
	} else {
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		decref(v8);
		push_value(v7);
	}
}
static void mw_std_prelude_ZAtZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mp_primZ_mutZ_isZ_set();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mp_primZ_mutZ_get();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		VAL v2 = pop_value();
		decref(v2);
		uint64_t v3 = (0LL /* None */);
		push_u64(v3);
	}
}
static void mw_std_path_PATHz_SEPARATOR (void) {
	mp_primZ_sysZ_os();
	mw_std_prim_Int_ZToOS();
	uint64_t v0 = (1LL /* OS_WINDOWS */);
	VAL v1 = pop_value();
	bool v2 = (VI64(v1) == ((int64_t)(v0)));
	if (v2) {
		STRLIT("\\", 1);
	} else {
		STRLIT("/", 1);
	}
}
static void mw_std_path_Path_joinZ_with (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v0);
	push_value(v2);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	int64_t v3 = (0LL);
	VAL v4 = pop_value();
	bool v5 = (VI64(v4) == v3);
	if (v5) {
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		decref(v7);
		VAL v8 = pop_value();
		decref(v8);
		push_value(v6);
	} else {
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v10);
		mp_primZ_strZ_cat();
		push_value(v9);
		mp_primZ_strZ_cat();
	}
}
static void mw_std_path_Path_join (void) {
	VAL v0 = pop_value();
	mw_std_path_PATHz_SEPARATOR();
	push_value(v0);
	mw_std_path_Path_joinZ_with();
}
static void mw_std_byte_Byte_isZ_pathZ_separatorZAsk (void) {
	switch (get_top_data_tag()) {
		case 47LL: { // B'/'
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		case 92LL: { // B'\'
			(void)pop_u64();
			mp_primZ_sysZ_os();
			mw_std_prim_Int_ZToOS();
			uint64_t v1 = (1LL /* OS_WINDOWS */);
			VAL v2 = pop_value();
			bool v3 = (VI64(v2) == ((int64_t)(v1)));
			push_bool(v3);
		} break;
		default: {
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (0LL /* False */);
			push_u64(v5);
		} break;
	}
}
static void mw_std_path_Path_splitZ_last (void) {
	mtw_std_str_ZPlusStr_ZPlusStr();
	mw_std_str_ZPlusStr_numZ_bytesZAsk();
	uint64_t v0 = (0LL /* None */);
	push_u64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mw_std_maybe_Maybe_1_noneZAsk();
		VAL v2 = pop_value();
		if (VBOOL(v2)) {
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			int64_t v5 = (0LL);
			bool v6 = (v5 < VI64(v4));
			push_value(v4);
			push_value(v3);
			push_bool(v6);
		} else {
			uint64_t v7 = (0LL /* False */);
			push_u64(v7);
		}
		VAL v8 = pop_value();
		if (!VBOOL(v8)) break;
		VAL v9 = pop_value();
		decref(v9);
		int64_t v10 = (1LL);
		push_i64(v10);
		mp_primZ_intZ_sub();
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		mw_std_str_ZPlusStr_byteZAt();
		VAL r12 = pop_resource();
		mw_std_byte_Byte_isZ_pathZ_separatorZAsk();
		VAL v13 = pop_value();
		push_resource(r12);
		push_value(v11);
		if (VBOOL(v13)) {
			VAL v14 = pop_value();
			incref(v14);
			push_value(v14);
			push_value(v14);
			mtw_std_maybe_Maybe_1_Some();
		} else {
			uint64_t v15 = (0LL /* None */);
			push_u64(v15);
		}
	}
	VAL v16 = pop_value();
	VAL v17 = pop_value();
	decref(v17);
	push_value(v16);
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v18 = pop_value();
	VAL v19 = pop_value();
	push_value(v18);
	push_value(v19);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v20 = (MKU64(0LL /* +Unsafe */));
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			incref(v21);
			incref(v22);
			int64_t v23 = (1LL);
			push_resource(v20);
			push_value(v21);
			push_value(v22);
			push_value(v21);
			push_i64(v23);
			mp_primZ_intZ_add();
			push_value(v22);
			mw_std_prim_Str_dropZ_slice();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			mw_std_prim_Int_ZToNat();
			push_value(v25);
			mw_std_prim_Str_takeZ_slice();
			push_value(v24);
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +Unsafe
					(void)pop_resource();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v26 = (0LL /* None */);
			push_u64(v26);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v27 = pop_value();
	push_value(v27);
}
static void mw_std_path_Path_pathZThen (void) {
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_std_input_INPUTz_BUFFERz_SIZZE (void) {
	int64_t v0 = (8192LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
}
static void mw_std_input_ZPlusInput_startZBang (void) {
	VAL r0 = pop_resource();
	lpush(&lbl_ZPlusfile, r0);
	mw_std_input_INPUTz_BUFFERz_SIZZE();
	mw_std_buffer_ZPlusBuffer_new();
	VAL r1 = pop_resource();
	int64_t v2 = (0LL);
	lpush(&lbl_ZPlusbuffer, r1);
	push_i64(v2);
	mw_std_prim_Int_ZToNat();
	VAL v3 = pop_value();
	int64_t v4 = (0LL);
	lpush(&lbl_length, v3);
	lpush(&lbl_offset, MKI64(v4));
	mtw_std_input_ZPlusInputOpenState_ZPlusInputOpenState();
	mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang();
}
static void mw_std_input_ZPlusInput_stopZBang (void) {
	mw_std_input_ZPlusInput_endZBang();
	mtw_std_input_ZPlusInput_ZPlusInputDone();
}
static void mw_std_input_ZPlusInput_endZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +InputOpen
			mtp_std_input_ZPlusInput_ZPlusInputOpen();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +InputOpenState
					mtp_std_input_ZPlusInputOpenState_ZPlusInputOpenState();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v0 = (lpop(&lbl_ZPlusbuffer));
			push_resource(v0);
			mw_std_buffer_ZPlusBuffer_rdrop();
			VAL v1 = (lpop(&lbl_length));
			VAL v2 = (lpop(&lbl_offset));
			decref(v2);
			decref(v1);
			VAL v3 = (lpop(&lbl_ZPlusfile));
			push_resource(v3);
		} break;
		case 1LL: { // +InputDone
			mtp_std_input_ZPlusInput_ZPlusInputDone();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_input_ZPlusInput_doneZAsk (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +InputOpen
			mtp_std_input_ZPlusInput_ZPlusInputOpen();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
			mtw_std_input_ZPlusInput_ZPlusInputOpen();
		} break;
		case 1LL: { // +InputDone
			mtp_std_input_ZPlusInput_ZPlusInputDone();
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
			mtw_std_input_ZPlusInput_ZPlusInputDone();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[4];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_std_file_ZPlusFile_unsafeZ_readZBang();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[3];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL v2 = pop_value();
	incref(v2);
	int64_t v3 = (0LL);
	bool v4 = (v3 < VI64(v2));
	push_value(v2);
	if (v4) {
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL t = *p; *p = u; decref(t);
		}
		int64_t v5 = (0LL);
		push_i64(v5);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mtw_std_input_ZPlusInput_ZPlusInputOpen();
	} else {
		VAL v6 = pop_value();
		decref(v6);
		mtw_std_input_ZPlusInput_ZPlusInputOpen();
		mw_std_input_ZPlusInput_stopZBang();
	}
}
static void mw_std_input_ZPlusInput_peek (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +InputOpen
			mtp_std_input_ZPlusInput_ZPlusInputOpen();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r0 = pop_resource();
			mw_std_buffer_ZPlusBuffer_ZAtU8();
			push_resource(r0);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[4];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_std_prim_U8_ZToByte();
			mtw_std_input_ZPlusInput_ZPlusInputOpen();
		} break;
		case 1LL: { // +InputDone
			mtp_std_input_ZPlusInput_ZPlusInputDone();
			STRLIT("error: no more input", 20);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_input_ZPlusInput_moveZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +InputOpen
			mtp_std_input_ZPlusInput_ZPlusInputOpen();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r0 = pop_resource();
			int64_t v1 = (1LL);
			push_i64(v1);
			mp_primZ_intZ_add();
			push_resource(r0);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL t = *p; *p = u; decref(t);
			}
			mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang();
		} break;
		case 1LL: { // +InputDone
			mtp_std_input_ZPlusInput_ZPlusInputDone();
			STRLIT("error: no more input", 20);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_input_ZPlusInputOpenState_prepareZ_forZ_moreZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	bool v2 = (VI64(v1) < VI64(v0));
	if (v2) {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	} else {
		uint64_t v4 = (1LL /* True */);
		push_u64(v4);
	}
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
		mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang();
	} else {
		mtw_std_input_ZPlusInput_ZPlusInputOpen();
	}
}
static void mw_std_input_ZPlusInput_readZ_chunkZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +InputOpen
			mtp_std_input_ZPlusInput_ZPlusInputOpen();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			mw_std_prim_Int_ZToNat();
			VAL v0 = pop_value();
			push_value(v0);
			mp_primZ_intZ_sub();
			mw_std_prim_Int_ZToNat();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r1 = pop_resource();
			mw_std_buffer_ZPlusBuffer_ZAtStr();
			push_resource(r1);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[4];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_std_input_ZPlusInputOpenState_fillZ_bufferZBang();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // +InputDone
			mtp_std_input_ZPlusInput_ZPlusInputDone();
			uint64_t v2 = (0LL /* None */);
			push_u64(v2);
			mtw_std_input_ZPlusInput_ZPlusInputDone();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_input_ZPlusInput_readZ_fileZBang (void) {
	STRLIT("", 0);
	mw_std_input_ZPlusInput_readZ_chunkZBang();
	while(1) {
		VAL v0 = pop_value();
		incref(v0);
		push_value(v0);
		push_value(v0);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v1 = pop_value();
		if (!VBOOL(v1)) break;
		mw_std_maybe_Maybe_1_unwrap();
		mp_primZ_strZ_cat();
		mw_std_input_ZPlusInput_readZ_chunkZBang();
	}
	VAL v2 = pop_value();
	decref(v2);
}
static void mw_std_output_OUTPUTz_BUFFERz_SIZZE (void) {
	int64_t v0 = (4096LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
}
static void mw_std_output_ZPlusOutput_startZBang (void) {
	VAL r0 = pop_resource();
	int64_t v1 = (0LL);
	lpush(&lbl_ZPlusfile, r0);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	lpush(&lbl_sizze, v2);
	mw_std_output_OUTPUTz_BUFFERz_SIZZE();
	mw_std_buffer_ZPlusBuffer_new();
	VAL r3 = pop_resource();
	lpush(&lbl_ZPlusbuffer, r3);
	mtw_std_output_ZPlusOutput_ZPlusOutput();
}
static void mw_std_output_ZPlusOutput_endZBang (void) {
	mw_std_output_ZPlusOutput_flushZBang();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Output
			mtp_std_output_ZPlusOutput_ZPlusOutput();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_sizze));
	decref(v0);
	VAL v1 = (lpop(&lbl_ZPlusbuffer));
	push_resource(v1);
	mw_std_buffer_ZPlusBuffer_rdrop();
	VAL v2 = (lpop(&lbl_ZPlusfile));
	push_resource(v2);
}
static void mw_std_output_ZPlusOutput_offset (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
}
static void mw_std_output_ZPlusOutput_flushZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[3];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_std_file_ZPlusFile_unsafeZ_writeZBang();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	int64_t v2 = (0LL);
	push_i64(v2);
	mw_std_prim_Int_ZToNat();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_std_output_ZPlusOutput_capacityZ_total (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[3];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_std_output_ZPlusOutput_capacityZ_remaining (void) {
	mw_std_output_ZPlusOutput_capacityZ_total();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	push_value(v0);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
}
static void mw_std_output_ZPlusOutput_fullZAsk (void) {
	mw_std_output_ZPlusOutput_capacityZ_remaining();
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v1) < VI64(v2));
	if (v3) {
		uint64_t v4 = (0LL /* False */);
		push_u64(v4);
	} else {
		uint64_t v5 = (1LL /* True */);
		push_u64(v5);
	}
}
static void mw_std_output_ZPlusOutput_put (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	mw_std_output_ZPlusOutput_capacityZ_remaining();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v1) < VI64(v2));
	if (v3) {
		mw_std_output_ZPlusOutput_flushZBang();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mp_primZ_strZ_numZ_bytes();
		mw_std_prim_Int_ZToNat();
		mw_std_output_ZPlusOutput_capacityZ_total();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		bool v7 = (VI64(v6) < VI64(v5));
		if (v7) {
			uint64_t v8 = (0LL /* False */);
			push_u64(v8);
		} else {
			uint64_t v9 = (1LL /* True */);
			push_u64(v9);
		}
		VAL v10 = pop_value();
		if (VBOOL(v10)) {
			VAL v11 = pop_value();
			incref(v11);
			incref(v11);
			push_value(v11);
			mp_primZ_strZ_base();
			push_value(v11);
			mp_primZ_strZ_numZ_bytes();
			mw_std_prim_Int_ZToNat();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 4, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r12 = pop_resource();
			mw_std_file_ZPlusFile_unsafeZ_writeZBang();
			push_resource(r12);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 4, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[2];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			decref(v11);
		} else {
			mw_std_output_ZPlusOutput_put();
		}
	} else {
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v13);
		mw_std_output_ZPlusOutput_offset();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 4, v);
			VAL* p = &VTUP(v)->cells[3];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r14 = pop_resource();
		mw_std_buffer_ZPlusBuffer_ZBangStr();
		push_resource(r14);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 4, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[3];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mp_primZ_strZ_numZ_bytes();
		mw_std_prim_Int_ZToNat();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 4, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r15 = pop_resource();
		VAL v16 = pop_value();
		push_value(v16);
		mp_primZ_intZ_add();
		push_resource(r15);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 4, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL t = *p; *p = u; decref(t);
		}
	}
}
static void mw_std_output_ZPlusOutput_putZ_byte (void) {
	mw_std_output_ZPlusOutput_fullZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_std_output_ZPlusOutput_flushZBang();
	} else {
	}
	mw_std_output_ZPlusOutput_offset();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_std_buffer_ZPlusBuffer_ZBangByte();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[3];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r2 = pop_resource();
	int64_t v3 = (1LL);
	push_i64(v3);
	mp_primZ_intZ_add();
	push_resource(r2);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_std_output_ZPlusOutput_line (void) {
	uint64_t v0 = (10LL /* BLF */);
	push_u64(v0);
	mw_std_output_ZPlusOutput_putZ_byte();
}
static void mw_std_posix_posixZ_openZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v1);
	push_value(v0);
	push_value(v2);
	mp_primZ_strZ_base();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v3);
	push_value(v5);
	push_value(v4);
	mext_std_posix_internalZ_posixZ_open();
	decref(v2);
}
static void mw_std_file_ZPlusFileZAsk_unwrapZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +FileOk
			mtp_std_file_ZPlusFileZAsk_ZPlusFileOk();
		} break;
		case 1LL: { // +FileErr
			mtp_std_file_ZPlusFileZAsk_ZPlusFileErr();
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_prim_ZPlusWorld_openZ_fileZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (0LL);
	int64_t v2 = (0LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	push_i64(v2);
	mw_std_posix_posixZ_openZBang();
	VAL v3 = pop_value();
	incref(v3);
	int64_t v4 = (0LL);
	bool v5 = (v4 < VI64(v3));
	push_value(v3);
	if (v5) {
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		decref(v7);
		uint64_t v8 = (1LL /* True */);
		lpush(&lbl_fileZ_descriptor, v6);
		lpush(&lbl_owned, MKU64(v8));
		mtw_std_file_ZPlusFile_ZPlusFile();
		mtw_std_file_ZPlusFileZAsk_ZPlusFileOk();
	} else {
		VAL v9 = pop_value();
		decref(v9);
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("failed to open file: ", 21);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mw_std_prim_Str_showZThen();
		mtp_std_str_ZPlusStr_ZPlusStr();
		mtw_std_file_ZPlusFileZAsk_ZPlusFileErr();
	}
}
static void mw_std_prim_ZPlusWorld_createZ_fileZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC();
	int64_t v1 = (438LL);
	push_i64(v1);
	mw_std_posix_posixZ_openZBang();
	VAL v2 = pop_value();
	incref(v2);
	int64_t v3 = (0LL);
	bool v4 = (v3 < VI64(v2));
	push_value(v2);
	if (v4) {
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		decref(v6);
		uint64_t v7 = (1LL /* True */);
		lpush(&lbl_fileZ_descriptor, v5);
		lpush(&lbl_owned, MKU64(v7));
		mtw_std_file_ZPlusFile_ZPlusFile();
		mtw_std_file_ZPlusFileZAsk_ZPlusFileOk();
	} else {
		VAL v8 = pop_value();
		decref(v8);
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("failed to create file: ", 23);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mw_std_prim_Str_showZThen();
		mtp_std_str_ZPlusStr_ZPlusStr();
		mtw_std_file_ZPlusFileZAsk_ZPlusFileErr();
	}
}
static void mw_std_prim_ZPlusWorld_stderrZ_file (void) {
	int64_t v0 = (2LL);
	uint64_t v1 = (0LL /* False */);
	lpush(&lbl_fileZ_descriptor, MKI64(v0));
	lpush(&lbl_owned, MKU64(v1));
	mtw_std_file_ZPlusFile_ZPlusFile();
}
static void mw_std_file_Oz_WRONLYZPipeOz_CREATZPipeOz_TRUNC (void) {
	mp_primZ_sysZ_os();
	mw_std_prim_Int_ZToOS();
	switch (get_top_data_tag()) {
		case 3LL: { // OS_MACOS
			(void)pop_u64();
			int64_t v0 = (1537LL);
			push_i64(v0);
		} break;
		case 2LL: { // OS_LINUX
			(void)pop_u64();
			int64_t v1 = (577LL);
			push_i64(v1);
		} break;
		case 1LL: { // OS_WINDOWS
			(void)pop_u64();
			int64_t v2 = (769LL);
			push_i64(v2);
		} break;
		case 0LL: { // OS_UNKNOWN
			(void)pop_u64();
			STRLIT("O_WRONLY|O_CREAT|O_TRUNC on unknown os", 38);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_file_ZPlusFile_closeZ_fileZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +File
			mtp_std_file_ZPlusFile_ZPlusFile();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_owned));
	if (VBOOL(v0)) {
		VAL v1 = (lpop(&lbl_fileZ_descriptor));
		push_value(v1);
		mext_std_posix_externalZ_posixZ_close();
		VAL v2 = pop_value();
		incref(v2);
		int64_t v3 = (0LL);
		bool v4 = (VI64(v2) < v3);
		push_value(v2);
		if (v4) {
			uint64_t v5 = (0LL /* False */);
			push_u64(v5);
		} else {
			uint64_t v6 = (1LL /* True */);
			push_u64(v6);
		}
		VAL v7 = pop_value();
		if (VBOOL(v7)) {
		} else {
			STRLIT("failed to close file", 20);
			mp_primZ_panic();
		}
		VAL v8 = pop_value();
		decref(v8);
	} else {
		VAL v9 = (lpop(&lbl_fileZ_descriptor));
		decref(v9);
	}
}
static void mw_std_file_ZPlusFile_unsafeZ_writeZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	incref(v0);
	push_value(v1);
	push_value(v0);
	mext_std_posix_externalZ_posixZ_write();
	VAL v2 = pop_value();
	incref(v2);
	int64_t v3 = (0LL);
	bool v4 = (VI64(v2) < v3);
	push_value(v2);
	if (v4) {
		uint64_t v5 = (0LL /* False */);
		push_u64(v5);
	} else {
		uint64_t v6 = (1LL /* True */);
		push_u64(v6);
	}
	VAL v7 = pop_value();
	if (VBOOL(v7)) {
	} else {
		STRLIT("write failed", 12);
		mp_primZ_panic();
	}
	mw_std_prim_Int_ZToNat();
	VAL v8 = pop_value();
	incref(v8);
	incref(v0);
	bool v9 = (VI64(v8) == VI64(v0));
	push_value(v8);
	push_value(v0);
	if (v9) {
	} else {
		STRLIT("write output fewer bytes than expected", 38);
		mp_primZ_panic();
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_std_file_ZPlusFile_unsafeZ_readZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_value(v1);
	push_value(v0);
	mext_std_posix_externalZ_posixZ_read();
	VAL v2 = pop_value();
	incref(v2);
	int64_t v3 = (0LL);
	bool v4 = (VI64(v2) < v3);
	push_value(v2);
	if (v4) {
		uint64_t v5 = (0LL /* False */);
		push_u64(v5);
	} else {
		uint64_t v6 = (1LL /* True */);
		push_u64(v6);
	}
	VAL v7 = pop_value();
	if (VBOOL(v7)) {
	} else {
		STRLIT("read failed", 11);
		mp_primZ_panic();
	}
	mw_std_prim_Int_ZToNat();
}
static void mw_std_file_ZPlusFile_readZ_fileZBang (void) {
	mw_std_input_ZPlusInput_startZBang();
	mw_std_input_ZPlusInput_readZ_fileZBang();
	mw_std_input_ZPlusInput_endZBang();
}
static void mw_std_prim_ZPlusWorld_traceZ_ (void) {
	mw_std_prim_ZPlusWorld_stderrZ_file();
	VAL v0 = pop_value();
	incref(v0);
	incref(v0);
	push_value(v0);
	mp_primZ_strZ_base();
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	mw_std_file_ZPlusFile_unsafeZ_writeZBang();
	decref(v0);
	mw_std_file_ZPlusFile_closeZ_fileZBang();
}
static void mw_std_prim_ZPlusWorld_isZ_directoryZAsk (void) {
	int64_t v0 = (256LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	mw_std_buffer_ZPlusBuffer_new();
	VAL v1 = pop_value();
	incref(v1);
	incref(v1);
	push_value(v1);
	mp_primZ_strZ_base();
	push_value(v1);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	VAL v4 = (MKU64(0LL /* +Unsafe */));
	push_value(v3);
	push_value(v2);
	push_resource(v4);
	push_value(v3);
	mp_primZ_ptrZ_add();
	mp_primZ_u8Z_get();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	int64_t v5 = (0LL);
	VAL v6 = pop_value();
	bool v7 = (VI64(v6) == v5);
	if (v7) {
	} else {
		STRLIT("tried to use Str as CStr, but Str is not zero terminated", 56);
		mp_primZ_panic();
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v8 = (MKU64(0LL /* +Unsafe */));
	push_resource(v8);
	mext_std_world_posixZ_stat();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	int64_t v9 = (0LL);
	VAL v10 = pop_value();
	bool v11 = (VI64(v10) == v9);
	if (v11) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL v12 = (MKU64(0LL /* +Unsafe */));
		push_resource(v12);
		mw_std_world_stz_modeZAt();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_world_Sz_ISDIR();
	} else {
		uint64_t v13 = (0LL /* False */);
		push_u64(v13);
	}
	decref(v1);
	mw_std_buffer_ZPlusBuffer_rdrop();
}
static void mw_std_world_Sz_IFMT (void) {
	int64_t v0 = (61440LL);
	push_i64(v0);
	mw_std_prim_Int_ZToU16();
}
static void mw_std_world_Sz_IFDIR (void) {
	int64_t v0 = (16384LL);
	push_i64(v0);
	mw_std_prim_Int_ZToU16();
}
static void mw_std_world_Sz_ISDIR (void) {
	mw_std_world_Sz_IFMT();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	uint64_t v2 = (VU64(v1) & VU64(v0));
	push_u64(v2);
	mw_std_world_Sz_IFDIR();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	bool v5 = (VI64(v4) == VI64(v3));
	push_bool(v5);
}
static void mw_std_world_stz_modeZAt (void) {
	mp_primZ_sysZ_os();
	mw_std_prim_Int_ZToOS();
	switch (get_top_data_tag()) {
		case 2LL: { // OS_LINUX
			(void)pop_u64();
			int64_t v0 = (24LL);
			push_i64(v0);
		} break;
		case 1LL: { // OS_WINDOWS
			(void)pop_u64();
			int64_t v1 = (6LL);
			push_i64(v1);
		} break;
		case 3LL: { // OS_MACOS
			(void)pop_u64();
			mp_primZ_sysZ_arch();
			mw_std_prim_Int_ZToArch();
			uint64_t v2 = (3LL /* ARCH_ARM64 */);
			VAL v3 = pop_value();
			bool v4 = (VI64(v3) == ((int64_t)(v2)));
			if (v4) {
				int64_t v5 = (4LL);
				push_i64(v5);
			} else {
				int64_t v6 = (8LL);
				push_i64(v6);
			}
		} break;
		default: {
			VAL v7 = pop_value();
			decref(v7);
			int64_t v8 = (8LL);
			push_i64(v8);
		} break;
	}
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	mp_primZ_ptrZ_add();
	mp_primZ_u16Z_get();
}
static void mw_std_terminal_SGRColor_showZThen (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Numbered
			mtp_std_terminal_SGRColor_Numbered();
			STRLIT(";5;", 3);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mp_primZ_intZ_toZ_str();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 1LL: { // RGB
			mtp_std_terminal_SGRColor_RGB();
			STRLIT(";2;", 3);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mp_primZ_intZ_toZ_str();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(";", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mp_primZ_intZ_toZ_str();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(";", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mp_primZ_intZ_toZ_str();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_terminal_Sgr_emitZThen (void) {
	mw_std_terminal_csiZThen();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL val = pop_value();
		USIZE tag = get_data_tag(val);
		push_u64(tag);
		decref(val);
	}
	mp_primZ_intZ_toZ_str();
	mw_std_str_ZPlusStr_pushZ_strZBang();
	switch (get_top_data_tag()) {
		case 38LL: { // FGColor
			mtp_std_terminal_Sgr_FGColor();
			mw_std_terminal_SGRColor_showZThen();
		} break;
		case 48LL: { // BGColor
			mtp_std_terminal_Sgr_BGColor();
			mw_std_terminal_SGRColor_showZThen();
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
		} break;
	}
	STRLIT("m", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_std_terminal_csiZThen (void) {
	uint64_t v0 = (27LL /* BESC */);
	push_u64(v0);
	mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang();
	uint64_t v1 = (91LL /* BLSQUARE */);
	push_u64(v1);
	mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang();
}
static void mw_argZ_parser_state_State_1_init (void) {
	mw_argZ_parser_parse_argvZ_toZ_str();
	VAL v0 = pop_value();
	int64_t v1 = (0LL);
	VAL v2 = (MKU64(0LL /* +Unsafe */));
	lpush(&lbl_argv, v0);
	push_i64(v1);
	push_resource(v2);
	mw_argZ_parser_parse_readZ_fromZ_argv();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v3 = pop_value();
	lpush(&lbl_programZ_name, v3);
	mtw_argZ_parser_state_ArgvInfo_ArgvInfo();
	VAL v4 = pop_value();
	uint64_t v5 = (0LL /* False */);
	uint64_t v6 = (0LL /* None */);
	uint64_t v7 = (0LL /* None */);
	lpush(&lbl_argvZ_info, v4);
	lpush(&lbl_parsingZAsk, MKU64(v5));
	lpush(&lbl_option, MKU64(v6));
	lpush(&lbl_optionZ_option, MKU64(v7));
	mtw_argZ_parser_state_CurrentArg_CurrentArg();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	int64_t v10 = (0LL);
	int64_t v11 = (0LL);
	uint64_t v12 = (0LL /* None */);
	lpush(&lbl_arg, v8);
	lpush(&lbl_arguments, v9);
	lpush(&lbl_positionalZ_index, MKI64(v10));
	lpush(&lbl_longestZ_argZ_length, MKI64(v11));
	lpush(&lbl_error, MKU64(v12));
	mtw_argZ_parser_state_State_1_State();
}
static void mw_argZ_parser_state_State_1_argv (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_argZ_parser_state_State_1_programZ_name (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_argZ_parser_state_State_1_parsingZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_argZ_parser_state_State_1_parsingZAskZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[1];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(4);
			tup->size = 4;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = u;
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			decref(v);
			push_value(MKTUP(tup,4));
		}
	}
	push_value(v0);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[3];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(7);
			tup->size = 7;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = u;
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			decref(v);
			push_value(MKTUP(tup,7));
		}
	}
}
static void mw_argZ_parser_state_State_1_optionZ_option (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_argZ_parser_state_State_1_optionZ_optionZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[3];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(4);
			tup->size = 4;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = u;
			decref(v);
			push_value(MKTUP(tup,4));
		}
	}
	push_value(v0);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[3];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(7);
			tup->size = 7;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = u;
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			decref(v);
			push_value(MKTUP(tup,7));
		}
	}
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +ArgumentParser
			mtp_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_argumentZ_parser));
	decref(v0);
	VAL v1 = (lpop(&lbl_state));
	decref(v1);
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_parser (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Short
			mtp_argZ_parser_types_ArgpOptionType_Short();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		default: {
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* False */);
			push_u64(v3);
		} break;
	}
}
static void mw_argZ_parser_types_ArgumentParsingError_emitZThen (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // MissingArg
			mtp_argZ_parser_types_ArgumentParsingError_MissingArg();
			uint64_t v0 = (31LL /* FGRed */);
			push_u64(v0);
			mw_std_terminal_Sgr_emitZThen();
			STRLIT("Missing argument: ", 18);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			uint64_t v1 = (0LL /* Reset */);
			push_u64(v1);
			mw_std_terminal_Sgr_emitZThen();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 0LL: { // MissingArgValue
			(void)pop_u64();
			STRLIT("Missing associated value for flag option", 40);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 2LL: { // TooManyArgs
			(void)pop_u64();
			STRLIT("Too many positional arguments passed", 36);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 3LL: { // TooFewArgs
			(void)pop_u64();
			STRLIT("Too few positional arguments passed", 35);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 4LL: { // UnknownArg
			(void)pop_u64();
			STRLIT("Got an unknown option", 21);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_argZ_parser_types_ZPlusArgumentParser_1_usage (void) {
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	uint64_t v0 = (1LL /* Bold */);
	push_u64(v0);
	mw_std_terminal_Sgr_emitZThen();
	STRLIT("Usage: ", 7);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	uint64_t v1 = (0LL /* Reset */);
	push_u64(v1);
	mw_std_terminal_Sgr_emitZThen();
	STRLIT("  ", 2);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL r2 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r2);
	mw_argZ_parser_state_State_1_programZ_name();
	mw_std_str_ZPlusStr_pushZ_strZBang();
	STRLIT(" [options] ", 11);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL r3 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r3);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	STRLIT("\n\n", 2);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL r4 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r4);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	while(1) {
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		push_value(v7);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v8 = pop_value();
		if (!VBOOL(v8)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		mw_argZ_parser_types_ArgpOption_usageZThen();
		push_value(v10);
		mw_std_list_List_1_uncons();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	STRLIT("\n", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mtp_std_str_ZPlusStr_ZPlusStr();
}
static void mw_argZ_parser_types_ArgpOption_usageZThen (void) {
	STRLIT("  ", 2);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	int64_t v0 = (0LL);
	VAL v1 = pop_value();
	incref(v1);
	lpush(&lbl_colZ_offset, MKI64(v0));
	push_value(v1);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // Short
			mtp_argZ_parser_types_ArgpOptionType_Short();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v2);
			mw_std_byte_Byte_isZ_printable();
			VAL v3 = pop_value();
			if (VBOOL(v3)) {
				VAL v4 = (lpop(&lbl_colZ_offset));
				int64_t v5 = (2LL);
				push_value(v4);
				push_i64(v5);
				mp_primZ_intZ_add();
				VAL v6 = pop_value();
				lpush(&lbl_colZ_offset, v6);
				STRLIT("-", 1);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				VAL v7 = pop_value();
				incref(v7);
				push_value(v7);
				push_value(v7);
				mw_std_byte_Byte_emitZ_asciiZThen();
			} else {
			}
			VAL v8 = pop_value();
			decref(v8);
		} break;
		default: {
			VAL v9 = pop_value();
			decref(v9);
		} break;
	}
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	push_value(v10);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_argZ_parser_types_ArgpOptionType_hasZ_shortZAsk();
	VAL v11 = pop_value();
	if (VBOOL(v11)) {
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		push_value(v12);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 6, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_std_maybe_Maybe_1_someZAsk();
	} else {
		uint64_t v13 = (0LL /* False */);
		push_u64(v13);
	}
	VAL v14 = pop_value();
	if (VBOOL(v14)) {
		STRLIT(", ", 2);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL v15 = (lpop(&lbl_colZ_offset));
		int64_t v16 = (2LL);
		push_value(v15);
		push_i64(v16);
		mp_primZ_intZ_add();
		VAL v17 = pop_value();
		lpush(&lbl_colZ_offset, v17);
	} else {
	}
	VAL v18 = pop_value();
	incref(v18);
	push_value(v18);
	push_value(v18);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v19 = pop_value();
			incref(v19);
			push_value(v19);
			push_value(v19);
			mp_primZ_strZ_numZ_bytes();
			mw_std_prim_Int_ZToNat();
			VAL v20 = (lpop(&lbl_colZ_offset));
			int64_t v21 = (2LL);
			push_value(v20);
			push_i64(v21);
			mp_primZ_intZ_add();
			mp_primZ_intZ_add();
			VAL v22 = pop_value();
			lpush(&lbl_colZ_offset, v22);
			STRLIT("--", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			VAL v23 = pop_value();
			incref(v23);
			push_value(v23);
			push_value(v23);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 6, v);
				VAL* p = &VTUP(v)->cells[3];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v24 = pop_value();
					incref(v24);
					push_value(v24);
					push_value(v24);
					mp_primZ_strZ_numZ_bytes();
					mw_std_prim_Int_ZToNat();
					VAL v25 = (lpop(&lbl_colZ_offset));
					int64_t v26 = (1LL);
					push_value(v25);
					push_i64(v26);
					mp_primZ_intZ_add();
					mp_primZ_intZ_add();
					VAL v27 = pop_value();
					lpush(&lbl_colZ_offset, v27);
					STRLIT(" ", 1);
					mw_std_str_ZPlusStr_pushZ_strZBang();
					mw_std_str_ZPlusStr_pushZ_strZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v28 = pop_value();
	incref(v28);
	push_value(v28);
	push_value(v28);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v29 = (lpop(&lbl_colZ_offset));
			incref(v29);
			VAL r30 = pop_resource();
			push_value(v29);
			lpush(&lbl_colZ_offset, v29);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			push_resource(r30);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[5];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			incref(v32);
			incref(v31);
			bool v33 = (VI64(v32) < VI64(v31));
			push_value(v32);
			push_value(v31);
			if (v33) {
				VAL v34 = pop_value();
				VAL v35 = pop_value();
				push_value(v34);
				push_value(v35);
				mp_primZ_intZ_sub();
				VAL v36 = pop_value();
				int64_t v37 = (0LL);
				push_i64(v37);
				push_value(v36);
				mw_std_prim_Int_range();
				mw_std_list_List_1_uncons();
				VAL v38 = pop_value();
				VAL v39 = pop_value();
				push_value(v38);
				push_value(v39);
				while(1) {
					VAL v40 = pop_value();
					incref(v40);
					push_value(v40);
					push_value(v40);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v41 = pop_value();
					if (!VBOOL(v41)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v42 = pop_value();
					VAL v43 = pop_value();
					decref(v42);
					STRLIT(" ", 1);
					mw_std_str_ZPlusStr_pushZ_strZBang();
					push_value(v43);
					mw_std_list_List_1_uncons();
					VAL v44 = pop_value();
					VAL v45 = pop_value();
					push_value(v44);
					push_value(v45);
				}
				VAL v46 = pop_value();
				decref(v46);
				VAL v47 = pop_value();
				decref(v47);
			} else {
				VAL v48 = pop_value();
				decref(v48);
				VAL v49 = pop_value();
				decref(v49);
			}
			STRLIT("    ", 4);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v50 = (lpop(&lbl_colZ_offset));
	decref(v50);
	STRLIT("\n", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v51 = pop_value();
	decref(v51);
}
static void mw_argZ_parser_parse_checkZ_shortZ_flag (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // Short
			mtp_argZ_parser_types_ArgpOptionType_Short();
			int64_t v2 = (0LL);
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			push_value(v3);
			push_i64(v2);
			push_value(v4);
			mw_std_prim_Str_byteZAt();
			mw_std_byte_Byte_ZEqualZEqual();
		} break;
		default: {
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* False */);
			push_u64(v7);
		} break;
	}
}
static void mw_argZ_parser_parse_checkZ_longZ_flag (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mp_primZ_strZ_cmp();
			int64_t v2 = (0LL);
			VAL v3 = pop_value();
			incref(v3);
			bool v4 = (VI64(v3) == v2);
			push_value(v3);
			push_i64(v2);
			if (v4) {
				VAL v5 = pop_value();
				decref(v5);
				VAL v6 = pop_value();
				decref(v6);
				uint64_t v7 = (1LL /* EQ */);
				push_u64(v7);
			} else {
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				bool v10 = (VI64(v9) < VI64(v8));
				if (v10) {
					uint64_t v11 = (0LL /* LT */);
					push_u64(v11);
				} else {
					uint64_t v12 = (2LL /* GT */);
					push_u64(v12);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v13 = (0LL /* False */);
					push_u64(v13);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v14 = (1LL /* True */);
					push_u64(v14);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v15 = (0LL /* False */);
					push_u64(v15);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v16 = pop_value();
			decref(v16);
			uint64_t v17 = (0LL /* False */);
			push_u64(v17);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_argZ_parser_parse_parseZ_flags (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	int64_t v1 = (2LL);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	bool v4 = (VI64(v3) < VI64(v2));
	if (v4) {
		uint64_t v5 = (0LL /* False */);
		push_u64(v5);
	} else {
		uint64_t v6 = (1LL /* True */);
		push_u64(v6);
	}
	VAL v7 = pop_value();
	if (VBOOL(v7)) {
		int64_t v8 = (1LL);
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_i64(v8);
		push_value(v9);
		mw_std_prim_Str_byteZAt();
		uint64_t v10 = (45LL /* B'-' */);
		push_u64(v10);
		mw_std_byte_Byte_ZEqualZEqual();
	} else {
		uint64_t v11 = (0LL /* False */);
		push_u64(v11);
	}
	VAL v12 = pop_value();
	if (VBOOL(v12)) {
		int64_t v13 = (2LL);
		push_i64(v13);
		mw_std_prim_Int_ZToNat();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		incref(v15);
		VAL v16 = (MKU64(0LL /* +Unsafe */));
		push_value(v15);
		push_value(v14);
		push_value(v15);
		push_resource(v16);
		mw_std_prim_Str_dropZ_bytes();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		uint64_t v17 = (0LL /* None */);
		VAL v18 = pop_value();
		push_u64(v17);
		push_value(v18);
		mw_std_list_List_1_uncons();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
		while(1) {
			VAL v21 = pop_value();
			incref(v21);
			push_value(v21);
			push_value(v21);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v22 = pop_value();
			if (!VBOOL(v22)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v23 = pop_value();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			incref(v23);
			VAL v26 = pop_value();
			incref(v26);
			push_value(v26);
			push_value(v23);
			push_value(v26);
			mw_argZ_parser_parse_checkZ_longZ_flag();
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			decref(v28);
			push_value(v23);
			if (VBOOL(v27)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v29 = pop_value();
				decref(v29);
				uint64_t v30 = (0LL /* None */);
				push_u64(v30);
			}
			VAL v31 = pop_value();
			push_value(v25);
			push_value(v24);
			push_value(v31);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v32 = pop_value();
					VAL v33 = pop_value();
					decref(v33);
					VAL v34 = pop_value();
					decref(v34);
					uint64_t v35 = (0LL /* Nil */);
					push_value(v32);
					push_u64(v35);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v36 = pop_value();
			VAL v37 = pop_value();
			push_value(v36);
			push_value(v37);
		}
		VAL v38 = pop_value();
		decref(v38);
		VAL v39 = pop_value();
		decref(v39);
		VAL v40 = pop_value();
		VAL v41 = pop_value();
		decref(v41);
		push_value(v40);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v42 = pop_value();
				incref(v42);
				push_value(v42);
				push_value(v42);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 6, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						uint64_t v43 = (1LL /* True */);
						push_u64(v43);
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						mw_argZ_parser_state_State_1_parsingZAskZBang();
						{
							VAL v = top_resource();
							VAL u = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL t = *p; *p = u; decref(t);
						}
						VAL v44 = pop_value();
						decref(v44);
						mtw_std_maybe_Maybe_1_Some();
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						mw_argZ_parser_state_State_1_optionZ_optionZBang();
						{
							VAL v = top_resource();
							VAL u = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL t = *p; *p = u; decref(t);
						}
					} break;
					case 0LL: { // None
						(void)pop_u64();
						{
							VAL v = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 6, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							decref(v);
							push_value(u);
						}
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						{
							VAL v = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 7, v);
							VAL* p = &VTUP(v)->cells[1];
							VAL u = *p;
							incref(u);
							decref(v);
							push_value(u);
						}
						VAL v45 = pop_value();
						VAL v46 = pop_value();
						uint64_t v47 = (0LL /* None */);
						push_value(v45);
						push_u64(v47);
						push_value(v46);
						mw_argZ_parser_types_ZPlusArgumentParser_1_parser();
						switch (get_top_data_tag()) {
							case 1LL: { // Some
								mtp_std_maybe_Maybe_1_Some();
								mp_primZ_run();
								{
									VAL v = pop_resource();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 3, v);
									VAL* p = &VTUP(v)->cells[2];
									VAL u = *p;
									incref(u);
									push_resource(v);
									push_value(u);
								}
								{
									VAL v = pop_value();
									VAL u = pop_value();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 7, v);
									if (VTUP(v)->refs == 1) {
										VAL* p = &VTUP(v)->cells[1];
										VAL t = *p; *p = u; decref(t);
										push_value(v);
									} else {
										TUP *tup = tup_new(7);
										tup->size = 7;
										tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
										tup->cells[1] = u;
										tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
										tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
										tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
										tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
										tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
										decref(v);
										push_value(MKTUP(tup,7));
									}
								}
								{
									VAL v = top_resource();
									VAL u = pop_value();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 3, v);
									VAL* p = &VTUP(v)->cells[2];
									VAL t = *p; *p = u; decref(t);
								}
							} break;
							case 0LL: { // None
								(void)pop_u64();
								VAL v48 = pop_value();
								decref(v48);
								VAL v49 = pop_value();
								decref(v49);
								VAL v50 = pop_value();
								decref(v50);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								mp_primZ_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				uint64_t v51 = (0LL /* None */);
				push_u64(v51);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v52 = (4LL /* UnknownArg */);
				push_u64(v52);
				mtw_std_maybe_Maybe_1_Some();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	} else {
		int64_t v53 = (1LL);
		push_i64(v53);
		mw_std_prim_Int_ZToNat();
		VAL v54 = pop_value();
		VAL v55 = pop_value();
		incref(v55);
		VAL v56 = (MKU64(0LL /* +Unsafe */));
		push_value(v55);
		push_value(v54);
		push_value(v55);
		push_resource(v56);
		mw_std_prim_Str_dropZ_bytes();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		uint64_t v57 = (0LL /* None */);
		VAL v58 = pop_value();
		push_u64(v57);
		push_value(v58);
		mw_std_list_List_1_uncons();
		VAL v59 = pop_value();
		VAL v60 = pop_value();
		push_value(v59);
		push_value(v60);
		while(1) {
			VAL v61 = pop_value();
			incref(v61);
			push_value(v61);
			push_value(v61);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v62 = pop_value();
			if (!VBOOL(v62)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v63 = pop_value();
			VAL v64 = pop_value();
			VAL v65 = pop_value();
			incref(v63);
			VAL v66 = pop_value();
			incref(v66);
			push_value(v66);
			push_value(v63);
			push_value(v66);
			mw_argZ_parser_parse_checkZ_shortZ_flag();
			VAL v67 = pop_value();
			VAL v68 = pop_value();
			decref(v68);
			push_value(v63);
			if (VBOOL(v67)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v69 = pop_value();
				decref(v69);
				uint64_t v70 = (0LL /* None */);
				push_u64(v70);
			}
			VAL v71 = pop_value();
			push_value(v65);
			push_value(v64);
			push_value(v71);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v72 = pop_value();
					VAL v73 = pop_value();
					decref(v73);
					VAL v74 = pop_value();
					decref(v74);
					uint64_t v75 = (0LL /* Nil */);
					push_value(v72);
					push_u64(v75);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v76 = pop_value();
			VAL v77 = pop_value();
			push_value(v76);
			push_value(v77);
		}
		VAL v78 = pop_value();
		decref(v78);
		VAL v79 = pop_value();
		decref(v79);
		VAL v80 = pop_value();
		VAL v81 = pop_value();
		decref(v81);
		push_value(v80);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v82 = pop_value();
				incref(v82);
				push_value(v82);
				push_value(v82);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 6, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						uint64_t v83 = (1LL /* True */);
						push_u64(v83);
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						mw_argZ_parser_state_State_1_parsingZAskZBang();
						{
							VAL v = top_resource();
							VAL u = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL t = *p; *p = u; decref(t);
						}
						VAL v84 = pop_value();
						decref(v84);
						mtw_std_maybe_Maybe_1_Some();
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						mw_argZ_parser_state_State_1_optionZ_optionZBang();
						{
							VAL v = top_resource();
							VAL u = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL t = *p; *p = u; decref(t);
						}
					} break;
					case 0LL: { // None
						(void)pop_u64();
						{
							VAL v = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 6, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							decref(v);
							push_value(u);
						}
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 3, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						{
							VAL v = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 7, v);
							VAL* p = &VTUP(v)->cells[1];
							VAL u = *p;
							incref(u);
							decref(v);
							push_value(u);
						}
						VAL v85 = pop_value();
						VAL v86 = pop_value();
						uint64_t v87 = (0LL /* None */);
						push_value(v85);
						push_u64(v87);
						push_value(v86);
						mw_argZ_parser_types_ZPlusArgumentParser_1_parser();
						switch (get_top_data_tag()) {
							case 1LL: { // Some
								mtp_std_maybe_Maybe_1_Some();
								mp_primZ_run();
								{
									VAL v = pop_resource();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 3, v);
									VAL* p = &VTUP(v)->cells[2];
									VAL u = *p;
									incref(u);
									push_resource(v);
									push_value(u);
								}
								{
									VAL v = pop_value();
									VAL u = pop_value();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 7, v);
									if (VTUP(v)->refs == 1) {
										VAL* p = &VTUP(v)->cells[1];
										VAL t = *p; *p = u; decref(t);
										push_value(v);
									} else {
										TUP *tup = tup_new(7);
										tup->size = 7;
										tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
										tup->cells[1] = u;
										tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
										tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
										tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
										tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
										tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
										decref(v);
										push_value(MKTUP(tup,7));
									}
								}
								{
									VAL v = top_resource();
									VAL u = pop_value();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 3, v);
									VAL* p = &VTUP(v)->cells[2];
									VAL t = *p; *p = u; decref(t);
								}
							} break;
							case 0LL: { // None
								(void)pop_u64();
								VAL v88 = pop_value();
								decref(v88);
								VAL v89 = pop_value();
								decref(v89);
								VAL v90 = pop_value();
								decref(v90);
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								mp_primZ_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				uint64_t v91 = (0LL /* None */);
				push_u64(v91);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v92 = (4LL /* UnknownArg */);
				push_u64(v92);
				mtw_std_maybe_Maybe_1_Some();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
	VAL v93 = pop_value();
	VAL v94 = pop_value();
	decref(v94);
	push_value(v93);
}
static void mw_argZ_parser_parse_doZ_positionalZ_option (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mtw_std_maybe_Maybe_1_Some();
	uint64_t v2 = (2LL /* Positional */);
	push_u64(v2);
	mw_argZ_parser_types_ZPlusArgumentParser_1_parser();
	mw_std_maybe_Maybe_1_unwrap();
	mp_primZ_run();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[1];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(7);
			tup->size = 7;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = u;
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			decref(v);
			push_value(MKTUP(tup,7));
		}
	}
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	uint64_t v3 = (0LL /* None */);
	push_u64(v3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	int64_t v4 = (1LL);
	push_i64(v4);
	mp_primZ_intZ_add();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[4];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(7);
			tup->size = 7;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = u;
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			decref(v);
			push_value(MKTUP(tup,7));
		}
	}
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_argZ_parser_parse_parseZ_args (void) {
	VAL v0 = pop_value();
	lpush(&lbl_argumentZ_parser, v0);
	mw_argZ_parser_state_State_1_init();
	VAL v1 = pop_value();
	lpush(&lbl_state, v1);
	mtw_argZ_parser_types_ZPlusArgumentParser_1_ZPlusArgumentParser();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		int64_t v8 = (0LL);
		incref(v6);
		lpush(&lbl_docZ_length, MKI64(v8));
		push_value(v6);
		push_value(v6);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 6, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		switch (get_top_data_tag()) {
			case 0LL: { // Short
				mtp_argZ_parser_types_ArgpOptionType_Short();
				VAL v9 = pop_value();
				decref(v9);
				VAL v10 = (lpop(&lbl_docZ_length));
				int64_t v11 = (2LL);
				push_value(v10);
				push_i64(v11);
				mp_primZ_intZ_add();
				VAL v12 = pop_value();
				lpush(&lbl_docZ_length, v12);
			} break;
			default: {
				VAL v13 = pop_value();
				decref(v13);
			} break;
		}
		VAL v14 = pop_value();
		incref(v14);
		push_value(v14);
		push_value(v14);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 6, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mp_primZ_strZ_numZ_bytes();
				mw_std_prim_Int_ZToNat();
				VAL v15 = (lpop(&lbl_docZ_length));
				int64_t v16 = (3LL);
				push_value(v15);
				push_i64(v16);
				mp_primZ_intZ_add();
				mp_primZ_intZ_add();
				VAL v17 = pop_value();
				lpush(&lbl_docZ_length, v17);
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 6, v);
			VAL* p = &VTUP(v)->cells[3];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mp_primZ_strZ_numZ_bytes();
				mw_std_prim_Int_ZToNat();
				VAL v18 = (lpop(&lbl_docZ_length));
				int64_t v19 = (1LL);
				push_value(v18);
				push_i64(v19);
				mp_primZ_intZ_add();
				mp_primZ_intZ_add();
				VAL v20 = pop_value();
				lpush(&lbl_docZ_length, v20);
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v21 = (lpop(&lbl_docZ_length));
		incref(v21);
		push_value(v21);
		push_value(v21);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[5];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		bool v24 = (VI64(v22) < VI64(v23));
		if (v24) {
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r25 = pop_resource();
			{
				VAL v = pop_value();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				if (VTUP(v)->refs == 1) {
					VAL* p = &VTUP(v)->cells[5];
					VAL t = *p; *p = u; decref(t);
					push_value(v);
				} else {
					TUP *tup = tup_new(7);
					tup->size = 7;
					tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
					tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
					tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
					tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
					tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
					tup->cells[5] = u;
					tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
					decref(v);
					push_value(MKTUP(tup,7));
				}
			}
			push_resource(r25);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL t = *p; *p = u; decref(t);
			}
		} else {
			VAL v26 = pop_value();
			decref(v26);
		}
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v27 = pop_value();
		VAL v28 = pop_value();
		push_value(v27);
		push_value(v28);
	}
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	decref(v30);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_argZ_parser_state_State_1_argv();
	mw_std_list_List_1_uncons();
	VAL v31 = pop_value();
	VAL v32 = pop_value();
	push_value(v31);
	push_value(v32);
	while(1) {
		VAL v33 = pop_value();
		incref(v33);
		push_value(v33);
		push_value(v33);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v34 = pop_value();
		if (!VBOOL(v34)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v35 = pop_value();
		VAL v36 = pop_value();
		incref(v35);
		push_value(v35);
		push_value(v35);
		mp_primZ_strZ_numZ_bytes();
		mw_std_prim_Int_ZToNat();
		int64_t v37 = (1LL);
		push_i64(v37);
		mw_std_prim_Int_ZToNat();
		VAL v38 = pop_value();
		VAL v39 = pop_value();
		bool v40 = (VI64(v38) < VI64(v39));
		if (v40) {
			int64_t v41 = (0LL);
			VAL v42 = pop_value();
			incref(v42);
			push_value(v42);
			push_i64(v41);
			push_value(v42);
			mw_std_prim_Str_byteZAt();
			uint64_t v43 = (45LL /* B'-' */);
			push_u64(v43);
			mw_std_byte_Byte_ZEqualZEqual();
			VAL v44 = pop_value();
			if (VBOOL(v44)) {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				mw_argZ_parser_state_State_1_parsingZAsk();
				VAL v45 = pop_value();
				if (VBOOL(v45)) {
					VAL v46 = pop_value();
					decref(v46);
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					mw_argZ_parser_state_State_1_optionZ_option();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							{
								VAL v = pop_value();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 6, v);
								VAL* p = &VTUP(v)->cells[3];
								VAL u = *p;
								incref(u);
								decref(v);
								push_value(u);
							}
							switch (get_top_data_tag()) {
								case 1LL: { // Some
									mtp_std_maybe_Maybe_1_Some();
									VAL v47 = pop_value();
									decref(v47);
									uint64_t v48 = (0LL /* MissingArgValue */);
									push_u64(v48);
									mtw_std_maybe_Maybe_1_Some();
								} break;
								case 0LL: { // None
									(void)pop_u64();
									uint64_t v49 = (0LL /* False */);
									push_u64(v49);
									{
										VAL v = pop_resource();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 3, v);
										VAL* p = &VTUP(v)->cells[2];
										VAL u = *p;
										incref(u);
										push_resource(v);
										push_value(u);
									}
									mw_argZ_parser_state_State_1_parsingZAskZBang();
									{
										VAL v = top_resource();
										VAL u = pop_value();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 3, v);
										VAL* p = &VTUP(v)->cells[2];
										VAL t = *p; *p = u; decref(t);
									}
									uint64_t v50 = (0LL /* None */);
									push_u64(v50);
								} break;
								default: {
									push_value(mkstr("unexpected fallthrough in match\n", 32));
									mp_primZ_panic();
								}
							}
						} break;
						case 0LL: { // None
							(void)pop_u64();
							uint64_t v51 = (0LL /* MissingArgValue */);
							push_u64(v51);
							mtw_std_maybe_Maybe_1_Some();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} else {
					mw_argZ_parser_parse_parseZ_flags();
				}
			} else {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				mw_argZ_parser_state_State_1_parsingZAsk();
				VAL v52 = pop_value();
				if (VBOOL(v52)) {
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					mw_argZ_parser_state_State_1_optionZ_option();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							{
								VAL v = pop_value();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 6, v);
								VAL* p = &VTUP(v)->cells[3];
								VAL u = *p;
								incref(u);
								decref(v);
								push_value(u);
							}
							switch (get_top_data_tag()) {
								case 1LL: { // Some
									mtp_std_maybe_Maybe_1_Some();
									VAL v53 = pop_value();
									decref(v53);
									{
										VAL v = pop_resource();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 3, v);
										VAL* p = &VTUP(v)->cells[2];
										VAL u = *p;
										incref(u);
										push_resource(v);
										push_value(u);
									}
									{
										VAL v = pop_value();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 7, v);
										VAL* p = &VTUP(v)->cells[1];
										VAL u = *p;
										incref(u);
										decref(v);
										push_value(u);
									}
									VAL v54 = pop_value();
									VAL v55 = pop_value();
									push_value(v54);
									push_value(v55);
									mtw_std_maybe_Maybe_1_Some();
									{
										VAL v = pop_resource();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 3, v);
										VAL* p = &VTUP(v)->cells[2];
										VAL u = *p;
										incref(u);
										push_resource(v);
										push_value(u);
									}
									mw_argZ_parser_state_State_1_optionZ_option();
									mw_std_maybe_Maybe_1_unwrap();
									{
										VAL v = pop_value();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 6, v);
										VAL* p = &VTUP(v)->cells[2];
										VAL u = *p;
										incref(u);
										decref(v);
										push_value(u);
									}
									mw_argZ_parser_types_ZPlusArgumentParser_1_parser();
									mw_std_maybe_Maybe_1_unwrap();
									mp_primZ_run();
									{
										VAL v = pop_resource();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 3, v);
										VAL* p = &VTUP(v)->cells[2];
										VAL u = *p;
										incref(u);
										push_resource(v);
										push_value(u);
									}
									VAL r56 = pop_resource();
									{
										VAL v = pop_value();
										VAL u = pop_value();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 7, v);
										if (VTUP(v)->refs == 1) {
											VAL* p = &VTUP(v)->cells[1];
											VAL t = *p; *p = u; decref(t);
											push_value(v);
										} else {
											TUP *tup = tup_new(7);
											tup->size = 7;
											tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
											tup->cells[1] = u;
											tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
											tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
											tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
											tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
											tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
											decref(v);
											push_value(MKTUP(tup,7));
										}
									}
									push_resource(r56);
									{
										VAL v = top_resource();
										VAL u = pop_value();
										ASSERT1(IS_TUP(v), v);
										ASSERT1(VTUPLEN(v) == 3, v);
										VAL* p = &VTUP(v)->cells[2];
										VAL t = *p; *p = u; decref(t);
									}
									uint64_t v57 = (0LL /* None */);
									push_u64(v57);
								} break;
								case 0LL: { // None
									(void)pop_u64();
									VAL v58 = pop_value();
									decref(v58);
									uint64_t v59 = (4LL /* UnknownArg */);
									push_u64(v59);
									mtw_std_maybe_Maybe_1_Some();
								} break;
								default: {
									push_value(mkstr("unexpected fallthrough in match\n", 32));
									mp_primZ_panic();
								}
							}
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v60 = pop_value();
							decref(v60);
							uint64_t v61 = (4LL /* UnknownArg */);
							push_u64(v61);
							mtw_std_maybe_Maybe_1_Some();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					uint64_t v62 = (0LL /* False */);
					push_u64(v62);
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r63 = pop_resource();
					mw_argZ_parser_state_State_1_parsingZAskZBang();
					push_resource(r63);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
				} else {
					mw_argZ_parser_parse_doZ_positionalZ_option();
				}
			}
		} else {
			VAL v64 = pop_value();
			decref(v64);
			uint64_t v65 = (0LL /* None */);
			push_u64(v65);
		}
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtw_std_maybe_Maybe_1_Some();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r66 = pop_resource();
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[6];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(7);
						tup->size = 7;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = u;
						decref(v);
						push_value(MKTUP(tup,7));
					}
				}
				push_resource(r66);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v36);
		mw_std_list_List_1_uncons();
		VAL v67 = pop_value();
		VAL v68 = pop_value();
		push_value(v67);
		push_value(v68);
	}
	VAL v69 = pop_value();
	decref(v69);
	VAL v70 = pop_value();
	decref(v70);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_argZ_parser_state_State_1_parsingZAsk();
	VAL v71 = pop_value();
	if (VBOOL(v71)) {
		uint64_t v72 = (0LL /* MissingArgValue */);
		push_u64(v72);
		mtw_std_maybe_Maybe_1_Some();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		{
			VAL v = pop_value();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			if (VTUP(v)->refs == 1) {
				VAL* p = &VTUP(v)->cells[6];
				VAL t = *p; *p = u; decref(t);
				push_value(v);
			} else {
				TUP *tup = tup_new(7);
				tup->size = 7;
				tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
				tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
				tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
				tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
				tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
				tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
				tup->cells[6] = u;
				decref(v);
				push_value(MKTUP(tup,7));
			}
		}
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
	} else {
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v73 = (0LL /* None */);
	uint64_t v74 = (3LL /* End */);
	push_u64(v73);
	push_u64(v74);
	mw_argZ_parser_types_ZPlusArgumentParser_1_parser();
	mw_std_maybe_Maybe_1_unwrap();
	mp_primZ_run();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r75 = pop_resource();
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[1];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(7);
			tup->size = 7;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = u;
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			decref(v);
			push_value(MKTUP(tup,7));
		}
	}
	push_resource(r75);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_argZ_parser_types_ZPlusArgumentParser_1_usage();
			VAL v76 = pop_value();
			VAL v77 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v77);
			mp_primZ_packZ_cons();
			push_value(v76);
			mp_primZ_packZ_cons();
			mtw_std_either_Either_2_Left();
			VAL v78 = pop_value();
			VAL v79 = pop_value();
			decref(v79);
			push_value(v78);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mtw_std_either_Either_2_Right();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_argZ_parser_types_ZPlusArgumentParser_1_rdrop();
}
static void mw_argZ_parser_parse_readZ_fromZ_argv (void) {
	mp_primZ_ptrZ_sizze();
	mw_std_prim_Int_ZToNat();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	int64_t v2 = (VI64(v1) * VI64(v0));
	push_i64(v2);
	mw_std_prim_Int_ZToNat();
	mp_primZ_sysZ_argv();
	VAL v3 = pop_value();
	push_value(v3);
	mp_primZ_ptrZ_add();
	mp_primZ_ptrZ_get();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mext_std_ctypes_CStr_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	mp_primZ_strZ_copy();
}
static void mw_argZ_parser_parse_argvZ_toZ_str (void) {
	int64_t v0 = (1LL);
	mp_primZ_sysZ_argc();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_sub();
	VAL v2 = pop_value();
	push_i64(v0);
	push_value(v2);
	mw_std_prim_Int_range();
	uint64_t v3 = (0LL /* Nil */);
	push_u64(v3);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v7 = pop_value();
		if (!VBOOL(v7)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		VAL r10 = pop_resource();
		VAL v11 = (MKU64(0LL /* +Unsafe */));
		push_value(v8);
		push_resource(v11);
		mw_argZ_parser_parse_readZ_fromZ_argv();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_resource(r10);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		push_value(v9);
		mw_std_list_List_1_uncons();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		push_value(v12);
		push_value(v13);
	}
	VAL v14 = pop_value();
	decref(v14);
	VAL v15 = pop_value();
	decref(v15);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
}
static void mw_std_lazzy_Lazzy_1_forceZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mp_primZ_mutZ_get();
	switch (get_top_data_tag()) {
		case 0LL: { // LazyReady
			mtp_std_lazzy_Lazzy_1_LazzyReady();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
		} break;
		case 1LL: { // LazyDelay
			mtp_std_lazzy_Lazzy_1_LazzyDelay();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			uint64_t v6 = (2LL /* LazyWait */);
			incref(v5);
			push_value(v4);
			push_value(v3);
			push_value(v5);
			push_u64(v6);
			push_value(v5);
			mp_primZ_mutZ_set();
			VAL v7 = pop_value();
			mp_primZ_run();
			VAL v8 = pop_value();
			incref(v8);
			push_value(v8);
			push_value(v8);
			mtw_std_lazzy_Lazzy_1_LazzyReady();
			push_value(v7);
			mp_primZ_mutZ_set();
		} break;
		case 2LL: { // LazyWait
			(void)pop_u64();
			STRLIT("recursive thunk dependency", 26);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_label_Label_index (void) {
}
static void mw_mirth_label_Label_allocZBang (void) {
	mbuf_mirth_label_Label_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_label_Label_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_label_Label_name (void) {
	mfld_mirth_label_Label_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_label_Label_ZToStr (void) {
	mw_mirth_label_Label_name();
	mw_mirth_name_Name_ZToStr();
}
static void mw_mirth_label_Label_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_label_Label_index();
	push_value(v0);
	mw_mirth_label_Label_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_label_Label_newZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_name_Name_ZTildelabel();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		mw_mirth_label_Label_allocZBang();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		incref(v5);
		incref(v4);
		push_value(v5);
		push_value(v4);
		push_value(v5);
		push_value(v4);
		mfld_mirth_label_Label_ZTildename();
		mp_primZ_mutZ_set();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
}
static void mw_mirth_label_Label_isZ_resourceZ_labelZAsk (void) {
	mw_mirth_label_Label_name();
	mw_mirth_name_Name_head();
	uint64_t v0 = (43LL /* B'+' */);
	push_u64(v0);
	mw_std_byte_Byte_ZEqualZEqual();
}
static void mw_mirth_var_Var_index (void) {
}
static void mw_mirth_var_Var_allocZBang (void) {
	mbuf_mirth_var_Var_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_var_Var_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_var_Var_name (void) {
	mfld_mirth_var_Var_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_var_Var_type (void) {
	mfld_mirth_var_Var_ZTildetype();
	mp_primZ_mutZ_get();
}
static void mw_mirth_var_Var_autoZ_runZAsk (void) {
	mfld_mirth_var_Var_ZTildeautoZ_runZAsk();
	mp_primZ_mutZ_get();
}
static void mw_mirth_var_Var_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_var_Var_index();
	push_value(v0);
	mw_mirth_var_Var_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_var_Var_typeZThen (void) {
	mw_mirth_var_Var_name();
	mw_mirth_name_Name_ZToStr();
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_mirth_var_Var_isZ_stackZAsk (void) {
	mw_mirth_var_Var_type();
	mw_mirth_type_Type_primZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			uint64_t v0 = (1LL /* PRIM_TYPE_STACK */);
			push_u64(v0);
			mw_mirth_type_PrimType_ZEqualZEqual();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_var_Var_isZ_physicalZAsk (void) {
	mw_mirth_var_Var_type();
	mw_mirth_type_Type_isZ_physicalZAsk();
}
static void mw_mirth_var_Var_newZBang (void) {
	mw_mirth_var_Var_allocZBang();
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mfld_mirth_var_Var_ZTildename();
	mp_primZ_mutZ_set();
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	push_value(v2);
	mfld_mirth_var_Var_ZTildetype();
	mp_primZ_mutZ_set();
	uint64_t v4 = (0LL /* False */);
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_u64(v4);
	push_value(v5);
	mfld_mirth_var_Var_ZTildeautoZ_runZAsk();
	mp_primZ_mutZ_set();
}
static void mw_mirth_var_Var_newZ_autoZ_runZBang (void) {
	mw_mirth_var_Var_newZBang();
	uint64_t v0 = (1LL /* True */);
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_u64(v0);
	push_value(v1);
	mfld_mirth_var_Var_ZTildeautoZ_runZAsk();
	mp_primZ_mutZ_set();
}
static void mw_std_list_List_1_ZToCtx (void) {
}
static void mw_mirth_var_Ctx_ZToList (void) {
}
static void mw_mirth_var_Ctx0 (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
}
static void mw_mirth_var_Ctx1 (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mtw_std_list_List_1_Cons();
}
static void mw_mirth_var_Ctx2 (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mtw_std_list_List_1_Cons();
	mtw_std_list_List_1_Cons();
}
static void mw_mirth_var_Ctx3 (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mtw_std_list_List_1_Cons();
	mtw_std_list_List_1_Cons();
	mtw_std_list_List_1_Cons();
}
static void mw_mirth_var_Ctx_new (void) {
	VAL v0 = pop_value();
	mw_mirth_var_Ctx_ZToList();
	uint64_t v1 = (0LL /* Nil */);
	push_value(v0);
	push_u64(v1);
	mtw_std_list_List_1_Cons();
	mw_std_list_List_1_cat();
	mw_std_list_List_1_ZToCtx();
}
static void mw_mirth_var_Ctx_lookup (void) {
	mw_mirth_var_Ctx_ZToList();
	mw_std_list_List_1_reverse();
	uint64_t v0 = (0LL /* None */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v6);
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_value(v6);
		mw_mirth_var_Var_name();
		mw_mirth_name_Name_ZEqualZEqual();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v6);
		if (VBOOL(v10)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* None */);
			push_u64(v12);
		}
		VAL v13 = pop_value();
		push_value(v8);
		push_value(v7);
		push_value(v13);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				decref(v15);
				VAL v16 = pop_value();
				decref(v16);
				uint64_t v17 = (0LL /* Nil */);
				push_value(v14);
				push_u64(v17);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	decref(v23);
	push_value(v22);
}
static void mw_mirth_var_Ctx_freshZ_nameZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	STRLIT("_x1", 3);
	mw_std_prim_Str_ZToName();
	VAL v1 = pop_value();
	incref(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v1);
	push_value(v1);
	push_value(v3);
	mw_mirth_var_Ctx_lookup();
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		decref(v6);
		VAL v7 = pop_value();
		decref(v7);
		int64_t v8 = (1LL);
		push_i64(v8);
		mp_primZ_intZ_add();
		STRLIT("_x", 2);
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v9);
		push_value(v10);
		mp_primZ_intZ_toZ_str();
		mp_primZ_strZ_cat();
		mw_std_prim_Str_ZToName();
		VAL v11 = pop_value();
		incref(v11);
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v12);
		push_value(v11);
		push_value(v11);
		push_value(v13);
		mw_mirth_var_Ctx_lookup();
	}
	VAL v14 = pop_value();
	decref(v14);
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	decref(v16);
	push_value(v15);
}
static void mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang (void) {
	VAL v0 = pop_value();
	uint64_t v1 = (1LL /* PRIM_TYPE_STACK */);
	push_u64(v1);
	mtw_mirth_type_Type_TPrim();
	push_value(v0);
	mw_mirth_var_Ctx_freshZ_varZBang();
}
static void mw_mirth_var_Ctx_freshZ_typeZ_varZBang (void) {
	VAL v0 = pop_value();
	uint64_t v1 = (0LL /* PRIM_TYPE_TYPE */);
	push_u64(v1);
	mtw_mirth_type_Type_TPrim();
	push_value(v0);
	mw_mirth_var_Ctx_freshZ_varZBang();
}
static void mw_mirth_var_Ctx_freshZ_varZBang (void) {
	mw_mirth_var_Ctx_freshZ_nameZBang();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	push_value(v0);
	mw_mirth_var_Var_newZBang();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	mw_mirth_var_Ctx_new();
	push_value(v3);
}
static void mw_mirth_var_Var_unifyZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_mirth_var_Var_ZEqualZEqual();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
		mtw_mirth_type_Type_TVar();
	} else {
		VAL v4 = pop_value();
		mtw_mirth_type_Type_TVar();
		push_value(v4);
		mtw_mirth_type_Type_TVar();
		mw_mirth_type_Type_unifyZ_failedZBang();
	}
}
static void mw_mirth_var_Var_freshen (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v0);
	incref(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mw_mirth_type_Subst_hasZ_varZAsk();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		incref(v3);
		VAL v4 = pop_value();
		push_value(v3);
		push_value(v4);
		push_value(v3);
		mw_mirth_type_Subst_getZ_var();
	} else {
		mw_mirth_type_MetaVar_newZBang();
		mtw_mirth_type_Type_TMeta();
		VAL v5 = pop_value();
		incref(v5);
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v5);
		push_value(v7);
		push_value(v6);
		mw_mirth_type_Subst_cons();
		push_value(v5);
	}
}
static void mw_mirth_buffer_Buffer_index (void) {
}
static void mw_mirth_buffer_Buffer_allocZBang (void) {
	mbuf_mirth_buffer_Buffer_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_buffer_Buffer_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_buffer_Buffer_sizze (void) {
	mfld_mirth_buffer_Buffer_ZTildesizze();
	mp_primZ_mutZ_get();
}
static void mw_mirth_buffer_Buffer_qname (void) {
	mfld_mirth_buffer_Buffer_ZTildeqname();
	mp_primZ_mutZ_get();
}
static void mw_mirth_buffer_Buffer_name (void) {
	mw_mirth_buffer_Buffer_qname();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_buffer_Buffer_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_buffer_Buffer_index();
	push_value(v0);
	mw_mirth_buffer_Buffer_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_buffer_Buffer_newZBang (void) {
	mw_mirth_buffer_Buffer_allocZBang();
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mfld_mirth_buffer_Buffer_ZTildesizze();
	mp_primZ_mutZ_set();
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	push_value(v2);
	mfld_mirth_buffer_Buffer_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v4 = pop_value();
	incref(v4);
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	push_value(v4);
	mfld_mirth_buffer_Buffer_ZTildehead();
	mp_primZ_mutZ_set();
	VAL v6 = pop_value();
	incref(v6);
	push_value(v6);
	push_value(v6);
	mtw_mirth_def_Def_DefBuffer();
	mw_mirth_def_Def_register();
}
static void mw_mirth_word_Word_index (void) {
}
static void mw_mirth_word_Word_allocZBang (void) {
	mbuf_mirth_word_Word_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_word_Word_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_word_Word_qnameZ_soft (void) {
	mfld_mirth_word_Word_ZTildeqname();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_mirth_Prop_1_readyZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_word_Word_qnameZ_hard (void) {
	mfld_mirth_word_Word_ZTildeqname();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_word_Word_namespaceZ_hard (void) {
	mw_mirth_word_Word_qnameZ_hard();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_word_Word_name (void) {
	mfld_mirth_word_Word_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_word_Word_head (void) {
	mfld_mirth_word_Word_ZTildehead();
	mp_primZ_mutZ_get();
}
static void mw_mirth_word_Word_sigZAsk (void) {
	mfld_mirth_word_Word_ZTildesigZAsk();
	mp_primZ_mutZ_get();
}
static void mw_mirth_word_Word_body (void) {
	mfld_mirth_word_Word_ZTildebody();
	mp_primZ_mutZ_get();
}
static void mw_mirth_word_Word_arity (void) {
	mfld_mirth_word_Word_ZTildearity();
	mp_primZ_mutZ_get();
}
static void mw_mirth_word_Word_params (void) {
	mfld_mirth_word_Word_ZTildeparams();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_word_Word_arrow (void) {
	mfld_mirth_word_Word_ZTildearrow();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_word_Word_inferringZ_typeZAsk (void) {
	mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_word_Word_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_word_Word_ZTildecname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_word_Word_qnameZ_hard();
		mw_mirth_name_QName_mangled();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mw_", 3);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_word_Word_ctxZ_type (void) {
	mfld_mirth_word_Word_ZTildectxZ_type();
	mw_mirth_mirth_Prop_1_forceZBang();
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	decref(v2);
	push_value(v1);
	push_value(v0);
}
static void mw_mirth_word_Word_type (void) {
	mw_mirth_word_Word_ctxZ_type();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	push_value(v0);
}
static void mw_mirth_word_Word_preferZ_inlineZAsk (void) {
	mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_word_Word_makeZ_inlineZBang (void) {
	VAL v0 = pop_value();
	uint64_t v1 = (1LL /* True */);
	push_u64(v1);
	push_value(v0);
	mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk();
	mp_primZ_mutZ_set();
}
static void mw_mirth_word_Word_newZBang (void) {
	mw_mirth_word_Word_allocZBang();
	VAL v0 = (lpop(&lbl_name));
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mfld_mirth_word_Word_ZTildename();
	mp_primZ_mutZ_set();
	VAL v2 = (lpop(&lbl_head));
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mfld_mirth_word_Word_ZTildehead();
	mp_primZ_mutZ_set();
	VAL v4 = (lpop(&lbl_body));
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v4);
	push_value(v5);
	mfld_mirth_word_Word_ZTildebody();
	mp_primZ_mutZ_set();
	VAL v6 = (lpop(&lbl_arity));
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	push_value(v6);
	push_value(v7);
	mfld_mirth_word_Word_ZTildearity();
	mp_primZ_mutZ_set();
	VAL v8 = (lpop(&lbl_sigZAsk));
	VAL v9 = pop_value();
	incref(v9);
	push_value(v9);
	push_value(v8);
	push_value(v9);
	mfld_mirth_word_Word_ZTildesigZAsk();
	mp_primZ_mutZ_set();
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	push_value(v10);
	mtw_mirth_def_Def_DefWord();
	mw_mirth_def_Def_register();
}
static void mw_mirth_word_Word_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_word_Word_index();
	push_value(v0);
	mw_mirth_word_Word_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_word_Word_incZ_numZ_blocksZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_word_Word_ZTildenumZ_blocks();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			incref(v1);
			VAL v2 = pop_value();
			int64_t v3 = (1LL);
			push_value(v1);
			push_value(v2);
			push_value(v1);
			push_i64(v3);
			mp_primZ_intZ_add();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			push_value(v4);
			push_value(v5);
			mfld_mirth_word_Word_ZTildenumZ_blocks();
			mp_primZ_mutZ_set();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			int64_t v6 = (1LL);
			VAL v7 = pop_value();
			push_i64(v6);
			push_value(v7);
			mfld_mirth_word_Word_ZTildenumZ_blocks();
			mp_primZ_mutZ_set();
			int64_t v8 = (0LL);
			push_i64(v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_table_Table_index (void) {
}
static void mw_mirth_table_Table_allocZBang (void) {
	mbuf_mirth_table_Table_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_table_Table_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_table_Table_head (void) {
	mfld_mirth_table_Table_ZTildehead();
	mp_primZ_mutZ_get();
}
static void mw_mirth_table_Table_qnameZ_soft (void) {
	mfld_mirth_table_Table_ZTildeqname();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_mirth_Prop_1_readyZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_table_Table_qnameZ_hard (void) {
	mfld_mirth_table_Table_ZTildeqname();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_table_Table_name (void) {
	mfld_mirth_table_Table_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_table_Table_numZ_buffer (void) {
	mfld_mirth_table_Table_ZTildenumZ_buffer();
	mp_primZ_mutZ_get();
}
static void mw_mirth_table_Table_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_table_Table_index();
	push_value(v0);
	mw_mirth_table_Table_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_table_Field_index (void) {
}
static void mw_mirth_table_Field_allocZBang (void) {
	mbuf_mirth_table_Field_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_table_Field_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_table_Field_name (void) {
	mfld_mirth_table_Field_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_table_Field_qnameZ_soft (void) {
	mfld_mirth_table_Field_ZTildeqname();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_mirth_Prop_1_readyZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_table_Field_qnameZ_hard (void) {
	mfld_mirth_table_Field_ZTildeqname();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_table_Field_indexZ_type (void) {
	mfld_mirth_table_Field_ZTildeindexZ_type();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_table_Field_valueZ_type (void) {
	mfld_mirth_table_Field_ZTildevalueZ_type();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_table_Field_dom (void) {
	mw_mirth_table_Field_indexZ_type();
	mw_mirth_type_T1();
}
static void mw_mirth_table_Field_cod (void) {
	mw_mirth_table_Field_valueZ_type();
	mtw_mirth_type_Type_TMut();
	mw_mirth_type_T1();
}
static void mw_mirth_table_Field_type (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_table_Field_dom();
	push_value(v0);
	mw_mirth_table_Field_cod();
	mw_mirth_type_TZ_ZTo();
}
static void mw_mirth_table_Field_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_table_Field_index();
	push_value(v0);
	mw_mirth_table_Field_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_tycon_Tycon_qnameZ_hard (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYCON_DATA
			mtp_mirth_tycon_Tycon_TYCONz_DATA();
			mw_mirth_data_Data_qnameZ_hard();
		} break;
		case 1LL: { // TYCON_TABLE
			mtp_mirth_tycon_Tycon_TYCONz_TABLE();
			mw_mirth_table_Table_qnameZ_hard();
		} break;
		case 2LL: { // TYCON_PRIM
			mtp_mirth_tycon_Tycon_TYCONz_PRIM();
			mw_mirth_type_PrimType_tyconZ_qname();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_tycon_Tycon_ZEqualZEqual (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYCON_DATA
			mtp_mirth_tycon_Tycon_TYCONz_DATA();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			switch (get_top_data_tag()) {
				case 0LL: { // TYCON_DATA
					mtp_mirth_tycon_Tycon_TYCONz_DATA();
					mw_mirth_data_Data_ZEqualZEqual();
				} break;
				default: {
					VAL v2 = pop_value();
					decref(v2);
					VAL v3 = pop_value();
					decref(v3);
					uint64_t v4 = (0LL /* False */);
					push_u64(v4);
				} break;
			}
		} break;
		case 1LL: { // TYCON_TABLE
			mtp_mirth_tycon_Tycon_TYCONz_TABLE();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			push_value(v5);
			push_value(v6);
			switch (get_top_data_tag()) {
				case 1LL: { // TYCON_TABLE
					mtp_mirth_tycon_Tycon_TYCONz_TABLE();
					mw_mirth_table_Table_ZEqualZEqual();
				} break;
				default: {
					VAL v7 = pop_value();
					decref(v7);
					VAL v8 = pop_value();
					decref(v8);
					uint64_t v9 = (0LL /* False */);
					push_u64(v9);
				} break;
			}
		} break;
		case 2LL: { // TYCON_PRIM
			mtp_mirth_tycon_Tycon_TYCONz_PRIM();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			push_value(v10);
			push_value(v11);
			switch (get_top_data_tag()) {
				case 2LL: { // TYCON_PRIM
					mtp_mirth_tycon_Tycon_TYCONz_PRIM();
					mw_mirth_type_PrimType_ZEqualZEqual();
				} break;
				default: {
					VAL v12 = pop_value();
					decref(v12);
					VAL v13 = pop_value();
					decref(v13);
					uint64_t v14 = (0LL /* False */);
					push_u64(v14);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_tycon_Tycon_fullZ_typeZ_fresh (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYCON_DATA
			mtp_mirth_tycon_Tycon_TYCONz_DATA();
			VAL v0 = pop_value();
			uint64_t v1 = (0LL /* SUBST_NIL */);
			push_u64(v1);
			push_value(v0);
			mw_mirth_data_Data_fullZ_type();
			switch (get_top_data_tag()) {
				case 0LL: { // Left
					mtp_std_either_Either_2_Left();
					mw_mirth_type_Type_freshen();
					mtw_std_either_Either_2_Left();
				} break;
				case 1LL: { // Right
					mtp_std_either_Either_2_Right();
					mw_mirth_type_Resource_freshen();
					mtw_std_either_Either_2_Right();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			decref(v3);
			push_value(v2);
		} break;
		case 2LL: { // TYCON_PRIM
			mtp_mirth_tycon_Tycon_TYCONz_PRIM();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mw_mirth_type_PrimType_isZ_resourceZAsk();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				mtw_mirth_type_Type_TPrim();
				mtw_std_either_Either_2_Right();
			} else {
				mtw_mirth_type_Type_TPrim();
				mtw_std_either_Either_2_Left();
			}
		} break;
		case 1LL: { // TYCON_TABLE
			mtp_mirth_tycon_Tycon_TYCONz_TABLE();
			mtw_mirth_type_Type_TTable();
			mtw_std_either_Either_2_Left();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_data_Data_index (void) {
}
static void mw_mirth_data_Data_allocZBang (void) {
	mbuf_mirth_data_Data_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_data_Data_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_data_Data_headZAsk (void) {
	mfld_mirth_data_Data_ZTildeheadZAsk();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Data_name (void) {
	mfld_mirth_data_Data_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Data_qnameZ_soft (void) {
	mfld_mirth_data_Data_ZTildeqname();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_mirth_Prop_1_readyZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_data_Data_qnameZ_hard (void) {
	mfld_mirth_data_Data_ZTildeqname();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_data_Data_arity (void) {
	mfld_mirth_data_Data_ZTildearity();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Data_params (void) {
	mfld_mirth_data_Data_ZTildeparams();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_data_Data_tags (void) {
	mfld_mirth_data_Data_ZTildetags();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Data_ctypeZAsk (void) {
	mfld_mirth_data_Data_ZTildectypeZAsk();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_data_TYPEz_BOOL (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_U64 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_U32 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[8];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_U16 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[10];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_U8 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[12];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_I64 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[14];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_I32 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[16];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_I16 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[18];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_TYPEz_I8 (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[20];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_mirth_type_Type_TData();
}
static void mw_mirth_data_makeZ_primZ_dataZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	incref(v3);
	lpush(&lbl_ctype, v0);
	lpush(&lbl_tags, v1);
	lpush(&lbl_data, v2);
	lpush(&lbl_name, v4);
	push_value(v3);
	lpush(&lbl_params, v3);
	mw_std_list_List_1_len();
	VAL v5 = pop_value();
	incref(v5);
	VAL v6 = (lpop(&lbl_data));
	incref(v6);
	push_value(v5);
	push_value(v5);
	push_value(v6);
	lpush(&lbl_data, v6);
	mfld_mirth_data_Data_ZTildearity();
	mp_primZ_mutZ_set();
	VAL v7 = (lpop(&lbl_name));
	incref(v7);
	push_value(v7);
	lpush(&lbl_name, v7);
	mw_std_prim_Str_ZToName();
	VAL v8 = (lpop(&lbl_data));
	incref(v8);
	push_value(v8);
	lpush(&lbl_data, v8);
	mfld_mirth_data_Data_ZTildename();
	mp_primZ_mutZ_set();
	VAL v9 = (lpop(&lbl_name));
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	mw_mirth_name_QName_prim();
	VAL v11 = (lpop(&lbl_data));
	incref(v11);
	push_value(v11);
	lpush(&lbl_data, v11);
	mtw_mirth_mirth_PropLabel_DataQName();
	mw_mirth_mirth_PropLabel_prop();
	VAL v12 = (lpop(&lbl_data));
	incref(v12);
	push_value(v12);
	lpush(&lbl_data, v12);
	mfld_mirth_data_Data_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v13 = (lpop(&lbl_ctype));
	VAL v14 = (lpop(&lbl_data));
	incref(v14);
	push_value(v13);
	push_value(v14);
	lpush(&lbl_data, v14);
	mtw_mirth_mirth_PropLabel_DataCType();
	mw_mirth_mirth_PropLabel_prop();
	VAL v15 = (lpop(&lbl_data));
	incref(v15);
	push_value(v15);
	lpush(&lbl_data, v15);
	mfld_mirth_data_Data_ZTildectypeZAsk();
	mp_primZ_mutZ_set();
	VAL v16 = (lpop(&lbl_tags));
	incref(v16);
	push_value(v16);
	lpush(&lbl_tags, v16);
	mw_std_list_List_1_uncons();
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	push_value(v17);
	push_value(v18);
	while(1) {
		VAL v19 = pop_value();
		incref(v19);
		push_value(v19);
		push_value(v19);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v20 = pop_value();
		if (!VBOOL(v20)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		VAL v23 = (lpop(&lbl_data));
		incref(v23);
		lpush(&lbl_data, v23);
		push_value(v23);
		push_value(v21);
		mfld_mirth_data_Tag_ZTildedata();
		mp_primZ_mutZ_set();
		push_value(v22);
		mw_std_list_List_1_uncons();
		VAL v24 = pop_value();
		VAL v25 = pop_value();
		push_value(v24);
		push_value(v25);
	}
	VAL v26 = pop_value();
	decref(v26);
	VAL v27 = pop_value();
	decref(v27);
	VAL v28 = (lpop(&lbl_tags));
	VAL v29 = (lpop(&lbl_data));
	incref(v29);
	push_value(v28);
	push_value(v29);
	lpush(&lbl_data, v29);
	mfld_mirth_data_Data_ZTildetags();
	mp_primZ_mutZ_set();
	VAL v30 = (lpop(&lbl_params));
	VAL v31 = (lpop(&lbl_data));
	incref(v31);
	push_value(v30);
	push_value(v31);
	lpush(&lbl_data, v31);
	mtw_mirth_mirth_PropLabel_DataParams();
	mw_mirth_mirth_PropLabel_prop();
	VAL v32 = (lpop(&lbl_data));
	incref(v32);
	push_value(v32);
	lpush(&lbl_data, v32);
	mfld_mirth_data_Data_ZTildeparams();
	mp_primZ_mutZ_set();
	uint64_t v33 = (0LL /* None */);
	VAL v34 = (lpop(&lbl_data));
	incref(v34);
	push_u64(v33);
	push_value(v34);
	lpush(&lbl_data, v34);
	mfld_mirth_data_Data_ZTildeheadZAsk();
	mp_primZ_mutZ_set();
	VAL v35 = (lpop(&lbl_data));
	push_value(v35);
	mtw_mirth_def_Def_DefData();
	mw_mirth_def_Def_register();
}
static void mw_mirth_data_makeZ_primZ_tagZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v0);
	lpush(&lbl_inputs, v1);
	lpush(&lbl_value, v2);
	lpush(&lbl_name, v3);
	push_value(v0);
	lpush(&lbl_tag, v0);
	mw_mirth_data_Tag_data();
	VAL v4 = (lpop(&lbl_name));
	int64_t v5 = (0LL);
	push_value(v4);
	push_i64(v5);
	mw_mirth_data_dataZ_wordZ_qname();
	VAL v6 = (lpop(&lbl_tag));
	incref(v6);
	push_value(v6);
	lpush(&lbl_tag, v6);
	mfld_mirth_data_Tag_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v7 = (lpop(&lbl_value));
	VAL v8 = (lpop(&lbl_tag));
	incref(v8);
	push_value(v7);
	push_value(v8);
	lpush(&lbl_tag, v8);
	mfld_mirth_data_Tag_ZTildevalue();
	mp_primZ_mutZ_set();
	VAL v9 = (lpop(&lbl_inputs));
	incref(v9);
	push_value(v9);
	lpush(&lbl_inputs, v9);
	mw_std_list_List_1_len();
	VAL v10 = (lpop(&lbl_tag));
	incref(v10);
	push_value(v10);
	lpush(&lbl_tag, v10);
	mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs();
	mp_primZ_mutZ_set();
	int64_t v11 = (0LL);
	push_i64(v11);
	mw_std_prim_Int_ZToNat();
	VAL v12 = (lpop(&lbl_tag));
	incref(v12);
	push_value(v12);
	lpush(&lbl_tag, v12);
	mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs();
	mp_primZ_mutZ_set();
	uint64_t v13 = (0LL /* Nil */);
	VAL v14 = (lpop(&lbl_tag));
	incref(v14);
	push_u64(v13);
	push_value(v14);
	lpush(&lbl_tag, v14);
	mfld_mirth_data_Tag_ZTildelabelZ_inputs();
	mp_primZ_mutZ_set();
	VAL v15 = (lpop(&lbl_tag));
	incref(v15);
	push_value(v15);
	lpush(&lbl_tag, v15);
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_params();
	mw_std_list_List_1_ZToCtx();
	VAL v16 = (lpop(&lbl_inputs));
	push_value(v16);
	mw_mirth_type_TT();
	mw_mirth_type_T0();
	VAL v17 = (lpop(&lbl_tag));
	incref(v17);
	push_value(v17);
	lpush(&lbl_tag, v17);
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_fullZ_type();
	mw_mirth_type_TZMulZPlus();
	mw_mirth_type_TZ_ZTo();
	VAL v18 = (lpop(&lbl_tag));
	incref(v18);
	push_value(v18);
	lpush(&lbl_tag, v18);
	mtw_mirth_mirth_PropLabel_TagType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v19 = (lpop(&lbl_tag));
	incref(v19);
	push_value(v19);
	lpush(&lbl_tag, v19);
	mfld_mirth_data_Tag_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v20 = (lpop(&lbl_tag));
	push_value(v20);
	mtw_mirth_def_Def_DefTag();
	mw_mirth_def_Def_register();
}
static void mw_mirth_data_makeZ_primZ_intlikeZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	uint64_t v5 = (0LL /* Nil */);
	incref(v1);
	uint64_t v6 = (0LL /* Nil */);
	lpush(&lbl_underlying, v0);
	lpush(&lbl_tagname, v2);
	push_value(v4);
	push_u64(v5);
	push_value(v3);
	push_value(v1);
	lpush(&lbl_tag, v1);
	push_u64(v6);
	mtw_std_list_List_1_Cons();
	VAL v7 = (lpop(&lbl_underlying));
	push_value(v7);
	mtw_mirth_type_CType_IntLike();
	mtw_std_maybe_Maybe_1_Some();
	mw_mirth_data_makeZ_primZ_dataZBang();
	VAL v8 = (lpop(&lbl_tagname));
	int64_t v9 = (0LL);
	push_value(v8);
	push_i64(v9);
	mw_mirth_type_TYPEz_INT();
	uint64_t v10 = (0LL /* Nil */);
	push_u64(v10);
	mtw_std_list_List_1_Cons();
	VAL v11 = (lpop(&lbl_tag));
	push_value(v11);
	mw_mirth_data_makeZ_primZ_tagZBang();
}
static void mw_mirth_data_initZ_dataZBang (void) {
	STRLIT("Bool", 4);
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v1 = (0LL /* Nil */);
	push_u64(v1);
	mtw_std_list_List_1_Cons();
	mtw_std_list_List_1_Cons();
	STRLIT("_Bool", 5);
	mtw_mirth_type_CType_IntLike();
	mtw_std_maybe_Maybe_1_Some();
	mw_mirth_data_makeZ_primZ_dataZBang();
	STRLIT("False", 5);
	int64_t v2 = (0LL);
	uint64_t v3 = (0LL /* Nil */);
	push_i64(v2);
	push_u64(v3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_makeZ_primZ_tagZBang();
	STRLIT("True", 4);
	int64_t v4 = (1LL);
	uint64_t v5 = (0LL /* Nil */);
	push_i64(v4);
	push_u64(v5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_makeZ_primZ_tagZBang();
	mw_mirth_type_TYPEz_TYPE();
	STRLIT("a", 1);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	VAL v6 = pop_value();
	lpush(&lbl_a, v6);
	STRLIT("CPtr", 4);
	VAL v7 = (lpop(&lbl_a));
	incref(v7);
	uint64_t v8 = (0LL /* Nil */);
	push_value(v7);
	lpush(&lbl_a, v7);
	push_u64(v8);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[52];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[53];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v9 = (0LL /* Nil */);
	push_u64(v9);
	mtw_std_list_List_1_Cons();
	uint64_t v10 = (0LL /* None */);
	push_u64(v10);
	mw_mirth_data_makeZ_primZ_dataZBang();
	STRLIT("CPtr", 4);
	int64_t v11 = (0LL);
	push_i64(v11);
	mw_mirth_type_TYPEz_PTR();
	uint64_t v12 = (0LL /* Nil */);
	push_u64(v12);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[53];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_makeZ_primZ_tagZBang();
	STRLIT("CConst", 6);
	VAL v13 = (lpop(&lbl_a));
	incref(v13);
	uint64_t v14 = (0LL /* Nil */);
	push_value(v13);
	lpush(&lbl_a, v13);
	push_u64(v14);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[54];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[55];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v15 = (0LL /* Nil */);
	push_u64(v15);
	mtw_std_list_List_1_Cons();
	uint64_t v16 = (0LL /* None */);
	push_u64(v16);
	mw_mirth_data_makeZ_primZ_dataZBang();
	STRLIT("CConst", 6);
	int64_t v17 = (0LL);
	VAL v18 = (lpop(&lbl_a));
	incref(v18);
	push_i64(v17);
	push_value(v18);
	lpush(&lbl_a, v18);
	mtw_mirth_type_Type_TVar();
	uint64_t v19 = (0LL /* Nil */);
	push_u64(v19);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[55];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_makeZ_primZ_tagZBang();
	STRLIT("CRestrict", 9);
	VAL v20 = (lpop(&lbl_a));
	incref(v20);
	uint64_t v21 = (0LL /* Nil */);
	push_value(v20);
	lpush(&lbl_a, v20);
	push_u64(v21);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[56];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[57];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v22 = (0LL /* Nil */);
	push_u64(v22);
	mtw_std_list_List_1_Cons();
	uint64_t v23 = (0LL /* None */);
	push_u64(v23);
	mw_mirth_data_makeZ_primZ_dataZBang();
	STRLIT("CRestrict", 9);
	int64_t v24 = (0LL);
	VAL v25 = (lpop(&lbl_a));
	incref(v25);
	push_i64(v24);
	push_value(v25);
	lpush(&lbl_a, v25);
	mtw_mirth_type_Type_TVar();
	uint64_t v26 = (0LL /* Nil */);
	push_u64(v26);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[57];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_makeZ_primZ_tagZBang();
	STRLIT("CVolatile", 9);
	VAL v27 = (lpop(&lbl_a));
	incref(v27);
	uint64_t v28 = (0LL /* Nil */);
	push_value(v27);
	lpush(&lbl_a, v27);
	push_u64(v28);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[58];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[59];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v29 = (0LL /* Nil */);
	push_u64(v29);
	mtw_std_list_List_1_Cons();
	uint64_t v30 = (0LL /* None */);
	push_u64(v30);
	mw_mirth_data_makeZ_primZ_dataZBang();
	STRLIT("CVolatile", 9);
	int64_t v31 = (0LL);
	VAL v32 = (lpop(&lbl_a));
	incref(v32);
	push_i64(v31);
	push_value(v32);
	lpush(&lbl_a, v32);
	mtw_mirth_type_Type_TVar();
	uint64_t v33 = (0LL /* Nil */);
	push_u64(v33);
	mtw_std_list_List_1_Cons();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[59];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_makeZ_primZ_tagZBang();
	VAL v34 = (lpop(&lbl_a));
	decref(v34);
	STRLIT("CVoid", 5);
	uint64_t v35 = (0LL /* Nil */);
	push_u64(v35);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[60];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[61];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v36 = (0LL /* Nil */);
	push_u64(v36);
	mtw_std_list_List_1_Cons();
	uint64_t v37 = (5LL /* Phantom */);
	push_u64(v37);
	mtw_std_maybe_Maybe_1_Some();
	mw_mirth_data_makeZ_primZ_dataZBang();
	STRLIT("CVoid", 5);
	int64_t v38 = (0LL);
	uint64_t v39 = (0LL /* Nil */);
	push_i64(v38);
	push_u64(v39);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[61];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_makeZ_primZ_tagZBang();
	STRLIT("U64", 3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>U64-unsafe", 14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("uint64_t", 8);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("U32", 3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[8];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>U32-unsafe", 14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("uint32_t", 8);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("U16", 3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[10];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>U16-unsafe", 14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[11];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("uint16_t", 8);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("U8", 2);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[12];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>U8-unsafe", 13);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[13];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("uint8_t", 7);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("I64", 3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[14];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>I64-unsafe", 14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[15];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("int64_t", 7);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("I32", 3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[16];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>I32-unsafe", 14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[17];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("int32_t", 7);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("I16", 3);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[18];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>I16-unsafe", 14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[19];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("int16_t", 7);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("I8", 2);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[20];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("Int>I8-unsafe", 13);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[21];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("int8_t", 6);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CChar", 5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[22];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CChar", 5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[23];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("char", 4);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CIChar", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[24];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CIChar", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[25];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("signed char", 11);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CShort", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[26];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CShort", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[27];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("short", 5);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CInt", 4);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[28];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CInt", 4);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[29];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("int", 3);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CLong", 5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[30];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CLong", 5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[31];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("long", 4);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CLongLong", 9);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[32];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CLongLong", 9);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[33];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("long long", 9);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CISize", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[34];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CISize", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[35];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("ssize_t", 7);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CIntPtr", 7);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[36];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CIntPtr", 7);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[37];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("intptr_t", 8);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CUChar", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[38];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CUChar", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[39];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("unsigned char", 13);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CUShort", 7);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[40];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CUShort", 7);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[41];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("unsigned short", 14);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CUInt", 5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[42];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CUInt", 5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[43];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("unsigned int", 12);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CULong", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[44];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CULong", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[45];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("unsigned long", 13);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CULongLong", 10);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[46];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CULongLong", 10);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[47];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("unsigned long long", 18);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CUSize", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[48];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CUSize", 6);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[49];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("size_t", 6);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
	STRLIT("CUIntPtr", 8);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[50];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("CUIntPtr", 8);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[51];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("uintptr_t", 9);
	mw_mirth_data_makeZ_primZ_intlikeZBang();
}
static void mw_mirth_data_dataZ_qname (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	lpush(&lbl_arity, v0);
	lpush(&lbl_name, v1);
	mtw_mirth_tycon_Tycon_TYCONz_DATA();
	mtw_mirth_name_Namespace_NAMESPACEz_TYCON();
	VAL v2 = pop_value();
	lpush(&lbl_namespace, v2);
	mtw_mirth_name_QName_MKQNAME();
}
static void mw_mirth_data_dataZ_wordZ_qname (void) {
	VAL v0 = pop_value();
	mw_std_prim_Str_ZToName();
	push_value(v0);
	mw_mirth_data_dataZ_qname();
}
static void mw_mirth_data_Data_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_data_Data_index();
	push_value(v0);
	mw_mirth_data_Data_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_data_Data_numZ_tags (void) {
	mw_mirth_data_Data_tags();
	mw_std_list_List_1_len();
}
static void mw_mirth_data_Data_addZ_tagZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mfld_mirth_data_Tag_ZTildevalue();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v2);
	mp_primZ_mutZ_isZ_set();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mfld_mirth_data_Data_ZTildelastZ_tagZ_value();
		mw_std_prelude_ZAtZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				int64_t v6 = (1LL);
				push_i64(v6);
				mp_primZ_intZ_add();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				int64_t v7 = (0LL);
				push_i64(v7);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		push_value(v4);
		mp_primZ_mutZ_set();
	}
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	push_value(v9);
	push_value(v10);
	mw_mirth_data_Data_tags();
	uint64_t v11 = (0LL /* None */);
	VAL v12 = pop_value();
	push_u64(v11);
	push_value(v12);
	mw_std_list_List_1_uncons();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	push_value(v13);
	push_value(v14);
	while(1) {
		VAL v15 = pop_value();
		incref(v15);
		push_value(v15);
		push_value(v15);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v16 = pop_value();
		if (!VBOOL(v16)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		incref(v17);
		push_value(v17);
		mw_mirth_data_Tag_value();
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		incref(v21);
		bool v22 = (VI64(v20) == VI64(v21));
		push_value(v21);
		push_value(v17);
		if (v22) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v23 = pop_value();
			decref(v23);
			uint64_t v24 = (0LL /* None */);
			push_u64(v24);
		}
		VAL v25 = pop_value();
		push_value(v19);
		push_value(v18);
		push_value(v25);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v26 = pop_value();
				VAL v27 = pop_value();
				decref(v27);
				VAL v28 = pop_value();
				decref(v28);
				uint64_t v29 = (0LL /* Nil */);
				push_value(v26);
				push_u64(v29);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v30 = pop_value();
		VAL v31 = pop_value();
		push_value(v30);
		push_value(v31);
	}
	VAL v32 = pop_value();
	decref(v32);
	VAL v33 = pop_value();
	decref(v33);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("Constructors ", 13);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_data_Tag_name();
			VAL r34 = pop_resource();
			mw_mirth_name_Name_ZToStr();
			push_resource(r34);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(" and ", 5);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			VAL v35 = pop_value();
			VAL v36 = pop_value();
			VAL v37 = pop_value();
			incref(v37);
			push_value(v37);
			push_value(v36);
			push_value(v35);
			push_value(v37);
			mw_mirth_data_Tag_name();
			VAL r38 = pop_resource();
			mw_mirth_name_Name_ZToStr();
			push_resource(r38);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(" have the same tag value.", 25);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
			VAL v39 = pop_value();
			VAL v40 = pop_value();
			VAL v41 = pop_value();
			incref(v41);
			push_value(v41);
			push_value(v40);
			push_value(v39);
			push_value(v41);
			mw_mirth_data_Data_headZAsk();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						VAL* p = &VTUP(v)->cells[5];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							mp_primZ_panic();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v42 = pop_value();
			VAL v43 = pop_value();
			push_value(v42);
			push_value(v43);
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v44 = pop_value();
	VAL v45 = pop_value();
	incref(v45);
	push_value(v45);
	push_value(v44);
	push_value(v45);
	mfld_mirth_data_Data_ZTildelastZ_tagZ_value();
	mp_primZ_mutZ_set();
	VAL v46 = pop_value();
	incref(v46);
	push_value(v46);
	mw_mirth_data_Data_tags();
	VAL v47 = pop_value();
	VAL v48 = pop_value();
	uint64_t v49 = (0LL /* Nil */);
	push_value(v47);
	push_value(v48);
	push_u64(v49);
	mtw_std_list_List_1_Cons();
	mw_std_list_List_1_cat();
	push_value(v46);
	mfld_mirth_data_Data_ZTildetags();
	mp_primZ_mutZ_set();
}
static void mw_mirth_data_Data_isZ_unitZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Data_ZTildeisZ_unitZAsk();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Data_tags();
		mw_std_list_List_1_ZDivL1();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mw_mirth_data_Tag_numZ_totalZ_inputs();
				int64_t v5 = (0LL);
				VAL v6 = pop_value();
				bool v7 = (VI64(v6) == v5);
				push_bool(v7);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v8 = (0LL /* False */);
				push_u64(v8);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_value(v9);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	decref(v11);
	push_value(v10);
}
static void mw_mirth_data_Data_isZ_enumZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Data_ZTildeisZ_enumZAsk();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Data_isZ_unitZAsk();
		VAL v5 = pop_value();
		if (VBOOL(v5)) {
			uint64_t v6 = (0LL /* False */);
			push_u64(v6);
		} else {
			uint64_t v7 = (1LL /* True */);
			push_u64(v7);
		}
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			push_value(v9);
			mw_mirth_data_Data_tags();
			uint64_t v10 = (0LL /* None */);
			VAL v11 = pop_value();
			push_u64(v10);
			push_value(v11);
			mw_std_list_List_1_uncons();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			push_value(v12);
			push_value(v13);
			while(1) {
				VAL v14 = pop_value();
				incref(v14);
				push_value(v14);
				push_value(v14);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v15 = pop_value();
				if (!VBOOL(v15)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v16 = pop_value();
				VAL v17 = pop_value();
				VAL v18 = pop_value();
				incref(v16);
				push_value(v16);
				mw_mirth_data_Tag_numZ_totalZ_inputs();
				int64_t v19 = (0LL);
				VAL v20 = pop_value();
				bool v21 = (VI64(v20) == v19);
				if (v21) {
					uint64_t v22 = (0LL /* False */);
					push_u64(v22);
				} else {
					uint64_t v23 = (1LL /* True */);
					push_u64(v23);
				}
				VAL v24 = pop_value();
				push_value(v16);
				if (VBOOL(v24)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v25 = pop_value();
					decref(v25);
					uint64_t v26 = (0LL /* None */);
					push_u64(v26);
				}
				VAL v27 = pop_value();
				push_value(v18);
				push_value(v17);
				push_value(v27);
				switch (get_top_data_tag()) {
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						VAL v28 = pop_value();
						VAL v29 = pop_value();
						decref(v29);
						VAL v30 = pop_value();
						decref(v30);
						uint64_t v31 = (0LL /* Nil */);
						push_value(v28);
						push_u64(v31);
					} break;
				}
				mw_std_list_List_1_uncons();
				VAL v32 = pop_value();
				VAL v33 = pop_value();
				push_value(v32);
				push_value(v33);
			}
			VAL v34 = pop_value();
			decref(v34);
			VAL v35 = pop_value();
			decref(v35);
			mw_std_maybe_Maybe_1_noneZAsk();
		} else {
			uint64_t v36 = (0LL /* False */);
			push_u64(v36);
		}
		VAL v37 = pop_value();
		incref(v37);
		push_value(v37);
		push_value(v37);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v38 = pop_value();
	VAL v39 = pop_value();
	decref(v39);
	push_value(v38);
}
static void mw_mirth_data_Data_isZ_transparentZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Data_ZTildeisZ_transparentZAsk();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Data_isZ_resourceZAsk();
		VAL v5 = pop_value();
		if (VBOOL(v5)) {
			VAL v6 = pop_value();
			incref(v6);
			push_value(v6);
			push_value(v6);
			mw_mirth_data_Data_tags();
			mw_std_list_List_1_ZDivL1();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v7 = pop_value();
					incref(v7);
					push_value(v7);
					push_value(v7);
					mw_mirth_data_Tag_numZ_resourceZ_inputs();
					int64_t v8 = (1LL);
					push_i64(v8);
					mw_std_prim_Int_ZToNat();
					VAL v9 = pop_value();
					VAL v10 = pop_value();
					bool v11 = (VI64(v10) == VI64(v9));
					VAL v12 = pop_value();
					push_bool(v11);
					push_value(v12);
					mw_mirth_data_Tag_numZ_totalZ_inputs();
					int64_t v13 = (1LL);
					push_i64(v13);
					mw_std_prim_Int_ZToNat();
					VAL v14 = pop_value();
					VAL v15 = pop_value();
					bool v16 = (VI64(v15) == VI64(v14));
					if (v16) {
					} else {
						VAL v17 = pop_value();
						decref(v17);
						uint64_t v18 = (0LL /* False */);
						push_u64(v18);
					}
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v19 = (0LL /* False */);
					push_u64(v19);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} else {
			VAL v20 = pop_value();
			incref(v20);
			push_value(v20);
			push_value(v20);
			mw_mirth_data_Data_tags();
			mw_std_list_List_1_ZDivL1();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v21 = pop_value();
					incref(v21);
					push_value(v21);
					push_value(v21);
					mw_mirth_data_Tag_numZ_typeZ_inputs();
					int64_t v22 = (1LL);
					push_i64(v22);
					mw_std_prim_Int_ZToNat();
					VAL v23 = pop_value();
					VAL v24 = pop_value();
					bool v25 = (VI64(v24) == VI64(v23));
					VAL v26 = pop_value();
					push_bool(v25);
					push_value(v26);
					mw_mirth_data_Tag_numZ_totalZ_inputs();
					int64_t v27 = (1LL);
					push_i64(v27);
					mw_std_prim_Int_ZToNat();
					VAL v28 = pop_value();
					VAL v29 = pop_value();
					bool v30 = (VI64(v29) == VI64(v28));
					if (v30) {
					} else {
						VAL v31 = pop_value();
						decref(v31);
						uint64_t v32 = (0LL /* False */);
						push_u64(v32);
					}
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v33 = (0LL /* False */);
					push_u64(v33);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		}
		VAL v34 = pop_value();
		incref(v34);
		push_value(v34);
		push_value(v34);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v35 = pop_value();
	VAL v36 = pop_value();
	decref(v36);
	push_value(v35);
}
static void mw_mirth_data_Data_isZ_semiZ_transparentZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Data_ZTildeisZ_semiZ_transparentZAsk();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Data_tags();
		mw_std_list_List_1_ZDivL1();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mw_mirth_data_Tag_numZ_totalZ_inputs();
				int64_t v5 = (1LL);
				push_i64(v5);
				mw_std_prim_Int_ZToNat();
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				bool v8 = (VI64(v7) == VI64(v6));
				push_bool(v8);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v9 = (0LL /* False */);
				push_u64(v9);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v10);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	decref(v12);
	push_value(v11);
}
static void mw_mirth_data_Data_isZ_resourceZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Data_ZTildeisZ_resourceZAsk();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Data_name();
		mw_mirth_name_Name_couldZ_beZ_resourceZ_con();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_data_Data_isZ_valueZ_typeZAsk (void) {
	mw_mirth_data_Data_isZ_resourceZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		uint64_t v1 = (0LL /* False */);
		push_u64(v1);
	} else {
		uint64_t v2 = (1LL /* True */);
		push_u64(v2);
	}
}
static void mw_mirth_data_Data_fullZ_type (void) {
	VAL v0 = pop_value();
	incref(v0);
	incref(v0);
	push_value(v0);
	push_value(v0);
	mtw_mirth_type_Type_TData();
	push_value(v0);
	mw_mirth_data_Data_params();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		push_value(v5);
		mtw_mirth_type_Type_TVar();
		mtw_mirth_type_Type_TApp();
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
	}
	VAL v9 = pop_value();
	decref(v9);
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	push_value(v11);
	push_value(v12);
	mw_mirth_data_Data_isZ_valueZ_typeZAsk();
	VAL v13 = pop_value();
	if (VBOOL(v13)) {
		mtw_std_either_Either_2_Left();
	} else {
		mtw_std_either_Either_2_Right();
	}
}
static void mw_mirth_data_Tag_index (void) {
}
static void mw_mirth_data_Tag_allocZBang (void) {
	mbuf_mirth_data_Tag_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_data_Tag_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_data_Tag_data (void) {
	mfld_mirth_data_Tag_ZTildedata();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_qname (void) {
	mfld_mirth_data_Tag_ZTildeqname();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_name (void) {
	mw_mirth_data_Tag_qname();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_data_Tag_value (void) {
	mfld_mirth_data_Tag_ZTildevalue();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_labelZ_inputs (void) {
	mfld_mirth_data_Tag_ZTildelabelZ_inputs();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_numZ_typeZ_inputs (void) {
	mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_numZ_resourceZ_inputs (void) {
	mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_sigZAsk (void) {
	mfld_mirth_data_Tag_ZTildesigZAsk();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_ctxZ_type (void) {
	mfld_mirth_data_Tag_ZTildectxZ_type();
	mw_mirth_mirth_Prop_1_forceZBang();
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	decref(v2);
	push_value(v1);
	push_value(v0);
}
static void mw_mirth_data_Tag_ctx (void) {
	mw_mirth_data_Tag_ctxZ_type();
	VAL v0 = pop_value();
	decref(v0);
}
static void mw_mirth_data_Tag_type (void) {
	mw_mirth_data_Tag_ctxZ_type();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	push_value(v0);
}
static void mw_mirth_data_Tag_untag (void) {
	mfld_mirth_data_Tag_ZTildeuntag();
	mp_primZ_mutZ_get();
}
static void mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig (void) {
	mw_mirth_data_Tag_sigZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_token_Token_runZ_tokens();
			uint64_t v0 = (0LL /* Nil */);
			push_u64(v0);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			while(1) {
				VAL v3 = pop_value();
				incref(v3);
				push_value(v3);
				push_value(v3);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v4 = pop_value();
				if (!VBOOL(v4)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v5 = pop_value();
				VAL v6 = pop_value();
				VAL r7 = pop_resource();
				incref(v5);
				push_value(v5);
				mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk();
				VAL v8 = pop_value();
				push_value(v5);
				if (VBOOL(v8)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v9 = pop_value();
					decref(v9);
					uint64_t v10 = (0LL /* None */);
					push_u64(v10);
				}
				push_resource(r7);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mtp_std_list_ZPlusList_1_ZPlusList();
						mtw_std_list_List_1_Cons();
						mtw_std_list_ZPlusList_1_ZPlusList();
					} break;
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				push_value(v6);
				mw_std_list_List_1_uncons();
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				push_value(v11);
				push_value(v12);
			}
			VAL v13 = pop_value();
			decref(v13);
			VAL v14 = pop_value();
			decref(v14);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			uint64_t v15 = (0LL /* Nil */);
			push_u64(v15);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			push_value(v16);
			push_value(v17);
			while(1) {
				VAL v18 = pop_value();
				incref(v18);
				push_value(v18);
				push_value(v18);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v19 = pop_value();
				if (!VBOOL(v19)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v20 = pop_value();
				VAL v21 = pop_value();
				VAL r22 = pop_resource();
				push_value(v20);
				mw_mirth_token_Token_nameZAsk();
				mw_std_maybe_Maybe_1_unwrap();
				mw_mirth_label_Label_newZBang();
				push_resource(r22);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
				push_value(v21);
				mw_std_list_List_1_uncons();
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				push_value(v23);
				push_value(v24);
			}
			VAL v25 = pop_value();
			decref(v25);
			VAL v26 = pop_value();
			decref(v26);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v27 = (0LL /* Nil */);
			push_u64(v27);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_sigZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_token_Token_runZ_length();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v1);
			push_value(v2);
			mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig();
			VAL v3 = pop_value();
			push_value(v3);
			mp_primZ_intZ_sub();
			mw_std_prim_Int_ZToNat();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			push_value(v4);
			push_value(v5);
			mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig();
			mw_std_list_List_1_len();
			VAL v6 = pop_value();
			push_value(v6);
			mp_primZ_intZ_sub();
			mw_std_prim_Int_ZToNat();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v7 = pop_value();
			decref(v7);
			int64_t v8 = (0LL);
			push_i64(v8);
			mw_std_prim_Int_ZToNat();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig (void) {
	mw_mirth_data_Tag_sigZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_token_Token_runZ_tokens();
			uint64_t v0 = (0LL /* Nil */);
			push_u64(v0);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			while(1) {
				VAL v3 = pop_value();
				incref(v3);
				push_value(v3);
				push_value(v3);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v4 = pop_value();
				if (!VBOOL(v4)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v5 = pop_value();
				VAL v6 = pop_value();
				VAL r7 = pop_resource();
				incref(v5);
				push_value(v5);
				mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk();
				VAL v8 = pop_value();
				if (VBOOL(v8)) {
					uint64_t v9 = (0LL /* False */);
					push_u64(v9);
				} else {
					uint64_t v10 = (1LL /* True */);
					push_u64(v10);
				}
				VAL v11 = pop_value();
				push_value(v5);
				if (VBOOL(v11)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v12 = pop_value();
					decref(v12);
					uint64_t v13 = (0LL /* None */);
					push_u64(v13);
				}
				push_resource(r7);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mtp_std_list_ZPlusList_1_ZPlusList();
						mtw_std_list_List_1_Cons();
						mtw_std_list_ZPlusList_1_ZPlusList();
					} break;
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				push_value(v6);
				mw_std_list_List_1_uncons();
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				push_value(v14);
				push_value(v15);
			}
			VAL v16 = pop_value();
			decref(v16);
			VAL v17 = pop_value();
			decref(v17);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			uint64_t v18 = (0LL /* Nil */);
			push_u64(v18);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			push_value(v19);
			push_value(v20);
			while(1) {
				VAL v21 = pop_value();
				incref(v21);
				push_value(v21);
				push_value(v21);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v22 = pop_value();
				if (!VBOOL(v22)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				VAL r25 = pop_resource();
				push_value(v23);
				mw_mirth_token_Token_nameZAsk();
				push_resource(r25);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mtp_std_list_ZPlusList_1_ZPlusList();
						mtw_std_list_List_1_Cons();
						mtw_std_list_ZPlusList_1_ZPlusList();
					} break;
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				push_value(v24);
				mw_std_list_List_1_uncons();
				VAL v26 = pop_value();
				VAL v27 = pop_value();
				push_value(v26);
				push_value(v27);
			}
			VAL v28 = pop_value();
			decref(v28);
			VAL v29 = pop_value();
			decref(v29);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			uint64_t v30 = (0LL /* Nil */);
			push_u64(v30);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			push_value(v31);
			push_value(v32);
			while(1) {
				VAL v33 = pop_value();
				incref(v33);
				push_value(v33);
				push_value(v33);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v34 = pop_value();
				if (!VBOOL(v34)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v35 = pop_value();
				VAL v36 = pop_value();
				VAL r37 = pop_resource();
				incref(v35);
				incref(v35);
				push_value(v35);
				mw_mirth_name_Name_couldZ_beZ_resourceZ_var();
				VAL v38 = pop_value();
				push_value(v35);
				if (VBOOL(v38)) {
					VAL v39 = pop_value();
					decref(v39);
					uint64_t v40 = (1LL /* True */);
					push_u64(v40);
				} else {
					mw_mirth_name_Name_couldZ_beZ_resourceZ_con();
				}
				VAL v41 = pop_value();
				push_value(v35);
				if (VBOOL(v41)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v42 = pop_value();
					decref(v42);
					uint64_t v43 = (0LL /* None */);
					push_u64(v43);
				}
				push_resource(r37);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mtp_std_list_ZPlusList_1_ZPlusList();
						mtw_std_list_List_1_Cons();
						mtw_std_list_ZPlusList_1_ZPlusList();
					} break;
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				push_value(v36);
				mw_std_list_List_1_uncons();
				VAL v44 = pop_value();
				VAL v45 = pop_value();
				push_value(v44);
				push_value(v45);
			}
			VAL v46 = pop_value();
			decref(v46);
			VAL v47 = pop_value();
			decref(v47);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			mw_std_list_List_1_len();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			int64_t v48 = (0LL);
			push_i64(v48);
			mw_std_prim_Int_ZToNat();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_data_Tag_numZ_labelZ_inputs (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Tag_ZTildenumZ_labelZ_inputs();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Tag_labelZ_inputs();
		mw_std_list_List_1_len();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_data_Tag_numZ_totalZ_inputs (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_tag, v0);
	mw_mirth_data_Tag_numZ_labelZ_inputs();
	VAL v1 = (lpop(&lbl_tag));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tag, v1);
	mw_mirth_data_Tag_numZ_typeZ_inputs();
	VAL v2 = pop_value();
	push_value(v2);
	mp_primZ_intZ_add();
	VAL v3 = (lpop(&lbl_tag));
	push_value(v3);
	mw_mirth_data_Tag_numZ_resourceZ_inputs();
	VAL v4 = pop_value();
	push_value(v4);
	mp_primZ_intZ_add();
}
static void mw_mirth_data_Tag_isZ_transparentZAsk (void) {
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_isZ_transparentZAsk();
}
static void mw_mirth_data_Tag_isZ_semiZ_transparentZAsk (void) {
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_isZ_semiZ_transparentZAsk();
}
static void mw_mirth_data_Tag_outputsZ_resourceZAsk (void) {
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_isZ_resourceZAsk();
}
static void mw_mirth_data_Tag_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_data_Tag_index();
	push_value(v0);
	mw_mirth_data_Tag_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_data_Tag_preferZ_inlineZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_isZ_transparentZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		uint64_t v2 = (1LL /* True */);
		push_u64(v2);
	} else {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_data_Tag_numZ_totalZ_inputs();
		int64_t v4 = (0LL);
		VAL v5 = pop_value();
		bool v6 = (VI64(v5) == v4);
		push_bool(v6);
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
}
static void mw_mirth_data_DataPartial_ZEqualZEqual (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DataPartial
			mtp_mirth_data_DataPartial_DataPartial();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // DataPartial
			mtp_mirth_data_DataPartial_DataPartial();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_data));
	VAL v1 = (lpop(&lbl_data));
	push_value(v0);
	push_value(v1);
	mw_mirth_data_Data_ZEqualZEqual();
	VAL v2 = (lpop(&lbl_field));
	VAL v3 = (lpop(&lbl_field));
	push_value(v2);
	push_value(v3);
	mw_mirth_label_Label_ZEqualZEqual();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
	} else {
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (0LL /* False */);
		push_u64(v6);
	}
}
static void mw_mirth_match_Match_thaw (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Match
			mtp_mirth_match_Match_Match();
			mtw_mirth_match_ZPlusMatch_ZPlusMatch();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_ZPlusMatch_freezze (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Match
			mtp_mirth_match_ZPlusMatch_ZPlusMatch();
			mtw_mirth_match_Match_Match();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_Match_isZ_exhaustiveZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_match_Match_hasZ_defaultZ_caseZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		uint64_t v2 = (1LL /* True */);
		push_u64(v2);
	} else {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_match_Match_scrutineeZ_dataZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mw_mirth_data_Data_numZ_tags();
				VAL v4 = pop_value();
				VAL v5 = pop_value();
				incref(v5);
				push_value(v5);
				push_value(v4);
				push_value(v5);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[7];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_std_list_List_1_len();
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				bool v8 = (VI64(v7) == VI64(v6));
				push_bool(v8);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				VAL v9 = pop_value();
				incref(v9);
				push_value(v9);
				push_value(v9);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[7];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_std_list_List_1_len();
				int64_t v10 = (0LL);
				VAL v11 = pop_value();
				bool v12 = (v10 < VI64(v11));
				push_bool(v12);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	decref(v14);
	push_value(v13);
}
static void mw_mirth_match_Match_hasZ_defaultZ_caseZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* None */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_match_Case_isZ_defaultZ_caseZAsk();
		VAL v9 = pop_value();
		push_value(v6);
		if (VBOOL(v9)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (0LL /* None */);
			push_u64(v11);
		}
		VAL v12 = pop_value();
		push_value(v8);
		push_value(v7);
		push_value(v12);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				decref(v14);
				VAL v15 = pop_value();
				decref(v15);
				uint64_t v16 = (0LL /* Nil */);
				push_value(v13);
				push_u64(v16);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		push_value(v17);
		push_value(v18);
	}
	VAL v19 = pop_value();
	decref(v19);
	VAL v20 = pop_value();
	decref(v20);
	mw_std_maybe_Maybe_1_someZAsk();
}
static void mw_mirth_match_Match_scrutineeZ_dataZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		incref(v5);
		push_value(v5);
		mw_mirth_match_Case_isZ_defaultZ_caseZAsk();
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			uint64_t v9 = (0LL /* False */);
			push_u64(v9);
		} else {
			uint64_t v10 = (1LL /* True */);
			push_u64(v10);
		}
		VAL v11 = pop_value();
		push_value(v5);
		if (VBOOL(v11)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (0LL /* None */);
			push_u64(v13);
		}
		push_resource(r7);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v14);
		push_value(v15);
	}
	VAL v16 = pop_value();
	decref(v16);
	VAL v17 = pop_value();
	decref(v17);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v18 = pop_value();
	incref(v18);
	push_value(v18);
	push_value(v18);
	mw_std_list_List_1_first();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_match_Pattern_singleZ_tagZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v19 = (0LL /* None */);
			push_u64(v19);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_data_Tag_data();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v20 = (0LL /* None */);
			push_u64(v20);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			uint64_t v23 = (0LL /* None */);
			push_value(v21);
			push_u64(v23);
			push_value(v22);
			mw_std_list_List_1_uncons();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
			while(1) {
				VAL v26 = pop_value();
				incref(v26);
				push_value(v26);
				push_value(v26);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v27 = pop_value();
				if (!VBOOL(v27)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v28 = pop_value();
				VAL v29 = pop_value();
				VAL v30 = pop_value();
				incref(v28);
				push_value(v28);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_match_Pattern_singleZ_tagZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v31 = pop_value();
						VAL v32 = pop_value();
						incref(v32);
						push_value(v32);
						push_value(v32);
						push_value(v31);
						mw_mirth_data_Tag_data();
						mw_mirth_data_Data_ZEqualZEqual();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						uint64_t v33 = (0LL /* False */);
						push_u64(v33);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				VAL v34 = pop_value();
				if (VBOOL(v34)) {
					uint64_t v35 = (0LL /* False */);
					push_u64(v35);
				} else {
					uint64_t v36 = (1LL /* True */);
					push_u64(v36);
				}
				VAL v37 = pop_value();
				push_value(v28);
				if (VBOOL(v37)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v38 = pop_value();
					decref(v38);
					uint64_t v39 = (0LL /* None */);
					push_u64(v39);
				}
				VAL v40 = pop_value();
				push_value(v30);
				push_value(v29);
				push_value(v40);
				switch (get_top_data_tag()) {
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						VAL v41 = pop_value();
						VAL v42 = pop_value();
						decref(v42);
						VAL v43 = pop_value();
						decref(v43);
						uint64_t v44 = (0LL /* Nil */);
						push_value(v41);
						push_u64(v44);
					} break;
				}
				mw_std_list_List_1_uncons();
				VAL v45 = pop_value();
				VAL v46 = pop_value();
				push_value(v45);
				push_value(v46);
			}
			VAL v47 = pop_value();
			decref(v47);
			VAL v48 = pop_value();
			decref(v48);
			mw_std_maybe_Maybe_1_noneZAsk();
			VAL v49 = pop_value();
			if (VBOOL(v49)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v50 = pop_value();
				decref(v50);
				uint64_t v51 = (0LL /* None */);
				push_u64(v51);
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v52 = pop_value();
			decref(v52);
			uint64_t v53 = (0LL /* None */);
			push_u64(v53);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_Match_isZ_transparentZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZDivL1();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 10, v);
				VAL* p = &VTUP(v)->cells[9];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_std_list_List_1_ZDivL1();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 8, v);
				VAL* p = &VTUP(v)->cells[7];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			switch (get_top_data_tag()) {
				case 1LL: { // PatOpTag
					mtp_mirth_match_PatternOp_PatOpTag();
					mw_mirth_data_Tag_data();
					mw_mirth_data_Data_isZ_transparentZAsk();
				} break;
				case 0LL: { // PatOpUnderscore
					(void)pop_u64();
					uint64_t v1 = (1LL /* True */);
					push_u64(v1);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_Match_semiZ_transparentZ_tagZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZDivL1();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 10, v);
				VAL* p = &VTUP(v)->cells[9];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_std_list_List_1_ZDivL1();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 8, v);
				VAL* p = &VTUP(v)->cells[7];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			switch (get_top_data_tag()) {
				case 1LL: { // PatOpTag
					mtp_mirth_match_PatternOp_PatOpTag();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				default: {
					VAL v1 = pop_value();
					decref(v1);
					uint64_t v2 = (0LL /* None */);
					push_u64(v2);
				} break;
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v3 = (0LL /* None */);
			push_u64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			mw_mirth_data_Tag_data();
			mw_mirth_data_Data_isZ_semiZ_transparentZAsk();
			VAL v5 = pop_value();
			push_value(v4);
			if (VBOOL(v5)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v6 = pop_value();
				decref(v6);
				uint64_t v7 = (0LL /* None */);
				push_u64(v7);
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v8 = (0LL /* None */);
			push_u64(v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_ZPlusMatch_addZ_case (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 10, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		STRLIT("Case is unreachable.", 20);
		VAL r2 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		push_resource(r2);
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[7];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r3 = pop_resource();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		uint64_t v6 = (0LL /* Nil */);
		push_value(v4);
		push_value(v5);
		push_u64(v6);
		mtw_std_list_List_1_Cons();
		mw_std_list_List_1_cat();
		push_resource(r3);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[7];
			VAL t = *p; *p = u; decref(t);
		}
	}
}
static void mw_mirth_match_ZPlusMatch_caseZ_redundantZAsk (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* None */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v6);
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_value(v6);
		mw_mirth_match_Case_coversZAsk();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v6);
		if (VBOOL(v10)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* None */);
			push_u64(v12);
		}
		VAL v13 = pop_value();
		push_value(v8);
		push_value(v7);
		push_value(v13);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				decref(v15);
				VAL v16 = pop_value();
				decref(v16);
				uint64_t v17 = (0LL /* Nil */);
				push_value(v14);
				push_u64(v17);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	decref(v23);
	push_value(v22);
	mw_std_maybe_Maybe_1_someZAsk();
}
static void mw_mirth_match_Case_coversZAsk (void) {
	VAL v0 = pop_value();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_match_Pattern_coversZAsk();
}
static void mw_mirth_match_Case_isZ_defaultZ_caseZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_match_Pattern_isZ_defaultZAsk();
}
static void mw_mirth_match_Pattern_dom (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		push_value(v5);
		mtw_mirth_type_StackType_STCons();
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
	}
	VAL v9 = pop_value();
	decref(v9);
	VAL v10 = pop_value();
	decref(v10);
}
static void mw_mirth_match_Pattern_thaw (void) {
	VAL v0 = pop_value();
	lpush(&lbl_pattern, v0);
	mtw_mirth_match_ZPlusPattern_ZPlusPattern();
}
static void mw_mirth_match_Pattern_singleZ_tagZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZDivL1();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 8, v);
				VAL* p = &VTUP(v)->cells[7];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_match_PatternOp_ZDivPatOpTag();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_Pattern_isZ_defaultZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* None */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v6);
		push_value(v6);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[7];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_match_PatternOp_ZDivPatOpUnderscore();
		VAL v9 = pop_value();
		if (VBOOL(v9)) {
			uint64_t v10 = (0LL /* False */);
			push_u64(v10);
		} else {
			uint64_t v11 = (1LL /* True */);
			push_u64(v11);
		}
		VAL v12 = pop_value();
		push_value(v6);
		if (VBOOL(v12)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v13 = pop_value();
			decref(v13);
			uint64_t v14 = (0LL /* None */);
			push_u64(v14);
		}
		VAL v15 = pop_value();
		push_value(v8);
		push_value(v7);
		push_value(v15);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v16 = pop_value();
				VAL v17 = pop_value();
				decref(v17);
				VAL v18 = pop_value();
				decref(v18);
				uint64_t v19 = (0LL /* Nil */);
				push_value(v16);
				push_u64(v19);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		push_value(v20);
		push_value(v21);
	}
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	decref(v23);
	mw_std_maybe_Maybe_1_noneZAsk();
}
static void mw_mirth_match_ZPlusPattern_freezze (void) {
	mtp_mirth_match_ZPlusPattern_ZPlusPattern();
	VAL v0 = (lpop(&lbl_pattern));
	push_value(v0);
}
static void mw_mirth_match_ZPlusPattern_opZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // PatOpUnderscore
			(void)pop_u64();
			mw_mirth_match_ZPlusPattern_underscoreZBang();
		} break;
		case 1LL: { // PatOpTag
			mtp_mirth_match_PatternOp_PatOpTag();
			mw_mirth_match_ZPlusPattern_tagZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_ZPlusPattern_underscoreZBang (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	lpush(&lbl_token, v0);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v1 = pop_value();
	lpush(&lbl_ctx, v1);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	uint64_t v3 = (0LL /* SUBST_NIL */);
	uint64_t v4 = (0LL /* PatOpUnderscore */);
	lpush(&lbl_cod, v2);
	lpush(&lbl_subst, MKU64(v3));
	lpush(&lbl_op, MKU64(v4));
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_type_StackType_forceZ_consZAskZBang();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			{
				VAL v = top_resource();
				incref(v);
				push_value(v);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 10, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			STRLIT("pattern expects something on stack", 34);
			VAL r5 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
			uint64_t v6 = (0LL /* STACK_TYPE_ERROR */);
			uint64_t v7 = (0LL /* TYPE_ERROR */);
			push_resource(r5);
			push_u64(v6);
			push_u64(v7);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mp_primZ_packZ_uncons();
			VAL v8 = pop_value();
			mp_primZ_packZ_uncons();
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			decref(v10);
			push_value(v9);
			push_value(v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v11 = pop_value();
	incref(v11);
	push_value(v11);
	push_value(v11);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r12 = pop_resource();
	VAL v13 = pop_value();
	incref(v13);
	push_value(v13);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_std_list_List_1_Cons();
	push_value(v13);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[6];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(10);
			tup->size = 10;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = u;
			tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
			tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
			tup->cells[9] = VTUP(v)->cells[9]; incref(tup->cells[9]);
			decref(v);
			push_value(MKTUP(tup,10));
		}
	}
	push_resource(r12);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
	uint64_t v14 = (0LL /* Nil */);
	push_u64(v14);
	mtw_std_list_List_1_Cons();
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	incref(v16);
	lpush(&lbl_saved, v15);
	push_value(v16);
	lpush(&lbl_dom, v16);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r17 = pop_resource();
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[7];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(10);
			tup->size = 10;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = u;
			tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
			tup->cells[9] = VTUP(v)->cells[9]; incref(tup->cells[9]);
			decref(v);
			push_value(MKTUP(tup,10));
		}
	}
	push_resource(r17);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
	mtw_mirth_match_PatternAtom_PATATOM();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r18 = pop_resource();
	VAL v19 = pop_value();
	incref(v19);
	push_value(v19);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_std_list_List_1_Cons();
	push_value(v19);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[9];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(10);
			tup->size = 10;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
			tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
			tup->cells[9] = u;
			decref(v);
			push_value(MKTUP(tup,10));
		}
	}
	push_resource(r18);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
}
static void mw_mirth_match_ZPlusPattern_tagZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mtw_mirth_match_PatternOp_PatOpTag();
	VAL v1 = pop_value();
	uint64_t v2 = (0LL /* Nil */);
	lpush(&lbl_op, v1);
	lpush(&lbl_saved, MKU64(v2));
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v3 = pop_value();
	lpush(&lbl_token, v3);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	uint64_t v6 = (0LL /* SUBST_NIL */);
	VAL r7 = pop_resource();
	lpush(&lbl_ctx, v4);
	push_u64(v6);
	push_value(v5);
	mw_mirth_data_Tag_type();
	push_resource(r7);
	mw_mirth_type_ArrowType_freshenZ_sig();
	mw_mirth_type_ArrowType_unpack();
	VAL v8 = pop_value();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v8);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v9 = pop_value();
	lpush(&lbl_token, v9);
	mtw_mirth_type_ZPlusGamma_ZPlusGamma();
	VAL r10 = pop_resource();
	VAL r11 = pop_resource();
	push_resource(r10);
	mw_mirth_type_StackType_unifyZBang();
	VAL r12 = pop_resource();
	push_resource(r11);
	push_resource(r12);
	mw_mirth_type_ZPlusGamma_rdrop();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	incref(v14);
	lpush(&lbl_cod, v13);
	push_value(v14);
	lpush(&lbl_dom, v14);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r15 = pop_resource();
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[7];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(10);
			tup->size = 10;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = u;
			tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
			tup->cells[9] = VTUP(v)->cells[9]; incref(tup->cells[9]);
			decref(v);
			push_value(MKTUP(tup,10));
		}
	}
	push_resource(r15);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
	VAL v16 = pop_value();
	lpush(&lbl_subst, v16);
	mtw_mirth_match_PatternAtom_PATATOM();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r17 = pop_resource();
	VAL v18 = pop_value();
	incref(v18);
	push_value(v18);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mtw_std_list_List_1_Cons();
	push_value(v18);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[9];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(10);
			tup->size = 10;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
			tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
			tup->cells[9] = u;
			decref(v);
			push_value(MKTUP(tup,10));
		}
	}
	push_resource(r17);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
}
static void mw_mirth_match_Pattern_coversZAsk (void) {
	VAL v0 = pop_value();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZDivL1();
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZDivL1();
	mw_std_maybe_Maybe_1_zzip();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mp_primZ_packZ_uncons();
			VAL v2 = pop_value();
			mp_primZ_packZ_uncons();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			decref(v4);
			push_value(v3);
			push_value(v2);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 8, v);
				VAL* p = &VTUP(v)->cells[7];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			switch (get_top_data_tag()) {
				case 0LL: { // PatOpUnderscore
					(void)pop_u64();
					VAL v5 = pop_value();
					decref(v5);
					uint64_t v6 = (1LL /* True */);
					push_u64(v6);
				} break;
				case 1LL: { // PatOpTag
					mtp_mirth_match_PatternOp_PatOpTag();
					VAL v7 = pop_value();
					VAL v8 = pop_value();
					push_value(v7);
					push_value(v8);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 8, v);
						VAL* p = &VTUP(v)->cells[7];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					switch (get_top_data_tag()) {
						case 0LL: { // PatOpUnderscore
							(void)pop_u64();
							VAL v9 = pop_value();
							decref(v9);
							uint64_t v10 = (0LL /* False */);
							push_u64(v10);
						} break;
						case 1LL: { // PatOpTag
							mtp_mirth_match_PatternOp_PatOpTag();
							mw_mirth_data_Tag_ZEqualZEqual();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_PatternOp_ZDivPatOpTag (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // PatOpTag
			mtp_mirth_match_PatternOp_PatOpTag();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_match_PatternOp_ZDivPatOpUnderscore (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // PatOpUnderscore
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_external_External_index (void) {
}
static void mw_mirth_external_External_allocZBang (void) {
	mbuf_mirth_external_External_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_external_External_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_external_External_qnameZ_soft (void) {
	mfld_mirth_external_External_ZTildeqname();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_mirth_Prop_1_readyZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_external_External_qnameZ_hard (void) {
	mfld_mirth_external_External_ZTildeqname();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_external_External_name (void) {
	mfld_mirth_external_External_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_external_External_arity (void) {
	mfld_mirth_external_External_ZTildearity();
	mp_primZ_mutZ_get();
}
static void mw_mirth_external_External_symbol (void) {
	mfld_mirth_external_External_ZTildesymbol();
	mp_primZ_mutZ_get();
}
static void mw_mirth_external_External_head (void) {
	mfld_mirth_external_External_ZTildehead();
	mp_primZ_mutZ_get();
}
static void mw_mirth_external_External_sig (void) {
	mfld_mirth_external_External_ZTildesig();
	mp_primZ_mutZ_get();
}
static void mw_mirth_external_External_ctxZ_type (void) {
	mfld_mirth_external_External_ZTildectxZ_type();
	mw_mirth_mirth_Prop_1_forceZBang();
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	decref(v2);
	push_value(v1);
	push_value(v0);
}
static void mw_mirth_external_External_type (void) {
	mw_mirth_external_External_ctxZ_type();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	push_value(v0);
}
static void mw_mirth_external_External_ctype (void) {
	mfld_mirth_external_External_ZTildectype();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_external_External_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_external_External_index();
	push_value(v0);
	mw_mirth_external_External_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_external_ExternalBlock_allocZBang (void) {
	mbuf_mirth_external_ExternalBlock_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_external_ExternalBlock_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_external_ExternalBlock_parts (void) {
	mfld_mirth_external_ExternalBlock_ZTildeparts();
	mp_primZ_mutZ_get();
}
static void mw_mirth_variable_Variable_index (void) {
}
static void mw_mirth_variable_Variable_allocZBang (void) {
	mbuf_mirth_variable_Variable_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_variable_Variable_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_variable_Variable_qname (void) {
	mfld_mirth_variable_Variable_ZTildeqname();
	mp_primZ_mutZ_get();
}
static void mw_mirth_variable_Variable_name (void) {
	mw_mirth_variable_Variable_qname();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_variable_Variable_type (void) {
	mfld_mirth_variable_Variable_ZTildetype();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_variable_Variable_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_variable_Variable_index();
	push_value(v0);
	mw_mirth_variable_Variable_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_variable_Variable_newZBang (void) {
	mw_mirth_variable_Variable_allocZBang();
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mfld_mirth_variable_Variable_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	push_value(v2);
	mfld_mirth_variable_Variable_ZTildehead();
	mp_primZ_mutZ_set();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mtw_mirth_def_Def_DefVariable();
	mw_mirth_def_Def_register();
}
static void mw_mirth_arrow_Block_index (void) {
}
static void mw_mirth_arrow_Block_allocZBang (void) {
	mbuf_mirth_arrow_Block_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_arrow_Block_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_arrow_Arrow_ctxZ_type (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v0);
	mw_mirth_arrow_Arrow_type();
}
static void mw_mirth_arrow_Arrow_type (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_type_TZ_ZTo();
}
static void mw_mirth_arrow_Lambda_cod (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_arrow_Block_ctx (void) {
	mfld_mirth_arrow_Block_ZTildectx();
	mp_primZ_mutZ_get();
}
static void mw_mirth_arrow_Block_token (void) {
	mfld_mirth_arrow_Block_ZTildetoken();
	mp_primZ_mutZ_get();
}
static void mw_mirth_arrow_Block_dom (void) {
	mfld_mirth_arrow_Block_ZTildedom();
	mp_primZ_mutZ_get();
}
static void mw_mirth_arrow_Block_cod (void) {
	mfld_mirth_arrow_Block_ZTildecod();
	mp_primZ_mutZ_get();
}
static void mw_mirth_arrow_Block_home (void) {
	mfld_mirth_arrow_Block_ZTildehome();
	mp_primZ_mutZ_get();
}
static void mw_mirth_arrow_Block_type (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_arrow_Block_dom();
	push_value(v0);
	mw_mirth_arrow_Block_cod();
	mw_mirth_type_TZ_ZTo();
}
static void mw_mirth_arrow_Block_arrow (void) {
	mfld_mirth_arrow_Block_ZTildearrow();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_arrow_Block_qname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_arrow_Block_ZTildeqname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		incref(v4);
		push_value(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_arrow_Block_home();
		switch (get_top_data_tag()) {
			case 0LL: { // HomeMain
				mtp_mirth_arrow_Home_HomeMain();
				mw_mirth_token_Token_module();
				mtw_mirth_name_Namespace_NAMESPACEz_MODULE();
				VAL v5 = pop_value();
				VAL v6 = pop_value();
				push_value(v5);
				push_value(v6);
				mw_mirth_arrow_Block_arrow();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_token_Token_index();
				mp_primZ_intZ_toZ_str();
				VAL v7 = pop_value();
				STRLIT("entry@", 6);
				push_value(v7);
				mp_primZ_strZ_cat();
				mw_std_prim_Str_ZToName();
				mw_mirth_name_QNAME0();
			} break;
			case 1LL: { // HomeWord
				mtp_mirth_arrow_Home_HomeWord();
				VAL v8 = pop_value();
				incref(v8);
				push_value(v8);
				push_value(v8);
				mtw_mirth_name_Namespace_NAMESPACEz_WORD();
				VAL v9 = pop_value();
				VAL v10 = pop_value();
				mw_mirth_arrow_Block_arrow();
				push_value(v10);
				mw_mirth_word_Word_arrow();
				VAL v11 = pop_value();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_token_Token_index();
				push_value(v11);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_token_Token_index();
				mp_primZ_intZ_sub();
				mp_primZ_intZ_toZ_str();
				mw_std_prim_Str_ZToName();
				VAL v12 = pop_value();
				push_value(v9);
				push_value(v12);
				mw_mirth_name_QNAME0();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v13);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	decref(v15);
	push_value(v14);
}
static void mw_mirth_arrow_Block_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_arrow_Block_index();
	push_value(v0);
	mw_mirth_arrow_Block_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_arrow_Block_registerZ_homeZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_arrow_Block_home();
	switch (get_top_data_tag()) {
		case 1LL: { // HomeWord
			mtp_mirth_arrow_Home_HomeWord();
			mw_mirth_word_Word_incZ_numZ_blocksZBang();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			mfld_mirth_arrow_Block_ZTildehomeZ_index();
			mp_primZ_mutZ_set();
		} break;
		case 0LL: { // HomeMain
			mtp_mirth_arrow_Home_HomeMain();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = pop_value();
			decref(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_arrow_Block_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_arrow_Block_ZTildecname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_arrow_Block_home();
		switch (get_top_data_tag()) {
			case 1LL: { // HomeWord
				mtp_mirth_arrow_Home_HomeWord();
				mw_mirth_word_Word_qnameZ_hard();
				mw_mirth_name_QName_mangled();
				STRLIT("", 0);
				mtw_std_str_ZPlusStr_ZPlusStr();
				STRLIT("mb_", 3);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				mw_std_str_ZPlusStr_pushZ_strZBang();
				STRLIT("_", 1);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				VAL v5 = pop_value();
				incref(v5);
				push_value(v5);
				push_value(v5);
				mfld_mirth_arrow_Block_ZTildehomeZ_index();
				mp_primZ_mutZ_get();
				mp_primZ_intZ_toZ_str();
				mw_std_str_ZPlusStr_pushZ_strZBang();
				mtp_std_str_ZPlusStr_ZPlusStr();
			} break;
			case 0LL: { // HomeMain
				mtp_mirth_arrow_Home_HomeMain();
				VAL v6 = pop_value();
				decref(v6);
				STRLIT("", 0);
				mtw_std_str_ZPlusStr_ZPlusStr();
				STRLIT("mb_", 3);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				VAL v7 = pop_value();
				incref(v7);
				push_value(v7);
				push_value(v7);
				mw_mirth_arrow_Block_index();
				mp_primZ_intZ_toZ_str();
				mw_std_str_ZPlusStr_pushZ_strZBang();
				mtp_std_str_ZPlusStr_ZPlusStr();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	decref(v10);
	push_value(v9);
}
static void mw_mirth_arrow_Block_newZBang (void) {
	mw_mirth_arrow_Block_allocZBang();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mfld_mirth_arrow_Block_ZTildehome();
	mp_primZ_mutZ_set();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mw_mirth_arrow_Block_registerZ_homeZBang();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	incref(v6);
	push_value(v6);
	push_value(v5);
	push_value(v6);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	incref(v8);
	push_value(v8);
	push_value(v7);
	push_value(v8);
	mfld_mirth_arrow_Block_ZTildectx();
	mp_primZ_mutZ_set();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	push_value(v9);
	push_value(v10);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	incref(v12);
	push_value(v12);
	push_value(v11);
	push_value(v12);
	mfld_mirth_arrow_Block_ZTildetoken();
	mp_primZ_mutZ_set();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	incref(v14);
	push_value(v14);
	push_value(v13);
	push_value(v14);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	incref(v16);
	push_value(v16);
	push_value(v15);
	push_value(v16);
	mfld_mirth_arrow_Block_ZTildedom();
	mp_primZ_mutZ_set();
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	incref(v18);
	push_value(v18);
	push_value(v17);
	push_value(v18);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v19 = pop_value();
	VAL v20 = pop_value();
	incref(v20);
	push_value(v20);
	push_value(v19);
	push_value(v20);
	mfld_mirth_arrow_Block_ZTildecod();
	mp_primZ_mutZ_set();
	VAL v21 = pop_value();
	incref(v21);
	VAL v22 = pop_value();
	incref(v21);
	push_value(v21);
	push_value(v22);
	push_value(v21);
	mtw_mirth_mirth_PropLabel_BlockArrow();
	mw_mirth_mirth_PropLabel_prop();
	push_value(v21);
	mfld_mirth_arrow_Block_ZTildearrow();
	mp_primZ_mutZ_set();
}
static void mw_mirth_arrow_Block_newZ_deferredZBang_1 (void) {
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		mw_mirth_arrow_Block_allocZBang();
		VAL v1 = pop_value();
		incref(v1);
		VAL v2 = pop_value();
		push_value(v1);
		push_value(v2);
		push_value(v1);
		mfld_mirth_arrow_Block_ZTildehome();
		mp_primZ_mutZ_set();
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_arrow_Block_registerZ_homeZBang();
		VAL v4 = pop_value();
		incref(v4);
		VAL v5 = pop_value();
		push_value(v4);
		push_value(v5);
		push_value(v4);
		mfld_mirth_arrow_Block_ZTildetoken();
		mp_primZ_mutZ_set();
		VAL v6 = pop_value();
		incref(v6);
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
		push_value(v6);
		mfld_mirth_arrow_Block_ZTildectx();
		mp_primZ_mutZ_set();
		mw_mirth_type_MetaVar_newZBang();
		mtw_mirth_type_StackType_STMeta();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_value(v8);
		push_value(v9);
		mfld_mirth_arrow_Block_ZTildedom();
		mp_primZ_mutZ_set();
		mw_mirth_type_MetaVar_newZBang();
		mtw_mirth_type_StackType_STMeta();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		push_value(v10);
		push_value(v11);
		mfld_mirth_arrow_Block_ZTildecod();
		mp_primZ_mutZ_set();
		VAL v12 = pop_value();
		incref(v12);
		incref(v12);
		push_value(v12);
		push_value(v12);
		push_value(v12);
		mtw_mirth_mirth_PropLabel_BlockArrow();
		incref(var_f);
		VAL v13 = (var_f);
		push_value(v13);
		mw_mirth_mirth_PropLabel_prop_1();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		incref(v15);
		push_value(v15);
		push_value(v14);
		push_value(v15);
		mfld_mirth_arrow_Block_ZTildearrow();
		mp_primZ_mutZ_set();
		decref(var_f);
	}
}
static void mw_mirth_arrow_Block_typecheckZBang (void) {
	mw_mirth_arrow_Block_arrow();
	VAL v0 = pop_value();
	decref(v0);
}
static void mw_mirth_arrow_blockZ_unifyZ_typeZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mw_mirth_arrow_Block_type();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v0);
	mw_mirth_type_ArrowType_unifyZBang();
	VAL v4 = pop_value();
	decref(v4);
	VAL r5 = pop_resource();
	push_value(v3);
	mw_mirth_arrow_Block_arrow();
	push_resource(r5);
	mw_mirth_arrow_Arrow_type();
}
static void mw_mirth_arrow_Block_toZ_runZ_var (void) {
	mw_mirth_arrow_Block_arrow();
	mw_mirth_arrow_Arrow_toZ_runZ_var();
}
static void mw_mirth_arrow_Arrow_toZ_runZ_var (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZDivL1();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_arrow_Atom_toZ_runZ_var();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_arrow_Atom_toZ_runZ_var (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_var_Var_autoZ_runZAsk();
			VAL v1 = pop_value();
			if (VBOOL(v1)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v2 = pop_value();
				decref(v2);
				uint64_t v3 = (0LL /* None */);
				push_u64(v3);
			}
		} break;
		default: {
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (0LL /* None */);
			push_u64(v5);
		} break;
	}
}
static void mw_mirth_arrow_Arg_ZToStr (void) {
	mw_mirth_arrow_Block_qname();
	mw_mirth_name_QName_ZToStr();
}
static void mw_mirth_arrow_Arg_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	push_value(v0);
	mw_mirth_arrow_Block_ZEqualZEqual();
}
static void mw_mirth_arrow_Block_freeZ_vars (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_arrow_Block_ZTildefreeZ_vars();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_arrow_Block_arrow();
		mw_mirth_arrow_Arrow_freeZ_vars();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_arrow_Arrow_freeZ_vars (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		push_value(v5);
		mw_mirth_arrow_Atom_freeZ_vars();
		push_resource(r7);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_std_list_ListZPlus_1_uncons();
			mw_std_list_List_1_uncons();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			push_value(v12);
			push_value(v13);
			while(1) {
				VAL v14 = pop_value();
				incref(v14);
				push_value(v14);
				push_value(v14);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v15 = pop_value();
				if (!VBOOL(v15)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v16 = pop_value();
				VAL v17 = pop_value();
				VAL v18 = pop_value();
				incref(v18);
				uint64_t v19 = (0LL /* Nil */);
				push_value(v18);
				push_value(v16);
				push_u64(v19);
				mw_std_list_List_1_reverse();
				mtw_std_list_ZPlusList_1_ZPlusList();
				mw_std_list_List_1_uncons();
				VAL v20 = pop_value();
				VAL v21 = pop_value();
				push_value(v20);
				push_value(v21);
				while(1) {
					VAL v22 = pop_value();
					incref(v22);
					push_value(v22);
					push_value(v22);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v23 = pop_value();
					if (!VBOOL(v23)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					VAL r26 = pop_resource();
					incref(v24);
					VAL v27 = pop_value();
					incref(v27);
					uint64_t v28 = (0LL /* None */);
					push_value(v24);
					push_u64(v28);
					push_value(v27);
					mw_std_list_List_1_uncons();
					VAL v29 = pop_value();
					VAL v30 = pop_value();
					push_value(v29);
					push_value(v30);
					while(1) {
						VAL v31 = pop_value();
						incref(v31);
						push_value(v31);
						push_value(v31);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v32 = pop_value();
						if (!VBOOL(v32)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v33 = pop_value();
						VAL v34 = pop_value();
						VAL v35 = pop_value();
						incref(v33);
						VAL v36 = pop_value();
						incref(v36);
						push_value(v36);
						push_value(v33);
						mw_mirth_var_Var_ZEqualZEqual();
						VAL v37 = pop_value();
						push_value(v36);
						push_value(v33);
						if (VBOOL(v37)) {
							mtw_std_maybe_Maybe_1_Some();
						} else {
							VAL v38 = pop_value();
							decref(v38);
							uint64_t v39 = (0LL /* None */);
							push_u64(v39);
						}
						VAL v40 = pop_value();
						push_value(v35);
						push_value(v34);
						push_value(v40);
						switch (get_top_data_tag()) {
							case 0LL: { // None
								(void)pop_u64();
							} break;
							default: {
								VAL v41 = pop_value();
								VAL v42 = pop_value();
								decref(v42);
								VAL v43 = pop_value();
								decref(v43);
								uint64_t v44 = (0LL /* Nil */);
								push_value(v41);
								push_u64(v44);
							} break;
						}
						mw_std_list_List_1_uncons();
						VAL v45 = pop_value();
						VAL v46 = pop_value();
						push_value(v45);
						push_value(v46);
					}
					VAL v47 = pop_value();
					decref(v47);
					VAL v48 = pop_value();
					decref(v48);
					VAL v49 = pop_value();
					VAL v50 = pop_value();
					decref(v50);
					push_value(v49);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v51 = pop_value();
					if (VBOOL(v51)) {
						uint64_t v52 = (0LL /* False */);
						push_u64(v52);
					} else {
						uint64_t v53 = (1LL /* True */);
						push_u64(v53);
					}
					VAL v54 = pop_value();
					push_value(v27);
					push_value(v24);
					if (VBOOL(v54)) {
						mtw_std_maybe_Maybe_1_Some();
					} else {
						VAL v55 = pop_value();
						decref(v55);
						uint64_t v56 = (0LL /* None */);
						push_u64(v56);
					}
					push_resource(r26);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							mtp_std_list_ZPlusList_1_ZPlusList();
							mtw_std_list_List_1_Cons();
							mtw_std_list_ZPlusList_1_ZPlusList();
						} break;
						case 0LL: { // None
							(void)pop_u64();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					push_value(v25);
					mw_std_list_List_1_uncons();
					VAL v57 = pop_value();
					VAL v58 = pop_value();
					push_value(v57);
					push_value(v58);
				}
				VAL v59 = pop_value();
				decref(v59);
				VAL v60 = pop_value();
				decref(v60);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mw_std_list_List_1_reverse();
				VAL v61 = pop_value();
				VAL v62 = pop_value();
				decref(v62);
				push_value(v18);
				push_value(v61);
				mw_std_list_List_1_cat();
				push_value(v17);
				mw_std_list_List_1_uncons();
				VAL v63 = pop_value();
				VAL v64 = pop_value();
				push_value(v63);
				push_value(v64);
			}
			VAL v65 = pop_value();
			decref(v65);
			VAL v66 = pop_value();
			decref(v66);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v67 = (0LL /* None */);
			push_u64(v67);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v68 = (0LL /* Nil */);
			push_u64(v68);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_arrow_Atom_freeZ_vars (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v1 = (0LL /* Nil */);
	push_u64(v1);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		push_value(v6);
		mw_mirth_arrow_Arg_freeZ_vars();
		push_resource(r8);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_std_list_ListZPlus_1_uncons();
			mw_std_list_List_1_uncons();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			push_value(v13);
			push_value(v14);
			while(1) {
				VAL v15 = pop_value();
				incref(v15);
				push_value(v15);
				push_value(v15);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v16 = pop_value();
				if (!VBOOL(v16)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v17 = pop_value();
				VAL v18 = pop_value();
				VAL v19 = pop_value();
				incref(v19);
				uint64_t v20 = (0LL /* Nil */);
				push_value(v19);
				push_value(v17);
				push_u64(v20);
				mw_std_list_List_1_reverse();
				mtw_std_list_ZPlusList_1_ZPlusList();
				mw_std_list_List_1_uncons();
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				push_value(v21);
				push_value(v22);
				while(1) {
					VAL v23 = pop_value();
					incref(v23);
					push_value(v23);
					push_value(v23);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v24 = pop_value();
					if (!VBOOL(v24)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v25 = pop_value();
					VAL v26 = pop_value();
					VAL r27 = pop_resource();
					incref(v25);
					VAL v28 = pop_value();
					incref(v28);
					uint64_t v29 = (0LL /* None */);
					push_value(v25);
					push_u64(v29);
					push_value(v28);
					mw_std_list_List_1_uncons();
					VAL v30 = pop_value();
					VAL v31 = pop_value();
					push_value(v30);
					push_value(v31);
					while(1) {
						VAL v32 = pop_value();
						incref(v32);
						push_value(v32);
						push_value(v32);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v33 = pop_value();
						if (!VBOOL(v33)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v34 = pop_value();
						VAL v35 = pop_value();
						VAL v36 = pop_value();
						incref(v34);
						VAL v37 = pop_value();
						incref(v37);
						push_value(v37);
						push_value(v34);
						mw_mirth_var_Var_ZEqualZEqual();
						VAL v38 = pop_value();
						push_value(v37);
						push_value(v34);
						if (VBOOL(v38)) {
							mtw_std_maybe_Maybe_1_Some();
						} else {
							VAL v39 = pop_value();
							decref(v39);
							uint64_t v40 = (0LL /* None */);
							push_u64(v40);
						}
						VAL v41 = pop_value();
						push_value(v36);
						push_value(v35);
						push_value(v41);
						switch (get_top_data_tag()) {
							case 0LL: { // None
								(void)pop_u64();
							} break;
							default: {
								VAL v42 = pop_value();
								VAL v43 = pop_value();
								decref(v43);
								VAL v44 = pop_value();
								decref(v44);
								uint64_t v45 = (0LL /* Nil */);
								push_value(v42);
								push_u64(v45);
							} break;
						}
						mw_std_list_List_1_uncons();
						VAL v46 = pop_value();
						VAL v47 = pop_value();
						push_value(v46);
						push_value(v47);
					}
					VAL v48 = pop_value();
					decref(v48);
					VAL v49 = pop_value();
					decref(v49);
					VAL v50 = pop_value();
					VAL v51 = pop_value();
					decref(v51);
					push_value(v50);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v52 = pop_value();
					if (VBOOL(v52)) {
						uint64_t v53 = (0LL /* False */);
						push_u64(v53);
					} else {
						uint64_t v54 = (1LL /* True */);
						push_u64(v54);
					}
					VAL v55 = pop_value();
					push_value(v28);
					push_value(v25);
					if (VBOOL(v55)) {
						mtw_std_maybe_Maybe_1_Some();
					} else {
						VAL v56 = pop_value();
						decref(v56);
						uint64_t v57 = (0LL /* None */);
						push_u64(v57);
					}
					push_resource(r27);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							mtp_std_list_ZPlusList_1_ZPlusList();
							mtw_std_list_List_1_Cons();
							mtw_std_list_ZPlusList_1_ZPlusList();
						} break;
						case 0LL: { // None
							(void)pop_u64();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					push_value(v26);
					mw_std_list_List_1_uncons();
					VAL v58 = pop_value();
					VAL v59 = pop_value();
					push_value(v58);
					push_value(v59);
				}
				VAL v60 = pop_value();
				decref(v60);
				VAL v61 = pop_value();
				decref(v61);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mw_std_list_List_1_reverse();
				VAL v62 = pop_value();
				VAL v63 = pop_value();
				decref(v63);
				push_value(v19);
				push_value(v62);
				mw_std_list_List_1_cat();
				push_value(v18);
				mw_std_list_List_1_uncons();
				VAL v64 = pop_value();
				VAL v65 = pop_value();
				push_value(v64);
				push_value(v65);
			}
			VAL v66 = pop_value();
			decref(v66);
			VAL v67 = pop_value();
			decref(v67);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v68 = (0LL /* None */);
			push_u64(v68);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v69 = (0LL /* Nil */);
			push_u64(v69);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v70 = pop_value();
	VAL v71 = pop_value();
	push_value(v70);
	push_value(v71);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_arrow_Op_freeZ_vars();
	VAL v72 = pop_value();
	VAL v73 = pop_value();
	incref(v73);
	uint64_t v74 = (0LL /* Nil */);
	push_value(v73);
	push_value(v72);
	push_u64(v74);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v75 = pop_value();
	VAL v76 = pop_value();
	push_value(v75);
	push_value(v76);
	while(1) {
		VAL v77 = pop_value();
		incref(v77);
		push_value(v77);
		push_value(v77);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v78 = pop_value();
		if (!VBOOL(v78)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v79 = pop_value();
		VAL v80 = pop_value();
		VAL r81 = pop_resource();
		incref(v79);
		VAL v82 = pop_value();
		incref(v82);
		uint64_t v83 = (0LL /* None */);
		push_value(v79);
		push_u64(v83);
		push_value(v82);
		mw_std_list_List_1_uncons();
		VAL v84 = pop_value();
		VAL v85 = pop_value();
		push_value(v84);
		push_value(v85);
		while(1) {
			VAL v86 = pop_value();
			incref(v86);
			push_value(v86);
			push_value(v86);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v87 = pop_value();
			if (!VBOOL(v87)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v88 = pop_value();
			VAL v89 = pop_value();
			VAL v90 = pop_value();
			incref(v88);
			VAL v91 = pop_value();
			incref(v91);
			push_value(v91);
			push_value(v88);
			mw_mirth_var_Var_ZEqualZEqual();
			VAL v92 = pop_value();
			push_value(v91);
			push_value(v88);
			if (VBOOL(v92)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v93 = pop_value();
				decref(v93);
				uint64_t v94 = (0LL /* None */);
				push_u64(v94);
			}
			VAL v95 = pop_value();
			push_value(v90);
			push_value(v89);
			push_value(v95);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v96 = pop_value();
					VAL v97 = pop_value();
					decref(v97);
					VAL v98 = pop_value();
					decref(v98);
					uint64_t v99 = (0LL /* Nil */);
					push_value(v96);
					push_u64(v99);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v100 = pop_value();
			VAL v101 = pop_value();
			push_value(v100);
			push_value(v101);
		}
		VAL v102 = pop_value();
		decref(v102);
		VAL v103 = pop_value();
		decref(v103);
		VAL v104 = pop_value();
		VAL v105 = pop_value();
		decref(v105);
		push_value(v104);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v106 = pop_value();
		if (VBOOL(v106)) {
			uint64_t v107 = (0LL /* False */);
			push_u64(v107);
		} else {
			uint64_t v108 = (1LL /* True */);
			push_u64(v108);
		}
		VAL v109 = pop_value();
		push_value(v82);
		push_value(v79);
		if (VBOOL(v109)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v110 = pop_value();
			decref(v110);
			uint64_t v111 = (0LL /* None */);
			push_u64(v111);
		}
		push_resource(r81);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v80);
		mw_std_list_List_1_uncons();
		VAL v112 = pop_value();
		VAL v113 = pop_value();
		push_value(v112);
		push_value(v113);
	}
	VAL v114 = pop_value();
	decref(v114);
	VAL v115 = pop_value();
	decref(v115);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v116 = pop_value();
	VAL v117 = pop_value();
	decref(v117);
	push_value(v73);
	push_value(v116);
	mw_std_list_List_1_cat();
}
static void mw_mirth_arrow_Arg_freeZ_vars (void) {
	mw_mirth_arrow_Block_freeZ_vars();
}
static void mw_mirth_arrow_Op_freeZ_vars (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // OpNone
			(void)pop_u64();
			uint64_t v0 = (0LL /* Nil */);
			push_u64(v0);
		} break;
		case 1LL: { // OpPrim
			mtp_mirth_arrow_Op_OpPrim();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* Nil */);
			push_u64(v2);
		} break;
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* Nil */);
			push_u64(v4);
		} break;
		case 3LL: { // OpExternal
			mtp_mirth_arrow_Op_OpExternal();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* Nil */);
			push_u64(v6);
		} break;
		case 4LL: { // OpBuffer
			mtp_mirth_arrow_Op_OpBuffer();
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (0LL /* Nil */);
			push_u64(v8);
		} break;
		case 5LL: { // OpVariable
			mtp_mirth_arrow_Op_OpVariable();
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* Nil */);
			push_u64(v10);
		} break;
		case 6LL: { // OpField
			mtp_mirth_arrow_Op_OpField();
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* Nil */);
			push_u64(v12);
		} break;
		case 7LL: { // OpInt
			mtp_mirth_arrow_Op_OpInt();
			VAL v13 = pop_value();
			decref(v13);
			uint64_t v14 = (0LL /* Nil */);
			push_u64(v14);
		} break;
		case 8LL: { // OpF64
			mtp_mirth_arrow_Op_OpF64();
			VAL v15 = pop_value();
			decref(v15);
			uint64_t v16 = (0LL /* Nil */);
			push_u64(v16);
		} break;
		case 9LL: { // OpStr
			mtp_mirth_arrow_Op_OpStr();
			VAL v17 = pop_value();
			decref(v17);
			uint64_t v18 = (0LL /* Nil */);
			push_u64(v18);
		} break;
		case 10LL: { // OpTag
			mtp_mirth_arrow_Op_OpTag();
			VAL v19 = pop_value();
			decref(v19);
			uint64_t v20 = (0LL /* Nil */);
			push_u64(v20);
		} break;
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			mw_mirth_match_Match_freeZ_vars();
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			mw_mirth_arrow_Lambda_freeZ_vars();
		} break;
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			uint64_t v21 = (0LL /* Nil */);
			push_u64(v21);
			mtw_std_list_List_1_Cons();
		} break;
		case 14LL: { // OpBlockPush
			mtp_mirth_arrow_Op_OpBlockPush();
			mw_mirth_arrow_Block_freeZ_vars();
		} break;
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			mw_mirth_arrow_Block_freeZ_vars();
		} break;
		case 16LL: { // OpCoerce
			mtp_mirth_arrow_Op_OpCoerce();
			VAL v22 = pop_value();
			decref(v22);
			uint64_t v23 = (0LL /* Nil */);
			push_u64(v23);
		} break;
		case 17LL: { // OpLabelPush
			mtp_mirth_arrow_Op_OpLabelPush();
			VAL v24 = pop_value();
			decref(v24);
			uint64_t v25 = (0LL /* Nil */);
			push_u64(v25);
		} break;
		case 18LL: { // OpLabelPop
			mtp_mirth_arrow_Op_OpLabelPop();
			VAL v26 = pop_value();
			decref(v26);
			uint64_t v27 = (0LL /* Nil */);
			push_u64(v27);
		} break;
		case 19LL: { // OpLabelPushR
			mtp_mirth_arrow_Op_OpLabelPushR();
			VAL v28 = pop_value();
			decref(v28);
			uint64_t v29 = (0LL /* Nil */);
			push_u64(v29);
		} break;
		case 20LL: { // OpLabelPopR
			mtp_mirth_arrow_Op_OpLabelPopR();
			VAL v30 = pop_value();
			decref(v30);
			uint64_t v31 = (0LL /* Nil */);
			push_u64(v31);
		} break;
		case 21LL: { // OpDataGetTag
			mtp_mirth_arrow_Op_OpDataGetTag();
			VAL v32 = pop_value();
			decref(v32);
			uint64_t v33 = (0LL /* Nil */);
			push_u64(v33);
		} break;
		case 22LL: { // OpDataGetLabel
			mtp_mirth_arrow_Op_OpDataGetLabel();
			VAL v34 = pop_value();
			decref(v34);
			VAL v35 = pop_value();
			decref(v35);
			uint64_t v36 = (0LL /* Nil */);
			push_u64(v36);
		} break;
		case 23LL: { // OpDataSetLabel
			mtp_mirth_arrow_Op_OpDataSetLabel();
			VAL v37 = pop_value();
			decref(v37);
			VAL v38 = pop_value();
			decref(v38);
			uint64_t v39 = (0LL /* Nil */);
			push_u64(v39);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_Match_freeZ_vars (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		push_value(v5);
		mw_mirth_match_Case_freeZ_vars();
		push_resource(r7);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_std_list_ListZPlus_1_uncons();
			mw_std_list_List_1_uncons();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			push_value(v12);
			push_value(v13);
			while(1) {
				VAL v14 = pop_value();
				incref(v14);
				push_value(v14);
				push_value(v14);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v15 = pop_value();
				if (!VBOOL(v15)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v16 = pop_value();
				VAL v17 = pop_value();
				VAL v18 = pop_value();
				incref(v18);
				uint64_t v19 = (0LL /* Nil */);
				push_value(v18);
				push_value(v16);
				push_u64(v19);
				mw_std_list_List_1_reverse();
				mtw_std_list_ZPlusList_1_ZPlusList();
				mw_std_list_List_1_uncons();
				VAL v20 = pop_value();
				VAL v21 = pop_value();
				push_value(v20);
				push_value(v21);
				while(1) {
					VAL v22 = pop_value();
					incref(v22);
					push_value(v22);
					push_value(v22);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v23 = pop_value();
					if (!VBOOL(v23)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					VAL r26 = pop_resource();
					incref(v24);
					VAL v27 = pop_value();
					incref(v27);
					uint64_t v28 = (0LL /* None */);
					push_value(v24);
					push_u64(v28);
					push_value(v27);
					mw_std_list_List_1_uncons();
					VAL v29 = pop_value();
					VAL v30 = pop_value();
					push_value(v29);
					push_value(v30);
					while(1) {
						VAL v31 = pop_value();
						incref(v31);
						push_value(v31);
						push_value(v31);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v32 = pop_value();
						if (!VBOOL(v32)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v33 = pop_value();
						VAL v34 = pop_value();
						VAL v35 = pop_value();
						incref(v33);
						VAL v36 = pop_value();
						incref(v36);
						push_value(v36);
						push_value(v33);
						mw_mirth_var_Var_ZEqualZEqual();
						VAL v37 = pop_value();
						push_value(v36);
						push_value(v33);
						if (VBOOL(v37)) {
							mtw_std_maybe_Maybe_1_Some();
						} else {
							VAL v38 = pop_value();
							decref(v38);
							uint64_t v39 = (0LL /* None */);
							push_u64(v39);
						}
						VAL v40 = pop_value();
						push_value(v35);
						push_value(v34);
						push_value(v40);
						switch (get_top_data_tag()) {
							case 0LL: { // None
								(void)pop_u64();
							} break;
							default: {
								VAL v41 = pop_value();
								VAL v42 = pop_value();
								decref(v42);
								VAL v43 = pop_value();
								decref(v43);
								uint64_t v44 = (0LL /* Nil */);
								push_value(v41);
								push_u64(v44);
							} break;
						}
						mw_std_list_List_1_uncons();
						VAL v45 = pop_value();
						VAL v46 = pop_value();
						push_value(v45);
						push_value(v46);
					}
					VAL v47 = pop_value();
					decref(v47);
					VAL v48 = pop_value();
					decref(v48);
					VAL v49 = pop_value();
					VAL v50 = pop_value();
					decref(v50);
					push_value(v49);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v51 = pop_value();
					if (VBOOL(v51)) {
						uint64_t v52 = (0LL /* False */);
						push_u64(v52);
					} else {
						uint64_t v53 = (1LL /* True */);
						push_u64(v53);
					}
					VAL v54 = pop_value();
					push_value(v27);
					push_value(v24);
					if (VBOOL(v54)) {
						mtw_std_maybe_Maybe_1_Some();
					} else {
						VAL v55 = pop_value();
						decref(v55);
						uint64_t v56 = (0LL /* None */);
						push_u64(v56);
					}
					push_resource(r26);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							mtp_std_list_ZPlusList_1_ZPlusList();
							mtw_std_list_List_1_Cons();
							mtw_std_list_ZPlusList_1_ZPlusList();
						} break;
						case 0LL: { // None
							(void)pop_u64();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					push_value(v25);
					mw_std_list_List_1_uncons();
					VAL v57 = pop_value();
					VAL v58 = pop_value();
					push_value(v57);
					push_value(v58);
				}
				VAL v59 = pop_value();
				decref(v59);
				VAL v60 = pop_value();
				decref(v60);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mw_std_list_List_1_reverse();
				VAL v61 = pop_value();
				VAL v62 = pop_value();
				decref(v62);
				push_value(v18);
				push_value(v61);
				mw_std_list_List_1_cat();
				push_value(v17);
				mw_std_list_List_1_uncons();
				VAL v63 = pop_value();
				VAL v64 = pop_value();
				push_value(v63);
				push_value(v64);
			}
			VAL v65 = pop_value();
			decref(v65);
			VAL v66 = pop_value();
			decref(v66);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v67 = (0LL /* None */);
			push_u64(v67);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v68 = (0LL /* Nil */);
			push_u64(v68);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_match_Case_freeZ_vars (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_arrow_Arrow_freeZ_vars();
}
static void mw_mirth_arrow_Lambda_freeZ_vars (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_arrow_Arrow_freeZ_vars();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	uint64_t v5 = (0LL /* Nil */);
	push_value(v3);
	push_value(v4);
	push_u64(v5);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	while(1) {
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v9 = pop_value();
		if (!VBOOL(v9)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		VAL r12 = pop_resource();
		incref(v10);
		VAL v13 = pop_value();
		incref(v13);
		uint64_t v14 = (0LL /* None */);
		push_value(v10);
		push_u64(v14);
		push_value(v13);
		mw_std_list_List_1_uncons();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
		while(1) {
			VAL v17 = pop_value();
			incref(v17);
			push_value(v17);
			push_value(v17);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v18 = pop_value();
			if (!VBOOL(v18)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			incref(v19);
			VAL v22 = pop_value();
			incref(v22);
			push_value(v22);
			push_value(v19);
			mw_mirth_var_Var_ZEqualZEqual();
			VAL v23 = pop_value();
			push_value(v22);
			push_value(v19);
			if (VBOOL(v23)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v24 = pop_value();
				decref(v24);
				uint64_t v25 = (0LL /* None */);
				push_u64(v25);
			}
			VAL v26 = pop_value();
			push_value(v21);
			push_value(v20);
			push_value(v26);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v27 = pop_value();
					VAL v28 = pop_value();
					decref(v28);
					VAL v29 = pop_value();
					decref(v29);
					uint64_t v30 = (0LL /* Nil */);
					push_value(v27);
					push_u64(v30);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			push_value(v31);
			push_value(v32);
		}
		VAL v33 = pop_value();
		decref(v33);
		VAL v34 = pop_value();
		decref(v34);
		VAL v35 = pop_value();
		VAL v36 = pop_value();
		decref(v36);
		push_value(v35);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v37 = pop_value();
		if (VBOOL(v37)) {
			uint64_t v38 = (0LL /* False */);
			push_u64(v38);
		} else {
			uint64_t v39 = (1LL /* True */);
			push_u64(v39);
		}
		VAL v40 = pop_value();
		push_value(v13);
		push_value(v10);
		if (VBOOL(v40)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v41 = pop_value();
			decref(v41);
			uint64_t v42 = (0LL /* None */);
			push_u64(v42);
		}
		push_resource(r12);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v11);
		mw_std_list_List_1_uncons();
		VAL v43 = pop_value();
		VAL v44 = pop_value();
		push_value(v43);
		push_value(v44);
	}
	VAL v45 = pop_value();
	decref(v45);
	VAL v46 = pop_value();
	decref(v46);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v47 = pop_value();
	VAL v48 = pop_value();
	decref(v48);
	push_value(v47);
}
static void mw_mirth_arrow_Arg_token (void) {
	mw_mirth_arrow_Block_token();
}
static void mw_mirth_typedef_TypeDef_index (void) {
}
static void mw_mirth_typedef_TypeDef_allocZBang (void) {
	mbuf_mirth_typedef_TypeDef_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_typedef_TypeDef_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_typedef_TypeDef_qnameZ_soft (void) {
	mfld_mirth_typedef_TypeDef_ZTildeqname();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_mirth_Prop_1_readyZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_typedef_TypeDef_qnameZ_hard (void) {
	mfld_mirth_typedef_TypeDef_ZTildeqname();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_typedef_TypeDef_namespace (void) {
	mw_mirth_typedef_TypeDef_qnameZ_hard();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_typedef_TypeDef_name (void) {
	mfld_mirth_typedef_TypeDef_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_typedef_TypeDef_target (void) {
	mfld_mirth_typedef_TypeDef_ZTildetarget();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_typedef_TypeDef_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_typedef_TypeDef_index();
	push_value(v0);
	mw_mirth_typedef_TypeDef_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_typedef_TypeDef_newZBang (void) {
	mw_mirth_typedef_TypeDef_allocZBang();
	VAL v0 = (lpop(&lbl_head));
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mfld_mirth_typedef_TypeDef_ZTildeheadZAsk();
	mp_primZ_mutZ_set();
	VAL v2 = (lpop(&lbl_name));
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mfld_mirth_typedef_TypeDef_ZTildename();
	mp_primZ_mutZ_set();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mtw_mirth_mirth_PropLabel_TypeDefQName();
	VAL v5 = pop_value();
	lpush(&lbl_label, v5);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	push_value(v6);
	push_value(v7);
	mfld_mirth_typedef_TypeDef_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v8 = pop_value();
	incref(v8);
	push_value(v8);
	push_value(v8);
	mtw_mirth_def_Def_DefType();
	mw_mirth_def_Def_register();
}
static void mw_mirth_mirth_ZPlusMirth_defZ_typeZBang (void) {
	uint64_t v0 = (0LL /* None */);
	VAL v1 = (lpop(&lbl_qname));
	incref(v1);
	lpush(&lbl_head, MKU64(v0));
	push_value(v1);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	lpush(&lbl_name, v2);
	mtw_mirth_mirth_PropState_1_PSReady();
	VAL v3 = pop_value();
	lpush(&lbl_state, v3);
	mw_mirth_typedef_TypeDef_newZBang();
	VAL v4 = (lpop(&lbl_type));
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v4);
	push_value(v5);
	mtw_mirth_mirth_PropLabel_TypeDefTarget();
	mw_mirth_mirth_PropLabel_prop();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	mfld_mirth_typedef_TypeDef_ZTildetarget();
	mp_primZ_mutZ_set();
}
static void mw_mirth_type_PrimType_isZ_resourceZAsk (void) {
	switch (get_top_data_tag()) {
		case 8LL: { // PRIM_TYPE_WORLD
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_type_PrimType_isZ_physicalZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // PRIM_TYPE_TYPE
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			(void)pop_u64();
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		default: {
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (1LL /* True */);
			push_u64(v4);
		} break;
	}
}
static void mw_mirth_type_Type_tyconZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			mtw_mirth_tycon_Tycon_TYCONz_PRIM();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v2);
			mw_mirth_type_MetaVar_typeZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					VAL v3 = pop_value();
					decref(v3);
					uint64_t v4 = (0LL /* None */);
					push_u64(v4);
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_type_Type_expand();
					VAL v5 = pop_value();
					incref(v5);
					VAL v6 = pop_value();
					push_value(v5);
					push_value(v6);
					push_value(v5);
					mtw_std_maybe_Maybe_1_Some();
					VAL v7 = pop_value();
					VAL v8 = pop_value();
					push_value(v7);
					push_value(v8);
					mfld_mirth_type_MetaVar_ZTildetypeZAsk();
					mp_primZ_mutZ_set();
					mw_mirth_type_Type_tyconZAsk();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 4LL: { // THole
			mtp_mirth_type_Type_THole();
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		} break;
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* None */);
			push_u64(v12);
		} break;
		case 6LL: { // TTable
			mtp_mirth_type_Type_TTable();
			mtw_mirth_tycon_Tycon_TYCONz_TABLE();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			mtw_mirth_tycon_Tycon_TYCONz_DATA();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 8LL: { // TDataPartial
			mtp_mirth_type_Type_TDataPartial();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mtw_mirth_tycon_Tycon_TYCONz_DATA();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			VAL v13 = pop_value();
			decref(v13);
			uint64_t v14 = (0LL /* None */);
			push_u64(v14);
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
			VAL v15 = pop_value();
			decref(v15);
			uint64_t v16 = (0LL /* None */);
			push_u64(v16);
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			VAL v17 = pop_value();
			decref(v17);
			mw_mirth_type_Type_tyconZAsk();
		} break;
		case 12LL: { // TMut
			mtp_mirth_type_Type_TMut();
			mw_mirth_type_Type_tyconZAsk();
		} break;
		case 13LL: { // TValue
			mtp_mirth_type_Type_TValue();
			mw_mirth_type_Value_tyconZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_PrimType_tyconZ_qname (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // PRIM_TYPE_TYPE
			(void)pop_u64();
			STRLIT("TYPE", 4);
			int64_t v0 = (0LL);
			push_i64(v0);
			mw_mirth_name_QName_prim();
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			(void)pop_u64();
			STRLIT("STACK", 5);
			int64_t v1 = (0LL);
			push_i64(v1);
			mw_mirth_name_QName_prim();
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			(void)pop_u64();
			STRLIT("Resource", 8);
			int64_t v2 = (0LL);
			push_i64(v2);
			mw_mirth_name_QName_prim();
		} break;
		case 3LL: { // PRIM_TYPE_INT
			(void)pop_u64();
			STRLIT("Int", 3);
			int64_t v3 = (0LL);
			push_i64(v3);
			mw_mirth_name_QName_prim();
		} break;
		case 4LL: { // PRIM_TYPE_F32
			(void)pop_u64();
			STRLIT("F32", 3);
			int64_t v4 = (0LL);
			push_i64(v4);
			mw_mirth_name_QName_prim();
		} break;
		case 5LL: { // PRIM_TYPE_F64
			(void)pop_u64();
			STRLIT("F64", 3);
			int64_t v5 = (0LL);
			push_i64(v5);
			mw_mirth_name_QName_prim();
		} break;
		case 7LL: { // PRIM_TYPE_STR
			(void)pop_u64();
			STRLIT("Str", 3);
			int64_t v6 = (0LL);
			push_i64(v6);
			mw_mirth_name_QName_prim();
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			(void)pop_u64();
			STRLIT("Ptr", 3);
			int64_t v7 = (0LL);
			push_i64(v7);
			mw_mirth_name_QName_prim();
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			(void)pop_u64();
			STRLIT("+World", 6);
			int64_t v8 = (0LL);
			push_i64(v8);
			mw_mirth_name_QName_prim();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Value_tyconZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // VALUE_INT
			mtp_mirth_type_Value_VALUEz_INT();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (3LL /* PRIM_TYPE_INT */);
			push_u64(v1);
			mtw_mirth_tycon_Tycon_TYCONz_PRIM();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // VALUE_F64
			mtp_mirth_type_Value_VALUEz_F64();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (5LL /* PRIM_TYPE_F64 */);
			push_u64(v3);
			mtw_mirth_tycon_Tycon_TYCONz_PRIM();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // VALUE_STR
			mtp_mirth_type_Value_VALUEz_STR();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (7LL /* PRIM_TYPE_STR */);
			push_u64(v5);
			mtw_mirth_tycon_Tycon_TYCONz_PRIM();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 3LL: { // VALUE_BLOCK
			mtp_mirth_type_Value_VALUEz_BLOCK();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* None */);
			push_u64(v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_PrimType_ZToInt (void) {
}
static void mw_mirth_type_PrimType_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_type_PrimType_ZToInt();
	push_value(v0);
	mw_mirth_type_PrimType_ZToInt();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_PrimType_tyconZ_qname();
	VAL v1 = pop_value();
	lpush(&lbl_qname, v1);
	mtw_mirth_type_Type_TPrim();
	VAL v2 = pop_value();
	lpush(&lbl_type, v2);
	mw_mirth_mirth_ZPlusMirth_defZ_typeZBang();
}
static void mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang (void) {
	mw_std_prim_Str_ZToName();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mw_mirth_type_PrimType_tyconZ_qname();
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(4);
			tup->size = 4;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = u;
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			decref(v);
			push_value(MKTUP(tup,4));
		}
	}
	VAL v2 = pop_value();
	lpush(&lbl_qname, v2);
	mtw_mirth_type_Type_TPrim();
	VAL v3 = pop_value();
	lpush(&lbl_type, v3);
	mw_mirth_mirth_ZPlusMirth_defZ_typeZBang();
}
static void mw_mirth_mirth_ZPlusMirth_initZ_typesZBang (void) {
	uint64_t v0 = (3LL /* PRIM_TYPE_INT */);
	push_u64(v0);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang();
	uint64_t v1 = (4LL /* PRIM_TYPE_F32 */);
	push_u64(v1);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang();
	uint64_t v2 = (4LL /* PRIM_TYPE_F32 */);
	push_u64(v2);
	STRLIT("Float32", 7);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang();
	uint64_t v3 = (5LL /* PRIM_TYPE_F64 */);
	push_u64(v3);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang();
	uint64_t v4 = (5LL /* PRIM_TYPE_F64 */);
	push_u64(v4);
	STRLIT("Float64", 7);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZ_aliasZBang();
	uint64_t v5 = (6LL /* PRIM_TYPE_PTR */);
	push_u64(v5);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang();
	uint64_t v6 = (7LL /* PRIM_TYPE_STR */);
	push_u64(v6);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang();
	uint64_t v7 = (8LL /* PRIM_TYPE_WORLD */);
	push_u64(v7);
	mw_mirth_mirth_ZPlusMirth_defZ_primZ_typeZBang();
	mw_mirth_data_initZ_dataZBang();
}
static void mw_mirth_type_TZPlus (void) {
	mtw_mirth_type_StackType_STWith();
}
static void mw_mirth_type_TZMul (void) {
	mtw_mirth_type_StackType_STCons();
}
static void mw_mirth_type_TZMulZPlus (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Left
			mtp_std_either_Either_2_Left();
			mw_mirth_type_TZMul();
		} break;
		case 1LL: { // Right
			mtp_std_either_Either_2_Right();
			mw_mirth_type_TZPlus();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_TZ_ZTo (void) {
	mtw_mirth_type_ArrowType_ARROWz_TYPE();
}
static void mw_mirth_type_TT (void) {
	mw_mirth_type_T0();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		mw_mirth_type_TZMul();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_mirth_type_T0 (void) {
	uint64_t v0 = (2LL /* STACK_TYPE_UNIT */);
	push_u64(v0);
}
static void mw_mirth_type_T1 (void) {
	VAL v0 = pop_value();
	mw_mirth_type_T0();
	push_value(v0);
	mw_mirth_type_TZMul();
}
static void mw_mirth_type_T2 (void) {
	VAL v0 = pop_value();
	mw_mirth_type_T1();
	push_value(v0);
	mw_mirth_type_TZMul();
}
static void mw_mirth_type_T3 (void) {
	VAL v0 = pop_value();
	mw_mirth_type_T2();
	push_value(v0);
	mw_mirth_type_TZMul();
}
static void mw_mirth_type_Type_errorZAsk (void) {
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_type_Type_morphismZAsk (void) {
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_type_Type_primZAsk (void) {
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_type_Type_metaZEqual (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			mw_mirth_type_MetaVar_ZEqualZEqual();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_type_Type_isZ_physicalZAsk (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_type_MetaVar_typeZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					STRLIT("unbound meta at Type.is-physical?", 33);
					mp_primZ_panic();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_type_Type_expand();
					VAL v1 = pop_value();
					incref(v1);
					VAL v2 = pop_value();
					push_value(v1);
					push_value(v2);
					push_value(v1);
					mtw_std_maybe_Maybe_1_Some();
					VAL v3 = pop_value();
					VAL v4 = pop_value();
					push_value(v3);
					push_value(v4);
					mfld_mirth_type_MetaVar_ZTildetypeZAsk();
					mp_primZ_mutZ_set();
					mw_mirth_type_Type_isZ_physicalZAsk();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			mw_mirth_type_PrimType_isZ_physicalZAsk();
		} break;
		default: {
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (1LL /* True */);
			push_u64(v6);
		} break;
	}
}
static void mw_mirth_type_TYPEz_TYPE (void) {
	uint64_t v0 = (0LL /* PRIM_TYPE_TYPE */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_STACK (void) {
	uint64_t v0 = (1LL /* PRIM_TYPE_STACK */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_RESOURCE (void) {
	uint64_t v0 = (2LL /* PRIM_TYPE_RESOURCE */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_INT (void) {
	uint64_t v0 = (3LL /* PRIM_TYPE_INT */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_F32 (void) {
	uint64_t v0 = (4LL /* PRIM_TYPE_F32 */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_F64 (void) {
	uint64_t v0 = (5LL /* PRIM_TYPE_F64 */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_PTR (void) {
	uint64_t v0 = (6LL /* PRIM_TYPE_PTR */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_STR (void) {
	uint64_t v0 = (7LL /* PRIM_TYPE_STR */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_TYPEz_WORLD (void) {
	uint64_t v0 = (8LL /* PRIM_TYPE_WORLD */);
	push_u64(v0);
	mtw_mirth_type_Type_TPrim();
}
static void mw_mirth_type_RESOURCEz_WORLD (void) {
	mw_mirth_type_TYPEz_WORLD();
}
static void mw_mirth_type_Type_expand (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			mw_mirth_type_MetaVar_expand();
		} break;
		default: {
		} break;
	}
}
static void mw_mirth_type_ZPlusGamma_rdrop (void) {
	mtp_mirth_type_ZPlusGamma_ZPlusGamma();
	VAL v0 = (lpop(&lbl_token));
	decref(v0);
}
static void mw_mirth_type_Type_unifyZ_failedZBang (void) {
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	STRLIT("Failed to unify ", 16);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v0 = pop_value();
	mw_mirth_type_Type_typeZThen();
	push_value(v0);
	STRLIT(" with ", 6);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mw_mirth_type_Type_typeZThen();
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v1 = pop_value();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r2 = pop_resource();
	push_value(v1);
	mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
	uint64_t v3 = (0LL /* TYPE_ERROR */);
	push_resource(r2);
	push_u64(v3);
}
static void mw_mirth_type_Type_unifyZ_simpleZBang (void) {
	switch (get_top_data_tag()) {
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			switch (get_top_data_tag()) {
				case 5LL: { // TVar
					mtp_mirth_type_Type_TVar();
					mw_mirth_var_Var_unifyZBang();
				} break;
				default: {
					VAL v2 = pop_value();
					mtw_mirth_type_Type_TVar();
					push_value(v2);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			push_value(v3);
			push_value(v4);
			switch (get_top_data_tag()) {
				case 2LL: { // TPrim
					mtp_mirth_type_Type_TPrim();
					mw_mirth_type_PrimType_unifyZBang();
				} break;
				default: {
					VAL v5 = pop_value();
					mtw_mirth_type_Type_TPrim();
					push_value(v5);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			push_value(v6);
			push_value(v7);
			switch (get_top_data_tag()) {
				case 7LL: { // TData
					mtp_mirth_type_Type_TData();
					mw_mirth_data_Data_unifyZBang();
				} break;
				default: {
					VAL v8 = pop_value();
					mtw_mirth_type_Type_TData();
					push_value(v8);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 8LL: { // TDataPartial
			mtp_mirth_type_Type_TDataPartial();
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			push_value(v9);
			push_value(v10);
			switch (get_top_data_tag()) {
				case 8LL: { // TDataPartial
					mtp_mirth_type_Type_TDataPartial();
					mw_mirth_data_DataPartial_unifyZBang();
				} break;
				default: {
					VAL v11 = pop_value();
					mtw_mirth_type_Type_TDataPartial();
					push_value(v11);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 6LL: { // TTable
			mtp_mirth_type_Type_TTable();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			push_value(v12);
			push_value(v13);
			switch (get_top_data_tag()) {
				case 6LL: { // TTable
					mtp_mirth_type_Type_TTable();
					mw_mirth_table_Table_unifyZBang();
				} break;
				default: {
					VAL v14 = pop_value();
					mtw_mirth_type_Type_TTable();
					push_value(v14);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			push_value(v15);
			push_value(v16);
			switch (get_top_data_tag()) {
				case 9LL: { // TTensor
					mtp_mirth_type_Type_TTensor();
					mw_mirth_type_StackType_unifyZBang();
					mw_mirth_type_StackType_ZToType();
				} break;
				default: {
					VAL v17 = pop_value();
					mtw_mirth_type_Type_TTensor();
					push_value(v17);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			push_value(v18);
			push_value(v19);
			switch (get_top_data_tag()) {
				case 10LL: { // TMorphism
					mtp_mirth_type_Type_TMorphism();
					mw_mirth_type_ArrowType_unifyZBang();
					mtw_mirth_type_Type_TMorphism();
				} break;
				default: {
					VAL v20 = pop_value();
					mtw_mirth_type_Type_TMorphism();
					push_value(v20);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			push_value(v21);
			push_value(v23);
			switch (get_top_data_tag()) {
				case 11LL: { // TApp
					mtp_mirth_type_Type_TApp();
					mw_mirth_type_Type_unify2ZBang();
					mtw_mirth_type_Type_TApp();
				} break;
				default: {
					VAL v24 = pop_value();
					mtw_mirth_type_Type_TApp();
					push_value(v24);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 12LL: { // TMut
			mtp_mirth_type_Type_TMut();
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			push_value(v25);
			push_value(v26);
			switch (get_top_data_tag()) {
				case 12LL: { // TMut
					mtp_mirth_type_Type_TMut();
					mw_mirth_type_Type_unifyZBang();
					mtw_mirth_type_Type_TMut();
				} break;
				default: {
					VAL v27 = pop_value();
					mtw_mirth_type_Type_TMut();
					push_value(v27);
					mw_mirth_type_Type_unifyZ_failedZBang();
				} break;
			}
		} break;
		default: {
			mw_mirth_type_Type_unifyZ_failedZBang();
		} break;
	}
}
static void mw_mirth_type_Type_unifyZ_auxZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			mw_mirth_type_Type_unifyZ_errorZBang();
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
		} break;
		case 4LL: { // THole
			mtp_mirth_type_Type_THole();
			mw_mirth_type_typeZ_holeZ_unifyZBang();
		} break;
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			switch (get_top_data_tag()) {
				case 0LL: { // TYPE_ERROR
					(void)pop_u64();
					mw_mirth_type_MetaVar_unifyZ_errorZBang();
				} break;
				case 1LL: { // TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_Type_TMeta();
				} break;
				case 4LL: { // THole
					mtp_mirth_type_Type_THole();
					VAL v2 = pop_value();
					mtw_mirth_type_Type_TMeta();
					push_value(v2);
					mw_mirth_type_typeZ_holeZ_unifyZBang();
				} break;
				case 3LL: { // TMeta
					mtp_mirth_type_Type_TMeta();
					VAL v3 = pop_value();
					mtw_mirth_type_Type_TMeta();
					push_value(v3);
					mw_mirth_type_MetaVar_unifyZBang();
				} break;
				case 13LL: { // TValue
					mtp_mirth_type_Type_TValue();
					VAL v4 = pop_value();
					mtw_mirth_type_Type_TMeta();
					push_value(v4);
					mw_mirth_type_Value_unifyZ_typeZBang();
				} break;
				default: {
					VAL v5 = pop_value();
					VAL v6 = pop_value();
					push_value(v5);
					push_value(v6);
					mw_mirth_type_MetaVar_unifyZBang();
				} break;
			}
		} break;
		case 13LL: { // TValue
			mtp_mirth_type_Type_TValue();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			push_value(v7);
			push_value(v8);
			switch (get_top_data_tag()) {
				case 0LL: { // TYPE_ERROR
					(void)pop_u64();
					mw_mirth_type_Value_unifyZ_errorZBang();
				} break;
				case 1LL: { // TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_Type_TValue();
				} break;
				case 4LL: { // THole
					mtp_mirth_type_Type_THole();
					VAL v9 = pop_value();
					mtw_mirth_type_Type_TValue();
					push_value(v9);
					mw_mirth_type_typeZ_holeZ_unifyZBang();
				} break;
				case 3LL: { // TMeta
					mtp_mirth_type_Type_TMeta();
					VAL v10 = pop_value();
					mtw_mirth_type_Type_TValue();
					push_value(v10);
					mw_mirth_type_MetaVar_unifyZBang();
				} break;
				case 13LL: { // TValue
					mtp_mirth_type_Type_TValue();
					mw_mirth_type_Value_unifyZBang();
				} break;
				default: {
					VAL v11 = pop_value();
					VAL v12 = pop_value();
					push_value(v11);
					push_value(v12);
					mw_mirth_type_Value_unifyZ_typeZBang();
				} break;
			}
		} break;
		default: {
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			push_value(v13);
			push_value(v14);
			switch (get_top_data_tag()) {
				case 0LL: { // TYPE_ERROR
					(void)pop_u64();
					mw_mirth_type_Type_unifyZ_errorZBang();
				} break;
				case 1LL: { // TYPE_DONT_CARE
					(void)pop_u64();
				} break;
				case 4LL: { // THole
					mtp_mirth_type_Type_THole();
					mw_mirth_type_typeZ_holeZ_unifyZBang();
				} break;
				case 3LL: { // TMeta
					mtp_mirth_type_Type_TMeta();
					mw_mirth_type_MetaVar_unifyZBang();
				} break;
				case 13LL: { // TValue
					mtp_mirth_type_Type_TValue();
					mw_mirth_type_Value_unifyZ_typeZBang();
				} break;
				default: {
					mw_mirth_type_Type_unifyZ_simpleZBang();
				} break;
			}
		} break;
	}
}
static void mw_mirth_type_Type_unifyZ_errorZBang (void) {
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* TYPE_ERROR */);
			push_u64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v1 = (0LL /* TYPE_ERROR */);
			push_u64(v1);
		} break;
		case 4LL: { // THole
			mtp_mirth_type_Type_THole();
			uint64_t v2 = (0LL /* TYPE_ERROR */);
			VAL v3 = pop_value();
			push_u64(v2);
			push_value(v3);
			mw_mirth_type_typeZ_holeZ_unifyZBang();
		} break;
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			mw_mirth_type_MetaVar_unifyZ_errorZBang();
		} break;
		case 13LL: { // TValue
			mtp_mirth_type_Type_TValue();
			mw_mirth_type_Value_unifyZ_errorZBang();
		} break;
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (0LL /* TYPE_ERROR */);
			push_u64(v5);
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* TYPE_ERROR */);
			push_u64(v7);
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			VAL v8 = pop_value();
			decref(v8);
			uint64_t v9 = (0LL /* TYPE_ERROR */);
			push_u64(v9);
		} break;
		case 8LL: { // TDataPartial
			mtp_mirth_type_Type_TDataPartial();
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (0LL /* TYPE_ERROR */);
			push_u64(v11);
		} break;
		case 6LL: { // TTable
			mtp_mirth_type_Type_TTable();
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (0LL /* TYPE_ERROR */);
			push_u64(v13);
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
			mw_mirth_type_StackType_unifyZ_errorZBang();
			VAL v14 = pop_value();
			decref(v14);
			uint64_t v15 = (0LL /* TYPE_ERROR */);
			push_u64(v15);
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			mw_mirth_type_ArrowType_unifyZ_errorZBang();
			VAL v16 = pop_value();
			decref(v16);
			uint64_t v17 = (0LL /* TYPE_ERROR */);
			push_u64(v17);
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			VAL v18 = pop_value();
			mw_mirth_type_Type_unifyZ_errorZBang();
			VAL v19 = pop_value();
			decref(v19);
			push_value(v18);
			mw_mirth_type_Type_unifyZ_errorZBang();
			VAL v20 = pop_value();
			decref(v20);
			uint64_t v21 = (0LL /* TYPE_ERROR */);
			push_u64(v21);
		} break;
		case 12LL: { // TMut
			mtp_mirth_type_Type_TMut();
			mw_mirth_type_Type_unifyZ_errorZBang();
			VAL v22 = pop_value();
			decref(v22);
			uint64_t v23 = (0LL /* TYPE_ERROR */);
			push_u64(v23);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Type_unifyZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_Type_expand();
	push_value(v0);
	mw_mirth_type_Type_expand();
	mw_mirth_type_Type_unifyZ_auxZBang();
}
static void mw_mirth_type_Value_unifyZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	switch (get_top_data_tag()) {
		case 0LL: { // VALUE_INT
			mtp_mirth_type_Value_VALUEz_INT();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			switch (get_top_data_tag()) {
				case 0LL: { // VALUE_INT
					mtp_mirth_type_Value_VALUEz_INT();
					VAL v4 = pop_value();
					VAL v5 = pop_value();
					incref(v5);
					incref(v4);
					bool v6 = (VI64(v5) == VI64(v4));
					push_value(v5);
					push_value(v4);
					if (v6) {
						VAL v7 = pop_value();
						decref(v7);
						mtw_mirth_type_Value_VALUEz_INT();
						mtw_mirth_type_Type_TValue();
					} else {
						VAL v8 = pop_value();
						decref(v8);
						VAL v9 = pop_value();
						decref(v9);
						mw_mirth_type_TYPEz_INT();
					}
				} break;
				case 2LL: { // VALUE_STR
					mtp_mirth_type_Value_VALUEz_STR();
					VAL v10 = pop_value();
					decref(v10);
					VAL v11 = pop_value();
					decref(v11);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify int value with string value.", 40);
					VAL r12 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v13 = (0LL /* TYPE_ERROR */);
					push_resource(r12);
					push_u64(v13);
				} break;
				case 1LL: { // VALUE_F64
					mtp_mirth_type_Value_VALUEz_F64();
					VAL v14 = pop_value();
					decref(v14);
					VAL v15 = pop_value();
					decref(v15);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify int value with float value.", 39);
					VAL r16 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v17 = (0LL /* TYPE_ERROR */);
					push_resource(r16);
					push_u64(v17);
				} break;
				case 3LL: { // VALUE_BLOCK
					mtp_mirth_type_Value_VALUEz_BLOCK();
					VAL v18 = pop_value();
					decref(v18);
					VAL v19 = pop_value();
					decref(v19);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify int value with block.", 33);
					VAL r20 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v21 = (0LL /* TYPE_ERROR */);
					push_resource(r20);
					push_u64(v21);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 2LL: { // VALUE_STR
			mtp_mirth_type_Value_VALUEz_STR();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			push_value(v23);
			switch (get_top_data_tag()) {
				case 2LL: { // VALUE_STR
					mtp_mirth_type_Value_VALUEz_STR();
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					incref(v25);
					incref(v24);
					push_value(v25);
					push_value(v24);
					push_value(v25);
					push_value(v24);
					mp_primZ_strZ_cmp();
					int64_t v26 = (0LL);
					VAL v27 = pop_value();
					incref(v27);
					bool v28 = (VI64(v27) == v26);
					push_value(v27);
					push_i64(v26);
					if (v28) {
						VAL v29 = pop_value();
						decref(v29);
						VAL v30 = pop_value();
						decref(v30);
						uint64_t v31 = (1LL /* EQ */);
						push_u64(v31);
					} else {
						VAL v32 = pop_value();
						VAL v33 = pop_value();
						bool v34 = (VI64(v33) < VI64(v32));
						if (v34) {
							uint64_t v35 = (0LL /* LT */);
							push_u64(v35);
						} else {
							uint64_t v36 = (2LL /* GT */);
							push_u64(v36);
						}
					}
					switch (get_top_data_tag()) {
						case 0LL: { // LT
							(void)pop_u64();
							uint64_t v37 = (0LL /* False */);
							push_u64(v37);
						} break;
						case 1LL: { // EQ
							(void)pop_u64();
							uint64_t v38 = (1LL /* True */);
							push_u64(v38);
						} break;
						case 2LL: { // GT
							(void)pop_u64();
							uint64_t v39 = (0LL /* False */);
							push_u64(v39);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					VAL v40 = pop_value();
					if (VBOOL(v40)) {
						VAL v41 = pop_value();
						decref(v41);
						mtw_mirth_type_Value_VALUEz_STR();
						mtw_mirth_type_Type_TValue();
					} else {
						VAL v42 = pop_value();
						decref(v42);
						VAL v43 = pop_value();
						decref(v43);
						mw_mirth_type_TYPEz_STR();
					}
				} break;
				case 0LL: { // VALUE_INT
					mtp_mirth_type_Value_VALUEz_INT();
					VAL v44 = pop_value();
					decref(v44);
					VAL v45 = pop_value();
					decref(v45);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify string value with int value.", 40);
					VAL r46 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v47 = (0LL /* TYPE_ERROR */);
					push_resource(r46);
					push_u64(v47);
				} break;
				case 1LL: { // VALUE_F64
					mtp_mirth_type_Value_VALUEz_F64();
					VAL v48 = pop_value();
					decref(v48);
					VAL v49 = pop_value();
					decref(v49);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify string value with float value.", 42);
					VAL r50 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v51 = (0LL /* TYPE_ERROR */);
					push_resource(r50);
					push_u64(v51);
				} break;
				case 3LL: { // VALUE_BLOCK
					mtp_mirth_type_Value_VALUEz_BLOCK();
					VAL v52 = pop_value();
					decref(v52);
					VAL v53 = pop_value();
					decref(v53);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify string value with block.", 36);
					VAL r54 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v55 = (0LL /* TYPE_ERROR */);
					push_resource(r54);
					push_u64(v55);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 3LL: { // VALUE_BLOCK
			mtp_mirth_type_Value_VALUEz_BLOCK();
			VAL v56 = pop_value();
			VAL v57 = pop_value();
			push_value(v56);
			push_value(v57);
			switch (get_top_data_tag()) {
				case 3LL: { // VALUE_BLOCK
					mtp_mirth_type_Value_VALUEz_BLOCK();
					VAL v58 = pop_value();
					VAL v59 = pop_value();
					incref(v59);
					incref(v58);
					push_value(v59);
					push_value(v58);
					push_value(v59);
					push_value(v58);
					mw_mirth_arrow_Block_ZEqualZEqual();
					VAL v60 = pop_value();
					if (VBOOL(v60)) {
						VAL v61 = pop_value();
						decref(v61);
						mtw_mirth_type_Value_VALUEz_BLOCK();
						mtw_mirth_type_Type_TValue();
					} else {
						VAL r62 = pop_resource();
						mw_mirth_arrow_Block_arrow();
						push_resource(r62);
						mw_mirth_arrow_Arrow_type();
						mw_mirth_arrow_blockZ_unifyZ_typeZBang();
						mw_mirth_type_ArrowType_ZToType();
					}
				} break;
				case 0LL: { // VALUE_INT
					mtp_mirth_type_Value_VALUEz_INT();
					VAL v63 = pop_value();
					decref(v63);
					VAL v64 = pop_value();
					decref(v64);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify block with int value.", 33);
					VAL r65 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v66 = (0LL /* TYPE_ERROR */);
					push_resource(r65);
					push_u64(v66);
				} break;
				case 1LL: { // VALUE_F64
					mtp_mirth_type_Value_VALUEz_F64();
					VAL v67 = pop_value();
					decref(v67);
					VAL v68 = pop_value();
					decref(v68);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify block with float value.", 35);
					VAL r69 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v70 = (0LL /* TYPE_ERROR */);
					push_resource(r69);
					push_u64(v70);
				} break;
				case 2LL: { // VALUE_STR
					mtp_mirth_type_Value_VALUEz_STR();
					VAL v71 = pop_value();
					decref(v71);
					VAL v72 = pop_value();
					decref(v72);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify block with string value.", 36);
					VAL r73 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v74 = (0LL /* TYPE_ERROR */);
					push_resource(r73);
					push_u64(v74);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 1LL: { // VALUE_F64
			mtp_mirth_type_Value_VALUEz_F64();
			VAL v75 = pop_value();
			VAL v76 = pop_value();
			push_value(v75);
			push_value(v76);
			switch (get_top_data_tag()) {
				case 1LL: { // VALUE_F64
					mtp_mirth_type_Value_VALUEz_F64();
					VAL v77 = pop_value();
					VAL v78 = pop_value();
					incref(v78);
					incref(v77);
					bool v79 = (VF64(v78) == VF64(v77));
					push_value(v78);
					push_value(v77);
					if (v79) {
						VAL v80 = pop_value();
						decref(v80);
						mtw_mirth_type_Value_VALUEz_F64();
						mtw_mirth_type_Type_TValue();
					} else {
						VAL v81 = pop_value();
						decref(v81);
						VAL v82 = pop_value();
						decref(v82);
						mw_mirth_type_TYPEz_F64();
					}
				} break;
				case 0LL: { // VALUE_INT
					mtp_mirth_type_Value_VALUEz_INT();
					VAL v83 = pop_value();
					decref(v83);
					VAL v84 = pop_value();
					decref(v84);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify float value with int value.", 39);
					VAL r85 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v86 = (0LL /* TYPE_ERROR */);
					push_resource(r85);
					push_u64(v86);
				} break;
				case 3LL: { // VALUE_BLOCK
					mtp_mirth_type_Value_VALUEz_BLOCK();
					VAL v87 = pop_value();
					decref(v87);
					VAL v88 = pop_value();
					decref(v88);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify float value with block.", 35);
					VAL r89 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v90 = (0LL /* TYPE_ERROR */);
					push_resource(r89);
					push_u64(v90);
				} break;
				case 2LL: { // VALUE_STR
					mtp_mirth_type_Value_VALUEz_STR();
					VAL v91 = pop_value();
					decref(v91);
					VAL v92 = pop_value();
					decref(v92);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					STRLIT("Can't unify float value with string value.", 42);
					VAL r93 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v94 = (0LL /* TYPE_ERROR */);
					push_resource(r93);
					push_u64(v94);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Value_unifyZ_typeZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // VALUE_INT
			mtp_mirth_type_Value_VALUEz_INT();
			VAL v0 = pop_value();
			decref(v0);
			mw_mirth_type_TYPEz_INT();
			mw_mirth_type_Type_unifyZBang();
		} break;
		case 2LL: { // VALUE_STR
			mtp_mirth_type_Value_VALUEz_STR();
			VAL v1 = pop_value();
			decref(v1);
			mw_mirth_type_TYPEz_STR();
			mw_mirth_type_Type_unifyZBang();
		} break;
		case 1LL: { // VALUE_F64
			mtp_mirth_type_Value_VALUEz_F64();
			VAL v2 = pop_value();
			decref(v2);
			mw_mirth_type_TYPEz_F64();
			mw_mirth_type_Type_unifyZBang();
		} break;
		case 3LL: { // VALUE_BLOCK
			mtp_mirth_type_Value_VALUEz_BLOCK();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			push_value(v3);
			push_value(v4);
			mw_mirth_type_Type_unifyZ_blockZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Value_unifyZ_errorZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // VALUE_INT
			mtp_mirth_type_Value_VALUEz_INT();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* TYPE_ERROR */);
			push_u64(v1);
		} break;
		case 2LL: { // VALUE_STR
			mtp_mirth_type_Value_VALUEz_STR();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* TYPE_ERROR */);
			push_u64(v3);
		} break;
		case 1LL: { // VALUE_F64
			mtp_mirth_type_Value_VALUEz_F64();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (0LL /* TYPE_ERROR */);
			push_u64(v5);
		} break;
		case 3LL: { // VALUE_BLOCK
			mtp_mirth_type_Value_VALUEz_BLOCK();
			uint64_t v6 = (0LL /* TYPE_ERROR */);
			push_u64(v6);
			mw_mirth_type_Type_unifyZ_blockZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Type_unifyZ_blockZBang (void) {
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
			uint64_t v1 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v0);
			push_u64(v1);
			mw_mirth_type_TZ_ZTo();
			mw_mirth_arrow_blockZ_unifyZ_typeZBang();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* TYPE_ERROR */);
			push_u64(v3);
		} break;
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			incref(v5);
			push_value(v5);
			mw_mirth_arrow_Block_type();
			mw_mirth_type_ArrowType_ZToType();
			push_value(v4);
			mw_mirth_type_MetaVar_unifyZBang();
			VAL v6 = pop_value();
			decref(v6);
			VAL r7 = pop_resource();
			push_value(v5);
			mw_mirth_arrow_Block_arrow();
			push_resource(r7);
			mw_mirth_arrow_Arrow_type();
			mw_mirth_type_ArrowType_ZToType();
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			mw_mirth_arrow_blockZ_unifyZ_typeZBang();
			mw_mirth_type_ArrowType_ZToType();
		} break;
		default: {
			VAL v8 = pop_value();
			mw_mirth_arrow_Block_type();
			mw_mirth_type_ArrowType_ZToType();
			push_value(v8);
			mw_mirth_type_Type_unifyZBang();
		} break;
	}
}
static void mw_mirth_type_Type_unify2ZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	mw_mirth_type_Type_unifyZBang();
	push_value(v2);
	push_value(v0);
	mw_mirth_type_Type_unifyZBang();
}
static void mw_mirth_type_PrimType_unifyZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_mirth_type_PrimType_ZEqualZEqual();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
		mtw_mirth_type_Type_TPrim();
	} else {
		VAL v4 = pop_value();
		mtw_mirth_type_Type_TPrim();
		push_value(v4);
		mtw_mirth_type_Type_TPrim();
		mw_mirth_type_Type_unifyZ_failedZBang();
	}
}
static void mw_mirth_data_Data_unifyZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_mirth_data_Data_ZEqualZEqual();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
		mtw_mirth_type_Type_TData();
	} else {
		VAL v4 = pop_value();
		mtw_mirth_type_Type_TData();
		push_value(v4);
		mtw_mirth_type_Type_TData();
		mw_mirth_type_Type_unifyZ_failedZBang();
	}
}
static void mw_mirth_data_DataPartial_unifyZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_mirth_data_DataPartial_ZEqualZEqual();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
		mtw_mirth_type_Type_TDataPartial();
	} else {
		VAL v4 = pop_value();
		mtw_mirth_type_Type_TDataPartial();
		push_value(v4);
		mtw_mirth_type_Type_TDataPartial();
		mw_mirth_type_Type_unifyZ_failedZBang();
	}
}
static void mw_mirth_table_Table_unifyZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_mirth_table_Table_ZEqualZEqual();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
		mtw_mirth_type_Type_TTable();
	} else {
		VAL v4 = pop_value();
		mtw_mirth_type_Type_TTable();
		push_value(v4);
		mtw_mirth_type_Type_TTable();
		mw_mirth_type_Type_unifyZ_failedZBang();
	}
}
static void mw_mirth_type_Type_hasZ_metaZAsk (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			mw_mirth_type_MetaVar_hasZ_metaZAsk();
		} break;
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* False */);
			push_u64(v3);
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* False */);
			push_u64(v6);
		} break;
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			VAL v7 = pop_value();
			decref(v7);
			VAL v8 = pop_value();
			decref(v8);
			uint64_t v9 = (0LL /* False */);
			push_u64(v9);
		} break;
		case 4LL: { // THole
			mtp_mirth_type_Type_THole();
			VAL v10 = pop_value();
			decref(v10);
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* False */);
			push_u64(v12);
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
			mw_mirth_type_StackType_hasZ_metaZAsk();
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			mw_mirth_type_ArrowType_hasZ_metaZAsk();
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			mw_mirth_type_Type_hasZ_meta2ZAsk();
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			VAL v13 = pop_value();
			decref(v13);
			VAL v14 = pop_value();
			decref(v14);
			uint64_t v15 = (0LL /* False */);
			push_u64(v15);
		} break;
		case 8LL: { // TDataPartial
			mtp_mirth_type_Type_TDataPartial();
			VAL v16 = pop_value();
			decref(v16);
			VAL v17 = pop_value();
			decref(v17);
			uint64_t v18 = (0LL /* False */);
			push_u64(v18);
		} break;
		case 6LL: { // TTable
			mtp_mirth_type_Type_TTable();
			VAL v19 = pop_value();
			decref(v19);
			VAL v20 = pop_value();
			decref(v20);
			uint64_t v21 = (0LL /* False */);
			push_u64(v21);
		} break;
		case 13LL: { // TValue
			mtp_mirth_type_Type_TValue();
			mw_mirth_type_Value_hasZ_metaZAsk();
		} break;
		case 12LL: { // TMut
			mtp_mirth_type_Type_TMut();
			mw_mirth_type_Type_hasZ_metaZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Type_hasZ_meta2ZAsk (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	push_value(v0);
	mw_mirth_type_Type_hasZ_metaZAsk();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = pop_value();
		decref(v4);
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (1LL /* True */);
		push_u64(v6);
	} else {
		mw_mirth_type_Type_hasZ_metaZAsk();
	}
}
static void mw_mirth_type_Value_hasZ_metaZAsk (void) {
	mw_mirth_type_Value_type();
	mw_mirth_type_Type_hasZ_metaZAsk();
}
static void mw_mirth_type_Type_typeZThen (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			STRLIT("<ERROR>", 7);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
			STRLIT("_", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			mw_mirth_type_PrimType_typeZThen();
		} break;
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			mw_mirth_var_Var_typeZThen();
		} break;
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			mw_mirth_type_MetaVar_typeZThen();
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
			STRLIT("[", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_StackType_stackZThen();
			STRLIT("]", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			STRLIT("[", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_ArrowType_sigZThen();
			STRLIT("]", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			mw_mirth_data_Data_name();
			mw_mirth_name_Name_ZToStr();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 8LL: { // TDataPartial
			mtp_mirth_type_Type_TDataPartial();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_data_Data_name();
			mw_mirth_name_Name_ZToStr();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("/", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_ZToStr();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 6LL: { // TTable
			mtp_mirth_type_Type_TTable();
			mw_mirth_table_Table_name();
			mw_mirth_name_Name_ZToStr();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 4LL: { // THole
			mtp_mirth_type_Type_THole();
			mw_mirth_name_Name_ZToStr();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			mw_mirth_type_Type_appZ_typeZThenZThen();
		} break;
		case 13LL: { // TValue
			mtp_mirth_type_Type_TValue();
			mw_mirth_type_Value_type();
			mw_mirth_type_Type_typeZThen();
		} break;
		case 12LL: { // TMut
			mtp_mirth_type_Type_TMut();
			STRLIT("Mut(", 4);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_Type_typeZThen();
			STRLIT(")", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Value_type (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // VALUE_INT
			mtp_mirth_type_Value_VALUEz_INT();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (3LL /* PRIM_TYPE_INT */);
			push_u64(v1);
			mtw_mirth_type_Type_TPrim();
		} break;
		case 1LL: { // VALUE_F64
			mtp_mirth_type_Value_VALUEz_F64();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (5LL /* PRIM_TYPE_F64 */);
			push_u64(v3);
			mtw_mirth_type_Type_TPrim();
		} break;
		case 2LL: { // VALUE_STR
			mtp_mirth_type_Value_VALUEz_STR();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (7LL /* PRIM_TYPE_STR */);
			push_u64(v5);
			mtw_mirth_type_Type_TPrim();
		} break;
		case 3LL: { // VALUE_BLOCK
			mtp_mirth_type_Value_VALUEz_BLOCK();
			mw_mirth_arrow_Block_type();
			mw_mirth_type_ArrowType_ZToType();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_PrimType_typeZThen (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // PRIM_TYPE_TYPE
			(void)pop_u64();
			STRLIT("<TYPE>", 6);
		} break;
		case 1LL: { // PRIM_TYPE_STACK
			(void)pop_u64();
			STRLIT("<STACK>", 7);
		} break;
		case 2LL: { // PRIM_TYPE_RESOURCE
			(void)pop_u64();
			STRLIT("<Resource>", 10);
		} break;
		case 3LL: { // PRIM_TYPE_INT
			(void)pop_u64();
			STRLIT("Int", 3);
		} break;
		case 4LL: { // PRIM_TYPE_F32
			(void)pop_u64();
			STRLIT("F32", 3);
		} break;
		case 5LL: { // PRIM_TYPE_F64
			(void)pop_u64();
			STRLIT("F64", 3);
		} break;
		case 6LL: { // PRIM_TYPE_PTR
			(void)pop_u64();
			STRLIT("Ptr", 3);
		} break;
		case 7LL: { // PRIM_TYPE_STR
			(void)pop_u64();
			STRLIT("Str", 3);
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			(void)pop_u64();
			STRLIT("+World", 6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_mirth_type_Type_freshen (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* TYPE_ERROR */);
			push_u64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v1 = (1LL /* TYPE_DONT_CARE */);
			push_u64(v1);
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			mtw_mirth_type_Type_TPrim();
		} break;
		case 4LL: { // THole
			mtp_mirth_type_Type_THole();
			mtw_mirth_type_Type_THole();
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			mtw_mirth_type_Type_TData();
		} break;
		case 8LL: { // TDataPartial
			mtp_mirth_type_Type_TDataPartial();
			mtw_mirth_type_Type_TDataPartial();
		} break;
		case 6LL: { // TTable
			mtp_mirth_type_Type_TTable();
			mtw_mirth_type_Type_TTable();
		} break;
		case 13LL: { // TValue
			mtp_mirth_type_Type_TValue();
			mtw_mirth_type_Type_TValue();
		} break;
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			mw_mirth_var_Var_freshen();
		} break;
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			mw_mirth_type_MetaVar_freshen();
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
			mw_mirth_type_StackType_freshen();
			mtw_mirth_type_Type_TTensor();
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			mw_mirth_type_ArrowType_freshen();
			mtw_mirth_type_Type_TMorphism();
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			mw_mirth_type_Type_freshen2();
			mtw_mirth_type_Type_TApp();
		} break;
		case 12LL: { // TMut
			mtp_mirth_type_Type_TMut();
			mw_mirth_type_Type_freshen();
			mtw_mirth_type_Type_TMut();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Type_freshen2 (void) {
	VAL v0 = pop_value();
	mw_mirth_type_Type_freshen();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	push_value(v0);
	mw_mirth_type_Type_freshen();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	push_value(v3);
}
static void mw_mirth_type_Type_rigidifyZBang (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_type_MetaVar_typeZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					VAL v1 = pop_value();
					mw_mirth_var_Ctx_freshZ_typeZ_varZBang();
					mtw_mirth_type_Type_TVar();
					VAL v2 = pop_value();
					incref(v2);
					push_value(v2);
					push_value(v2);
					mtw_std_maybe_Maybe_1_Some();
					push_value(v1);
					mfld_mirth_type_MetaVar_ZTildetypeZAsk();
					mp_primZ_mutZ_set();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v3 = pop_value();
					VAL v4 = pop_value();
					decref(v4);
					push_value(v3);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			mw_mirth_type_Type_rigidifyZBang();
		} break;
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			uint64_t v5 = (0LL /* TYPE_ERROR */);
			push_u64(v5);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v6 = (1LL /* TYPE_DONT_CARE */);
			push_u64(v6);
		} break;
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			mtw_mirth_type_Type_TPrim();
		} break;
		case 4LL: { // THole
			mtp_mirth_type_Type_THole();
			mtw_mirth_type_Type_THole();
		} break;
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			mtw_mirth_type_Type_TVar();
		} break;
		case 6LL: { // TTable
			mtp_mirth_type_Type_TTable();
			mtw_mirth_type_Type_TTable();
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			mtw_mirth_type_Type_TData();
		} break;
		case 8LL: { // TDataPartial
			mtp_mirth_type_Type_TDataPartial();
			mtw_mirth_type_Type_TDataPartial();
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			VAL v7 = pop_value();
			mw_mirth_type_Type_rigidifyZBang();
			VAL v8 = pop_value();
			push_value(v7);
			mw_mirth_type_Type_rigidifyZBang();
			VAL v9 = pop_value();
			push_value(v8);
			push_value(v9);
			mtw_mirth_type_Type_TApp();
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
			mw_mirth_type_StackType_rigidifyZBang();
			mtw_mirth_type_Type_TTensor();
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			mw_mirth_type_ArrowType_rigidifyZBang();
			mtw_mirth_type_Type_TMorphism();
		} break;
		case 13LL: { // TValue
			mtp_mirth_type_Type_TValue();
			mw_mirth_type_Value_rigidifyZBang();
		} break;
		case 12LL: { // TMut
			mtp_mirth_type_Type_TMut();
			mw_mirth_type_Type_rigidifyZBang();
			mtw_mirth_type_Type_TMut();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Value_rigidifyZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // VALUE_INT
			mtp_mirth_type_Value_VALUEz_INT();
			mtw_mirth_type_Value_VALUEz_INT();
			mtw_mirth_type_Type_TValue();
		} break;
		case 2LL: { // VALUE_STR
			mtp_mirth_type_Value_VALUEz_STR();
			mtw_mirth_type_Value_VALUEz_STR();
			mtw_mirth_type_Type_TValue();
		} break;
		case 1LL: { // VALUE_F64
			mtp_mirth_type_Value_VALUEz_F64();
			mtw_mirth_type_Value_VALUEz_F64();
			mtw_mirth_type_Type_TValue();
		} break;
		case 3LL: { // VALUE_BLOCK
			mtp_mirth_type_Value_VALUEz_BLOCK();
			mw_mirth_arrow_Block_arrow();
			mw_mirth_arrow_Arrow_type();
			mw_mirth_type_ArrowType_rigidifyZBang();
			mw_mirth_type_ArrowType_ZToType();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Type_exceptZ_field (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_type_MetaVar_typeZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					STRLIT("Type.except-field on metavar", 28);
					mp_primZ_panic();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_type_Type_expand();
					VAL v1 = pop_value();
					incref(v1);
					VAL v2 = pop_value();
					push_value(v1);
					push_value(v2);
					push_value(v1);
					mtw_std_maybe_Maybe_1_Some();
					VAL v3 = pop_value();
					VAL v4 = pop_value();
					push_value(v3);
					push_value(v4);
					mfld_mirth_type_MetaVar_ZTildetypeZAsk();
					mp_primZ_mutZ_set();
					mw_mirth_type_Type_exceptZ_field();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			decref(v6);
			VAL v7 = pop_value();
			lpush(&lbl_data, v5);
			lpush(&lbl_field, v7);
			mtw_mirth_data_DataPartial_DataPartial();
			mtw_mirth_type_Type_TDataPartial();
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			VAL v8 = pop_value();
			mw_mirth_type_Type_exceptZ_field();
			push_value(v8);
			mtw_mirth_type_Type_TApp();
		} break;
		default: {
			STRLIT("Type.except-field on unexpected type", 36);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_type_MetaVar_index (void) {
}
static void mw_mirth_type_MetaVar_allocZBang (void) {
	mbuf_mirth_type_MetaVar_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_type_MetaVar_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_type_MetaVar_typeZAsk (void) {
	mfld_mirth_type_MetaVar_ZTildetypeZAsk();
	mp_primZ_mutZ_get();
}
static void mw_mirth_type_MetaVar_hasZ_metaZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_MetaVar_typeZAsk();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_type_MetaVar_ZEqualZEqual();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_type_Type_hasZ_metaZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_MetaVar_typeZThen (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_MetaVar_typeZAsk();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("?", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_MetaVar_index();
			mp_primZ_intZ_toZ_str();
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_type_Type_typeZThen();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_MetaVar_newZBang (void) {
	mw_mirth_type_MetaVar_allocZBang();
	uint64_t v0 = (0LL /* None */);
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_u64(v0);
	push_value(v1);
	mfld_mirth_type_MetaVar_ZTildetypeZAsk();
	mp_primZ_mutZ_set();
}
static void mw_mirth_type_MetaVar_expand (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_MetaVar_typeZAsk();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			mtw_mirth_type_Type_TMeta();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_type_Type_expand();
			VAL v1 = pop_value();
			incref(v1);
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			push_value(v1);
			mtw_std_maybe_Maybe_1_Some();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			push_value(v3);
			push_value(v4);
			mfld_mirth_type_MetaVar_ZTildetypeZAsk();
			mp_primZ_mutZ_set();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_MetaVar_unifyZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_MetaVar_typeZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_type_Type_unifyZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			incref(v3);
			push_value(v4);
			push_value(v3);
			push_value(v3);
			push_value(v4);
			mw_mirth_type_Type_metaZEqual();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				VAL v6 = pop_value();
				decref(v6);
			} else {
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				incref(v7);
				incref(v8);
				push_value(v7);
				push_value(v8);
				push_value(v7);
				push_value(v8);
				mw_mirth_type_Type_hasZ_metaZAsk();
				VAL v9 = pop_value();
				if (VBOOL(v9)) {
					VAL v10 = pop_value();
					VAL v11 = pop_value();
					push_value(v10);
					push_value(v11);
					mtw_mirth_type_Type_TMeta();
					mw_mirth_type_Type_unifyZ_failedZBang();
				} else {
					VAL v12 = pop_value();
					incref(v12);
					VAL v13 = pop_value();
					push_value(v12);
					push_value(v13);
					push_value(v12);
					mtw_std_maybe_Maybe_1_Some();
					VAL v14 = pop_value();
					VAL v15 = pop_value();
					push_value(v14);
					push_value(v15);
					mfld_mirth_type_MetaVar_ZTildetypeZAsk();
					mp_primZ_mutZ_set();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_MetaVar_unifyZ_errorZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_MetaVar_typeZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_type_Type_unifyZ_errorZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v3 = pop_value();
			uint64_t v4 = (0LL /* TYPE_ERROR */);
			push_u64(v4);
			mtw_std_maybe_Maybe_1_Some();
			push_value(v3);
			mfld_mirth_type_MetaVar_ZTildetypeZAsk();
			mp_primZ_mutZ_set();
			uint64_t v5 = (0LL /* TYPE_ERROR */);
			push_u64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_MetaVar_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_type_MetaVar_index();
	push_value(v0);
	mw_mirth_type_MetaVar_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_type_MetaVar_freshen (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_MetaVar_typeZAsk();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			VAL v1 = pop_value();
			decref(v1);
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_Type_TMeta();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_type_Type_expand();
			VAL v2 = pop_value();
			incref(v2);
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			push_value(v2);
			mtw_std_maybe_Maybe_1_Some();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			push_value(v4);
			push_value(v5);
			mfld_mirth_type_MetaVar_ZTildetypeZAsk();
			mp_primZ_mutZ_set();
			mw_mirth_type_Type_freshen();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_typeZ_holeZ_unifyZBang (void) {
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	mtw_mirth_type_Type_THole();
	mw_mirth_type_Type_typeZThen();
	STRLIT(" ~ ", 3);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_Type_typeZThen();
	STRLIT("\n", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v1 = pop_value();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r2 = pop_resource();
	push_value(v1);
	mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang();
	push_resource(r2);
}
static void mw_mirth_type_Type_appZ_typeZThenZThen (void) {
	mw_mirth_type_Type_appZ_typeZ_openZThenZThen();
	STRLIT(")", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_mirth_type_Type_appZ_typeZ_openZThenZThen (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			mw_mirth_type_Type_appZ_typeZ_openZThenZThen();
			STRLIT(", ", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_Type_typeZThen();
		} break;
		default: {
			mw_mirth_type_Type_typeZThen();
			STRLIT("(", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_Type_typeZThen();
		} break;
	}
}
static void mw_mirth_type_Resource_ZToType (void) {
}
static void mw_mirth_type_Type_ZToResource (void) {
}
static void mw_mirth_type_Resource_hasZ_metaZAsk (void) {
	mw_mirth_type_Resource_ZToType();
	mw_mirth_type_Type_hasZ_metaZAsk();
}
static void mw_mirth_type_Resource_unifyZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_Resource_ZToType();
	push_value(v0);
	mw_mirth_type_Resource_ZToType();
	mw_mirth_type_Type_unifyZBang();
	mw_mirth_type_Type_ZToResource();
}
static void mw_mirth_type_Resource_unifyZ_errorZBang (void) {
	mw_mirth_type_Resource_ZToType();
	mw_mirth_type_Type_unifyZ_errorZBang();
	mw_mirth_type_Type_ZToResource();
}
static void mw_mirth_type_Resource_typeZThen (void) {
	mw_mirth_type_Resource_ZToType();
	mw_mirth_type_Type_typeZThen();
}
static void mw_mirth_type_Resource_freshen (void) {
	mw_mirth_type_Resource_ZToType();
	mw_mirth_type_Type_freshen();
	mw_mirth_type_Type_ZToResource();
}
static void mw_mirth_type_Resource_rigidifyZBang (void) {
	mw_mirth_type_Resource_ZToType();
	mw_mirth_type_Type_rigidifyZBang();
	mw_mirth_type_Type_ZToResource();
}
static void mw_mirth_type_Resource_exceptZ_field (void) {
	mw_mirth_type_Type_exceptZ_field();
}
static void mw_mirth_type_Type_ZToStackType (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v0);
		} break;
		case 1LL: { // TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v1 = (1LL /* STACK_TYPE_DONT_CARE */);
			push_u64(v1);
		} break;
		case 5LL: { // TVar
			mtp_mirth_type_Type_TVar();
			mtw_mirth_type_StackType_STVar();
		} break;
		case 3LL: { // TMeta
			mtp_mirth_type_Type_TMeta();
			mtw_mirth_type_StackType_STMeta();
		} break;
		case 9LL: { // TTensor
			mtp_mirth_type_Type_TTensor();
		} break;
		default: {
			STRLIT("kind error! expected stack type, got regular type.", 50);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_type_StackType_ZToType (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* TYPE_ERROR */);
			push_u64(v0);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v1 = (1LL /* TYPE_DONT_CARE */);
			push_u64(v1);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			mtw_mirth_type_Type_TVar();
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			mtw_mirth_type_Type_TMeta();
		} break;
		default: {
			mtw_mirth_type_Type_TTensor();
		} break;
	}
}
static void mw_mirth_type_StackType_expand (void) {
	switch (get_top_data_tag()) {
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_expand();
			mw_mirth_type_Type_ZToStackType();
		} break;
		default: {
		} break;
	}
}
static void mw_mirth_type_StackType_unitZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_type_StackType_split4 (void) {
	uint64_t v0 = (0LL /* Nil */);
	uint64_t v1 = (0LL /* Nil */);
	uint64_t v2 = (0LL /* Nil */);
	lpush(&lbl_labels, MKU64(v2));
	lpush(&lbl_withses, MKU64(v1));
	lpush(&lbl_conses, MKU64(v0));
	while(1) {
		mw_mirth_type_StackType_expand();
		switch (get_top_data_tag()) {
			case 5LL: { // STCons
				mtp_mirth_type_StackType_STCons();
				VAL v3 = (lpop(&lbl_conses));
				push_value(v3);
				mtw_std_list_List_1_Cons();
				VAL v4 = pop_value();
				uint64_t v5 = (1LL /* True */);
				lpush(&lbl_conses, v4);
				push_u64(v5);
			} break;
			case 7LL: { // STWith
				mtp_mirth_type_StackType_STWith();
				VAL v6 = (lpop(&lbl_withses));
				push_value(v6);
				mtw_std_list_List_1_Cons();
				VAL v7 = pop_value();
				uint64_t v8 = (1LL /* True */);
				lpush(&lbl_withses, v7);
				push_u64(v8);
			} break;
			case 6LL: { // STConsLabel
				mtp_mirth_type_StackType_STConsLabel();
				VAL v9 = pop_value();
				mtw_std_either_Either_2_Left();
				VAL v10 = pop_value();
				mp_primZ_packZ_nil();
				push_value(v10);
				mp_primZ_packZ_cons();
				push_value(v9);
				mp_primZ_packZ_cons();
				VAL v11 = (lpop(&lbl_labels));
				push_value(v11);
				mtw_std_list_List_1_Cons();
				VAL v12 = pop_value();
				uint64_t v13 = (1LL /* True */);
				lpush(&lbl_labels, v12);
				push_u64(v13);
			} break;
			case 8LL: { // STWithLabel
				mtp_mirth_type_StackType_STWithLabel();
				VAL v14 = pop_value();
				mtw_std_either_Either_2_Right();
				VAL v15 = pop_value();
				mp_primZ_packZ_nil();
				push_value(v15);
				mp_primZ_packZ_cons();
				push_value(v14);
				mp_primZ_packZ_cons();
				VAL v16 = (lpop(&lbl_labels));
				push_value(v16);
				mtw_std_list_List_1_Cons();
				VAL v17 = pop_value();
				uint64_t v18 = (1LL /* True */);
				lpush(&lbl_labels, v17);
				push_u64(v18);
			} break;
			default: {
				uint64_t v19 = (0LL /* False */);
				push_u64(v19);
			} break;
		}
		VAL v20 = pop_value();
		if (!VBOOL(v20)) break;
	}
	VAL v21 = (lpop(&lbl_labels));
	VAL v22 = (lpop(&lbl_conses));
	VAL v23 = (lpop(&lbl_withses));
	push_value(v21);
	push_value(v22);
	push_value(v23);
}
static void mw_mirth_type_StackType_base (void) {
	mw_mirth_type_StackType_split4();
	VAL v0 = pop_value();
	decref(v0);
	VAL v1 = pop_value();
	decref(v1);
	VAL v2 = pop_value();
	decref(v2);
}
static void mw_mirth_type_StackType_labelZ_topZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v0 = pop_value();
			decref(v0);
			mw_mirth_type_StackType_labelZ_topZAsk();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v1 = pop_value();
			decref(v1);
			mw_mirth_type_StackType_labelZ_topZAsk();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			incref(v5);
			incref(v2);
			push_value(v5);
			push_value(v4);
			push_value(v3);
			push_value(v2);
			push_value(v5);
			push_value(v2);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				VAL v7 = pop_value();
				decref(v7);
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				decref(v9);
				VAL v10 = pop_value();
				decref(v10);
				push_value(v8);
				mtw_std_either_Either_2_Left();
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v11 = pop_value();
				decref(v11);
				VAL v12 = pop_value();
				decref(v12);
				mw_mirth_type_StackType_labelZ_topZAsk();
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			incref(v16);
			incref(v13);
			push_value(v16);
			push_value(v15);
			push_value(v14);
			push_value(v13);
			push_value(v16);
			push_value(v13);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v17 = pop_value();
			if (VBOOL(v17)) {
				VAL v18 = pop_value();
				decref(v18);
				VAL v19 = pop_value();
				VAL v20 = pop_value();
				decref(v20);
				VAL v21 = pop_value();
				decref(v21);
				push_value(v19);
				mtw_std_either_Either_2_Right();
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v22 = pop_value();
				decref(v22);
				VAL v23 = pop_value();
				decref(v23);
				mw_mirth_type_StackType_labelZ_topZAsk();
			}
		} break;
		default: {
			VAL v24 = pop_value();
			decref(v24);
			VAL v25 = pop_value();
			decref(v25);
			uint64_t v26 = (0LL /* None */);
			push_u64(v26);
		} break;
	}
}
static void mw_mirth_type_StackType_topZ_typeZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v0 = pop_value();
			decref(v0);
			mw_mirth_type_StackType_topZ_typeZAsk();
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = pop_value();
			decref(v4);
			mw_mirth_type_StackType_topZ_typeZAsk();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			mw_mirth_type_StackType_topZ_typeZAsk();
		} break;
		default: {
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (0LL /* None */);
			push_u64(v8);
		} break;
	}
}
static void mw_mirth_type_StackType_topZ_tyconZAsk (void) {
	mw_mirth_type_StackType_topZ_typeZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_type_Type_tyconZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_topZ_resourceZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			decref(v1);
			push_value(v0);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v2 = pop_value();
			decref(v2);
			mw_mirth_type_StackType_topZ_resourceZAsk();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = pop_value();
			decref(v4);
			mw_mirth_type_StackType_topZ_resourceZAsk();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			mw_mirth_type_StackType_topZ_resourceZAsk();
		} break;
		default: {
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (0LL /* None */);
			push_u64(v8);
		} break;
	}
}
static void mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk (void) {
	mw_mirth_type_StackType_topZ_resourceZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_type_Resource_ZToType();
			mw_mirth_type_Type_tyconZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_topZ_namespaces (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mw_mirth_type_StackType_topZ_tyconZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_mirth_name_Namespace_NAMESPACEz_TYCON();
			mtp_std_list_ZPlusList_1_ZPlusList();
			mtw_std_list_List_1_Cons();
			mtw_std_list_ZPlusList_1_ZPlusList();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_type_StackType_topZ_resourceZ_tyconZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_mirth_name_Namespace_NAMESPACEz_TYCON();
			mtp_std_list_ZPlusList_1_ZPlusList();
			mtw_std_list_List_1_Cons();
			mtw_std_list_ZPlusList_1_ZPlusList();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
}
static void mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk();
	} else {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	decref(v5);
	push_value(v4);
}
static void mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			decref(v1);
			push_value(v0);
			mw_mirth_type_Type_errorZAsk();
			VAL v2 = pop_value();
			if (VBOOL(v2)) {
				uint64_t v3 = (0LL /* False */);
				push_u64(v3);
			} else {
				uint64_t v4 = (1LL /* True */);
				push_u64(v4);
			}
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v7 = pop_value();
			decref(v7);
			mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v8 = pop_value();
			decref(v8);
			VAL v9 = pop_value();
			decref(v9);
			mw_mirth_type_StackType_topZ_valueZ_isZ_fineZAsk();
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (1LL /* True */);
			push_u64(v11);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (1LL /* True */);
			push_u64(v13);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v14 = (1LL /* True */);
			push_u64(v14);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v15 = (0LL /* False */);
			push_u64(v15);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v16 = (0LL /* False */);
			push_u64(v16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v0 = pop_value();
			decref(v0);
			mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v1 = pop_value();
			decref(v1);
			VAL v2 = pop_value();
			decref(v2);
			mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			decref(v4);
			push_value(v3);
			mw_mirth_type_Type_errorZAsk();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				uint64_t v6 = (0LL /* False */);
				push_u64(v6);
			} else {
				uint64_t v7 = (1LL /* True */);
				push_u64(v7);
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v8 = pop_value();
			decref(v8);
			VAL v9 = pop_value();
			decref(v9);
			mw_mirth_type_StackType_topZ_resourceZ_isZ_fineZAsk();
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (1LL /* True */);
			push_u64(v11);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (1LL /* True */);
			push_u64(v13);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v14 = (1LL /* True */);
			push_u64(v14);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v15 = (0LL /* False */);
			push_u64(v15);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v16 = (0LL /* False */);
			push_u64(v16);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_hasZ_metaZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_ZEqualZEqual();
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* False */);
			push_u64(v3);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* False */);
			push_u64(v6);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (0LL /* False */);
			push_u64(v8);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			incref(v11);
			push_value(v11);
			push_value(v10);
			push_value(v11);
			push_value(v9);
			mw_mirth_type_Type_hasZ_metaZAsk();
			VAL v12 = pop_value();
			if (VBOOL(v12)) {
				VAL v13 = pop_value();
				decref(v13);
				VAL v14 = pop_value();
				decref(v14);
				uint64_t v15 = (1LL /* True */);
				push_u64(v15);
			} else {
				mw_mirth_type_StackType_hasZ_metaZAsk();
			}
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v16 = pop_value();
			decref(v16);
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			incref(v19);
			push_value(v19);
			push_value(v18);
			push_value(v19);
			push_value(v17);
			mw_mirth_type_Type_hasZ_metaZAsk();
			VAL v20 = pop_value();
			if (VBOOL(v20)) {
				VAL v21 = pop_value();
				decref(v21);
				VAL v22 = pop_value();
				decref(v22);
				uint64_t v23 = (1LL /* True */);
				push_u64(v23);
			} else {
				mw_mirth_type_StackType_hasZ_metaZAsk();
			}
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			incref(v26);
			push_value(v26);
			push_value(v25);
			push_value(v26);
			push_value(v24);
			mw_mirth_type_Resource_hasZ_metaZAsk();
			VAL v27 = pop_value();
			if (VBOOL(v27)) {
				VAL v28 = pop_value();
				decref(v28);
				VAL v29 = pop_value();
				decref(v29);
				uint64_t v30 = (1LL /* True */);
				push_u64(v30);
			} else {
				mw_mirth_type_StackType_hasZ_metaZAsk();
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v31 = pop_value();
			decref(v31);
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			VAL v34 = pop_value();
			incref(v34);
			push_value(v34);
			push_value(v33);
			push_value(v34);
			push_value(v32);
			mw_mirth_type_Resource_hasZ_metaZAsk();
			VAL v35 = pop_value();
			if (VBOOL(v35)) {
				VAL v36 = pop_value();
				decref(v36);
				VAL v37 = pop_value();
				decref(v37);
				uint64_t v38 = (1LL /* True */);
				push_u64(v38);
			} else {
				mw_mirth_type_StackType_hasZ_metaZAsk();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_unifyZ_failedZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_StackType_ZToType();
	push_value(v0);
	mw_mirth_type_StackType_ZToType();
	mw_mirth_type_Type_unifyZ_failedZBang();
	mw_mirth_type_Type_ZToStackType();
}
static void mw_mirth_type_StackType_unifyZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			mw_mirth_type_StackType_unifyZ_errorZBang();
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			mw_mirth_type_StackType_expand();
			switch (get_top_data_tag()) {
				case 0LL: { // STACK_TYPE_ERROR
					(void)pop_u64();
					mtw_mirth_type_StackType_STMeta();
					mw_mirth_type_StackType_unifyZ_errorZBang();
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_StackType_STMeta();
				} break;
				case 4LL: { // STMeta
					mtp_mirth_type_StackType_STMeta();
					VAL v4 = pop_value();
					mtw_mirth_type_Type_TMeta();
					push_value(v4);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				default: {
					mw_mirth_type_StackType_ZToType();
					VAL v5 = pop_value();
					VAL v6 = pop_value();
					push_value(v5);
					push_value(v6);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
			}
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			push_value(v7);
			push_value(v8);
			mw_mirth_type_StackType_expand();
			switch (get_top_data_tag()) {
				case 0LL: { // STACK_TYPE_ERROR
					(void)pop_u64();
					VAL v9 = pop_value();
					decref(v9);
					uint64_t v10 = (0LL /* STACK_TYPE_ERROR */);
					push_u64(v10);
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_StackType_STVar();
				} break;
				case 4LL: { // STMeta
					mtp_mirth_type_StackType_STMeta();
					VAL v11 = pop_value();
					mtw_mirth_type_Type_TVar();
					push_value(v11);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				case 3LL: { // STVar
					mtp_mirth_type_StackType_STVar();
					mw_mirth_var_Var_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				default: {
					VAL v12 = pop_value();
					mtw_mirth_type_StackType_STVar();
					push_value(v12);
					mw_mirth_type_StackType_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			mw_mirth_type_StackType_expand();
			switch (get_top_data_tag()) {
				case 0LL: { // STACK_TYPE_ERROR
					(void)pop_u64();
					uint64_t v13 = (0LL /* STACK_TYPE_ERROR */);
					push_u64(v13);
				} break;
				case 4LL: { // STMeta
					mtp_mirth_type_StackType_STMeta();
					VAL v14 = pop_value();
					uint64_t v15 = (2LL /* STACK_TYPE_UNIT */);
					push_u64(v15);
					mw_mirth_type_StackType_ZToType();
					push_value(v14);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					uint64_t v16 = (2LL /* STACK_TYPE_UNIT */);
					push_u64(v16);
				} break;
				case 2LL: { // STACK_TYPE_UNIT
					(void)pop_u64();
					uint64_t v17 = (2LL /* STACK_TYPE_UNIT */);
					push_u64(v17);
				} break;
				default: {
					uint64_t v18 = (2LL /* STACK_TYPE_UNIT */);
					push_u64(v18);
					mw_mirth_type_StackType_unifyZ_failedZBang();
				} break;
			}
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			push_value(v20);
			push_value(v19);
			push_value(v21);
			mw_mirth_type_StackType_expand();
			switch (get_top_data_tag()) {
				case 0LL: { // STACK_TYPE_ERROR
					(void)pop_u64();
					mtw_mirth_type_StackType_STCons();
					mw_mirth_type_StackType_unifyZ_errorZBang();
				} break;
				case 4LL: { // STMeta
					mtp_mirth_type_StackType_STMeta();
					VAL v22 = pop_value();
					mtw_mirth_type_StackType_STCons();
					mw_mirth_type_StackType_ZToType();
					push_value(v22);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_StackType_STCons();
				} break;
				default: {
					VAL v23 = pop_value();
					incref(v23);
					push_value(v23);
					push_value(v23);
					mw_mirth_type_StackType_forceZ_consZAskZBang();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v24 = pop_value();
							VAL v25 = pop_value();
							decref(v25);
							push_value(v24);
							mp_primZ_packZ_uncons();
							VAL v26 = pop_value();
							mp_primZ_packZ_uncons();
							VAL v27 = pop_value();
							VAL v28 = pop_value();
							decref(v28);
							VAL v29 = pop_value();
							push_value(v27);
							mw_mirth_type_StackType_unifyZBang();
							push_value(v29);
							push_value(v26);
							mw_mirth_type_Type_unifyZBang();
							mtw_mirth_type_StackType_STCons();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v30 = pop_value();
							mtw_mirth_type_StackType_STCons();
							push_value(v30);
							mw_mirth_type_StackType_unifyZ_failedZBang();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
			}
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			push_value(v32);
			push_value(v31);
			push_value(v33);
			mw_mirth_type_StackType_expand();
			switch (get_top_data_tag()) {
				case 0LL: { // STACK_TYPE_ERROR
					(void)pop_u64();
					mtw_mirth_type_StackType_STWith();
					mw_mirth_type_StackType_unifyZ_errorZBang();
				} break;
				case 4LL: { // STMeta
					mtp_mirth_type_StackType_STMeta();
					VAL v34 = pop_value();
					mtw_mirth_type_StackType_STWith();
					mw_mirth_type_StackType_ZToType();
					push_value(v34);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_StackType_STWith();
				} break;
				default: {
					VAL v35 = pop_value();
					incref(v35);
					push_value(v35);
					push_value(v35);
					mw_mirth_type_StackType_forceZ_withZAskZBang();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v36 = pop_value();
							VAL v37 = pop_value();
							decref(v37);
							push_value(v36);
							mp_primZ_packZ_uncons();
							VAL v38 = pop_value();
							mp_primZ_packZ_uncons();
							VAL v39 = pop_value();
							VAL v40 = pop_value();
							decref(v40);
							VAL v41 = pop_value();
							push_value(v39);
							mw_mirth_type_StackType_unifyZBang();
							push_value(v41);
							push_value(v38);
							mw_mirth_type_Resource_unifyZBang();
							mtw_mirth_type_StackType_STWith();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v42 = pop_value();
							mtw_mirth_type_StackType_STWith();
							push_value(v42);
							mw_mirth_type_StackType_unifyZ_failedZBang();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
			}
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v43 = pop_value();
			VAL v44 = pop_value();
			VAL v45 = pop_value();
			VAL v46 = pop_value();
			push_value(v45);
			push_value(v44);
			push_value(v43);
			push_value(v46);
			mw_mirth_type_StackType_expand();
			switch (get_top_data_tag()) {
				case 0LL: { // STACK_TYPE_ERROR
					(void)pop_u64();
					mtw_mirth_type_StackType_STConsLabel();
					mw_mirth_type_StackType_unifyZ_errorZBang();
				} break;
				case 4LL: { // STMeta
					mtp_mirth_type_StackType_STMeta();
					VAL v47 = pop_value();
					mtw_mirth_type_StackType_STConsLabel();
					mw_mirth_type_StackType_ZToType();
					push_value(v47);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_StackType_STConsLabel();
				} break;
				default: {
					VAL v48 = pop_value();
					VAL v49 = pop_value();
					incref(v49);
					incref(v48);
					push_value(v49);
					push_value(v48);
					push_value(v49);
					push_value(v48);
					mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v50 = pop_value();
							VAL v51 = pop_value();
							decref(v51);
							VAL v52 = pop_value();
							push_value(v50);
							mp_primZ_packZ_uncons();
							VAL v53 = pop_value();
							mp_primZ_packZ_uncons();
							VAL v54 = pop_value();
							VAL v55 = pop_value();
							decref(v55);
							VAL v56 = pop_value();
							push_value(v54);
							mw_mirth_type_StackType_unifyZBang();
							push_value(v56);
							push_value(v53);
							mw_mirth_type_Type_unifyZBang();
							push_value(v52);
							mtw_mirth_type_StackType_STConsLabel();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v57 = pop_value();
							mtw_mirth_type_StackType_STConsLabel();
							push_value(v57);
							mw_mirth_type_StackType_unifyZ_failedZBang();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v58 = pop_value();
			VAL v59 = pop_value();
			VAL v60 = pop_value();
			VAL v61 = pop_value();
			push_value(v60);
			push_value(v59);
			push_value(v58);
			push_value(v61);
			mw_mirth_type_StackType_expand();
			switch (get_top_data_tag()) {
				case 0LL: { // STACK_TYPE_ERROR
					(void)pop_u64();
					mtw_mirth_type_StackType_STWithLabel();
					mw_mirth_type_StackType_unifyZ_errorZBang();
				} break;
				case 4LL: { // STMeta
					mtp_mirth_type_StackType_STMeta();
					VAL v62 = pop_value();
					mtw_mirth_type_StackType_STWithLabel();
					mw_mirth_type_StackType_ZToType();
					push_value(v62);
					mw_mirth_type_MetaVar_unifyZBang();
					mw_mirth_type_Type_ZToStackType();
				} break;
				case 1LL: { // STACK_TYPE_DONT_CARE
					(void)pop_u64();
					mtw_mirth_type_StackType_STWithLabel();
				} break;
				default: {
					VAL v63 = pop_value();
					VAL v64 = pop_value();
					incref(v64);
					incref(v63);
					push_value(v64);
					push_value(v63);
					push_value(v64);
					push_value(v63);
					mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v65 = pop_value();
							VAL v66 = pop_value();
							decref(v66);
							VAL v67 = pop_value();
							push_value(v65);
							mp_primZ_packZ_uncons();
							VAL v68 = pop_value();
							mp_primZ_packZ_uncons();
							VAL v69 = pop_value();
							VAL v70 = pop_value();
							decref(v70);
							VAL v71 = pop_value();
							push_value(v69);
							mw_mirth_type_StackType_unifyZBang();
							push_value(v71);
							push_value(v68);
							mw_mirth_type_Resource_unifyZBang();
							push_value(v67);
							mtw_mirth_type_StackType_STWithLabel();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v72 = pop_value();
							mtw_mirth_type_StackType_STWithLabel();
							push_value(v72);
							mw_mirth_type_StackType_unifyZ_failedZBang();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_unifyZ_errorZBang (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v0);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v1 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v1);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v2 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v2);
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_unifyZ_errorZBang();
			mw_mirth_type_Type_ZToStackType();
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v4);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v5 = pop_value();
			mw_mirth_type_StackType_unifyZ_errorZBang();
			VAL v6 = pop_value();
			decref(v6);
			push_value(v5);
			mw_mirth_type_Type_unifyZ_errorZBang();
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v8);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v9 = pop_value();
			mw_mirth_type_StackType_unifyZ_errorZBang();
			VAL v10 = pop_value();
			decref(v10);
			push_value(v9);
			mw_mirth_type_Resource_unifyZ_errorZBang();
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v12);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v13 = pop_value();
			decref(v13);
			VAL v14 = pop_value();
			mw_mirth_type_StackType_unifyZ_errorZBang();
			VAL v15 = pop_value();
			decref(v15);
			push_value(v14);
			mw_mirth_type_Type_unifyZ_errorZBang();
			VAL v16 = pop_value();
			decref(v16);
			uint64_t v17 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v17);
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v18 = pop_value();
			decref(v18);
			VAL v19 = pop_value();
			mw_mirth_type_StackType_unifyZ_errorZBang();
			VAL v20 = pop_value();
			decref(v20);
			push_value(v19);
			mw_mirth_type_Resource_unifyZ_errorZBang();
			VAL v21 = pop_value();
			decref(v21);
			uint64_t v22 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v22);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* STACK_TYPE_ERROR */);
			uint64_t v2 = (0LL /* TYPE_ERROR */);
			mp_primZ_packZ_nil();
			push_u64(v1);
			mp_primZ_packZ_cons();
			push_u64(v2);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (1LL /* STACK_TYPE_DONT_CARE */);
			uint64_t v5 = (1LL /* TYPE_DONT_CARE */);
			mp_primZ_packZ_nil();
			push_u64(v4);
			mp_primZ_packZ_cons();
			push_u64(v5);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* None */);
			push_u64(v7);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v8 = pop_value();
			decref(v8);
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v11 = pop_value();
			mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang();
			VAL v12 = pop_value();
			push_value(v11);
			push_value(v12);
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v13 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v14 = pop_value();
					VAL v15 = pop_value();
					decref(v15);
					VAL v16 = pop_value();
					incref(v16);
					push_value(v16);
					push_value(v14);
					push_value(v16);
					mtw_mirth_type_StackType_STWith();
					VAL v17 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v17);
					mp_primZ_packZ_cons();
					push_value(v13);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v18 = (0LL /* None */);
					push_u64(v18);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			decref(v20);
			push_value(v19);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v21 = pop_value();
			mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang();
			VAL v22 = pop_value();
			push_value(v21);
			push_value(v22);
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v23 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					decref(v25);
					VAL v26 = pop_value();
					incref(v26);
					push_value(v26);
					push_value(v24);
					push_value(v26);
					mtw_mirth_type_StackType_STCons();
					VAL v27 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v27);
					mp_primZ_packZ_cons();
					push_value(v23);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v28 = (0LL /* None */);
					push_u64(v28);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			decref(v30);
			push_value(v29);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			VAL v34 = pop_value();
			incref(v34);
			incref(v31);
			push_value(v34);
			push_value(v33);
			push_value(v32);
			push_value(v31);
			push_value(v34);
			push_value(v31);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v35 = pop_value();
			if (VBOOL(v35)) {
				VAL v36 = pop_value();
				decref(v36);
				VAL v37 = pop_value();
				VAL v38 = pop_value();
				VAL v39 = pop_value();
				decref(v39);
				mp_primZ_packZ_nil();
				push_value(v38);
				mp_primZ_packZ_cons();
				push_value(v37);
				mp_primZ_packZ_cons();
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v40 = pop_value();
				VAL v41 = pop_value();
				mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang();
				VAL v42 = pop_value();
				push_value(v41);
				push_value(v40);
				push_value(v42);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mp_primZ_packZ_uncons();
						VAL v43 = pop_value();
						mp_primZ_packZ_uncons();
						VAL v44 = pop_value();
						VAL v45 = pop_value();
						decref(v45);
						VAL v46 = pop_value();
						VAL v47 = pop_value();
						push_value(v44);
						push_value(v47);
						push_value(v46);
						mtw_mirth_type_StackType_STConsLabel();
						VAL v48 = pop_value();
						mp_primZ_packZ_nil();
						push_value(v48);
						mp_primZ_packZ_cons();
						push_value(v43);
						mp_primZ_packZ_cons();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						VAL v49 = pop_value();
						decref(v49);
						VAL v50 = pop_value();
						decref(v50);
						uint64_t v51 = (0LL /* None */);
						push_u64(v51);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v52 = pop_value();
			VAL v53 = pop_value();
			VAL v54 = pop_value();
			VAL v55 = pop_value();
			incref(v55);
			incref(v52);
			push_value(v55);
			push_value(v54);
			push_value(v53);
			push_value(v52);
			push_value(v55);
			push_value(v52);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v56 = pop_value();
			if (VBOOL(v56)) {
				VAL v57 = pop_value();
				decref(v57);
				VAL v58 = pop_value();
				decref(v58);
				VAL v59 = pop_value();
				decref(v59);
				VAL v60 = pop_value();
				decref(v60);
				uint64_t v61 = (0LL /* None */);
				push_u64(v61);
			} else {
				VAL v62 = pop_value();
				VAL v63 = pop_value();
				mw_mirth_type_StackType_forceZ_consZ_labelZAskZBang();
				VAL v64 = pop_value();
				push_value(v63);
				push_value(v62);
				push_value(v64);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mp_primZ_packZ_uncons();
						VAL v65 = pop_value();
						mp_primZ_packZ_uncons();
						VAL v66 = pop_value();
						VAL v67 = pop_value();
						decref(v67);
						VAL v68 = pop_value();
						VAL v69 = pop_value();
						push_value(v66);
						push_value(v69);
						push_value(v68);
						mtw_mirth_type_StackType_STWithLabel();
						VAL v70 = pop_value();
						mp_primZ_packZ_nil();
						push_value(v70);
						mp_primZ_packZ_cons();
						push_value(v65);
						mp_primZ_packZ_cons();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						VAL v71 = pop_value();
						decref(v71);
						VAL v72 = pop_value();
						decref(v72);
						uint64_t v73 = (0LL /* None */);
						push_u64(v73);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			}
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v74 = pop_value();
			VAL v75 = pop_value();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_Type_TMeta();
			VAL v76 = pop_value();
			VAL v77 = pop_value();
			incref(v77);
			incref(v76);
			push_value(v77);
			push_value(v76);
			push_value(v77);
			push_value(v76);
			push_value(v75);
			mtw_mirth_type_StackType_STConsLabel();
			mw_mirth_type_StackType_ZToType();
			mtw_std_maybe_Maybe_1_Some();
			push_value(v74);
			mfld_mirth_type_MetaVar_ZTildetypeZAsk();
			mp_primZ_mutZ_set();
			VAL v78 = pop_value();
			VAL v79 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v79);
			mp_primZ_packZ_cons();
			push_value(v78);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* STACK_TYPE_ERROR */);
			uint64_t v2 = (0LL /* TYPE_ERROR */);
			mp_primZ_packZ_nil();
			push_u64(v1);
			mp_primZ_packZ_cons();
			push_u64(v2);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (1LL /* STACK_TYPE_DONT_CARE */);
			uint64_t v5 = (1LL /* TYPE_DONT_CARE */);
			mp_primZ_packZ_nil();
			push_u64(v4);
			mp_primZ_packZ_cons();
			push_u64(v5);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* None */);
			push_u64(v7);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v8 = pop_value();
			decref(v8);
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v11 = pop_value();
			mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang();
			VAL v12 = pop_value();
			push_value(v11);
			push_value(v12);
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v13 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v14 = pop_value();
					VAL v15 = pop_value();
					decref(v15);
					VAL v16 = pop_value();
					incref(v16);
					push_value(v16);
					push_value(v14);
					push_value(v16);
					mtw_mirth_type_StackType_STWith();
					VAL v17 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v17);
					mp_primZ_packZ_cons();
					push_value(v13);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v18 = (0LL /* None */);
					push_u64(v18);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			decref(v20);
			push_value(v19);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v21 = pop_value();
			mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang();
			VAL v22 = pop_value();
			push_value(v21);
			push_value(v22);
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v23 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					decref(v25);
					VAL v26 = pop_value();
					incref(v26);
					push_value(v26);
					push_value(v24);
					push_value(v26);
					mtw_mirth_type_StackType_STCons();
					VAL v27 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v27);
					mp_primZ_packZ_cons();
					push_value(v23);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v28 = (0LL /* None */);
					push_u64(v28);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			decref(v30);
			push_value(v29);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			VAL v34 = pop_value();
			incref(v34);
			incref(v31);
			push_value(v34);
			push_value(v33);
			push_value(v32);
			push_value(v31);
			push_value(v34);
			push_value(v31);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v35 = pop_value();
			if (VBOOL(v35)) {
				VAL v36 = pop_value();
				decref(v36);
				VAL v37 = pop_value();
				decref(v37);
				VAL v38 = pop_value();
				decref(v38);
				VAL v39 = pop_value();
				decref(v39);
				uint64_t v40 = (0LL /* None */);
				push_u64(v40);
			} else {
				VAL v41 = pop_value();
				VAL v42 = pop_value();
				mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang();
				VAL v43 = pop_value();
				push_value(v42);
				push_value(v41);
				push_value(v43);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mp_primZ_packZ_uncons();
						VAL v44 = pop_value();
						mp_primZ_packZ_uncons();
						VAL v45 = pop_value();
						VAL v46 = pop_value();
						decref(v46);
						VAL v47 = pop_value();
						VAL v48 = pop_value();
						push_value(v45);
						push_value(v48);
						push_value(v47);
						mtw_mirth_type_StackType_STConsLabel();
						VAL v49 = pop_value();
						mp_primZ_packZ_nil();
						push_value(v49);
						mp_primZ_packZ_cons();
						push_value(v44);
						mp_primZ_packZ_cons();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						VAL v50 = pop_value();
						decref(v50);
						VAL v51 = pop_value();
						decref(v51);
						uint64_t v52 = (0LL /* None */);
						push_u64(v52);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v53 = pop_value();
			VAL v54 = pop_value();
			VAL v55 = pop_value();
			VAL v56 = pop_value();
			incref(v56);
			incref(v53);
			push_value(v56);
			push_value(v55);
			push_value(v54);
			push_value(v53);
			push_value(v56);
			push_value(v53);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v57 = pop_value();
			if (VBOOL(v57)) {
				VAL v58 = pop_value();
				decref(v58);
				VAL v59 = pop_value();
				VAL v60 = pop_value();
				VAL v61 = pop_value();
				decref(v61);
				mp_primZ_packZ_nil();
				push_value(v60);
				mp_primZ_packZ_cons();
				push_value(v59);
				mp_primZ_packZ_cons();
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v62 = pop_value();
				VAL v63 = pop_value();
				mw_mirth_type_StackType_forceZ_withZ_labelZAskZBang();
				VAL v64 = pop_value();
				push_value(v63);
				push_value(v62);
				push_value(v64);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mp_primZ_packZ_uncons();
						VAL v65 = pop_value();
						mp_primZ_packZ_uncons();
						VAL v66 = pop_value();
						VAL v67 = pop_value();
						decref(v67);
						VAL v68 = pop_value();
						VAL v69 = pop_value();
						push_value(v66);
						push_value(v69);
						push_value(v68);
						mtw_mirth_type_StackType_STWithLabel();
						VAL v70 = pop_value();
						mp_primZ_packZ_nil();
						push_value(v70);
						mp_primZ_packZ_cons();
						push_value(v65);
						mp_primZ_packZ_cons();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						VAL v71 = pop_value();
						decref(v71);
						VAL v72 = pop_value();
						decref(v72);
						uint64_t v73 = (0LL /* None */);
						push_u64(v73);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			}
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v74 = pop_value();
			VAL v75 = pop_value();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_Type_TMeta();
			VAL v76 = pop_value();
			VAL v77 = pop_value();
			incref(v77);
			incref(v76);
			push_value(v77);
			push_value(v76);
			push_value(v77);
			push_value(v76);
			push_value(v75);
			mtw_mirth_type_StackType_STWithLabel();
			mw_mirth_type_StackType_ZToType();
			mtw_std_maybe_Maybe_1_Some();
			push_value(v74);
			mfld_mirth_type_MetaVar_ZTildetypeZAsk();
			mp_primZ_mutZ_set();
			VAL v78 = pop_value();
			VAL v79 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v79);
			mp_primZ_packZ_cons();
			push_value(v78);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_forceZ_consZAskZBang (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
			uint64_t v1 = (0LL /* TYPE_ERROR */);
			mp_primZ_packZ_nil();
			push_u64(v0);
			mp_primZ_packZ_cons();
			push_u64(v1);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v2 = (1LL /* STACK_TYPE_DONT_CARE */);
			uint64_t v3 = (1LL /* TYPE_DONT_CARE */);
			mp_primZ_packZ_nil();
			push_u64(v2);
			mp_primZ_packZ_cons();
			push_u64(v3);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v4 = (0LL /* None */);
			push_u64(v4);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* None */);
			push_u64(v6);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v8);
			mp_primZ_packZ_cons();
			push_value(v7);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			push_value(v9);
			push_value(v10);
			mw_mirth_type_StackType_forceZ_consZAskZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v11 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v12 = pop_value();
					VAL v13 = pop_value();
					decref(v13);
					VAL v14 = pop_value();
					incref(v14);
					push_value(v14);
					push_value(v12);
					push_value(v14);
					mtw_mirth_type_StackType_STWith();
					VAL v15 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v15);
					mp_primZ_packZ_cons();
					push_value(v11);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v16 = (0LL /* None */);
					push_u64(v16);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			decref(v18);
			push_value(v17);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			push_value(v20);
			push_value(v19);
			push_value(v21);
			mw_mirth_type_StackType_forceZ_consZAskZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v22 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v23 = pop_value();
					VAL v24 = pop_value();
					decref(v24);
					VAL v25 = pop_value();
					VAL v26 = pop_value();
					push_value(v23);
					push_value(v26);
					push_value(v25);
					mtw_mirth_type_StackType_STConsLabel();
					VAL v27 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v27);
					mp_primZ_packZ_cons();
					push_value(v22);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v28 = pop_value();
					decref(v28);
					VAL v29 = pop_value();
					decref(v29);
					uint64_t v30 = (0LL /* None */);
					push_u64(v30);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			push_value(v32);
			push_value(v31);
			push_value(v33);
			mw_mirth_type_StackType_forceZ_consZAskZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v34 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v35 = pop_value();
					VAL v36 = pop_value();
					decref(v36);
					VAL v37 = pop_value();
					VAL v38 = pop_value();
					push_value(v35);
					push_value(v38);
					push_value(v37);
					mtw_mirth_type_StackType_STWithLabel();
					VAL v39 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v39);
					mp_primZ_packZ_cons();
					push_value(v34);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v40 = pop_value();
					decref(v40);
					VAL v41 = pop_value();
					decref(v41);
					uint64_t v42 = (0LL /* None */);
					push_u64(v42);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v43 = pop_value();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_Type_TMeta();
			VAL v44 = pop_value();
			VAL v45 = pop_value();
			incref(v45);
			incref(v44);
			push_value(v45);
			push_value(v44);
			push_value(v45);
			push_value(v44);
			mtw_mirth_type_StackType_STCons();
			mw_mirth_type_StackType_ZToType();
			mtw_std_maybe_Maybe_1_Some();
			push_value(v43);
			mfld_mirth_type_MetaVar_ZTildetypeZAsk();
			mp_primZ_mutZ_set();
			VAL v46 = pop_value();
			VAL v47 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v47);
			mp_primZ_packZ_cons();
			push_value(v46);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_forceZ_withZAskZBang (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
			uint64_t v1 = (0LL /* TYPE_ERROR */);
			mp_primZ_packZ_nil();
			push_u64(v0);
			mp_primZ_packZ_cons();
			push_u64(v1);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v2 = (1LL /* STACK_TYPE_DONT_CARE */);
			uint64_t v3 = (1LL /* TYPE_DONT_CARE */);
			mp_primZ_packZ_nil();
			push_u64(v2);
			mp_primZ_packZ_cons();
			push_u64(v3);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v4 = (0LL /* None */);
			push_u64(v4);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* None */);
			push_u64(v6);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v8);
			mp_primZ_packZ_cons();
			push_value(v7);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			push_value(v9);
			push_value(v10);
			mw_mirth_type_StackType_forceZ_withZAskZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v11 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v12 = pop_value();
					VAL v13 = pop_value();
					decref(v13);
					VAL v14 = pop_value();
					incref(v14);
					push_value(v14);
					push_value(v12);
					push_value(v14);
					mtw_mirth_type_StackType_STCons();
					VAL v15 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v15);
					mp_primZ_packZ_cons();
					push_value(v11);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v16 = (0LL /* None */);
					push_u64(v16);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			decref(v18);
			push_value(v17);
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			push_value(v20);
			push_value(v19);
			push_value(v21);
			mw_mirth_type_StackType_forceZ_withZAskZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v22 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v23 = pop_value();
					VAL v24 = pop_value();
					decref(v24);
					VAL v25 = pop_value();
					VAL v26 = pop_value();
					push_value(v23);
					push_value(v26);
					push_value(v25);
					mtw_mirth_type_StackType_STConsLabel();
					VAL v27 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v27);
					mp_primZ_packZ_cons();
					push_value(v22);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v28 = pop_value();
					decref(v28);
					VAL v29 = pop_value();
					decref(v29);
					uint64_t v30 = (0LL /* None */);
					push_u64(v30);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			push_value(v32);
			push_value(v31);
			push_value(v33);
			mw_mirth_type_StackType_forceZ_withZAskZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mp_primZ_packZ_uncons();
					VAL v34 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v35 = pop_value();
					VAL v36 = pop_value();
					decref(v36);
					VAL v37 = pop_value();
					VAL v38 = pop_value();
					push_value(v35);
					push_value(v38);
					push_value(v37);
					mtw_mirth_type_StackType_STWithLabel();
					VAL v39 = pop_value();
					mp_primZ_packZ_nil();
					push_value(v39);
					mp_primZ_packZ_cons();
					push_value(v34);
					mp_primZ_packZ_cons();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v40 = pop_value();
					decref(v40);
					VAL v41 = pop_value();
					decref(v41);
					uint64_t v42 = (0LL /* None */);
					push_u64(v42);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v43 = pop_value();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_Type_TMeta();
			VAL v44 = pop_value();
			VAL v45 = pop_value();
			incref(v45);
			incref(v44);
			push_value(v45);
			push_value(v44);
			push_value(v45);
			push_value(v44);
			mtw_mirth_type_StackType_STWith();
			mw_mirth_type_StackType_ZToType();
			mtw_std_maybe_Maybe_1_Some();
			push_value(v43);
			mfld_mirth_type_MetaVar_ZTildetypeZAsk();
			mp_primZ_mutZ_set();
			VAL v46 = pop_value();
			VAL v47 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v47);
			mp_primZ_packZ_cons();
			push_value(v46);
			mp_primZ_packZ_cons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_domZThen (void) {
	mw_mirth_type_StackType_expand();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_StackType_unitZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		decref(v2);
	} else {
		mw_mirth_type_StackType_stackZThen();
		STRLIT(" ", 1);
		mw_std_str_ZPlusStr_pushZ_strZBang();
	}
}
static void mw_mirth_type_StackType_codZThen (void) {
	mw_mirth_type_StackType_expand();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_StackType_unitZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		decref(v2);
	} else {
		STRLIT(" ", 1);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mw_mirth_type_StackType_stackZThen();
	}
}
static void mw_mirth_type_StackType_baseZThen (void) {
	switch (get_top_data_tag()) {
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			STRLIT("*", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_MetaVar_typeZThen();
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v2);
			mw_mirth_var_Var_isZ_stackZAsk();
			VAL v3 = pop_value();
			if (VBOOL(v3)) {
			} else {
				STRLIT("* ", 2);
				mw_std_str_ZPlusStr_pushZ_strZBang();
			}
			mw_mirth_var_Var_typeZThen();
			uint64_t v4 = (1LL /* True */);
			push_u64(v4);
		} break;
		default: {
			mw_mirth_type_StackType_ZToType();
			STRLIT("* ", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_mirth_type_Type_typeZThen();
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		} break;
	}
}
static void mw_mirth_type_StackType_stackZThen (void) {
	mw_mirth_type_StackType_split4();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	mw_mirth_type_StackType_baseZThen();
	push_value(v2);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v7);
		if (VBOOL(v9)) {
			STRLIT(" ", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} else {
		}
		mp_primZ_packZ_uncons();
		VAL v10 = pop_value();
		mp_primZ_packZ_uncons();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		decref(v12);
		push_value(v11);
		push_value(v10);
		mw_mirth_label_Label_ZToStr();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(":", 1);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				mw_mirth_type_Type_typeZThen();
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				mw_mirth_type_Resource_typeZThen();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		uint64_t v13 = (1LL /* True */);
		push_u64(v13);
		push_value(v8);
		mw_std_list_List_1_uncons();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v14);
		push_value(v15);
	}
	VAL v16 = pop_value();
	decref(v16);
	VAL v17 = pop_value();
	decref(v17);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v18 = pop_value();
	VAL v19 = pop_value();
	push_value(v18);
	push_value(v19);
	while(1) {
		VAL v20 = pop_value();
		incref(v20);
		push_value(v20);
		push_value(v20);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v21 = pop_value();
		if (!VBOOL(v21)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		push_value(v22);
		if (VBOOL(v24)) {
			STRLIT(" ", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} else {
		}
		mw_mirth_type_Type_typeZThen();
		uint64_t v25 = (1LL /* True */);
		push_u64(v25);
		push_value(v23);
		mw_std_list_List_1_uncons();
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		push_value(v26);
		push_value(v27);
	}
	VAL v28 = pop_value();
	decref(v28);
	VAL v29 = pop_value();
	decref(v29);
	push_value(v0);
	mw_std_list_List_1_uncons();
	VAL v30 = pop_value();
	VAL v31 = pop_value();
	push_value(v30);
	push_value(v31);
	while(1) {
		VAL v32 = pop_value();
		incref(v32);
		push_value(v32);
		push_value(v32);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v33 = pop_value();
		if (!VBOOL(v33)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v34 = pop_value();
		VAL v35 = pop_value();
		VAL v36 = pop_value();
		push_value(v34);
		if (VBOOL(v36)) {
			STRLIT(" ", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} else {
		}
		mw_mirth_type_Resource_typeZThen();
		uint64_t v37 = (1LL /* True */);
		push_u64(v37);
		push_value(v35);
		mw_std_list_List_1_uncons();
		VAL v38 = pop_value();
		VAL v39 = pop_value();
		push_value(v38);
		push_value(v39);
	}
	VAL v40 = pop_value();
	decref(v40);
	VAL v41 = pop_value();
	decref(v41);
	VAL v42 = pop_value();
	decref(v42);
}
static void mw_mirth_type_StackType_semifreshen (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v1 = pop_value();
			mw_mirth_type_StackType_semifreshen();
			push_value(v1);
			mtw_mirth_type_StackType_STCons();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v2 = pop_value();
			mw_mirth_type_StackType_semifreshen();
			push_value(v2);
			mtw_mirth_type_StackType_STWith();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			mw_mirth_type_StackType_semifreshen();
			push_value(v4);
			push_value(v3);
			mtw_mirth_type_StackType_STConsLabel();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			mw_mirth_type_StackType_semifreshen();
			push_value(v6);
			push_value(v5);
			mtw_mirth_type_StackType_STWithLabel();
		} break;
		default: {
			STRLIT("expected unit-based stack in semifreshen!", 41);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_type_StackType_freshen (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v0 = (2LL /* STACK_TYPE_UNIT */);
			push_u64(v0);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v1 = pop_value();
			mw_mirth_type_StackType_freshen();
			VAL v2 = pop_value();
			push_value(v1);
			mw_mirth_type_Type_freshen();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			mtw_mirth_type_StackType_STCons();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v4 = pop_value();
			mw_mirth_type_StackType_freshen();
			VAL v5 = pop_value();
			push_value(v4);
			mw_mirth_type_Resource_freshen();
			VAL v6 = pop_value();
			push_value(v5);
			push_value(v6);
			mtw_mirth_type_StackType_STWith();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			mw_mirth_type_StackType_freshen();
			VAL v9 = pop_value();
			push_value(v8);
			mw_mirth_type_Type_freshen();
			VAL v10 = pop_value();
			push_value(v9);
			push_value(v10);
			push_value(v7);
			mtw_mirth_type_StackType_STConsLabel();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			mw_mirth_type_StackType_freshen();
			VAL v13 = pop_value();
			push_value(v12);
			mw_mirth_type_Resource_freshen();
			VAL v14 = pop_value();
			push_value(v13);
			push_value(v14);
			push_value(v11);
			mtw_mirth_type_StackType_STWithLabel();
		} break;
		default: {
			mw_mirth_type_StackType_ZToType();
			mw_mirth_type_Type_freshen();
			mw_mirth_type_Type_ZToStackType();
		} break;
	}
}
static void mw_mirth_type_StackType_freshenZ_aux (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			incref(v1);
			push_value(v1);
			push_value(v0);
			push_value(v1);
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v2 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux();
			VAL v3 = pop_value();
			push_value(v2);
			mw_mirth_type_Type_freshen();
			VAL v4 = pop_value();
			push_value(v3);
			push_value(v4);
			mtw_mirth_type_StackType_STCons();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v5 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux();
			VAL v6 = pop_value();
			push_value(v5);
			mw_mirth_type_Resource_freshen();
			VAL v7 = pop_value();
			push_value(v6);
			push_value(v7);
			mtw_mirth_type_StackType_STWith();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux();
			VAL v10 = pop_value();
			push_value(v9);
			mw_mirth_type_Type_freshen();
			VAL v11 = pop_value();
			push_value(v10);
			push_value(v11);
			push_value(v8);
			mtw_mirth_type_StackType_STConsLabel();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			mw_mirth_type_StackType_freshenZ_aux();
			VAL v14 = pop_value();
			push_value(v13);
			mw_mirth_type_Resource_freshen();
			VAL v15 = pop_value();
			push_value(v14);
			push_value(v15);
			push_value(v12);
			mtw_mirth_type_StackType_STWithLabel();
		} break;
		default: {
			mw_mirth_type_StackType_ZToType();
			mw_mirth_type_Type_freshen();
			mw_mirth_type_Type_ZToStackType();
		} break;
	}
}
static void mw_mirth_type_StackType_rigidifyZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v0);
		} break;
		case 1LL: { // STACK_TYPE_DONT_CARE
			(void)pop_u64();
			uint64_t v1 = (1LL /* STACK_TYPE_DONT_CARE */);
			push_u64(v1);
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v2 = (2LL /* STACK_TYPE_UNIT */);
			push_u64(v2);
		} break;
		case 4LL: { // STMeta
			mtp_mirth_type_StackType_STMeta();
			VAL v3 = pop_value();
			incref(v3);
			push_value(v3);
			push_value(v3);
			mw_mirth_type_MetaVar_typeZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					VAL v4 = pop_value();
					mw_mirth_var_Ctx_freshZ_stackZ_typeZ_varZBang();
					mtw_mirth_type_Type_TVar();
					VAL v5 = pop_value();
					incref(v5);
					push_value(v5);
					push_value(v5);
					mtw_std_maybe_Maybe_1_Some();
					push_value(v4);
					mfld_mirth_type_MetaVar_ZTildetypeZAsk();
					mp_primZ_mutZ_set();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v6 = pop_value();
					VAL v7 = pop_value();
					decref(v7);
					push_value(v6);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			mw_mirth_type_Type_ZToStackType();
			mw_mirth_type_StackType_rigidifyZBang();
		} break;
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			mtw_mirth_type_StackType_STVar();
		} break;
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			VAL v8 = pop_value();
			mw_mirth_type_StackType_rigidifyZBang();
			VAL v9 = pop_value();
			push_value(v8);
			mw_mirth_type_Type_rigidifyZBang();
			VAL v10 = pop_value();
			push_value(v9);
			push_value(v10);
			mtw_mirth_type_StackType_STCons();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			mw_mirth_type_StackType_rigidifyZBang();
			VAL v13 = pop_value();
			push_value(v12);
			mw_mirth_type_Type_rigidifyZBang();
			VAL v14 = pop_value();
			push_value(v13);
			push_value(v14);
			push_value(v11);
			mtw_mirth_type_StackType_STConsLabel();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			VAL v15 = pop_value();
			mw_mirth_type_StackType_rigidifyZBang();
			VAL v16 = pop_value();
			push_value(v15);
			mw_mirth_type_Resource_rigidifyZBang();
			VAL v17 = pop_value();
			push_value(v16);
			push_value(v17);
			mtw_mirth_type_StackType_STWith();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			mw_mirth_type_StackType_rigidifyZBang();
			VAL v20 = pop_value();
			push_value(v19);
			mw_mirth_type_Resource_rigidifyZBang();
			VAL v21 = pop_value();
			push_value(v20);
			push_value(v21);
			push_value(v18);
			mtw_mirth_type_StackType_STWithLabel();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_ArrowType_ZToType (void) {
	mtw_mirth_type_Type_TMorphism();
}
static void mw_mirth_type_ArrowType_unpack (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // ARROW_TYPE
			mtp_mirth_type_ArrowType_ARROWz_TYPE();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_ArrowType_dom (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	decref(v0);
}
static void mw_mirth_type_ArrowType_cod (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	push_value(v0);
}
static void mw_mirth_type_ArrowType_unifyZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_ArrowType_unpack();
	push_value(v0);
	mw_mirth_type_ArrowType_unpack();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	mw_mirth_type_StackType_unifyZBang();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v1);
	mw_mirth_type_StackType_unifyZBang();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	mtw_mirth_type_ArrowType_ARROWz_TYPE();
}
static void mw_mirth_type_ArrowType_unifyZ_errorZBang (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	mw_mirth_type_StackType_unifyZ_errorZBang();
	VAL v1 = pop_value();
	push_value(v0);
	mw_mirth_type_StackType_unifyZ_errorZBang();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	mtw_mirth_type_ArrowType_ARROWz_TYPE();
}
static void mw_mirth_type_ArrowType_hasZ_metaZAsk (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	push_value(v0);
	mw_mirth_type_StackType_hasZ_metaZAsk();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = pop_value();
		decref(v4);
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (1LL /* True */);
		push_u64(v6);
	} else {
		mw_mirth_type_StackType_hasZ_metaZAsk();
	}
}
static void mw_mirth_type_ArrowType_sigZThen (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_type_StackType_domZThen();
	STRLIT("--", 2);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mw_mirth_type_StackType_codZThen();
}
static void mw_mirth_type_ArrowType_semifreshenZ_sig (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_type_ArrowType_semifreshenZ_aux();
	} else {
	}
}
static void mw_mirth_type_ArrowType_semifreshenZ_aux (void) {
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_type_ArrowType_unpack();
	VAL v2 = pop_value();
	mw_mirth_type_StackType_semifreshen();
	VAL v3 = pop_value();
	push_value(v2);
	mw_mirth_type_StackType_semifreshen();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	mtw_mirth_type_ArrowType_ARROWz_TYPE();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	decref(v6);
	push_value(v5);
}
static void mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk (void) {
	mw_mirth_type_ArrowType_unpack();
	mw_mirth_type_StackType_base();
	mw_mirth_type_StackType_unitZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_mirth_type_StackType_base();
		mw_mirth_type_StackType_unitZAsk();
	} else {
		VAL v1 = pop_value();
		decref(v1);
		uint64_t v2 = (0LL /* False */);
		push_u64(v2);
	}
}
static void mw_mirth_type_ArrowType_freshenZ_sig (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_ArrowType_needsZ_freshZ_stackZ_restZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_type_ArrowType_freshenZ_sigZ_aux();
	} else {
		mw_mirth_type_ArrowType_freshen();
	}
}
static void mw_mirth_type_ArrowType_freshenZ_sigZ_aux (void) {
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v0);
	push_value(v2);
	push_value(v1);
	mw_mirth_type_ArrowType_unpack();
	VAL v3 = pop_value();
	mw_mirth_type_StackType_freshenZ_aux();
	VAL v4 = pop_value();
	push_value(v3);
	mw_mirth_type_StackType_freshenZ_aux();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	mtw_mirth_type_ArrowType_ARROWz_TYPE();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
	push_value(v6);
}
static void mw_mirth_type_ArrowType_freshen (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	mw_mirth_type_StackType_freshen();
	VAL v1 = pop_value();
	push_value(v0);
	mw_mirth_type_StackType_freshen();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	mtw_mirth_type_ArrowType_ARROWz_TYPE();
}
static void mw_mirth_type_ArrowType_rigidifyZBang (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	mw_mirth_type_StackType_rigidifyZBang();
	VAL v1 = pop_value();
	push_value(v0);
	mw_mirth_type_StackType_rigidifyZBang();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	mtw_mirth_type_ArrowType_ARROWz_TYPE();
}
static void mw_mirth_type_ArrowType_rigidifyZ_sigZBang (void) {
	mw_mirth_type_ArrowType_rigidifyZBang();
}
static void mw_mirth_type_Subst_nil (void) {
	uint64_t v0 = (0LL /* SUBST_NIL */);
	push_u64(v0);
}
static void mw_mirth_type_Subst_cons (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v0);
	push_value(v2);
	push_value(v1);
	mtw_mirth_type_Subst_SUBSTz_CON();
}
static void mw_mirth_type_Subst_hasZ_varZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // SUBST_NIL
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		case 1LL: { // SUBST_CON
			mtp_mirth_type_Subst_SUBSTz_CON();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			incref(v5);
			push_value(v5);
			push_value(v4);
			push_value(v2);
			push_value(v5);
			mw_mirth_var_Var_ZEqualZEqual();
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				VAL v7 = pop_value();
				decref(v7);
				VAL v8 = pop_value();
				decref(v8);
				uint64_t v9 = (1LL /* True */);
				push_u64(v9);
			} else {
				mw_mirth_type_Subst_hasZ_varZAsk();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Subst_getZ_var (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // SUBST_NIL
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* TYPE_ERROR */);
			push_u64(v1);
		} break;
		case 1LL: { // SUBST_CON
			mtp_mirth_type_Subst_SUBSTz_CON();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			incref(v5);
			push_value(v5);
			push_value(v4);
			push_value(v3);
			push_value(v2);
			push_value(v5);
			mw_mirth_var_Var_ZEqualZEqual();
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				decref(v8);
				VAL v9 = pop_value();
				decref(v9);
				push_value(v7);
			} else {
				VAL v10 = pop_value();
				decref(v10);
				mw_mirth_type_Subst_getZ_var();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackTypePart_cons (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // STPCons
			mtp_mirth_type_StackTypePart_STPCons();
			mtw_mirth_type_StackType_STCons();
		} break;
		case 1LL: { // STPConsLabel
			mtp_mirth_type_StackTypePart_STPConsLabel();
			mtw_mirth_type_StackType_STConsLabel();
		} break;
		case 2LL: { // STPWith
			mtp_mirth_type_StackTypePart_STPWith();
			mtw_mirth_type_StackType_STWith();
		} break;
		case 3LL: { // STPWithLabel
			mtp_mirth_type_StackTypePart_STPWithLabel();
			mtw_mirth_type_StackType_STWithLabel();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_splitZ_parts (void) {
	uint64_t v0 = (0LL /* Nil */);
	lpush(&lbl_parts, MKU64(v0));
	switch (get_top_data_tag()) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			mtw_mirth_type_StackTypePart_STPCons();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 6LL: { // STConsLabel
			mtp_mirth_type_StackType_STConsLabel();
			mtw_mirth_type_StackTypePart_STPConsLabel();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			mtw_mirth_type_StackTypePart_STPWith();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 8LL: { // STWithLabel
			mtp_mirth_type_StackType_STWithLabel();
			mtw_mirth_type_StackTypePart_STPWithLabel();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = (lpop(&lbl_parts));
		push_value(v4);
		mtw_std_list_List_1_Cons();
		VAL v5 = pop_value();
		lpush(&lbl_parts, v5);
		switch (get_top_data_tag()) {
			case 5LL: { // STCons
				mtp_mirth_type_StackType_STCons();
				mtw_mirth_type_StackTypePart_STPCons();
				mtw_std_maybe_Maybe_1_Some();
			} break;
			case 6LL: { // STConsLabel
				mtp_mirth_type_StackType_STConsLabel();
				mtw_mirth_type_StackTypePart_STPConsLabel();
				mtw_std_maybe_Maybe_1_Some();
			} break;
			case 7LL: { // STWith
				mtp_mirth_type_StackType_STWith();
				mtw_mirth_type_StackTypePart_STPWith();
				mtw_std_maybe_Maybe_1_Some();
			} break;
			case 8LL: { // STWithLabel
				mtp_mirth_type_StackType_STWithLabel();
				mtw_mirth_type_StackTypePart_STPWithLabel();
				mtw_std_maybe_Maybe_1_Some();
			} break;
			default: {
				uint64_t v6 = (0LL /* None */);
				push_u64(v6);
			} break;
		}
	}
	VAL v7 = pop_value();
	decref(v7);
	VAL v8 = (lpop(&lbl_parts));
	push_value(v8);
}
static void mw_mirth_type_CType_cname (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // IntLike
			mtp_mirth_type_CType_IntLike();
		} break;
		case 1LL: { // F32Like
			mtp_mirth_type_CType_F32Like();
		} break;
		case 2LL: { // F64Like
			mtp_mirth_type_CType_F64Like();
		} break;
		case 3LL: { // PtrLike
			mtp_mirth_type_CType_PtrLike();
		} break;
		case 4LL: { // FnPtr
			mtp_mirth_type_CType_FnPtr();
		} break;
		case 5LL: { // Phantom
			(void)pop_u64();
			STRLIT("void", 4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CType_phantomZAsk (void) {
	switch (get_top_data_tag()) {
		case 5LL: { // Phantom
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_type_Resource_ctype (void) {
	mw_mirth_type_Type_ctype();
}
static void mw_mirth_type_Type_ctype (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_type_Type_ctypeZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			mw_mirth_type_Type_typeZThen();
			STRLIT(" doesn't have a C representation.", 33);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
			mw_mirth_mirth_ZPlusMirth_errorZBang();
			uint64_t v3 = (5LL /* Phantom */);
			push_u64(v3);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_Resource_ctypeZAsk (void) {
	mw_mirth_type_Type_ctypeZAsk();
}
static void mw_mirth_type_Type_ctypeZAsk (void) {
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 2LL: { // TPrim
			mtp_mirth_type_Type_TPrim();
			mw_mirth_type_PrimType_ctypeZAsk();
		} break;
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			mw_mirth_data_Data_ctypeZAsk();
		} break;
		case 10LL: { // TMorphism
			mtp_mirth_type_Type_TMorphism();
			VAL v0 = pop_value();
			decref(v0);
			STRLIT("FNPTR", 5);
			mtw_mirth_type_CType_FnPtr();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 11LL: { // TApp
			mtp_mirth_type_Type_TApp();
			mw_mirth_type_Type_ctypeZAsk();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v1 = pop_value();
					VAL v2 = pop_value();
					incref(v2);
					push_value(v2);
					push_value(v1);
					push_value(v2);
					mw_mirth_type_Type_ctype1ZAsk();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v3 = (0LL /* None */);
					push_u64(v3);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			decref(v5);
			push_value(v4);
		} break;
		default: {
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* None */);
			push_u64(v7);
		} break;
	}
}
static void mw_mirth_type_Type_ctype1ZAsk (void) {
	mw_mirth_type_Type_expand();
	switch (get_top_data_tag()) {
		case 7LL: { // TData
			mtp_mirth_type_Type_TData();
			mw_mirth_data_Data_ctype1ZAsk();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* None */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_type_PrimType_ctypeZAsk (void) {
	switch (get_top_data_tag()) {
		case 6LL: { // PRIM_TYPE_PTR
			(void)pop_u64();
			STRLIT("void*", 5);
			mtw_mirth_type_CType_PtrLike();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 8LL: { // PRIM_TYPE_WORLD
			(void)pop_u64();
			uint64_t v0 = (5LL /* Phantom */);
			push_u64(v0);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 4LL: { // PRIM_TYPE_F32
			(void)pop_u64();
			STRLIT("float", 5);
			mtw_mirth_type_CType_F32Like();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 5LL: { // PRIM_TYPE_F64
			(void)pop_u64();
			STRLIT("double", 6);
			mtw_mirth_type_CType_F64Like();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* None */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_data_Data_ctype1ZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[52];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_data_Data_ZEqualZEqual();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		decref(v2);
		mw_mirth_type_CType_cname();
		STRLIT(" *", 2);
		mp_primZ_strZ_cat();
		mtw_mirth_type_CType_PtrLike();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 9, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 62, v);
			VAL* p = &VTUP(v)->cells[54];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_data_Data_ZEqualZEqual();
		VAL v4 = pop_value();
		if (VBOOL(v4)) {
			VAL v5 = pop_value();
			decref(v5);
			switch (get_top_data_tag()) {
				case 0LL: { // IntLike
					mtp_mirth_type_CType_IntLike();
					STRLIT("const ", 6);
					VAL v6 = pop_value();
					VAL v7 = pop_value();
					push_value(v6);
					push_value(v7);
					mp_primZ_strZ_cat();
					mtw_mirth_type_CType_IntLike();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 1LL: { // F32Like
					mtp_mirth_type_CType_F32Like();
					STRLIT("const ", 6);
					VAL v8 = pop_value();
					VAL v9 = pop_value();
					push_value(v8);
					push_value(v9);
					mp_primZ_strZ_cat();
					mtw_mirth_type_CType_F32Like();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 2LL: { // F64Like
					mtp_mirth_type_CType_F64Like();
					STRLIT("const ", 6);
					VAL v10 = pop_value();
					VAL v11 = pop_value();
					push_value(v10);
					push_value(v11);
					mp_primZ_strZ_cat();
					mtw_mirth_type_CType_F64Like();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 4LL: { // FnPtr
					mtp_mirth_type_CType_FnPtr();
					STRLIT("const ", 6);
					VAL v12 = pop_value();
					VAL v13 = pop_value();
					push_value(v12);
					push_value(v13);
					mp_primZ_strZ_cat();
					mtw_mirth_type_CType_FnPtr();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 3LL: { // PtrLike
					mtp_mirth_type_CType_PtrLike();
					STRLIT(" const", 6);
					mp_primZ_strZ_cat();
					mtw_mirth_type_CType_PtrLike();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 5LL: { // Phantom
					(void)pop_u64();
					uint64_t v14 = (5LL /* Phantom */);
					push_u64(v14);
					mtw_std_maybe_Maybe_1_Some();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} else {
			VAL v15 = pop_value();
			incref(v15);
			push_value(v15);
			push_value(v15);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 62, v);
				VAL* p = &VTUP(v)->cells[56];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_data_Data_ZEqualZEqual();
			VAL v16 = pop_value();
			if (VBOOL(v16)) {
				VAL v17 = pop_value();
				decref(v17);
				switch (get_top_data_tag()) {
					case 0LL: { // IntLike
						mtp_mirth_type_CType_IntLike();
						STRLIT("restrict ", 9);
						VAL v18 = pop_value();
						VAL v19 = pop_value();
						push_value(v18);
						push_value(v19);
						mp_primZ_strZ_cat();
						mtw_mirth_type_CType_IntLike();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 1LL: { // F32Like
						mtp_mirth_type_CType_F32Like();
						STRLIT("restrict ", 9);
						VAL v20 = pop_value();
						VAL v21 = pop_value();
						push_value(v20);
						push_value(v21);
						mp_primZ_strZ_cat();
						mtw_mirth_type_CType_F32Like();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 2LL: { // F64Like
						mtp_mirth_type_CType_F64Like();
						STRLIT("restrict ", 9);
						VAL v22 = pop_value();
						VAL v23 = pop_value();
						push_value(v22);
						push_value(v23);
						mp_primZ_strZ_cat();
						mtw_mirth_type_CType_F64Like();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 4LL: { // FnPtr
						mtp_mirth_type_CType_FnPtr();
						STRLIT("restrict ", 9);
						VAL v24 = pop_value();
						VAL v25 = pop_value();
						push_value(v24);
						push_value(v25);
						mp_primZ_strZ_cat();
						mtw_mirth_type_CType_FnPtr();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 3LL: { // PtrLike
						mtp_mirth_type_CType_PtrLike();
						STRLIT(" restrict", 9);
						mp_primZ_strZ_cat();
						mtw_mirth_type_CType_PtrLike();
						mtw_std_maybe_Maybe_1_Some();
					} break;
					case 5LL: { // Phantom
						(void)pop_u64();
						uint64_t v26 = (5LL /* Phantom */);
						push_u64(v26);
						mtw_std_maybe_Maybe_1_Some();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			} else {
				VAL v27 = pop_value();
				incref(v27);
				push_value(v27);
				push_value(v27);
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 9, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 62, v);
					VAL* p = &VTUP(v)->cells[58];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_data_Data_ZEqualZEqual();
				VAL v28 = pop_value();
				if (VBOOL(v28)) {
					VAL v29 = pop_value();
					decref(v29);
					switch (get_top_data_tag()) {
						case 0LL: { // IntLike
							mtp_mirth_type_CType_IntLike();
							STRLIT("volatile ", 9);
							VAL v30 = pop_value();
							VAL v31 = pop_value();
							push_value(v30);
							push_value(v31);
							mp_primZ_strZ_cat();
							mtw_mirth_type_CType_IntLike();
							mtw_std_maybe_Maybe_1_Some();
						} break;
						case 1LL: { // F32Like
							mtp_mirth_type_CType_F32Like();
							STRLIT("volatile ", 9);
							VAL v32 = pop_value();
							VAL v33 = pop_value();
							push_value(v32);
							push_value(v33);
							mp_primZ_strZ_cat();
							mtw_mirth_type_CType_F32Like();
							mtw_std_maybe_Maybe_1_Some();
						} break;
						case 2LL: { // F64Like
							mtp_mirth_type_CType_F64Like();
							STRLIT("volatile ", 9);
							VAL v34 = pop_value();
							VAL v35 = pop_value();
							push_value(v34);
							push_value(v35);
							mp_primZ_strZ_cat();
							mtw_mirth_type_CType_F64Like();
							mtw_std_maybe_Maybe_1_Some();
						} break;
						case 4LL: { // FnPtr
							mtp_mirth_type_CType_FnPtr();
							STRLIT("volatile ", 9);
							VAL v36 = pop_value();
							VAL v37 = pop_value();
							push_value(v36);
							push_value(v37);
							mp_primZ_strZ_cat();
							mtw_mirth_type_CType_FnPtr();
							mtw_std_maybe_Maybe_1_Some();
						} break;
						case 3LL: { // PtrLike
							mtp_mirth_type_CType_PtrLike();
							STRLIT(" volatile", 9);
							mp_primZ_strZ_cat();
							mtw_mirth_type_CType_PtrLike();
							mtw_std_maybe_Maybe_1_Some();
						} break;
						case 5LL: { // Phantom
							(void)pop_u64();
							uint64_t v38 = (5LL /* Phantom */);
							push_u64(v38);
							mtw_std_maybe_Maybe_1_Some();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} else {
					VAL v39 = pop_value();
					decref(v39);
					VAL v40 = pop_value();
					decref(v40);
					uint64_t v41 = (0LL /* None */);
					push_u64(v41);
				}
			}
		}
	}
}
static void mw_mirth_type_CTypeStackPart_ctype (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // CTSPCons
			mtp_mirth_type_CTypeStackPart_CTSPCons();
		} break;
		case 1LL: { // CTSPConsLabel
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		case 2LL: { // CTSPWith
			mtp_mirth_type_CTypeStackPart_CTSPWith();
		} break;
		case 3LL: { // CTSPWithLabel
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel();
			VAL v1 = pop_value();
			decref(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CTypeStackPart_labelZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // CTSPCons
			mtp_mirth_type_CTypeStackPart_CTSPCons();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
		case 1LL: { // CTSPConsLabel
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			decref(v3);
			push_value(v2);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // CTSPWith
			mtp_mirth_type_CTypeStackPart_CTSPWith();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (0LL /* None */);
			push_u64(v5);
		} break;
		case 3LL: { // CTSPWithLabel
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			decref(v7);
			push_value(v6);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackTypePart_ctype (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // STPCons
			mtp_mirth_type_StackTypePart_STPCons();
			mw_mirth_type_Type_ctype();
			mtw_mirth_type_CTypeStackPart_CTSPCons();
		} break;
		case 1LL: { // STPConsLabel
			mtp_mirth_type_StackTypePart_STPConsLabel();
			VAL v0 = pop_value();
			mw_mirth_type_Type_ctype();
			push_value(v0);
			mtw_mirth_type_CTypeStackPart_CTSPConsLabel();
		} break;
		case 2LL: { // STPWith
			mtp_mirth_type_StackTypePart_STPWith();
			mw_mirth_type_Resource_ctype();
			mtw_mirth_type_CTypeStackPart_CTSPWith();
		} break;
		case 3LL: { // STPWithLabel
			mtp_mirth_type_StackTypePart_STPWithLabel();
			VAL v1 = pop_value();
			mw_mirth_type_Resource_ctype();
			push_value(v1);
			mtw_mirth_type_CTypeStackPart_CTSPWithLabel();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_StackType_baseZ_ctypeZAsk (void) {
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 3LL: { // STVar
			mtp_mirth_type_StackType_STVar();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // STACK_TYPE_UNIT
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		case 0LL: { // STACK_TYPE_ERROR
			(void)pop_u64();
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
		default: {
			STRLIT("unexpected stack base in StackType.base-ctype", 45);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_type_StackType_ctype (void) {
	mw_mirth_type_StackType_splitZ_parts();
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		push_value(v5);
		mw_mirth_type_StackTypePart_ctype();
		push_resource(r7);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v12 = pop_value();
	lpush(&lbl_parts, v12);
	mw_mirth_type_StackType_baseZ_ctypeZAsk();
	VAL v13 = pop_value();
	lpush(&lbl_baseZAsk, v13);
	mtw_mirth_type_CTypeStack_CTypeStack();
}
static void mw_mirth_type_ArrowType_ctype (void) {
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	mw_mirth_type_StackType_ctype();
	VAL v1 = pop_value();
	lpush(&lbl_dom, v1);
	push_value(v0);
	mw_mirth_type_StackType_ctype();
	VAL v2 = pop_value();
	lpush(&lbl_cod, v2);
	mtw_mirth_type_CTypeArrow_CTypeArrow();
}
static void mw_mirth_prim_Prim_qname (void) {
	mw_mirth_name_Namespace_prim();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	lpush(&lbl_namespace, v0);
	push_value(v1);
	push_value(v1);
	mw_mirth_prim_Prim_name();
	VAL v2 = pop_value();
	lpush(&lbl_name, v2);
	mw_mirth_prim_Prim_arity();
	VAL v3 = pop_value();
	lpush(&lbl_arity, v3);
	mtw_mirth_name_QName_MKQNAME();
}
static void mw_mirth_prim_Prim_name (void) {
	mfld_mirth_prim_Prim_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_prim_Prim_type (void) {
	mfld_mirth_prim_Prim_ZTildetype();
	mp_primZ_mutZ_get();
}
static void mw_mirth_prim_Prim_arity (void) {
	mfld_mirth_prim_Prim_ZTildearity();
	mp_primZ_mutZ_get();
}
static void mw_mirth_prim_Prim_ZToInt (void) {
}
static void mw_mirth_prim_Prim_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_prim_Prim_ZToInt();
	push_value(v0);
	mw_mirth_prim_Prim_ZToInt();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_prim_defZ_primZBang (void) {
	VAL v0 = pop_value();
	mw_std_prim_Str_ZToName();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	mfld_mirth_prim_Prim_ZTildename();
	mp_primZ_mutZ_set();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v0);
	push_value(v3);
	mfld_mirth_prim_Prim_ZTildearity();
	mp_primZ_mutZ_set();
	mtw_mirth_def_Def_DefPrim();
	mw_mirth_def_Def_register();
}
static void mw_mirth_prim_Prim_ctxZ_typeZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mfld_mirth_prim_Prim_ZTildetype();
	mp_primZ_mutZ_set();
	mfld_mirth_prim_Prim_ZTildectx();
	mp_primZ_mutZ_set();
}
static void mw_mirth_prim_initZ_primsZBang (void) {
	uint64_t v0 = (90LL /* PRIM_SYNTAX_MODULE */);
	push_u64(v0);
	STRLIT("module", 6);
	int64_t v1 = (-1LL);
	push_i64(v1);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v2 = (91LL /* PRIM_SYNTAX_IMPORT */);
	push_u64(v2);
	STRLIT("import", 6);
	int64_t v3 = (-1LL);
	push_i64(v3);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v4 = (93LL /* PRIM_SYNTAX_INLINE */);
	push_u64(v4);
	STRLIT("inline", 6);
	int64_t v5 = (-1LL);
	push_i64(v5);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v6 = (92LL /* PRIM_SYNTAX_ALIAS */);
	push_u64(v6);
	STRLIT("alias", 5);
	int64_t v7 = (-1LL);
	push_i64(v7);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v8 = (94LL /* PRIM_SYNTAX_DEF */);
	push_u64(v8);
	STRLIT("def", 3);
	int64_t v9 = (-1LL);
	push_i64(v9);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v10 = (96LL /* PRIM_SYNTAX_DEF_TYPE */);
	push_u64(v10);
	STRLIT("def-type", 8);
	int64_t v11 = (-1LL);
	push_i64(v11);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v12 = (95LL /* PRIM_SYNTAX_DEF_MISSING */);
	push_u64(v12);
	STRLIT("def-missing", 11);
	int64_t v13 = (-1LL);
	push_i64(v13);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v14 = (97LL /* PRIM_SYNTAX_BUFFER */);
	push_u64(v14);
	STRLIT("buffer", 6);
	int64_t v15 = (-1LL);
	push_i64(v15);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v16 = (100LL /* PRIM_SYNTAX_DEF_EXTERNAL */);
	push_u64(v16);
	STRLIT("def-external", 12);
	int64_t v17 = (-1LL);
	push_i64(v17);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v18 = (99LL /* PRIM_SYNTAX_EXTERNAL */);
	push_u64(v18);
	STRLIT("external", 8);
	int64_t v19 = (-1LL);
	push_i64(v19);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v20 = (102LL /* PRIM_SYNTAX_TABLE */);
	push_u64(v20);
	STRLIT("table", 5);
	int64_t v21 = (-1LL);
	push_i64(v21);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v22 = (103LL /* PRIM_SYNTAX_FIELD */);
	push_u64(v22);
	STRLIT("field", 5);
	int64_t v23 = (-1LL);
	push_i64(v23);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v24 = (101LL /* PRIM_SYNTAX_EMBED_STR */);
	push_u64(v24);
	STRLIT("embed-str", 9);
	int64_t v25 = (-1LL);
	push_i64(v25);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v26 = (104LL /* PRIM_SYNTAX_DATA */);
	push_u64(v26);
	STRLIT("data", 4);
	int64_t v27 = (-1LL);
	push_i64(v27);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v28 = (105LL /* PRIM_SYNTAX_STRUCT */);
	push_u64(v28);
	STRLIT("struct", 6);
	int64_t v29 = (-1LL);
	push_i64(v29);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v30 = (98LL /* PRIM_SYNTAX_VARIABLE */);
	push_u64(v30);
	STRLIT("var", 3);
	int64_t v31 = (-1LL);
	push_i64(v31);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v32 = (107LL /* PRIM_SYNTAX_ARROW */);
	push_u64(v32);
	STRLIT("->", 2);
	int64_t v33 = (-1LL);
	push_i64(v33);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v34 = (106LL /* PRIM_SYNTAX_DASHES */);
	push_u64(v34);
	STRLIT("--", 2);
	int64_t v35 = (-1LL);
	push_i64(v35);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v36 = (4LL /* PRIM_CORE_DIP */);
	push_u64(v36);
	STRLIT("dip", 3);
	int64_t v37 = (1LL);
	push_i64(v37);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v38 = (6LL /* PRIM_CORE_WHILE */);
	push_u64(v38);
	STRLIT("while", 5);
	int64_t v39 = (2LL);
	push_i64(v39);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v40 = (10LL /* PRIM_CORE_MATCH */);
	push_u64(v40);
	STRLIT("match", 5);
	int64_t v41 = (-1LL);
	push_i64(v41);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v42 = (11LL /* PRIM_CORE_LAMBDA */);
	push_u64(v42);
	STRLIT("\\", 1);
	int64_t v43 = (-1LL);
	push_i64(v43);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v44 = (0LL /* PRIM_CORE_ID */);
	push_u64(v44);
	STRLIT("prim-id", 7);
	int64_t v45 = (0LL);
	push_i64(v45);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v46 = (1LL /* PRIM_CORE_DUP */);
	push_u64(v46);
	STRLIT("prim-dup", 8);
	int64_t v47 = (0LL);
	push_i64(v47);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v48 = (2LL /* PRIM_CORE_DROP */);
	push_u64(v48);
	STRLIT("prim-drop", 9);
	int64_t v49 = (0LL);
	push_i64(v49);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v50 = (3LL /* PRIM_CORE_SWAP */);
	push_u64(v50);
	STRLIT("prim-swap", 9);
	int64_t v51 = (0LL);
	push_i64(v51);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v52 = (4LL /* PRIM_CORE_DIP */);
	push_u64(v52);
	STRLIT("prim-dip", 8);
	int64_t v53 = (1LL);
	push_i64(v53);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v54 = (5LL /* PRIM_CORE_IF */);
	push_u64(v54);
	STRLIT("prim-if", 7);
	int64_t v55 = (2LL);
	push_i64(v55);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v56 = (6LL /* PRIM_CORE_WHILE */);
	push_u64(v56);
	STRLIT("prim-while", 10);
	int64_t v57 = (2LL);
	push_i64(v57);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v58 = (7LL /* PRIM_CORE_DEBUG */);
	push_u64(v58);
	STRLIT("prim-debug", 10);
	int64_t v59 = (0LL);
	push_i64(v59);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v60 = (8LL /* PRIM_CORE_PANIC */);
	push_u64(v60);
	STRLIT("prim-panic", 10);
	int64_t v61 = (0LL);
	push_i64(v61);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v62 = (9LL /* PRIM_CORE_RUN */);
	push_u64(v62);
	STRLIT("prim-run", 8);
	int64_t v63 = (0LL);
	push_i64(v63);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v64 = (10LL /* PRIM_CORE_MATCH */);
	push_u64(v64);
	STRLIT("prim-match", 10);
	int64_t v65 = (-1LL);
	push_i64(v65);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v66 = (11LL /* PRIM_CORE_LAMBDA */);
	push_u64(v66);
	STRLIT("prim-lambda", 11);
	int64_t v67 = (-1LL);
	push_i64(v67);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v68 = (12LL /* PRIM_CORE_RSWAP */);
	push_u64(v68);
	STRLIT("prim-rswap", 10);
	int64_t v69 = (0LL);
	push_i64(v69);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v70 = (13LL /* PRIM_CORE_RDIP */);
	push_u64(v70);
	STRLIT("prim-rdip", 9);
	int64_t v71 = (1LL);
	push_i64(v71);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v72 = (16LL /* PRIM_INT_ADD */);
	push_u64(v72);
	STRLIT("prim-int-add", 12);
	int64_t v73 = (0LL);
	push_i64(v73);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v74 = (17LL /* PRIM_INT_SUB */);
	push_u64(v74);
	STRLIT("prim-int-sub", 12);
	int64_t v75 = (0LL);
	push_i64(v75);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v76 = (18LL /* PRIM_INT_MUL */);
	push_u64(v76);
	STRLIT("prim-int-mul", 12);
	int64_t v77 = (0LL);
	push_i64(v77);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v78 = (19LL /* PRIM_INT_DIV */);
	push_u64(v78);
	STRLIT("prim-int-div", 12);
	int64_t v79 = (0LL);
	push_i64(v79);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v80 = (20LL /* PRIM_INT_MOD */);
	push_u64(v80);
	STRLIT("prim-int-mod", 12);
	int64_t v81 = (0LL);
	push_i64(v81);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v82 = (21LL /* PRIM_INT_AND */);
	push_u64(v82);
	STRLIT("prim-int-and", 12);
	int64_t v83 = (0LL);
	push_i64(v83);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v84 = (22LL /* PRIM_INT_OR */);
	push_u64(v84);
	STRLIT("prim-int-or", 11);
	int64_t v85 = (0LL);
	push_i64(v85);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v86 = (23LL /* PRIM_INT_XOR */);
	push_u64(v86);
	STRLIT("prim-int-xor", 12);
	int64_t v87 = (0LL);
	push_i64(v87);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v88 = (24LL /* PRIM_INT_SHL */);
	push_u64(v88);
	STRLIT("prim-int-shl", 12);
	int64_t v89 = (0LL);
	push_i64(v89);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v90 = (25LL /* PRIM_INT_SHR */);
	push_u64(v90);
	STRLIT("prim-int-shr", 12);
	int64_t v91 = (0LL);
	push_i64(v91);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v92 = (14LL /* PRIM_INT_EQ */);
	push_u64(v92);
	STRLIT("prim-int-eq", 11);
	int64_t v93 = (0LL);
	push_i64(v93);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v94 = (15LL /* PRIM_INT_LT */);
	push_u64(v94);
	STRLIT("prim-int-lt", 11);
	int64_t v95 = (0LL);
	push_i64(v95);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v96 = (26LL /* PRIM_INT_TO_STR */);
	push_u64(v96);
	STRLIT("prim-int-to-str", 15);
	int64_t v97 = (0LL);
	push_i64(v97);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v98 = (27LL /* PRIM_INT_TO_F32 */);
	push_u64(v98);
	STRLIT("prim-int-to-float32", 19);
	int64_t v99 = (0LL);
	push_i64(v99);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v100 = (28LL /* PRIM_INT_TO_F64 */);
	push_u64(v100);
	STRLIT("prim-int-to-float64", 19);
	int64_t v101 = (0LL);
	push_i64(v101);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v102 = (27LL /* PRIM_INT_TO_F32 */);
	push_u64(v102);
	STRLIT("prim-int-to-f32", 15);
	int64_t v103 = (0LL);
	push_i64(v103);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v104 = (28LL /* PRIM_INT_TO_F64 */);
	push_u64(v104);
	STRLIT("prim-int-to-f64", 15);
	int64_t v105 = (0LL);
	push_i64(v105);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v106 = (29LL /* PRIM_F32_EQ */);
	push_u64(v106);
	STRLIT("prim-f32-eq", 11);
	int64_t v107 = (0LL);
	push_i64(v107);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v108 = (30LL /* PRIM_F32_LT */);
	push_u64(v108);
	STRLIT("prim-f32-lt", 11);
	int64_t v109 = (0LL);
	push_i64(v109);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v110 = (31LL /* PRIM_F32_ADD */);
	push_u64(v110);
	STRLIT("prim-f32-add", 12);
	int64_t v111 = (0LL);
	push_i64(v111);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v112 = (32LL /* PRIM_F32_SUB */);
	push_u64(v112);
	STRLIT("prim-f32-sub", 12);
	int64_t v113 = (0LL);
	push_i64(v113);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v114 = (33LL /* PRIM_F32_MUL */);
	push_u64(v114);
	STRLIT("prim-f32-mul", 12);
	int64_t v115 = (0LL);
	push_i64(v115);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v116 = (34LL /* PRIM_F32_DIV */);
	push_u64(v116);
	STRLIT("prim-f32-div", 12);
	int64_t v117 = (0LL);
	push_i64(v117);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v118 = (35LL /* PRIM_F32_TO_INT */);
	push_u64(v118);
	STRLIT("prim-f32-to-int", 15);
	int64_t v119 = (0LL);
	push_i64(v119);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v120 = (36LL /* PRIM_F32_TO_STR */);
	push_u64(v120);
	STRLIT("prim-f32-to-str", 15);
	int64_t v121 = (0LL);
	push_i64(v121);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v122 = (37LL /* PRIM_F32_TO_F64 */);
	push_u64(v122);
	STRLIT("prim-f32-to-f64", 15);
	int64_t v123 = (0LL);
	push_i64(v123);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v124 = (38LL /* PRIM_F64_EQ */);
	push_u64(v124);
	STRLIT("prim-f64-eq", 11);
	int64_t v125 = (0LL);
	push_i64(v125);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v126 = (39LL /* PRIM_F64_LT */);
	push_u64(v126);
	STRLIT("prim-f64-lt", 11);
	int64_t v127 = (0LL);
	push_i64(v127);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v128 = (40LL /* PRIM_F64_ADD */);
	push_u64(v128);
	STRLIT("prim-f64-add", 12);
	int64_t v129 = (0LL);
	push_i64(v129);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v130 = (41LL /* PRIM_F64_SUB */);
	push_u64(v130);
	STRLIT("prim-f64-sub", 12);
	int64_t v131 = (0LL);
	push_i64(v131);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v132 = (42LL /* PRIM_F64_MUL */);
	push_u64(v132);
	STRLIT("prim-f64-mul", 12);
	int64_t v133 = (0LL);
	push_i64(v133);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v134 = (43LL /* PRIM_F64_DIV */);
	push_u64(v134);
	STRLIT("prim-f64-div", 12);
	int64_t v135 = (0LL);
	push_i64(v135);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v136 = (44LL /* PRIM_F64_TO_INT */);
	push_u64(v136);
	STRLIT("prim-f64-to-int", 15);
	int64_t v137 = (0LL);
	push_i64(v137);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v138 = (45LL /* PRIM_F64_TO_STR */);
	push_u64(v138);
	STRLIT("prim-f64-to-str", 15);
	int64_t v139 = (0LL);
	push_i64(v139);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v140 = (46LL /* PRIM_F64_TO_F32 */);
	push_u64(v140);
	STRLIT("prim-f64-to-f32", 15);
	int64_t v141 = (0LL);
	push_i64(v141);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v142 = (47LL /* PRIM_PACK_NIL */);
	push_u64(v142);
	STRLIT("prim-pack-nil", 13);
	int64_t v143 = (0LL);
	push_i64(v143);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v144 = (48LL /* PRIM_PACK_CONS */);
	push_u64(v144);
	STRLIT("prim-pack-cons", 14);
	int64_t v145 = (0LL);
	push_i64(v145);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v146 = (49LL /* PRIM_PACK_UNCONS */);
	push_u64(v146);
	STRLIT("prim-pack-uncons", 16);
	int64_t v147 = (0LL);
	push_i64(v147);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v148 = (51LL /* PRIM_MUT_GET */);
	push_u64(v148);
	STRLIT("prim-mut-get", 12);
	int64_t v149 = (0LL);
	push_i64(v149);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v150 = (52LL /* PRIM_MUT_SET */);
	push_u64(v150);
	STRLIT("prim-mut-set", 12);
	int64_t v151 = (0LL);
	push_i64(v151);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v152 = (53LL /* PRIM_MUT_IS_SET */);
	push_u64(v152);
	STRLIT("prim-mut-is-set", 15);
	int64_t v153 = (0LL);
	push_i64(v153);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v154 = (54LL /* PRIM_PTR_NIL */);
	push_u64(v154);
	STRLIT("prim-ptr-nil", 12);
	int64_t v155 = (0LL);
	push_i64(v155);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v156 = (55LL /* PRIM_PTR_EQ */);
	push_u64(v156);
	STRLIT("prim-ptr-eq", 11);
	int64_t v157 = (0LL);
	push_i64(v157);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v158 = (56LL /* PRIM_PTR_ADD */);
	push_u64(v158);
	STRLIT("prim-ptr-add", 12);
	int64_t v159 = (0LL);
	push_i64(v159);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v160 = (57LL /* PRIM_PTR_SIZE */);
	push_u64(v160);
	STRLIT("prim-ptr-size", 13);
	int64_t v161 = (0LL);
	push_i64(v161);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v162 = (58LL /* PRIM_PTR_GET */);
	push_u64(v162);
	STRLIT("prim-ptr-get", 12);
	int64_t v163 = (0LL);
	push_i64(v163);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v164 = (59LL /* PRIM_PTR_SET */);
	push_u64(v164);
	STRLIT("prim-ptr-set", 12);
	int64_t v165 = (0LL);
	push_i64(v165);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v166 = (60LL /* PRIM_PTR_ALLOC */);
	push_u64(v166);
	STRLIT("prim-ptr-alloc", 14);
	int64_t v167 = (0LL);
	push_i64(v167);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v168 = (61LL /* PRIM_PTR_REALLOC */);
	push_u64(v168);
	STRLIT("prim-ptr-realloc", 16);
	int64_t v169 = (0LL);
	push_i64(v169);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v170 = (62LL /* PRIM_PTR_FREE */);
	push_u64(v170);
	STRLIT("prim-ptr-free", 13);
	int64_t v171 = (0LL);
	push_i64(v171);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v172 = (64LL /* PRIM_PTR_FILL */);
	push_u64(v172);
	STRLIT("prim-ptr-fill", 13);
	int64_t v173 = (0LL);
	push_i64(v173);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v174 = (63LL /* PRIM_PTR_COPY */);
	push_u64(v174);
	STRLIT("prim-ptr-copy", 13);
	int64_t v175 = (0LL);
	push_i64(v175);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v176 = (66LL /* PRIM_STR_COPY */);
	push_u64(v176);
	STRLIT("prim-str-copy", 13);
	int64_t v177 = (0LL);
	push_i64(v177);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v178 = (67LL /* PRIM_STR_NUM_BYTES */);
	push_u64(v178);
	STRLIT("prim-str-num-bytes", 18);
	int64_t v179 = (0LL);
	push_i64(v179);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v180 = (68LL /* PRIM_STR_BASE */);
	push_u64(v180);
	STRLIT("prim-str-base", 13);
	int64_t v181 = (0LL);
	push_i64(v181);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v182 = (69LL /* PRIM_STR_CAT */);
	push_u64(v182);
	STRLIT("prim-str-cat", 12);
	int64_t v183 = (0LL);
	push_i64(v183);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v184 = (65LL /* PRIM_STR_CMP */);
	push_u64(v184);
	STRLIT("prim-str-cmp", 12);
	int64_t v185 = (0LL);
	push_i64(v185);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v186 = (70LL /* PRIM_U8_GET */);
	push_u64(v186);
	STRLIT("prim-u8-get", 11);
	int64_t v187 = (0LL);
	push_i64(v187);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v188 = (71LL /* PRIM_U8_SET */);
	push_u64(v188);
	STRLIT("prim-u8-set", 11);
	int64_t v189 = (0LL);
	push_i64(v189);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v190 = (72LL /* PRIM_U16_GET */);
	push_u64(v190);
	STRLIT("prim-u16-get", 12);
	int64_t v191 = (0LL);
	push_i64(v191);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v192 = (73LL /* PRIM_U16_SET */);
	push_u64(v192);
	STRLIT("prim-u16-set", 12);
	int64_t v193 = (0LL);
	push_i64(v193);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v194 = (74LL /* PRIM_U32_GET */);
	push_u64(v194);
	STRLIT("prim-u32-get", 12);
	int64_t v195 = (0LL);
	push_i64(v195);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v196 = (75LL /* PRIM_U32_SET */);
	push_u64(v196);
	STRLIT("prim-u32-set", 12);
	int64_t v197 = (0LL);
	push_i64(v197);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v198 = (76LL /* PRIM_U64_GET */);
	push_u64(v198);
	STRLIT("prim-u64-get", 12);
	int64_t v199 = (0LL);
	push_i64(v199);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v200 = (77LL /* PRIM_U64_SET */);
	push_u64(v200);
	STRLIT("prim-u64-set", 12);
	int64_t v201 = (0LL);
	push_i64(v201);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v202 = (78LL /* PRIM_I8_GET */);
	push_u64(v202);
	STRLIT("prim-i8-get", 11);
	int64_t v203 = (0LL);
	push_i64(v203);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v204 = (79LL /* PRIM_I8_SET */);
	push_u64(v204);
	STRLIT("prim-i8-set", 11);
	int64_t v205 = (0LL);
	push_i64(v205);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v206 = (80LL /* PRIM_I16_GET */);
	push_u64(v206);
	STRLIT("prim-i16-get", 12);
	int64_t v207 = (0LL);
	push_i64(v207);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v208 = (81LL /* PRIM_I16_SET */);
	push_u64(v208);
	STRLIT("prim-i16-set", 12);
	int64_t v209 = (0LL);
	push_i64(v209);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v210 = (82LL /* PRIM_I32_GET */);
	push_u64(v210);
	STRLIT("prim-i32-get", 12);
	int64_t v211 = (0LL);
	push_i64(v211);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v212 = (83LL /* PRIM_I32_SET */);
	push_u64(v212);
	STRLIT("prim-i32-set", 12);
	int64_t v213 = (0LL);
	push_i64(v213);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v214 = (84LL /* PRIM_I64_GET */);
	push_u64(v214);
	STRLIT("prim-i64-get", 12);
	int64_t v215 = (0LL);
	push_i64(v215);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v216 = (85LL /* PRIM_I64_SET */);
	push_u64(v216);
	STRLIT("prim-i64-set", 12);
	int64_t v217 = (0LL);
	push_i64(v217);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v218 = (86LL /* PRIM_SYS_OS */);
	push_u64(v218);
	STRLIT("prim-sys-os", 11);
	int64_t v219 = (0LL);
	push_i64(v219);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v220 = (87LL /* PRIM_SYS_ARCH */);
	push_u64(v220);
	STRLIT("prim-sys-arch", 13);
	int64_t v221 = (0LL);
	push_i64(v221);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v222 = (88LL /* PRIM_SYS_ARGC */);
	push_u64(v222);
	STRLIT("prim-sys-argc", 13);
	int64_t v223 = (0LL);
	push_i64(v223);
	mw_mirth_prim_defZ_primZBang();
	uint64_t v224 = (89LL /* PRIM_SYS_ARGV */);
	push_u64(v224);
	STRLIT("prim-sys-argv", 13);
	int64_t v225 = (0LL);
	push_i64(v225);
	mw_mirth_prim_defZ_primZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	VAL v226 = pop_value();
	VAL v227 = pop_value();
	incref(v227);
	incref(v226);
	uint64_t v228 = (0LL /* PRIM_CORE_ID */);
	push_value(v227);
	push_value(v226);
	push_value(v227);
	push_value(v226);
	push_u64(v228);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v229 = pop_value();
	VAL v230 = pop_value();
	incref(v230);
	incref(v229);
	uint64_t v231 = (7LL /* PRIM_CORE_DEBUG */);
	push_value(v230);
	push_value(v229);
	push_value(v230);
	push_value(v229);
	push_u64(v231);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v232 = pop_value();
	decref(v232);
	VAL v233 = pop_value();
	decref(v233);
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v234 = pop_value();
	VAL v235 = pop_value();
	incref(v235);
	incref(v234);
	uint64_t v236 = (16LL /* PRIM_INT_ADD */);
	push_value(v235);
	push_value(v234);
	push_value(v235);
	push_value(v234);
	push_u64(v236);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v237 = pop_value();
	VAL v238 = pop_value();
	incref(v238);
	incref(v237);
	uint64_t v239 = (17LL /* PRIM_INT_SUB */);
	push_value(v238);
	push_value(v237);
	push_value(v238);
	push_value(v237);
	push_u64(v239);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v240 = pop_value();
	VAL v241 = pop_value();
	incref(v241);
	incref(v240);
	uint64_t v242 = (18LL /* PRIM_INT_MUL */);
	push_value(v241);
	push_value(v240);
	push_value(v241);
	push_value(v240);
	push_u64(v242);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v243 = pop_value();
	VAL v244 = pop_value();
	incref(v244);
	incref(v243);
	uint64_t v245 = (19LL /* PRIM_INT_DIV */);
	push_value(v244);
	push_value(v243);
	push_value(v244);
	push_value(v243);
	push_u64(v245);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v246 = pop_value();
	VAL v247 = pop_value();
	incref(v247);
	incref(v246);
	uint64_t v248 = (20LL /* PRIM_INT_MOD */);
	push_value(v247);
	push_value(v246);
	push_value(v247);
	push_value(v246);
	push_u64(v248);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v249 = pop_value();
	VAL v250 = pop_value();
	incref(v250);
	incref(v249);
	uint64_t v251 = (21LL /* PRIM_INT_AND */);
	push_value(v250);
	push_value(v249);
	push_value(v250);
	push_value(v249);
	push_u64(v251);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v252 = pop_value();
	VAL v253 = pop_value();
	incref(v253);
	incref(v252);
	uint64_t v254 = (22LL /* PRIM_INT_OR */);
	push_value(v253);
	push_value(v252);
	push_value(v253);
	push_value(v252);
	push_u64(v254);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v255 = pop_value();
	VAL v256 = pop_value();
	incref(v256);
	incref(v255);
	uint64_t v257 = (23LL /* PRIM_INT_XOR */);
	push_value(v256);
	push_value(v255);
	push_value(v256);
	push_value(v255);
	push_u64(v257);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v258 = pop_value();
	VAL v259 = pop_value();
	incref(v259);
	incref(v258);
	uint64_t v260 = (24LL /* PRIM_INT_SHL */);
	push_value(v259);
	push_value(v258);
	push_value(v259);
	push_value(v258);
	push_u64(v260);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v261 = pop_value();
	VAL v262 = pop_value();
	incref(v262);
	incref(v261);
	uint64_t v263 = (25LL /* PRIM_INT_SHR */);
	push_value(v262);
	push_value(v261);
	push_value(v262);
	push_value(v261);
	push_u64(v263);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v264 = pop_value();
	decref(v264);
	VAL v265 = pop_value();
	decref(v265);
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T2();
	mw_mirth_data_TYPEz_BOOL();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v266 = pop_value();
	VAL v267 = pop_value();
	incref(v267);
	incref(v266);
	uint64_t v268 = (14LL /* PRIM_INT_EQ */);
	push_value(v267);
	push_value(v266);
	push_value(v267);
	push_value(v266);
	push_u64(v268);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v269 = pop_value();
	VAL v270 = pop_value();
	incref(v270);
	incref(v269);
	uint64_t v271 = (15LL /* PRIM_INT_LT */);
	push_value(v270);
	push_value(v269);
	push_value(v270);
	push_value(v269);
	push_u64(v271);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v272 = pop_value();
	decref(v272);
	VAL v273 = pop_value();
	decref(v273);
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_T2();
	mw_mirth_data_TYPEz_BOOL();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v274 = pop_value();
	VAL v275 = pop_value();
	incref(v275);
	incref(v274);
	uint64_t v276 = (29LL /* PRIM_F32_EQ */);
	push_value(v275);
	push_value(v274);
	push_value(v275);
	push_value(v274);
	push_u64(v276);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v277 = pop_value();
	VAL v278 = pop_value();
	incref(v278);
	incref(v277);
	uint64_t v279 = (30LL /* PRIM_F32_LT */);
	push_value(v278);
	push_value(v277);
	push_value(v278);
	push_value(v277);
	push_u64(v279);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v280 = pop_value();
	decref(v280);
	VAL v281 = pop_value();
	decref(v281);
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_T2();
	mw_mirth_data_TYPEz_BOOL();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v282 = pop_value();
	VAL v283 = pop_value();
	incref(v283);
	incref(v282);
	uint64_t v284 = (38LL /* PRIM_F64_EQ */);
	push_value(v283);
	push_value(v282);
	push_value(v283);
	push_value(v282);
	push_u64(v284);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v285 = pop_value();
	VAL v286 = pop_value();
	incref(v286);
	incref(v285);
	uint64_t v287 = (39LL /* PRIM_F64_LT */);
	push_value(v286);
	push_value(v285);
	push_value(v286);
	push_value(v285);
	push_u64(v287);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v288 = pop_value();
	decref(v288);
	VAL v289 = pop_value();
	decref(v289);
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v290 = pop_value();
	VAL v291 = pop_value();
	incref(v291);
	incref(v290);
	uint64_t v292 = (31LL /* PRIM_F32_ADD */);
	push_value(v291);
	push_value(v290);
	push_value(v291);
	push_value(v290);
	push_u64(v292);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v293 = pop_value();
	VAL v294 = pop_value();
	incref(v294);
	incref(v293);
	uint64_t v295 = (32LL /* PRIM_F32_SUB */);
	push_value(v294);
	push_value(v293);
	push_value(v294);
	push_value(v293);
	push_u64(v295);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v296 = pop_value();
	VAL v297 = pop_value();
	incref(v297);
	incref(v296);
	uint64_t v298 = (33LL /* PRIM_F32_MUL */);
	push_value(v297);
	push_value(v296);
	push_value(v297);
	push_value(v296);
	push_u64(v298);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v299 = pop_value();
	VAL v300 = pop_value();
	incref(v300);
	incref(v299);
	uint64_t v301 = (34LL /* PRIM_F32_DIV */);
	push_value(v300);
	push_value(v299);
	push_value(v300);
	push_value(v299);
	push_u64(v301);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v302 = pop_value();
	decref(v302);
	VAL v303 = pop_value();
	decref(v303);
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v304 = pop_value();
	VAL v305 = pop_value();
	incref(v305);
	incref(v304);
	uint64_t v306 = (40LL /* PRIM_F64_ADD */);
	push_value(v305);
	push_value(v304);
	push_value(v305);
	push_value(v304);
	push_u64(v306);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v307 = pop_value();
	VAL v308 = pop_value();
	incref(v308);
	incref(v307);
	uint64_t v309 = (41LL /* PRIM_F64_SUB */);
	push_value(v308);
	push_value(v307);
	push_value(v308);
	push_value(v307);
	push_u64(v309);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v310 = pop_value();
	VAL v311 = pop_value();
	incref(v311);
	incref(v310);
	uint64_t v312 = (42LL /* PRIM_F64_MUL */);
	push_value(v311);
	push_value(v310);
	push_value(v311);
	push_value(v310);
	push_u64(v312);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v313 = pop_value();
	VAL v314 = pop_value();
	incref(v314);
	incref(v313);
	uint64_t v315 = (43LL /* PRIM_F64_DIV */);
	push_value(v314);
	push_value(v313);
	push_value(v314);
	push_value(v313);
	push_u64(v315);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	VAL v316 = pop_value();
	decref(v316);
	VAL v317 = pop_value();
	decref(v317);
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v318 = (26LL /* PRIM_INT_TO_STR */);
	push_u64(v318);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v319 = (27LL /* PRIM_INT_TO_F32 */);
	push_u64(v319);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v320 = (28LL /* PRIM_INT_TO_F64 */);
	push_u64(v320);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v321 = (36LL /* PRIM_F32_TO_STR */);
	push_u64(v321);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v322 = (45LL /* PRIM_F64_TO_STR */);
	push_u64(v322);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F32();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v323 = (35LL /* PRIM_F32_TO_INT */);
	push_u64(v323);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_F64();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v324 = (44LL /* PRIM_F64_TO_INT */);
	push_u64(v324);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v325 = (58LL /* PRIM_PTR_GET */);
	push_u64(v325);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_U8();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v326 = (70LL /* PRIM_U8_GET */);
	push_u64(v326);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_U16();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v327 = (72LL /* PRIM_U16_GET */);
	push_u64(v327);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_U32();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v328 = (74LL /* PRIM_U32_GET */);
	push_u64(v328);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_U64();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v329 = (76LL /* PRIM_U64_GET */);
	push_u64(v329);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_I8();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v330 = (78LL /* PRIM_I8_GET */);
	push_u64(v330);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_I16();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v331 = (80LL /* PRIM_I16_GET */);
	push_u64(v331);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_I32();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v332 = (82LL /* PRIM_I32_GET */);
	push_u64(v332);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_data_TYPEz_I64();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v333 = (84LL /* PRIM_I64_GET */);
	push_u64(v333);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v334 = (59LL /* PRIM_PTR_SET */);
	push_u64(v334);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_U8();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v335 = (71LL /* PRIM_U8_SET */);
	push_u64(v335);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_U16();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v336 = (73LL /* PRIM_U16_SET */);
	push_u64(v336);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_U32();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v337 = (75LL /* PRIM_U32_SET */);
	push_u64(v337);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_U64();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v338 = (77LL /* PRIM_U64_SET */);
	push_u64(v338);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_I8();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v339 = (79LL /* PRIM_I8_SET */);
	push_u64(v339);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_I16();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v340 = (81LL /* PRIM_I16_SET */);
	push_u64(v340);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_I32();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v341 = (83LL /* PRIM_I32_SET */);
	push_u64(v341);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_data_TYPEz_I64();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v342 = (85LL /* PRIM_I64_SET */);
	push_u64(v342);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v343 = (54LL /* PRIM_PTR_NIL */);
	push_u64(v343);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_data_TYPEz_BOOL();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v344 = (55LL /* PRIM_PTR_EQ */);
	push_u64(v344);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v345 = (56LL /* PRIM_PTR_ADD */);
	push_u64(v345);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v346 = (57LL /* PRIM_PTR_SIZE */);
	push_u64(v346);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v347 = (60LL /* PRIM_PTR_ALLOC */);
	push_u64(v347);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v348 = (61LL /* PRIM_PTR_REALLOC */);
	push_u64(v348);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v349 = (62LL /* PRIM_PTR_FREE */);
	push_u64(v349);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T3();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v350 = (63LL /* PRIM_PTR_COPY */);
	push_u64(v350);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T3();
	mw_mirth_type_T0();
	mw_mirth_type_TZ_ZTo();
	uint64_t v351 = (64LL /* PRIM_PTR_FILL */);
	push_u64(v351);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v352 = (66LL /* PRIM_STR_COPY */);
	push_u64(v352);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v353 = (67LL /* PRIM_STR_NUM_BYTES */);
	push_u64(v353);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v354 = (68LL /* PRIM_STR_BASE */);
	push_u64(v354);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v355 = (69LL /* PRIM_STR_CAT */);
	push_u64(v355);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T2();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v356 = (65LL /* PRIM_STR_CMP */);
	push_u64(v356);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v357 = (86LL /* PRIM_SYS_OS */);
	push_u64(v357);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v358 = (87LL /* PRIM_SYS_ARCH */);
	push_u64(v358);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v359 = (88LL /* PRIM_SYS_ARGC */);
	push_u64(v359);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_PTR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v360 = (89LL /* PRIM_SYS_ARGV */);
	push_u64(v360);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_T0();
	mw_mirth_type_StackType_ZToType();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	uint64_t v361 = (47LL /* PRIM_PACK_NIL */);
	push_u64(v361);
	mw_mirth_prim_Prim_ctxZ_typeZBang();
	mw_mirth_type_TYPEz_TYPE();
	STRLIT("a", 1);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	mw_mirth_type_TYPEz_TYPE();
	STRLIT("b", 1);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	mw_mirth_type_TYPEz_TYPE();
	STRLIT("c", 1);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	mw_mirth_type_TYPEz_RESOURCE();
	STRLIT("+r", 2);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	mw_mirth_type_TYPEz_RESOURCE();
	STRLIT("+s", 2);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	mw_mirth_type_TYPEz_STACK();
	STRLIT("*x", 2);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	mw_mirth_type_TYPEz_STACK();
	STRLIT("*y", 2);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	{
		VAL v362 = pop_value();
		VAL var_ys = v362;
		VAL v363 = pop_value();
		VAL var_xs = v363;
		VAL v364 = pop_value();
		VAL var_sr = v364;
		VAL v365 = pop_value();
		VAL var_rr = v365;
		VAL v366 = pop_value();
		VAL var_c = v366;
		VAL v367 = pop_value();
		VAL var_b = v367;
		VAL v368 = pop_value();
		VAL var_a = v368;
		incref(var_a);
		VAL v369 = (var_a);
		push_value(v369);
		mtw_mirth_type_Type_TVar();
		incref(var_b);
		VAL v370 = (var_b);
		push_value(v370);
		mtw_mirth_type_Type_TVar();
		incref(var_c);
		VAL v371 = (var_c);
		push_value(v371);
		mtw_mirth_type_Type_TVar();
		incref(var_rr);
		VAL v372 = (var_rr);
		push_value(v372);
		mtw_mirth_type_Type_TVar();
		incref(var_sr);
		VAL v373 = (var_sr);
		push_value(v373);
		mtw_mirth_type_Type_TVar();
		incref(var_xs);
		VAL v374 = (var_xs);
		push_value(v374);
		mtw_mirth_type_StackType_STVar();
		incref(var_ys);
		VAL v375 = (var_ys);
		push_value(v375);
		mtw_mirth_type_StackType_STVar();
		{
			VAL v376 = pop_value();
			VAL var_tys = v376;
			VAL v377 = pop_value();
			VAL var_txs = v377;
			VAL v378 = pop_value();
			VAL var_tsr = v378;
			VAL v379 = pop_value();
			VAL var_trr = v379;
			VAL v380 = pop_value();
			VAL var_tc = v380;
			VAL v381 = pop_value();
			VAL var_tb = v381;
			VAL v382 = pop_value();
			VAL var_ta = v382;
			incref(var_a);
			VAL v383 = (var_a);
			push_value(v383);
			mw_mirth_var_Ctx1();
			incref(var_ta);
			VAL v384 = (var_ta);
			push_value(v384);
			mw_mirth_type_T1();
			mw_mirth_type_T0();
			mw_mirth_type_TZ_ZTo();
			uint64_t v385 = (2LL /* PRIM_CORE_DROP */);
			push_u64(v385);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_a);
			VAL v386 = (var_a);
			push_value(v386);
			mw_mirth_var_Ctx1();
			incref(var_ta);
			VAL v387 = (var_ta);
			push_value(v387);
			mw_mirth_type_T1();
			incref(var_ta);
			VAL v388 = (var_ta);
			push_value(v388);
			incref(var_ta);
			VAL v389 = (var_ta);
			push_value(v389);
			mw_mirth_type_T2();
			mw_mirth_type_TZ_ZTo();
			uint64_t v390 = (1LL /* PRIM_CORE_DUP */);
			push_u64(v390);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_a);
			VAL v391 = (var_a);
			push_value(v391);
			incref(var_b);
			VAL v392 = (var_b);
			push_value(v392);
			mw_mirth_var_Ctx2();
			incref(var_ta);
			VAL v393 = (var_ta);
			push_value(v393);
			incref(var_tb);
			VAL v394 = (var_tb);
			push_value(v394);
			mw_mirth_type_T2();
			incref(var_tb);
			VAL v395 = (var_tb);
			push_value(v395);
			incref(var_ta);
			VAL v396 = (var_ta);
			push_value(v396);
			mw_mirth_type_T2();
			mw_mirth_type_TZ_ZTo();
			uint64_t v397 = (3LL /* PRIM_CORE_SWAP */);
			push_u64(v397);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v398 = (var_xs);
			push_value(v398);
			incref(var_ys);
			VAL v399 = (var_ys);
			push_value(v399);
			mw_mirth_var_Ctx2();
			incref(var_txs);
			VAL v400 = (var_txs);
			push_value(v400);
			incref(var_txs);
			VAL v401 = (var_txs);
			push_value(v401);
			incref(var_tys);
			VAL v402 = (var_tys);
			push_value(v402);
			mw_mirth_type_TZ_ZTo();
			mw_mirth_type_ArrowType_ZToType();
			mw_mirth_type_TZMul();
			incref(var_tys);
			VAL v403 = (var_tys);
			push_value(v403);
			mw_mirth_type_TZ_ZTo();
			uint64_t v404 = (9LL /* PRIM_CORE_RUN */);
			push_u64(v404);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v405 = (var_xs);
			push_value(v405);
			incref(var_ys);
			VAL v406 = (var_ys);
			push_value(v406);
			mw_mirth_var_Ctx2();
			incref(var_txs);
			VAL v407 = (var_txs);
			push_value(v407);
			mw_mirth_type_TYPEz_STR();
			mw_mirth_type_TZMul();
			incref(var_tys);
			VAL v408 = (var_tys);
			push_value(v408);
			mw_mirth_type_TZ_ZTo();
			uint64_t v409 = (8LL /* PRIM_CORE_PANIC */);
			push_u64(v409);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v410 = (var_xs);
			push_value(v410);
			incref(var_ys);
			VAL v411 = (var_ys);
			push_value(v411);
			incref(var_c);
			VAL v412 = (var_c);
			push_value(v412);
			mw_mirth_var_Ctx3();
			incref(var_txs);
			VAL v413 = (var_txs);
			push_value(v413);
			incref(var_tc);
			VAL v414 = (var_tc);
			push_value(v414);
			mw_mirth_type_TZMul();
			incref(var_txs);
			VAL v415 = (var_txs);
			push_value(v415);
			incref(var_tys);
			VAL v416 = (var_tys);
			push_value(v416);
			mw_mirth_type_TZ_ZTo();
			mw_mirth_type_ArrowType_ZToType();
			mw_mirth_type_TZMul();
			incref(var_tys);
			VAL v417 = (var_tys);
			push_value(v417);
			incref(var_tc);
			VAL v418 = (var_tc);
			push_value(v418);
			mw_mirth_type_TZMul();
			mw_mirth_type_TZ_ZTo();
			uint64_t v419 = (4LL /* PRIM_CORE_DIP */);
			push_u64(v419);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v420 = (var_xs);
			push_value(v420);
			incref(var_ys);
			VAL v421 = (var_ys);
			push_value(v421);
			mw_mirth_var_Ctx2();
			incref(var_txs);
			VAL v422 = (var_txs);
			push_value(v422);
			mw_mirth_data_TYPEz_BOOL();
			mw_mirth_type_TZMul();
			incref(var_txs);
			VAL v423 = (var_txs);
			push_value(v423);
			incref(var_tys);
			VAL v424 = (var_tys);
			push_value(v424);
			mw_mirth_type_TZ_ZTo();
			mw_mirth_type_ArrowType_ZToType();
			VAL v425 = pop_value();
			incref(v425);
			push_value(v425);
			mw_mirth_type_TZMul();
			push_value(v425);
			mw_mirth_type_TZMul();
			incref(var_tys);
			VAL v426 = (var_tys);
			push_value(v426);
			mw_mirth_type_TZ_ZTo();
			uint64_t v427 = (5LL /* PRIM_CORE_IF */);
			push_u64(v427);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v428 = (var_xs);
			push_value(v428);
			mw_mirth_var_Ctx1();
			incref(var_txs);
			VAL v429 = (var_txs);
			push_value(v429);
			incref(var_txs);
			VAL v430 = (var_txs);
			push_value(v430);
			incref(var_txs);
			VAL v431 = (var_txs);
			push_value(v431);
			mw_mirth_data_TYPEz_BOOL();
			mw_mirth_type_TZMul();
			mw_mirth_type_TZ_ZTo();
			mw_mirth_type_ArrowType_ZToType();
			mw_mirth_type_TZMul();
			incref(var_txs);
			VAL v432 = (var_txs);
			push_value(v432);
			incref(var_txs);
			VAL v433 = (var_txs);
			push_value(v433);
			mw_mirth_type_TZ_ZTo();
			mw_mirth_type_ArrowType_ZToType();
			mw_mirth_type_TZMul();
			incref(var_txs);
			VAL v434 = (var_txs);
			push_value(v434);
			mw_mirth_type_TZ_ZTo();
			uint64_t v435 = (6LL /* PRIM_CORE_WHILE */);
			push_u64(v435);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_rr);
			VAL v436 = (var_rr);
			push_value(v436);
			incref(var_sr);
			VAL v437 = (var_sr);
			push_value(v437);
			mw_mirth_var_Ctx2();
			mw_mirth_type_T0();
			incref(var_trr);
			VAL v438 = (var_trr);
			push_value(v438);
			mw_mirth_type_TZPlus();
			incref(var_tsr);
			VAL v439 = (var_tsr);
			push_value(v439);
			mw_mirth_type_TZPlus();
			mw_mirth_type_T0();
			incref(var_tsr);
			VAL v440 = (var_tsr);
			push_value(v440);
			mw_mirth_type_TZPlus();
			incref(var_trr);
			VAL v441 = (var_trr);
			push_value(v441);
			mw_mirth_type_TZPlus();
			mw_mirth_type_TZ_ZTo();
			uint64_t v442 = (12LL /* PRIM_CORE_RSWAP */);
			push_u64(v442);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v443 = (var_xs);
			push_value(v443);
			incref(var_ys);
			VAL v444 = (var_ys);
			push_value(v444);
			incref(var_rr);
			VAL v445 = (var_rr);
			push_value(v445);
			mw_mirth_var_Ctx3();
			incref(var_txs);
			VAL v446 = (var_txs);
			push_value(v446);
			incref(var_trr);
			VAL v447 = (var_trr);
			push_value(v447);
			mw_mirth_type_TZPlus();
			incref(var_txs);
			VAL v448 = (var_txs);
			push_value(v448);
			incref(var_tys);
			VAL v449 = (var_tys);
			push_value(v449);
			mw_mirth_type_TZ_ZTo();
			mw_mirth_type_ArrowType_ZToType();
			mw_mirth_type_TZMul();
			incref(var_tys);
			VAL v450 = (var_tys);
			push_value(v450);
			incref(var_trr);
			VAL v451 = (var_trr);
			push_value(v451);
			mw_mirth_type_TZPlus();
			mw_mirth_type_TZ_ZTo();
			uint64_t v452 = (13LL /* PRIM_CORE_RDIP */);
			push_u64(v452);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v453 = (var_xs);
			push_value(v453);
			incref(var_b);
			VAL v454 = (var_b);
			push_value(v454);
			mw_mirth_var_Ctx2();
			incref(var_txs);
			VAL v455 = (var_txs);
			push_value(v455);
			mw_mirth_type_StackType_ZToType();
			incref(var_tb);
			VAL v456 = (var_tb);
			push_value(v456);
			mw_mirth_type_T2();
			incref(var_txs);
			VAL v457 = (var_txs);
			push_value(v457);
			incref(var_tb);
			VAL v458 = (var_tb);
			push_value(v458);
			mw_mirth_type_TZMul();
			mw_mirth_type_StackType_ZToType();
			mw_mirth_type_T1();
			mw_mirth_type_TZ_ZTo();
			uint64_t v459 = (48LL /* PRIM_PACK_CONS */);
			push_u64(v459);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_xs);
			VAL v460 = (var_xs);
			push_value(v460);
			incref(var_b);
			VAL v461 = (var_b);
			push_value(v461);
			mw_mirth_var_Ctx2();
			incref(var_txs);
			VAL v462 = (var_txs);
			push_value(v462);
			incref(var_tb);
			VAL v463 = (var_tb);
			push_value(v463);
			mw_mirth_type_TZMul();
			mw_mirth_type_StackType_ZToType();
			mw_mirth_type_T1();
			incref(var_txs);
			VAL v464 = (var_txs);
			push_value(v464);
			mw_mirth_type_StackType_ZToType();
			incref(var_tb);
			VAL v465 = (var_tb);
			push_value(v465);
			mw_mirth_type_T2();
			mw_mirth_type_TZ_ZTo();
			uint64_t v466 = (49LL /* PRIM_PACK_UNCONS */);
			push_u64(v466);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_a);
			VAL v467 = (var_a);
			push_value(v467);
			mw_mirth_var_Ctx1();
			incref(var_ta);
			VAL v468 = (var_ta);
			push_value(v468);
			mw_mirth_type_T1();
			incref(var_ta);
			VAL v469 = (var_ta);
			push_value(v469);
			mtw_mirth_type_Type_TMut();
			mw_mirth_type_T1();
			mw_mirth_type_TZ_ZTo();
			uint64_t v470 = (50LL /* PRIM_MUT_NEW */);
			push_u64(v470);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_a);
			VAL v471 = (var_a);
			push_value(v471);
			mw_mirth_var_Ctx1();
			incref(var_ta);
			VAL v472 = (var_ta);
			push_value(v472);
			mtw_mirth_type_Type_TMut();
			mw_mirth_type_T1();
			incref(var_ta);
			VAL v473 = (var_ta);
			push_value(v473);
			mw_mirth_type_T1();
			mw_mirth_type_TZ_ZTo();
			uint64_t v474 = (51LL /* PRIM_MUT_GET */);
			push_u64(v474);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_a);
			VAL v475 = (var_a);
			push_value(v475);
			mw_mirth_var_Ctx1();
			incref(var_ta);
			VAL v476 = (var_ta);
			push_value(v476);
			incref(var_ta);
			VAL v477 = (var_ta);
			push_value(v477);
			mtw_mirth_type_Type_TMut();
			mw_mirth_type_T2();
			mw_mirth_type_T0();
			mw_mirth_type_TZ_ZTo();
			uint64_t v478 = (52LL /* PRIM_MUT_SET */);
			push_u64(v478);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			incref(var_a);
			VAL v479 = (var_a);
			push_value(v479);
			mw_mirth_var_Ctx1();
			incref(var_ta);
			VAL v480 = (var_ta);
			push_value(v480);
			mtw_mirth_type_Type_TMut();
			mw_mirth_type_T1();
			mw_mirth_data_TYPEz_BOOL();
			mw_mirth_type_T1();
			mw_mirth_type_TZ_ZTo();
			uint64_t v481 = (53LL /* PRIM_MUT_IS_SET */);
			push_u64(v481);
			mw_mirth_prim_Prim_ctxZ_typeZBang();
			decref(var_tys);
			decref(var_txs);
			decref(var_tsr);
			decref(var_trr);
			decref(var_tc);
			decref(var_tb);
			decref(var_ta);
		}
		decref(var_ys);
		decref(var_xs);
		decref(var_sr);
		decref(var_rr);
		decref(var_c);
		decref(var_b);
		decref(var_a);
	}
}
static void mw_mirth_token_TokenValue_noneZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TokenNone
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_token_TokenValue_commaZAsk (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // TokenComma
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lparenZ_openZAsk (void) {
	switch (get_top_data_tag()) {
		case 2LL: { // TokenLParenOpen
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lparenZAsk (void) {
	switch (get_top_data_tag()) {
		case 6LL: { // TokenLParen
			mtp_mirth_token_TokenValue_TokenLParen();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_rparenZAsk (void) {
	switch (get_top_data_tag()) {
		case 7LL: { // TokenRParen
			mtp_mirth_token_TokenValue_TokenRParen();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lsquareZ_openZAsk (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // TokenLSquareOpen
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lsquareZAsk (void) {
	switch (get_top_data_tag()) {
		case 8LL: { // TokenLSquare
			mtp_mirth_token_TokenValue_TokenLSquare();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_rsquareZAsk (void) {
	switch (get_top_data_tag()) {
		case 9LL: { // TokenRSquare
			mtp_mirth_token_TokenValue_TokenRSquare();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lcurlyZ_openZAsk (void) {
	switch (get_top_data_tag()) {
		case 4LL: { // TokenLCurlyOpen
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lcurlyZAsk (void) {
	switch (get_top_data_tag()) {
		case 10LL: { // TokenLCurly
			mtp_mirth_token_TokenValue_TokenLCurly();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_rcurlyZAsk (void) {
	switch (get_top_data_tag()) {
		case 11LL: { // TokenRCurly
			mtp_mirth_token_TokenValue_TokenRCurly();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lcolonZ_openZAsk (void) {
	switch (get_top_data_tag()) {
		case 5LL: { // TokenLColonOpen
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		default: {
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lcolonZAsk (void) {
	switch (get_top_data_tag()) {
		case 12LL: { // TokenLColon
			mtp_mirth_token_TokenValue_TokenLColon();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk (void) {
	switch (get_top_data_tag()) {
		case 6LL: { // TokenLParen
			mtp_mirth_token_TokenValue_TokenLParen();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 12LL: { // TokenLColon
			mtp_mirth_token_TokenValue_TokenLColon();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk (void) {
	switch (get_top_data_tag()) {
		case 17LL: { // TokenName
			mtp_mirth_token_TokenValue_TokenName();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 18LL: { // TokenDName
			mtp_mirth_token_TokenValue_TokenDName();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		} break;
		case 23LL: { // TokenLabelGet
			mtp_mirth_token_TokenValue_TokenLabelGet();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		} break;
		default: {
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* False */);
			push_u64(v7);
		} break;
	}
}
static void mw_mirth_token_TokenValue_intZAsk (void) {
	switch (get_top_data_tag()) {
		case 14LL: { // TokenInt
			mtp_mirth_token_TokenValue_TokenInt();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_strZAsk (void) {
	switch (get_top_data_tag()) {
		case 16LL: { // TokenStr
			mtp_mirth_token_TokenValue_TokenStr();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_nameZAsk (void) {
	switch (get_top_data_tag()) {
		case 17LL: { // TokenName
			mtp_mirth_token_TokenValue_TokenName();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_dnameZAsk (void) {
	switch (get_top_data_tag()) {
		case 18LL: { // TokenDName
			mtp_mirth_token_TokenValue_TokenDName();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_nameZ_orZ_dnameZAsk (void) {
	switch (get_top_data_tag()) {
		case 17LL: { // TokenName
			mtp_mirth_token_TokenValue_TokenName();
			mtw_std_either_Either_2_Left();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 18LL: { // TokenDName
			mtp_mirth_token_TokenValue_TokenDName();
			mtw_std_either_Either_2_Right();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_lastZ_nameZAsk (void) {
	switch (get_top_data_tag()) {
		case 17LL: { // TokenName
			mtp_mirth_token_TokenValue_TokenName();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 18LL: { // TokenDName
			mtp_mirth_token_TokenValue_TokenDName();
			mw_mirth_name_DName_lastZ_name();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_penultimateZ_nameZAsk (void) {
	switch (get_top_data_tag()) {
		case 18LL: { // TokenDName
			mtp_mirth_token_TokenValue_TokenDName();
			mw_mirth_name_DName_penultimateZ_nameZAsk();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_token_TokenValue_argZ_endZAsk (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // TokenComma
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		case 7LL: { // TokenRParen
			mtp_mirth_token_TokenValue_TokenRParen();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		} break;
		case 11LL: { // TokenRCurly
			mtp_mirth_token_TokenValue_TokenRCurly();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (1LL /* True */);
			push_u64(v4);
		} break;
		case 9LL: { // TokenRSquare
			mtp_mirth_token_TokenValue_TokenRSquare();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (1LL /* True */);
			push_u64(v6);
		} break;
		case 13LL: { // TokenRColon
			mtp_mirth_token_TokenValue_TokenRColon();
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (1LL /* True */);
			push_u64(v8);
		} break;
		default: {
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* False */);
			push_u64(v10);
		} break;
	}
}
static void mw_mirth_token_TokenValue_leftZ_enclosureZAsk (void) {
	switch (get_top_data_tag()) {
		case 6LL: { // TokenLParen
			mtp_mirth_token_TokenValue_TokenLParen();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 8LL: { // TokenLSquare
			mtp_mirth_token_TokenValue_TokenLSquare();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		} break;
		case 10LL: { // TokenLCurly
			mtp_mirth_token_TokenValue_TokenLCurly();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		} break;
		case 12LL: { // TokenLColon
			mtp_mirth_token_TokenValue_TokenLColon();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (1LL /* True */);
			push_u64(v7);
		} break;
		default: {
			VAL v8 = pop_value();
			decref(v8);
			uint64_t v9 = (0LL /* False */);
			push_u64(v9);
		} break;
	}
}
static void mw_mirth_token_TokenValue_rightZ_enclosureZAsk (void) {
	switch (get_top_data_tag()) {
		case 7LL: { // TokenRParen
			mtp_mirth_token_TokenValue_TokenRParen();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 9LL: { // TokenRSquare
			mtp_mirth_token_TokenValue_TokenRSquare();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		} break;
		case 11LL: { // TokenRCurly
			mtp_mirth_token_TokenValue_TokenRCurly();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		} break;
		case 13LL: { // TokenRColon
			mtp_mirth_token_TokenValue_TokenRColon();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (1LL /* True */);
			push_u64(v7);
		} break;
		default: {
			VAL v8 = pop_value();
			decref(v8);
			uint64_t v9 = (0LL /* False */);
			push_u64(v9);
		} break;
	}
}
static void mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk (void) {
	mw_mirth_token_TokenValue_lastZ_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_typeZ_con();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_isZ_typeZ_hole();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_typeZ_var();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk (void) {
	mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk();
}
static void mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_stackZ_var();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_resourceZ_var();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk (void) {
	mw_mirth_token_TokenValue_lastZ_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_resourceZ_con();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_sigZ_dashesZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			uint64_t v0 = (106LL /* PRIM_SYNTAX_DASHES */);
			push_u64(v0);
			mw_mirth_prim_Prim_name();
			mw_mirth_name_Name_ZEqualZEqual();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_arrowZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			uint64_t v0 = (107LL /* PRIM_SYNTAX_ARROW */);
			push_u64(v0);
			mw_mirth_prim_Prim_name();
			mw_mirth_name_Name_ZEqualZEqual();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_patZ_underscoreZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_isZ_underscore();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_TokenValue_moduleZ_headerZAsk (void) {
	mw_mirth_token_TokenValue_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_ZToStr();
			STRLIT("module", 6);
			mp_primZ_strZ_cmp();
			int64_t v0 = (0LL);
			VAL v1 = pop_value();
			incref(v1);
			bool v2 = (VI64(v1) == v0);
			push_value(v1);
			push_i64(v0);
			if (v2) {
				VAL v3 = pop_value();
				decref(v3);
				VAL v4 = pop_value();
				decref(v4);
				uint64_t v5 = (1LL /* EQ */);
				push_u64(v5);
			} else {
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				bool v8 = (VI64(v7) < VI64(v6));
				if (v8) {
					uint64_t v9 = (0LL /* LT */);
					push_u64(v9);
				} else {
					uint64_t v10 = (2LL /* GT */);
					push_u64(v10);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v11 = (0LL /* False */);
					push_u64(v11);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v12 = (1LL /* True */);
					push_u64(v12);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v13 = (0LL /* False */);
					push_u64(v13);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v14 = (0LL /* False */);
			push_u64(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_Token_index (void) {
}
static void mw_mirth_token_Token_succ (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	mbuf_mirth_token_Token_NUM();
	mp_primZ_u64Z_get();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_add();
	mp_primZ_intZ_mod();
}
static void mw_mirth_token_Token_pred (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (0LL);
	bool v2 = (VI64(v0) == v1);
	push_value(v0);
	if (v2) {
	} else {
		int64_t v3 = (1LL);
		push_i64(v3);
		mp_primZ_intZ_sub();
	}
}
static void mw_mirth_token_Token_allocZBang (void) {
	mbuf_mirth_token_Token_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_token_Token_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_token_Token_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_token_Token_index();
	push_value(v0);
	mw_mirth_token_Token_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_token_Token_value (void) {
	mfld_mirth_token_Token_ZTildevalue();
	mp_primZ_mutZ_get();
}
static void mw_mirth_token_Token_module (void) {
	mfld_mirth_token_Token_ZTildemodule();
	mp_primZ_mutZ_get();
}
static void mw_mirth_token_Token_col (void) {
	mfld_mirth_token_Token_ZTildecol();
	mp_primZ_mutZ_get();
}
static void mw_mirth_token_Token_row (void) {
	mfld_mirth_token_Token_ZTilderow();
	mp_primZ_mutZ_get();
}
static void mw_mirth_token_Token_noneZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_noneZAsk();
}
static void mw_mirth_token_Token_commaZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_commaZAsk();
}
static void mw_mirth_token_Token_lparenZ_openZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lparenZ_openZAsk();
}
static void mw_mirth_token_Token_lparenZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lparenZAsk();
}
static void mw_mirth_token_Token_rparenZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_rparenZAsk();
}
static void mw_mirth_token_Token_lsquareZ_openZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lsquareZ_openZAsk();
}
static void mw_mirth_token_Token_lsquareZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lsquareZAsk();
}
static void mw_mirth_token_Token_rsquareZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_rsquareZAsk();
}
static void mw_mirth_token_Token_lcurlyZ_openZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lcurlyZ_openZAsk();
}
static void mw_mirth_token_Token_lcurlyZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lcurlyZAsk();
}
static void mw_mirth_token_Token_rcurlyZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_rcurlyZAsk();
}
static void mw_mirth_token_Token_lcolonZ_openZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lcolonZ_openZAsk();
}
static void mw_mirth_token_Token_lcolonZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lcolonZAsk();
}
static void mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lparenZ_orZ_lcolonZAsk();
}
static void mw_mirth_token_Token_intZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_intZAsk();
}
static void mw_mirth_token_Token_strZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_strZAsk();
}
static void mw_mirth_token_Token_nameZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_nameZAsk();
}
static void mw_mirth_token_Token_dnameZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_dnameZAsk();
}
static void mw_mirth_token_Token_nameZ_orZ_dnameZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_nameZ_orZ_dnameZAsk();
}
static void mw_mirth_token_Token_lastZ_nameZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_lastZ_nameZAsk();
}
static void mw_mirth_token_Token_penultimateZ_nameZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_penultimateZ_nameZAsk();
}
static void mw_mirth_token_Token_argZ_endZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_argZ_endZAsk();
}
static void mw_mirth_token_Token_leftZ_enclosureZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_leftZ_enclosureZAsk();
}
static void mw_mirth_token_Token_rightZ_enclosureZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_rightZ_enclosureZAsk();
}
static void mw_mirth_token_Token_sigZ_typeZ_conZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_typeZ_conZAsk();
}
static void mw_mirth_token_Token_sigZ_typeZ_holeZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_typeZ_holeZAsk();
}
static void mw_mirth_token_Token_sigZ_typeZ_varZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_typeZ_varZAsk();
}
static void mw_mirth_token_Token_sigZ_paramZ_nameZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_paramZ_nameZAsk();
}
static void mw_mirth_token_Token_sigZ_stackZ_varZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_stackZ_varZAsk();
}
static void mw_mirth_token_Token_sigZ_resourceZ_varZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_resourceZ_varZAsk();
}
static void mw_mirth_token_Token_sigZ_resourceZ_conZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_resourceZ_conZAsk();
}
static void mw_mirth_token_Token_sigZ_dashesZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_sigZ_dashesZAsk();
}
static void mw_mirth_token_Token_arrowZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_arrowZAsk();
}
static void mw_mirth_token_Token_patZ_underscoreZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_patZ_underscoreZAsk();
}
static void mw_mirth_token_Token_moduleZ_headerZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_moduleZ_headerZAsk();
}
static void mw_mirth_token_Token_canZ_takeZ_argsZAsk (void) {
	mw_mirth_token_Token_value();
	mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk();
}
static void mw_mirth_token_Token_allocZ_noneZBang (void) {
	mw_mirth_token_Token_allocZBang();
	uint64_t v0 = (0LL /* TokenNone */);
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_u64(v0);
	push_value(v1);
	mfld_mirth_token_Token_ZTildevalue();
	mp_primZ_mutZ_set();
}
static void mw_mirth_token_Token_location (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_module();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	lpush(&lbl_module, v1);
	push_value(v2);
	push_value(v2);
	mw_mirth_token_Token_row();
	VAL v3 = pop_value();
	lpush(&lbl_row, v3);
	mw_mirth_token_Token_col();
	VAL v4 = pop_value();
	lpush(&lbl_col, v4);
	mtw_mirth_location_Location_Location();
}
static void mw_mirth_token_Token_next (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_value();
	switch (get_top_data_tag()) {
		case 6LL: { // TokenLParen
			mtp_mirth_token_TokenValue_TokenLParen();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_token_Token_succ();
		} break;
		case 8LL: { // TokenLSquare
			mtp_mirth_token_TokenValue_TokenLSquare();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			decref(v4);
			push_value(v3);
			mw_mirth_token_Token_succ();
		} break;
		case 10LL: { // TokenLCurly
			mtp_mirth_token_TokenValue_TokenLCurly();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			decref(v6);
			push_value(v5);
			mw_mirth_token_Token_succ();
		} break;
		case 12LL: { // TokenLColon
			mtp_mirth_token_TokenValue_TokenLColon();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			decref(v8);
			push_value(v7);
			mw_mirth_token_Token_succ();
		} break;
		default: {
			mw_mirth_token_TokenValue_canZ_takeZ_argsZAsk();
			VAL v9 = pop_value();
			if (VBOOL(v9)) {
				mw_mirth_token_Token_succ();
				VAL v10 = pop_value();
				incref(v10);
				push_value(v10);
				push_value(v10);
				mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v11 = pop_value();
						VAL v12 = pop_value();
						decref(v12);
						push_value(v11);
						mw_mirth_token_Token_succ();
					} break;
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			} else {
				mw_mirth_token_Token_succ();
			}
		} break;
	}
}
static void mw_mirth_token_Token_prev (void) {
	mw_mirth_token_Token_pred();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_value();
	switch (get_top_data_tag()) {
		case 9LL: { // TokenRSquare
			mtp_mirth_token_TokenValue_TokenRSquare();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
		} break;
		case 11LL: { // TokenRCurly
			mtp_mirth_token_TokenValue_TokenRCurly();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			decref(v4);
			push_value(v3);
		} break;
		case 7LL: { // TokenRParen
			mtp_mirth_token_TokenValue_TokenRParen();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			decref(v6);
			incref(v5);
			push_value(v5);
			push_value(v5);
			mw_mirth_token_Token_pred();
			mw_mirth_token_Token_canZ_takeZ_argsZAsk();
			VAL v7 = pop_value();
			if (VBOOL(v7)) {
				mw_mirth_token_Token_pred();
			} else {
			}
		} break;
		case 13LL: { // TokenRColon
			mtp_mirth_token_TokenValue_TokenRColon();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			decref(v9);
			incref(v8);
			push_value(v8);
			push_value(v8);
			mw_mirth_token_Token_pred();
			mw_mirth_token_Token_canZ_takeZ_argsZAsk();
			VAL v10 = pop_value();
			if (VBOOL(v10)) {
				mw_mirth_token_Token_pred();
			} else {
			}
		} break;
		default: {
			VAL v11 = pop_value();
			decref(v11);
		} break;
	}
}
static void mw_mirth_token_Token_nextZ_argZ_end (void) {
	while(1) {
		VAL v0 = pop_value();
		incref(v0);
		push_value(v0);
		push_value(v0);
		mw_mirth_token_Token_argZ_endZAsk();
		VAL v1 = pop_value();
		if (VBOOL(v1)) {
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} else {
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		}
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_mirth_token_Token_next();
	}
}
static void mw_mirth_token_Token_hasZ_argsZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_canZ_takeZ_argsZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_token_Token_succ();
	} else {
	}
	mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk();
	mw_std_maybe_Maybe_1_ZToBool();
}
static void mw_mirth_token_Token_argsZ_start (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_canZ_takeZ_argsZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_token_Token_succ();
		mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk();
		mw_std_maybe_Maybe_1_ZToBool();
	} else {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	}
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
		mw_mirth_token_Token_succ();
	} else {
	}
}
static void mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_token_Token_succ();
		mw_mirth_token_Token_lcolonZAsk();
		mw_std_maybe_Maybe_1_ZToBool();
	} else {
		uint64_t v4 = (0LL /* False */);
		push_u64(v4);
	}
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	decref(v6);
	push_value(v5);
}
static void mw_mirth_token_Token_patternZ_varZAsk (void) {
	mw_mirth_token_Token_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_token_Token_argsZ_0 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_numZ_args();
	int64_t v1 = (0LL);
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == v1);
	if (v3) {
		VAL v4 = pop_value();
		decref(v4);
	} else {
		STRLIT("expected no args", 16);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
}
static void mw_mirth_token_Token_argsZ_1 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_numZ_args();
	int64_t v1 = (1LL);
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == v1);
	if (v3) {
		mw_mirth_token_Token_argsZ_start();
		mw_mirth_token_Token_succ();
	} else {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_token_Token_numZ_args();
		int64_t v5 = (1LL);
		VAL v6 = pop_value();
		bool v7 = (VI64(v6) < v5);
		if (v7) {
			STRLIT("expected 1 arg, got none", 24);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} else {
			STRLIT("expected 1 arg, got too many", 28);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
	}
}
static void mw_mirth_token_Token_argsZ_2 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_numZ_args();
	int64_t v1 = (2LL);
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == v1);
	if (v3) {
		mw_mirth_token_Token_argsZ_start();
		mw_mirth_token_Token_succ();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_token_Token_nextZ_argZ_end();
		mw_mirth_token_Token_succ();
	} else {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_mirth_token_Token_numZ_args();
		int64_t v6 = (2LL);
		VAL v7 = pop_value();
		bool v8 = (VI64(v7) < v6);
		if (v8) {
			STRLIT("expected 2 args, got too few", 28);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} else {
			STRLIT("expected 2 args, got too many", 29);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
	}
}
static void mw_mirth_token_Token_argsZ_3 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_numZ_args();
	int64_t v1 = (3LL);
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == v1);
	if (v3) {
		mw_mirth_token_Token_argsZ_start();
		mw_mirth_token_Token_succ();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_token_Token_nextZ_argZ_end();
		mw_mirth_token_Token_succ();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_mirth_token_Token_nextZ_argZ_end();
		mw_mirth_token_Token_succ();
	} else {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_mirth_token_Token_numZ_args();
		int64_t v7 = (3LL);
		VAL v8 = pop_value();
		bool v9 = (VI64(v8) < v7);
		if (v9) {
			STRLIT("expected 3 args, got too few", 28);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} else {
			STRLIT("expected 3 args, got too many", 29);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
	}
}
static void mw_mirth_token_Token_numZ_args (void) {
	mw_mirth_token_Token_argsZ_start();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_leftZ_enclosureZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		int64_t v3 = (0LL);
		push_i64(v3);
		push_value(v2);
		while(1) {
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mw_mirth_token_Token_argsZ_endZAsk();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				uint64_t v6 = (0LL /* False */);
				push_u64(v6);
			} else {
				uint64_t v7 = (1LL /* True */);
				push_u64(v7);
			}
			VAL v8 = pop_value();
			if (!VBOOL(v8)) break;
			VAL v9 = pop_value();
			int64_t v10 = (1LL);
			push_i64(v10);
			mp_primZ_intZ_add();
			push_value(v9);
			mw_mirth_token_Token_succ();
			mw_mirth_token_Token_nextZ_argZ_end();
		}
		VAL v11 = pop_value();
		decref(v11);
	} else {
		VAL v12 = pop_value();
		decref(v12);
		int64_t v13 = (0LL);
		push_i64(v13);
	}
}
static void mw_mirth_token_Token_args (void) {
	mw_mirth_token_Token_argsZ_start();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_leftZ_enclosureZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		uint64_t v2 = (0LL /* Nil */);
		push_u64(v2);
		mw_std_list_List_1_reverse();
		mtw_std_list_ZPlusList_1_ZPlusList();
		while(1) {
			VAL r3 = pop_resource();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mw_mirth_token_Token_argsZ_endZAsk();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				uint64_t v6 = (0LL /* False */);
				push_u64(v6);
			} else {
				uint64_t v7 = (1LL /* True */);
				push_u64(v7);
			}
			VAL v8 = pop_value();
			push_resource(r3);
			if (!VBOOL(v8)) break;
			VAL r9 = pop_resource();
			mw_mirth_token_Token_succ();
			VAL v10 = pop_value();
			incref(v10);
			push_value(v10);
			mw_mirth_token_Token_nextZ_argZ_end();
			push_value(v10);
			push_resource(r9);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mtw_std_list_List_1_Cons();
			mtw_std_list_ZPlusList_1_ZPlusList();
		}
		mtp_std_list_ZPlusList_1_ZPlusList();
		mw_std_list_List_1_reverse();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		decref(v12);
		push_value(v11);
	} else {
		VAL v13 = pop_value();
		decref(v13);
		uint64_t v14 = (0LL /* Nil */);
		push_u64(v14);
	}
}
static void mw_mirth_token_Token_argsZ_endZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_commaZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_token_Token_succ();
	} else {
	}
	mw_mirth_token_Token_rightZ_enclosureZAsk();
}
static void mw_mirth_token_Token_argsZPlus (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_args();
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("expected 1 or more args, got none", 33);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	decref(v2);
	push_value(v1);
}
static void mw_mirth_token_Token_moduleZ_endZAsk (void) {
	mw_mirth_token_Token_noneZAsk();
}
static void mw_mirth_token_Token_runZ_endZAsk (void) {
	mw_mirth_token_Token_value();
	switch (get_top_data_tag()) {
		case 0LL: { // TokenNone
			(void)pop_u64();
			uint64_t v0 = (1LL /* True */);
			push_u64(v0);
		} break;
		case 1LL: { // TokenComma
			(void)pop_u64();
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 7LL: { // TokenRParen
			mtp_mirth_token_TokenValue_TokenRParen();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		} break;
		case 9LL: { // TokenRSquare
			mtp_mirth_token_TokenValue_TokenRSquare();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		} break;
		case 11LL: { // TokenRCurly
			mtp_mirth_token_TokenValue_TokenRCurly();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (1LL /* True */);
			push_u64(v7);
		} break;
		case 13LL: { // TokenRColon
			mtp_mirth_token_TokenValue_TokenRColon();
			VAL v8 = pop_value();
			decref(v8);
			uint64_t v9 = (1LL /* True */);
			push_u64(v9);
		} break;
		default: {
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (0LL /* False */);
			push_u64(v11);
		} break;
	}
}
static void mw_mirth_token_Token_runZ_tokens (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	while(1) {
		VAL r1 = pop_resource();
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_token_Token_runZ_endZAsk();
		VAL v3 = pop_value();
		if (VBOOL(v3)) {
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} else {
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		}
		VAL v6 = pop_value();
		push_resource(r1);
		if (!VBOOL(v6)) break;
		VAL r7 = pop_resource();
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		mw_mirth_token_Token_next();
		push_value(v8);
		push_resource(r7);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
	}
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	decref(v10);
	push_value(v9);
}
static void mw_mirth_token_Token_runZ_length (void) {
	VAL v0 = pop_value();
	int64_t v1 = (0LL);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	push_value(v0);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_token_Token_runZ_endZAsk();
		VAL v3 = pop_value();
		if (VBOOL(v3)) {
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} else {
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		}
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_mirth_token_Token_next();
		VAL v7 = pop_value();
		int64_t v8 = (1LL);
		push_i64(v8);
		mp_primZ_intZ_add();
		push_value(v7);
	}
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_token_Token_runZ_arrowZAsk (void) {
	mw_mirth_token_Token_runZ_tokens();
	uint64_t v0 = (0LL /* None */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_token_Token_arrowZAsk();
		VAL v9 = pop_value();
		push_value(v6);
		if (VBOOL(v9)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (0LL /* None */);
			push_u64(v11);
		}
		VAL v12 = pop_value();
		push_value(v8);
		push_value(v7);
		push_value(v12);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				decref(v14);
				VAL v15 = pop_value();
				decref(v15);
				uint64_t v16 = (0LL /* Nil */);
				push_value(v13);
				push_u64(v16);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		push_value(v17);
		push_value(v18);
	}
	VAL v19 = pop_value();
	decref(v19);
	VAL v20 = pop_value();
	decref(v20);
}
static void mw_mirth_token_Token_sigZ_stackZ_endZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_sigZ_dashesZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		uint64_t v2 = (1LL /* True */);
		push_u64(v2);
	} else {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_token_Token_runZ_endZAsk();
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	decref(v5);
	push_value(v4);
}
static void mw_mirth_token_Token_sigZ_nextZ_stackZ_end (void) {
	while(1) {
		VAL v0 = pop_value();
		incref(v0);
		push_value(v0);
		push_value(v0);
		mw_mirth_token_Token_sigZ_stackZ_endZAsk();
		VAL v1 = pop_value();
		if (VBOOL(v1)) {
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} else {
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		}
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_mirth_token_Token_next();
	}
}
static void mw_mirth_token_Token_sigZ_hasZ_dashesZAsk (void) {
	mw_mirth_token_Token_sigZ_nextZ_stackZ_end();
	mw_mirth_token_Token_sigZ_dashesZAsk();
}
static void mw_mirth_token_Token_patZ_tokens (void) {
	mw_mirth_token_Token_runZ_tokens();
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	VAL r1 = pop_resource();
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v3 = pop_value();
			incref(v3);
			push_value(v3);
			mw_mirth_token_Token_arrowZAsk();
			VAL v4 = pop_value();
			if (VBOOL(v4)) {
				uint64_t v5 = (0LL /* False */);
				push_u64(v5);
			} else {
				uint64_t v6 = (1LL /* True */);
				push_u64(v6);
			}
			VAL v7 = pop_value();
			push_value(v3);
			if (VBOOL(v7)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v8 = pop_value();
				decref(v8);
				uint64_t v9 = (0LL /* None */);
				push_u64(v9);
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v11 = pop_value();
	push_value(v2);
	push_value(v11);
	push_resource(r1);
	while(1) {
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		push_value(v12);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v13 = pop_value();
		if (!VBOOL(v13)) break;
		mw_std_maybe_Maybe_1_unwrap();
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		VAL r14 = pop_resource();
		mw_std_list_List_1_uncons();
		VAL v15 = pop_value();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v16 = pop_value();
				incref(v16);
				push_value(v16);
				mw_mirth_token_Token_arrowZAsk();
				VAL v17 = pop_value();
				if (VBOOL(v17)) {
					uint64_t v18 = (0LL /* False */);
					push_u64(v18);
				} else {
					uint64_t v19 = (1LL /* True */);
					push_u64(v19);
				}
				VAL v20 = pop_value();
				push_value(v16);
				if (VBOOL(v20)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v21 = pop_value();
					decref(v21);
					uint64_t v22 = (0LL /* None */);
					push_u64(v22);
				}
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v23 = (0LL /* None */);
				push_u64(v23);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v24 = pop_value();
		push_value(v15);
		push_value(v24);
		push_resource(r14);
	}
	VAL v25 = pop_value();
	decref(v25);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v26 = pop_value();
	VAL v27 = pop_value();
	decref(v27);
	push_value(v26);
}
static void mw_mirth_module_Module_index (void) {
}
static void mw_mirth_module_Module_allocZBang (void) {
	mbuf_mirth_module_Module_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_module_Module_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_module_Module_package (void) {
	mfld_mirth_module_Module_ZTildepackage();
	mp_primZ_mutZ_get();
}
static void mw_mirth_module_Module_name (void) {
	mfld_mirth_module_Module_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_module_Module_qname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_module_Module_package();
	mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE();
	push_value(v0);
	mw_mirth_module_Module_name();
	mw_mirth_name_QNAME0();
}
static void mw_mirth_module_Module_path (void) {
	mfld_mirth_module_Module_ZTildepath();
	mp_primZ_mutZ_get();
}
static void mw_mirth_module_Module_start (void) {
	mfld_mirth_module_Module_ZTildestart();
	mp_primZ_mutZ_get();
}
static void mw_mirth_module_Module_imports (void) {
	mfld_mirth_module_Module_ZTildeimports();
	mp_primZ_mutZ_get();
}
static void mw_mirth_module_Module_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_module_Module_index();
	push_value(v0);
	mw_mirth_module_Module_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_module_Module_prim (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_module_initZ_modulesZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* Nil */);
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_u64(v0);
	push_value(v1);
	mfld_mirth_module_Module_ZTildeimports();
	mp_primZ_mutZ_set();
	STRLIT("<prim>", 6);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mfld_mirth_module_Module_ZTildepath();
	mp_primZ_mutZ_set();
	mw_mirth_package_Package_std();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v4);
	push_value(v5);
	mfld_mirth_module_Module_ZTildepackage();
	mp_primZ_mutZ_set();
	STRLIT("prim", 4);
	mw_std_prim_Str_ZToName();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	push_value(v6);
	push_value(v7);
	mfld_mirth_module_Module_ZTildename();
	mp_primZ_mutZ_set();
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_module_Module_newZBang (void) {
	mw_mirth_module_Module_allocZBang();
	mw_mirth_module_Module_prim();
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mtw_std_list_List_1_Cons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	mfld_mirth_module_Module_ZTildeimports();
	mp_primZ_mutZ_set();
	VAL v3 = pop_value();
	incref(v3);
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	push_value(v3);
	mfld_mirth_module_Module_ZTildepath();
	mp_primZ_mutZ_set();
}
static void mw_mirth_module_Module_addZ_importZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mfld_mirth_module_Module_ZTildeimports();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	mp_primZ_mutZ_get();
	mtw_std_list_List_1_Cons();
	push_value(v2);
	mp_primZ_mutZ_set();
}
static void mw_mirth_module_Module_sourceZ_path (void) {
	mw_mirth_module_Module_path();
}
static void mw_mirth_module_Module_visible (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	incref(v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_mirth_module_Module_ZEqualZEqual();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
		VAL v4 = pop_value();
		decref(v4);
		uint64_t v5 = (1LL /* True */);
		push_u64(v5);
	} else {
		mw_mirth_module_Module_imports();
		uint64_t v6 = (0LL /* None */);
		VAL v7 = pop_value();
		push_u64(v6);
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
		while(1) {
			VAL v10 = pop_value();
			incref(v10);
			push_value(v10);
			push_value(v10);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v11 = pop_value();
			if (!VBOOL(v11)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			incref(v12);
			VAL v15 = pop_value();
			incref(v15);
			push_value(v15);
			push_value(v12);
			mw_mirth_module_Module_ZEqualZEqual();
			VAL v16 = pop_value();
			push_value(v15);
			push_value(v12);
			if (VBOOL(v16)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v17 = pop_value();
				decref(v17);
				uint64_t v18 = (0LL /* None */);
				push_u64(v18);
			}
			VAL v19 = pop_value();
			push_value(v14);
			push_value(v13);
			push_value(v19);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v20 = pop_value();
					VAL v21 = pop_value();
					decref(v21);
					VAL v22 = pop_value();
					decref(v22);
					uint64_t v23 = (0LL /* Nil */);
					push_value(v20);
					push_u64(v23);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
		}
		VAL v26 = pop_value();
		decref(v26);
		VAL v27 = pop_value();
		decref(v27);
		VAL v28 = pop_value();
		VAL v29 = pop_value();
		decref(v29);
		push_value(v28);
		mw_std_maybe_Maybe_1_someZAsk();
	}
}
static void mw_std_prim_Int_ZToRow (void) {
}
static void mw_mirth_location_Row_ZToInt (void) {
}
static void mw_mirth_location_Row_showZThen (void) {
	mp_primZ_intZ_toZ_str();
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_std_prim_Int_ZToCol (void) {
}
static void mw_mirth_location_Col_ZToInt (void) {
}
static void mw_mirth_location_Col_showZThen (void) {
	mp_primZ_intZ_toZ_str();
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_mirth_location_Location_emitZThen (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Location
			mtp_mirth_location_Location_Location();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_module));
	push_value(v0);
	mw_mirth_module_Module_sourceZ_path();
	mw_std_str_ZPlusStr_pushZ_strZBang();
	STRLIT(":", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v1 = (lpop(&lbl_row));
	push_value(v1);
	mw_mirth_location_Row_showZThen();
	STRLIT(":", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v2 = (lpop(&lbl_col));
	push_value(v2);
	mw_mirth_location_Col_showZThen();
}
static void mw_mirth_alias_Alias_index (void) {
}
static void mw_mirth_alias_Alias_allocZBang (void) {
	mbuf_mirth_alias_Alias_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_alias_Alias_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_alias_Alias_qnameZ_soft (void) {
	mfld_mirth_alias_Alias_ZTildeqname();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_mirth_Prop_1_readyZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_alias_Alias_qnameZ_hard (void) {
	mfld_mirth_alias_Alias_ZTildeqname();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_alias_Alias_namespaceZ_hard (void) {
	mw_mirth_alias_Alias_qnameZ_hard();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_alias_Alias_name (void) {
	mfld_mirth_alias_Alias_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_alias_Alias_arity (void) {
	mfld_mirth_alias_Alias_ZTildearity();
	mp_primZ_mutZ_get();
}
static void mw_mirth_alias_Alias_target (void) {
	mfld_mirth_alias_Alias_ZTildetarget();
	mw_mirth_mirth_Prop_1_forceZBang();
}
static void mw_mirth_alias_Alias_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_alias_Alias_index();
	push_value(v0);
	mw_mirth_alias_Alias_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_alias_Alias_newZBang (void) {
	mw_mirth_alias_Alias_allocZBang();
	VAL v0 = (lpop(&lbl_name));
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mfld_mirth_alias_Alias_ZTildename();
	mp_primZ_mutZ_set();
	VAL v2 = (lpop(&lbl_head));
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mfld_mirth_alias_Alias_ZTildehead();
	mp_primZ_mutZ_set();
	VAL v4 = (lpop(&lbl_arity));
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v4);
	push_value(v5);
	mfld_mirth_alias_Alias_ZTildearity();
	mp_primZ_mutZ_set();
	VAL v6 = pop_value();
	incref(v6);
	push_value(v6);
	push_value(v6);
	mtw_mirth_def_Def_DefAlias();
	mw_mirth_def_Def_register();
}
static void mw_mirth_mirth_Builtin_AllocZBang (void) {
	mw_mirth_package_Package_allocZBang();
	VAL v0 = pop_value();
	lpush(&lbl_std, v0);
	mw_mirth_module_Module_allocZBang();
	VAL v1 = pop_value();
	lpush(&lbl_prim, v1);
	mw_mirth_data_Data_allocZBang();
	VAL v2 = pop_value();
	lpush(&lbl_bool, v2);
	mw_mirth_data_Tag_allocZBang();
	VAL v3 = pop_value();
	lpush(&lbl_true, v3);
	mw_mirth_data_Tag_allocZBang();
	VAL v4 = pop_value();
	lpush(&lbl_false, v4);
	mw_mirth_data_Data_allocZBang();
	VAL v5 = pop_value();
	lpush(&lbl_u64, v5);
	mw_mirth_data_Tag_allocZBang();
	VAL v6 = pop_value();
	lpush(&lbl_mkZ_u64, v6);
	mw_mirth_data_Data_allocZBang();
	VAL v7 = pop_value();
	lpush(&lbl_u32, v7);
	mw_mirth_data_Tag_allocZBang();
	VAL v8 = pop_value();
	lpush(&lbl_mkZ_u32, v8);
	mw_mirth_data_Data_allocZBang();
	VAL v9 = pop_value();
	lpush(&lbl_u16, v9);
	mw_mirth_data_Tag_allocZBang();
	VAL v10 = pop_value();
	lpush(&lbl_mkZ_u16, v10);
	mw_mirth_data_Data_allocZBang();
	VAL v11 = pop_value();
	lpush(&lbl_u8, v11);
	mw_mirth_data_Tag_allocZBang();
	VAL v12 = pop_value();
	lpush(&lbl_mkZ_u8, v12);
	mw_mirth_data_Data_allocZBang();
	VAL v13 = pop_value();
	lpush(&lbl_i64, v13);
	mw_mirth_data_Tag_allocZBang();
	VAL v14 = pop_value();
	lpush(&lbl_mkZ_i64, v14);
	mw_mirth_data_Data_allocZBang();
	VAL v15 = pop_value();
	lpush(&lbl_i32, v15);
	mw_mirth_data_Tag_allocZBang();
	VAL v16 = pop_value();
	lpush(&lbl_mkZ_i32, v16);
	mw_mirth_data_Data_allocZBang();
	VAL v17 = pop_value();
	lpush(&lbl_i16, v17);
	mw_mirth_data_Tag_allocZBang();
	VAL v18 = pop_value();
	lpush(&lbl_mkZ_i16, v18);
	mw_mirth_data_Data_allocZBang();
	VAL v19 = pop_value();
	lpush(&lbl_i8, v19);
	mw_mirth_data_Tag_allocZBang();
	VAL v20 = pop_value();
	lpush(&lbl_mkZ_i8, v20);
	mw_mirth_data_Data_allocZBang();
	VAL v21 = pop_value();
	lpush(&lbl_cchar, v21);
	mw_mirth_data_Tag_allocZBang();
	VAL v22 = pop_value();
	lpush(&lbl_mkZ_cchar, v22);
	mw_mirth_data_Data_allocZBang();
	VAL v23 = pop_value();
	lpush(&lbl_cichar, v23);
	mw_mirth_data_Tag_allocZBang();
	VAL v24 = pop_value();
	lpush(&lbl_mkZ_cichar, v24);
	mw_mirth_data_Data_allocZBang();
	VAL v25 = pop_value();
	lpush(&lbl_cshort, v25);
	mw_mirth_data_Tag_allocZBang();
	VAL v26 = pop_value();
	lpush(&lbl_mkZ_cshort, v26);
	mw_mirth_data_Data_allocZBang();
	VAL v27 = pop_value();
	lpush(&lbl_cint, v27);
	mw_mirth_data_Tag_allocZBang();
	VAL v28 = pop_value();
	lpush(&lbl_mkZ_cint, v28);
	mw_mirth_data_Data_allocZBang();
	VAL v29 = pop_value();
	lpush(&lbl_clong, v29);
	mw_mirth_data_Tag_allocZBang();
	VAL v30 = pop_value();
	lpush(&lbl_mkZ_clong, v30);
	mw_mirth_data_Data_allocZBang();
	VAL v31 = pop_value();
	lpush(&lbl_clonglong, v31);
	mw_mirth_data_Tag_allocZBang();
	VAL v32 = pop_value();
	lpush(&lbl_mkZ_clonglong, v32);
	mw_mirth_data_Data_allocZBang();
	VAL v33 = pop_value();
	lpush(&lbl_cisizze, v33);
	mw_mirth_data_Tag_allocZBang();
	VAL v34 = pop_value();
	lpush(&lbl_mkZ_cisizze, v34);
	mw_mirth_data_Data_allocZBang();
	VAL v35 = pop_value();
	lpush(&lbl_cintptr, v35);
	mw_mirth_data_Tag_allocZBang();
	VAL v36 = pop_value();
	lpush(&lbl_mkZ_cintptr, v36);
	mw_mirth_data_Data_allocZBang();
	VAL v37 = pop_value();
	lpush(&lbl_cuchar, v37);
	mw_mirth_data_Tag_allocZBang();
	VAL v38 = pop_value();
	lpush(&lbl_mkZ_cuchar, v38);
	mw_mirth_data_Data_allocZBang();
	VAL v39 = pop_value();
	lpush(&lbl_cushort, v39);
	mw_mirth_data_Tag_allocZBang();
	VAL v40 = pop_value();
	lpush(&lbl_mkZ_cushort, v40);
	mw_mirth_data_Data_allocZBang();
	VAL v41 = pop_value();
	lpush(&lbl_cuint, v41);
	mw_mirth_data_Tag_allocZBang();
	VAL v42 = pop_value();
	lpush(&lbl_mkZ_cuint, v42);
	mw_mirth_data_Data_allocZBang();
	VAL v43 = pop_value();
	lpush(&lbl_culong, v43);
	mw_mirth_data_Tag_allocZBang();
	VAL v44 = pop_value();
	lpush(&lbl_mkZ_culong, v44);
	mw_mirth_data_Data_allocZBang();
	VAL v45 = pop_value();
	lpush(&lbl_culonglong, v45);
	mw_mirth_data_Tag_allocZBang();
	VAL v46 = pop_value();
	lpush(&lbl_mkZ_culonglong, v46);
	mw_mirth_data_Data_allocZBang();
	VAL v47 = pop_value();
	lpush(&lbl_cusizze, v47);
	mw_mirth_data_Tag_allocZBang();
	VAL v48 = pop_value();
	lpush(&lbl_mkZ_cusizze, v48);
	mw_mirth_data_Data_allocZBang();
	VAL v49 = pop_value();
	lpush(&lbl_cuintptr, v49);
	mw_mirth_data_Tag_allocZBang();
	VAL v50 = pop_value();
	lpush(&lbl_mkZ_cuintptr, v50);
	mw_mirth_data_Data_allocZBang();
	VAL v51 = pop_value();
	lpush(&lbl_cptr, v51);
	mw_mirth_data_Tag_allocZBang();
	VAL v52 = pop_value();
	lpush(&lbl_mkZ_cptr, v52);
	mw_mirth_data_Data_allocZBang();
	VAL v53 = pop_value();
	lpush(&lbl_cconst, v53);
	mw_mirth_data_Tag_allocZBang();
	VAL v54 = pop_value();
	lpush(&lbl_mkZ_cconst, v54);
	mw_mirth_data_Data_allocZBang();
	VAL v55 = pop_value();
	lpush(&lbl_crestrict, v55);
	mw_mirth_data_Tag_allocZBang();
	VAL v56 = pop_value();
	lpush(&lbl_mkZ_crestrict, v56);
	mw_mirth_data_Data_allocZBang();
	VAL v57 = pop_value();
	lpush(&lbl_cvolatile, v57);
	mw_mirth_data_Tag_allocZBang();
	VAL v58 = pop_value();
	lpush(&lbl_mkZ_cvolatile, v58);
	mw_mirth_data_Data_allocZBang();
	VAL v59 = pop_value();
	lpush(&lbl_cvoid, v59);
	mw_mirth_data_Tag_allocZBang();
	VAL v60 = pop_value();
	lpush(&lbl_mkZ_cvoid, v60);
	mtw_mirth_mirth_Builtin_Builtin();
}
static void mw_mirth_mirth_ZPlusMirth_InitZBang (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	VAL v1 = pop_value();
	int64_t v2 = (0LL);
	lpush(&lbl_numZ_errors, v1);
	push_i64(v2);
	mw_std_prim_Int_ZToNat();
	VAL v3 = pop_value();
	uint64_t v4 = (0LL /* False */);
	lpush(&lbl_numZ_warnings, v3);
	lpush(&lbl_preferZ_inlineZ_defs, MKU64(v4));
	mw_mirth_mirth_Builtin_AllocZBang();
	VAL v5 = pop_value();
	uint64_t v6 = (0LL /* Nil */);
	uint64_t v7 = (0LL /* Nil */);
	lpush(&lbl_builtin, v5);
	lpush(&lbl_packageZ_searchZ_paths, MKU64(v6));
	push_u64(v7);
	mtw_std_list_ZPlusList_1_ZPlusList();
	VAL r8 = pop_resource();
	uint64_t v9 = (0LL /* Nil */);
	lpush(&lbl_ZPlusdiagnostics, r8);
	push_u64(v9);
	mtw_std_list_ZPlusList_1_ZPlusList();
	VAL r10 = pop_resource();
	uint64_t v11 = (0LL /* None */);
	lpush(&lbl_ZPluspropstack, r10);
	lpush(&lbl_errorZ_token, MKU64(v11));
	mtw_mirth_mirth_ZPlusMirth_ZPlusMirth();
	mw_mirth_package_initZ_packagesZBang();
	mw_mirth_module_initZ_modulesZBang();
	mw_mirth_mirth_ZPlusMirth_initZ_typesZBang();
	mw_mirth_prim_initZ_primsZBang();
}
static void mw_mirth_mirth_ZPlusMirth_rdrop (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Mirth
			mtp_mirth_mirth_ZPlusMirth_ZPlusMirth();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_numZ_errors));
	decref(v0);
	VAL v1 = (lpop(&lbl_numZ_warnings));
	decref(v1);
	VAL v2 = (lpop(&lbl_preferZ_inlineZ_defs));
	decref(v2);
	VAL v3 = (lpop(&lbl_builtin));
	decref(v3);
	VAL v4 = (lpop(&lbl_errorZ_token));
	decref(v4);
	VAL v5 = (lpop(&lbl_packageZ_searchZ_paths));
	decref(v5);
	VAL v6 = (lpop(&lbl_ZPlusdiagnostics));
	push_resource(v6);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v7 = pop_value();
	decref(v7);
	VAL v8 = (lpop(&lbl_ZPluspropstack));
	push_resource(v8);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_mirth_Severity_ZToStr (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Info
			(void)pop_u64();
			STRLIT("info", 4);
		} break;
		case 1LL: { // Warning
			(void)pop_u64();
			STRLIT("warning", 7);
		} break;
		case 2LL: { // Error
			(void)pop_u64();
			STRLIT("error", 5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v0);
	lpush(&lbl_message, v1);
	lpush(&lbl_location, v2);
	push_value(v0);
	lpush(&lbl_severity, v0);
	switch (get_top_data_tag()) {
		case 0LL: { // Info
			(void)pop_u64();
		} break;
		case 1LL: { // Warning
			(void)pop_u64();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r3 = pop_resource();
			int64_t v4 = (1LL);
			push_i64(v4);
			mp_primZ_intZ_add();
			push_resource(r3);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL t = *p; *p = u; decref(t);
			}
		} break;
		case 2LL: { // Error
			(void)pop_u64();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r5 = pop_resource();
			int64_t v6 = (1LL);
			push_i64(v6);
			mp_primZ_intZ_add();
			push_resource(r5);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL t = *p; *p = u; decref(t);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mtw_mirth_mirth_Diagnostic_Diagnostic();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r7 = pop_resource();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusList_1_ZPlusList();
	push_resource(r7);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[7];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang (void) {
	uint64_t v0 = (0LL /* Info */);
	push_u64(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang (void) {
	uint64_t v0 = (1LL /* Warning */);
	push_u64(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang (void) {
	uint64_t v0 = (2LL /* Error */);
	push_u64(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_diagnosticZ_atZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang (void) {
	mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang();
	mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_infoZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_token_Token_location();
	push_value(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_infoZ_atZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_token_Token_location();
	push_value(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_token_Token_location();
	push_value(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_errorZ_atZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_token_Token_location();
	push_value(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang();
}
static void mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang (void) {
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	uint64_t v0 = (36LL /* FGCyan */);
	push_u64(v0);
	mw_std_terminal_Sgr_emitZThen();
	VAL v1 = (lpop(&lbl_old));
	push_value(v1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	uint64_t v2 = (0LL /* Reset */);
	push_u64(v2);
	mw_std_terminal_Sgr_emitZThen();
	STRLIT(" is deprecated, please use ", 27);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	uint64_t v3 = (36LL /* FGCyan */);
	push_u64(v3);
	mw_std_terminal_Sgr_emitZThen();
	VAL v4 = (lpop(&lbl_new));
	push_value(v4);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	uint64_t v5 = (0LL /* Reset */);
	push_u64(v5);
	mw_std_terminal_Sgr_emitZThen();
	STRLIT(" instead.", 9);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mtp_std_str_ZPlusStr_ZPlusStr();
	mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang();
}
static void mw_mirth_mirth_ZPlusMirth_errorZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_std_maybe_Maybe_1_unwrap();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
}
static void mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_std_maybe_Maybe_1_unwrap();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
}
static void mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang (void) {
	mw_mirth_mirth_ZPlusMirth_popZ_diagnostics();
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_mirth_Diagnostic_diagnosticZThen();
		STRLIT("\n", 1);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
	uint64_t v10 = (31LL /* FGRed */);
	push_u64(v10);
	mw_std_terminal_Sgr_emitZThen();
	STRLIT("Fatal error. Stopping early.", 28);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	uint64_t v11 = (0LL /* Reset */);
	push_u64(v11);
	mw_std_terminal_Sgr_emitZThen();
	mtp_std_str_ZPlusStr_ZPlusStr();
	mp_primZ_panic();
}
static void mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang (void) {
	mw_mirth_mirth_ZPlusMirth_popZ_diagnostics();
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		VAL r6 = pop_resource();
		push_value(v4);
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		mw_mirth_mirth_Diagnostic_diagnosticZThen();
		mtp_std_str_ZPlusStr_ZPlusStr();
		STRLIT("\n", 1);
		mp_primZ_strZ_cat();
		mw_std_prim_ZPlusWorld_traceZ_();
		push_resource(r6);
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
	}
	VAL v9 = pop_value();
	decref(v9);
	VAL v10 = pop_value();
	decref(v10);
}
static void mw_mirth_mirth_ZPlusMirth_popZ_diagnostics (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	uint64_t v1 = (0LL /* Nil */);
	push_u64(v1);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[7];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_mirth_Diagnostic_diagnosticZThen (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Diagnostic
			mtp_mirth_mirth_Diagnostic_Diagnostic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_location));
	push_value(v0);
	mw_mirth_location_Location_emitZThen();
	STRLIT(": ", 2);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v1 = (lpop(&lbl_severity));
	push_value(v1);
	mw_mirth_mirth_Severity_ZToStr();
	mw_std_str_ZPlusStr_pushZ_strZBang();
	STRLIT(": ", 2);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v2 = (lpop(&lbl_message));
	push_value(v2);
	mw_std_str_ZPlusStr_pushZ_strZBang();
}
static void mw_mirth_mirth_PropLabel_prop (void) {
	VAL v0 = pop_value();
	lpush(&lbl_label, v0);
	mtw_mirth_mirth_PropState_1_PSReady();
	VAL v1 = pop_value();
	lpush(&lbl_state, v1);
	mtw_mirth_mirth_Prop_1_Prop();
}
static void mw_mirth_mirth_PropLabel_prop2 (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	mp_primZ_packZ_nil();
	push_value(v2);
	mp_primZ_packZ_cons();
	push_value(v1);
	mp_primZ_packZ_cons();
	push_value(v0);
	mw_mirth_mirth_PropLabel_prop();
}
static void mw_mirth_mirth_PropLabel_prop0_1 (void) {
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		VAL v1 = pop_value();
		int64_t v2 = (0LL);
		push_i64(v2);
		push_value(v1);
		VAL v3 = (MKFNPTR(&mb_mirth_mirth_PropLabel_prop0_1_1));
		push_value(v3);
		incref(var_f);
		VAL v4 = (var_f);
		push_value(v4);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop_1();
		decref(var_f);
	}
}
static void mw_mirth_mirth_PropLabel_prop_1 (void) {
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		VAL v1 = pop_value();
		lpush(&lbl_label, v1);
		incref(var_f);
		VAL v2 = (var_f);
		push_value(v2);
		mtw_mirth_mirth_PropState_1_PSDelay();
		VAL v3 = pop_value();
		lpush(&lbl_state, v3);
		mtw_mirth_mirth_Prop_1_Prop();
		decref(var_f);
	}
}
static void mw_mirth_mirth_PropLabel_prop2_1 (void) {
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		VAL v1 = pop_value();
		VAL v2 = pop_value();
		VAL v3 = pop_value();
		mp_primZ_packZ_nil();
		push_value(v3);
		mp_primZ_packZ_cons();
		push_value(v2);
		mp_primZ_packZ_cons();
		push_value(v1);
		VAL v4 = (MKFNPTR(&mb_mirth_mirth_PropLabel_prop2_1_1));
		push_value(v4);
		incref(var_f);
		VAL v5 = (var_f);
		push_value(v5);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop_1();
		decref(var_f);
	}
}
static void mw_mirth_mirth_PropLabel_prop3_1 (void) {
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		VAL v1 = pop_value();
		VAL v2 = pop_value();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		mp_primZ_packZ_nil();
		push_value(v4);
		mp_primZ_packZ_cons();
		push_value(v3);
		mp_primZ_packZ_cons();
		push_value(v2);
		mp_primZ_packZ_cons();
		push_value(v1);
		VAL v5 = (MKFNPTR(&mb_mirth_mirth_PropLabel_prop3_1_1));
		push_value(v5);
		incref(var_f);
		VAL v6 = (var_f);
		push_value(v6);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop_1();
		decref(var_f);
	}
}
static void mw_mirth_mirth_Prop_1_readyZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // PSReady
			mtp_mirth_mirth_PropState_1_PSReady();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_mirth_Prop_1_tryZ_forceZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mp_primZ_mutZ_get();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // PSReady
			mtp_mirth_mirth_PropState_1_PSReady();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // PSDelay
			mtp_mirth_mirth_PropState_1_PSDelay();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			uint64_t v6 = (2LL /* PSComputing */);
			incref(v5);
			incref(v5);
			push_value(v4);
			push_value(v3);
			push_value(v5);
			push_u64(v6);
			push_value(v5);
			mp_primZ_mutZ_get();
			{
				VAL v = pop_value();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				if (VTUP(v)->refs == 1) {
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
					push_value(v);
				} else {
					TUP *tup = tup_new(3);
					tup->size = 3;
					tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
					tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
					tup->cells[2] = u;
					decref(v);
					push_value(MKTUP(tup,3));
				}
			}
			push_value(v5);
			mp_primZ_mutZ_set();
			VAL v7 = pop_value();
			mp_primZ_run();
			VAL v8 = pop_value();
			incref(v8);
			push_value(v8);
			push_value(v8);
			mtw_mirth_mirth_PropState_1_PSReady();
			incref(v7);
			push_value(v7);
			mp_primZ_mutZ_get();
			{
				VAL v = pop_value();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				if (VTUP(v)->refs == 1) {
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
					push_value(v);
				} else {
					TUP *tup = tup_new(3);
					tup->size = 3;
					tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
					tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
					tup->cells[2] = u;
					decref(v);
					push_value(MKTUP(tup,3));
				}
			}
			push_value(v7);
			mp_primZ_mutZ_set();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // PSComputing
			(void)pop_u64();
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_mirth_Prop_1_forceZBang (void) {
	mw_mirth_mirth_Prop_1_tryZ_forceZBang();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Recursive prop detected!", 24);
			mw_mirth_mirth_ZPlusMirth_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_mirth_Prop_1_forceZ_orZBang_1 (void) {
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		mw_mirth_mirth_Prop_1_tryZ_forceZBang();
		incref(var_f);
		VAL v1 = (var_f);
		push_value(v1);
		{
			VAL v2 = pop_value();
			VAL var_f = v2;
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					incref(var_f);
					run_value(var_f);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			decref(var_f);
		}
		decref(var_f);
	}
}
static void mw_mirth_def_Def_packageZAsk (void) {
	switch (get_top_data_tag()) {
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_moduleZAsk (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_aliasZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_dataZAsk (void) {
	switch (get_top_data_tag()) {
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_tableZAsk (void) {
	switch (get_top_data_tag()) {
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_typedefZAsk (void) {
	switch (get_top_data_tag()) {
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_tagZAsk (void) {
	switch (get_top_data_tag()) {
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_primZAsk (void) {
	switch (get_top_data_tag()) {
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_wordZAsk (void) {
	switch (get_top_data_tag()) {
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_bufferZAsk (void) {
	switch (get_top_data_tag()) {
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_variableZAsk (void) {
	switch (get_top_data_tag()) {
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_externalZAsk (void) {
	switch (get_top_data_tag()) {
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_fieldZAsk (void) {
	switch (get_top_data_tag()) {
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_def_Def_ZEqualZEqual (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mtw_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			mw_mirth_def_Def_aliasZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v2 = pop_value();
					VAL v3 = pop_value();
					push_value(v2);
					push_value(v3);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v4 = pop_value();
							VAL v5 = pop_value();
							push_value(v4);
							push_value(v5);
							mw_mirth_alias_Alias_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v6 = pop_value();
							decref(v6);
							uint64_t v7 = (0LL /* False */);
							push_u64(v7);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			mtw_std_maybe_Maybe_1_Some();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			push_value(v8);
			push_value(v9);
			mw_mirth_def_Def_packageZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v10 = pop_value();
					VAL v11 = pop_value();
					push_value(v10);
					push_value(v11);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v12 = pop_value();
							VAL v13 = pop_value();
							push_value(v12);
							push_value(v13);
							mw_mirth_package_Package_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v14 = pop_value();
							decref(v14);
							uint64_t v15 = (0LL /* False */);
							push_u64(v15);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			mtw_std_maybe_Maybe_1_Some();
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			push_value(v16);
			push_value(v17);
			mw_mirth_def_Def_moduleZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v18 = pop_value();
					VAL v19 = pop_value();
					push_value(v18);
					push_value(v19);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v20 = pop_value();
							VAL v21 = pop_value();
							push_value(v20);
							push_value(v21);
							mw_mirth_module_Module_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v22 = pop_value();
							decref(v22);
							uint64_t v23 = (0LL /* False */);
							push_u64(v23);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			mtw_std_maybe_Maybe_1_Some();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
			mw_mirth_def_Def_bufferZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v26 = pop_value();
					VAL v27 = pop_value();
					push_value(v26);
					push_value(v27);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v28 = pop_value();
							VAL v29 = pop_value();
							push_value(v28);
							push_value(v29);
							mw_mirth_buffer_Buffer_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v30 = pop_value();
							decref(v30);
							uint64_t v31 = (0LL /* False */);
							push_u64(v31);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			mtw_std_maybe_Maybe_1_Some();
			VAL v32 = pop_value();
			VAL v33 = pop_value();
			push_value(v32);
			push_value(v33);
			mw_mirth_def_Def_primZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v34 = pop_value();
					VAL v35 = pop_value();
					push_value(v34);
					push_value(v35);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v36 = pop_value();
							VAL v37 = pop_value();
							push_value(v36);
							push_value(v37);
							mw_mirth_prim_Prim_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v38 = pop_value();
							decref(v38);
							uint64_t v39 = (0LL /* False */);
							push_u64(v39);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mtw_std_maybe_Maybe_1_Some();
			VAL v40 = pop_value();
			VAL v41 = pop_value();
			push_value(v40);
			push_value(v41);
			mw_mirth_def_Def_dataZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v42 = pop_value();
					VAL v43 = pop_value();
					push_value(v42);
					push_value(v43);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v44 = pop_value();
							VAL v45 = pop_value();
							push_value(v44);
							push_value(v45);
							mw_mirth_data_Data_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v46 = pop_value();
							decref(v46);
							uint64_t v47 = (0LL /* False */);
							push_u64(v47);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			mtw_std_maybe_Maybe_1_Some();
			VAL v48 = pop_value();
			VAL v49 = pop_value();
			push_value(v48);
			push_value(v49);
			mw_mirth_def_Def_tableZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v50 = pop_value();
					VAL v51 = pop_value();
					push_value(v50);
					push_value(v51);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v52 = pop_value();
							VAL v53 = pop_value();
							push_value(v52);
							push_value(v53);
							mw_mirth_table_Table_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v54 = pop_value();
							decref(v54);
							uint64_t v55 = (0LL /* False */);
							push_u64(v55);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mtw_std_maybe_Maybe_1_Some();
			VAL v56 = pop_value();
			VAL v57 = pop_value();
			push_value(v56);
			push_value(v57);
			mw_mirth_def_Def_typedefZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v58 = pop_value();
					VAL v59 = pop_value();
					push_value(v58);
					push_value(v59);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v60 = pop_value();
							VAL v61 = pop_value();
							push_value(v60);
							push_value(v61);
							mw_mirth_typedef_TypeDef_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v62 = pop_value();
							decref(v62);
							uint64_t v63 = (0LL /* False */);
							push_u64(v63);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mtw_std_maybe_Maybe_1_Some();
			VAL v64 = pop_value();
			VAL v65 = pop_value();
			push_value(v64);
			push_value(v65);
			mw_mirth_def_Def_externalZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v66 = pop_value();
					VAL v67 = pop_value();
					push_value(v66);
					push_value(v67);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v68 = pop_value();
							VAL v69 = pop_value();
							push_value(v68);
							push_value(v69);
							mw_mirth_external_External_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v70 = pop_value();
							decref(v70);
							uint64_t v71 = (0LL /* False */);
							push_u64(v71);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mtw_std_maybe_Maybe_1_Some();
			VAL v72 = pop_value();
			VAL v73 = pop_value();
			push_value(v72);
			push_value(v73);
			mw_mirth_def_Def_wordZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v74 = pop_value();
					VAL v75 = pop_value();
					push_value(v74);
					push_value(v75);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v76 = pop_value();
							VAL v77 = pop_value();
							push_value(v76);
							push_value(v77);
							mw_mirth_word_Word_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v78 = pop_value();
							decref(v78);
							uint64_t v79 = (0LL /* False */);
							push_u64(v79);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			mtw_std_maybe_Maybe_1_Some();
			VAL v80 = pop_value();
			VAL v81 = pop_value();
			push_value(v80);
			push_value(v81);
			mw_mirth_def_Def_fieldZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v82 = pop_value();
					VAL v83 = pop_value();
					push_value(v82);
					push_value(v83);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v84 = pop_value();
							VAL v85 = pop_value();
							push_value(v84);
							push_value(v85);
							mw_mirth_table_Field_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v86 = pop_value();
							decref(v86);
							uint64_t v87 = (0LL /* False */);
							push_u64(v87);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			mtw_std_maybe_Maybe_1_Some();
			VAL v88 = pop_value();
			VAL v89 = pop_value();
			push_value(v88);
			push_value(v89);
			mw_mirth_def_Def_tagZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v90 = pop_value();
					VAL v91 = pop_value();
					push_value(v90);
					push_value(v91);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v92 = pop_value();
							VAL v93 = pop_value();
							push_value(v92);
							push_value(v93);
							mw_mirth_data_Tag_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v94 = pop_value();
							decref(v94);
							uint64_t v95 = (0LL /* False */);
							push_u64(v95);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			mtw_std_maybe_Maybe_1_Some();
			VAL v96 = pop_value();
			VAL v97 = pop_value();
			push_value(v96);
			push_value(v97);
			mw_mirth_def_Def_variableZAsk();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v98 = pop_value();
					VAL v99 = pop_value();
					push_value(v98);
					push_value(v99);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v100 = pop_value();
							VAL v101 = pop_value();
							push_value(v100);
							push_value(v101);
							mw_mirth_variable_Variable_ZEqualZEqual();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v102 = pop_value();
							decref(v102);
							uint64_t v103 = (0LL /* False */);
							push_u64(v103);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_typecheckZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mw_mirth_alias_Alias_target();
			mw_mirth_def_Def_typecheckZBang();
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			VAL v1 = pop_value();
			decref(v1);
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			VAL v2 = pop_value();
			decref(v2);
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			VAL v3 = pop_value();
			decref(v3);
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			VAL v4 = pop_value();
			decref(v4);
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			VAL v5 = pop_value();
			decref(v5);
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mw_mirth_typedef_TypeDef_target();
			VAL v6 = pop_value();
			decref(v6);
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mw_mirth_external_External_type();
			VAL v7 = pop_value();
			decref(v7);
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			VAL v8 = pop_value();
			incref(v8);
			push_value(v8);
			push_value(v8);
			mw_mirth_word_Word_type();
			VAL v9 = pop_value();
			decref(v9);
			mw_mirth_word_Word_arrow();
			VAL v10 = pop_value();
			decref(v10);
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			mw_mirth_table_Field_type();
			VAL v11 = pop_value();
			decref(v11);
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			mw_mirth_data_Tag_type();
			VAL v12 = pop_value();
			decref(v12);
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			mw_mirth_variable_Variable_type();
			VAL v13 = pop_value();
			decref(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_callableZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mfld_mirth_alias_Alias_ZTildetarget();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_def_Def_callableZAsk();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v0 = (0LL /* False */);
					push_u64(v0);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (1LL /* True */);
			push_u64(v6);
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (1LL /* True */);
			push_u64(v8);
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* False */);
			push_u64(v10);
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* False */);
			push_u64(v12);
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			VAL v13 = pop_value();
			decref(v13);
			uint64_t v14 = (0LL /* False */);
			push_u64(v14);
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			VAL v15 = pop_value();
			decref(v15);
			uint64_t v16 = (1LL /* True */);
			push_u64(v16);
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			VAL v17 = pop_value();
			decref(v17);
			uint64_t v18 = (1LL /* True */);
			push_u64(v18);
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			VAL v19 = pop_value();
			decref(v19);
			uint64_t v20 = (1LL /* True */);
			push_u64(v20);
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			VAL v21 = pop_value();
			decref(v21);
			uint64_t v22 = (1LL /* True */);
			push_u64(v22);
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			VAL v23 = pop_value();
			decref(v23);
			uint64_t v24 = (1LL /* True */);
			push_u64(v24);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_definesZ_aZ_typeZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mfld_mirth_alias_Alias_ZTildetarget();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_def_Def_definesZ_aZ_typeZAsk();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v0 = (0LL /* False */);
					push_u64(v0);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* False */);
			push_u64(v6);
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (0LL /* False */);
			push_u64(v8);
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (1LL /* True */);
			push_u64(v10);
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (1LL /* True */);
			push_u64(v12);
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			VAL v13 = pop_value();
			decref(v13);
			uint64_t v14 = (1LL /* True */);
			push_u64(v14);
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			VAL v15 = pop_value();
			decref(v15);
			uint64_t v16 = (0LL /* False */);
			push_u64(v16);
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			VAL v17 = pop_value();
			decref(v17);
			uint64_t v18 = (0LL /* False */);
			push_u64(v18);
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			VAL v19 = pop_value();
			decref(v19);
			uint64_t v20 = (0LL /* False */);
			push_u64(v20);
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			VAL v21 = pop_value();
			decref(v21);
			uint64_t v22 = (0LL /* False */);
			push_u64(v22);
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			VAL v23 = pop_value();
			decref(v23);
			uint64_t v24 = (0LL /* False */);
			push_u64(v24);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_exposedZ_tyconZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mfld_mirth_alias_Alias_ZTildetarget();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_def_Def_exposedZ_tyconZAsk();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v0 = (0LL /* None */);
					push_u64(v0);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* None */);
			push_u64(v2);
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* None */);
			push_u64(v4);
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mtw_mirth_tycon_Tycon_TYCONz_DATA();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			mtw_mirth_tycon_Tycon_TYCONz_TABLE();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mw_mirth_typedef_TypeDef_target();
			mw_mirth_type_Type_tyconZAsk();
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* None */);
			push_u64(v6);
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			VAL v7 = pop_value();
			decref(v7);
			uint64_t v8 = (0LL /* None */);
			push_u64(v8);
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			VAL v11 = pop_value();
			decref(v11);
			uint64_t v12 = (0LL /* None */);
			push_u64(v12);
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			VAL v13 = pop_value();
			decref(v13);
			uint64_t v14 = (0LL /* None */);
			push_u64(v14);
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			VAL v15 = pop_value();
			decref(v15);
			uint64_t v16 = (0LL /* None */);
			push_u64(v16);
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			VAL v17 = pop_value();
			decref(v17);
			uint64_t v18 = (0LL /* None */);
			push_u64(v18);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_sameZ_resolvedZAsk (void) {
	VAL v0 = pop_value();
	mw_mirth_def_Def_resolve();
	VAL v1 = pop_value();
	push_value(v0);
	mw_mirth_def_Def_resolve();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	mw_mirth_def_Def_ZEqualZEqual();
}
static void mw_mirth_def_Def_resolve (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_def_Def_aliasZAsk();
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v2 = pop_value();
		if (!VBOOL(v2)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		decref(v4);
		push_value(v3);
		mw_mirth_alias_Alias_target();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_mirth_def_Def_aliasZAsk();
	}
	VAL v6 = pop_value();
	decref(v6);
}
static void mw_mirth_def_Def_name (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mw_mirth_alias_Alias_name();
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			mw_mirth_package_Package_name();
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			mw_mirth_module_Module_name();
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			mw_mirth_buffer_Buffer_name();
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			mw_mirth_prim_Prim_name();
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mw_mirth_data_Data_name();
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			mw_mirth_table_Table_name();
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mw_mirth_typedef_TypeDef_name();
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mw_mirth_external_External_name();
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mw_mirth_word_Word_name();
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			mw_mirth_table_Field_name();
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			mw_mirth_data_Tag_name();
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			mw_mirth_variable_Variable_name();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_arity (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mw_mirth_alias_Alias_arity();
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			VAL v0 = pop_value();
			decref(v0);
			int64_t v1 = (0LL);
			push_i64(v1);
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			VAL v2 = pop_value();
			decref(v2);
			int64_t v3 = (0LL);
			push_i64(v3);
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			VAL v4 = pop_value();
			decref(v4);
			int64_t v5 = (0LL);
			push_i64(v5);
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			mw_mirth_prim_Prim_arity();
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mw_mirth_data_Data_arity();
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			VAL v6 = pop_value();
			decref(v6);
			int64_t v7 = (0LL);
			push_i64(v7);
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			VAL v8 = pop_value();
			decref(v8);
			int64_t v9 = (0LL);
			push_i64(v9);
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mw_mirth_external_External_arity();
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mw_mirth_word_Word_arity();
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			VAL v10 = pop_value();
			decref(v10);
			int64_t v11 = (0LL);
			push_i64(v11);
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			VAL v12 = pop_value();
			decref(v12);
			int64_t v13 = (0LL);
			push_i64(v13);
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			VAL v14 = pop_value();
			decref(v14);
			int64_t v15 = (0LL);
			push_i64(v15);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_qnameZ_soft (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mw_mirth_alias_Alias_qnameZ_soft();
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			mw_mirth_package_Package_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			mw_mirth_module_Module_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			mw_mirth_buffer_Buffer_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			mw_mirth_prim_Prim_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mw_mirth_data_Data_qnameZ_soft();
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			mw_mirth_table_Table_qnameZ_soft();
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mw_mirth_typedef_TypeDef_qnameZ_soft();
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mw_mirth_external_External_qnameZ_soft();
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mw_mirth_word_Word_qnameZ_soft();
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			mw_mirth_table_Field_qnameZ_soft();
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			mw_mirth_data_Tag_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			mw_mirth_variable_Variable_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_qnameZ_hard (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mw_mirth_alias_Alias_qnameZ_hard();
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			mw_mirth_package_Package_qname();
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			mw_mirth_module_Module_qname();
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			mw_mirth_buffer_Buffer_qname();
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			mw_mirth_prim_Prim_qname();
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mw_mirth_data_Data_qnameZ_hard();
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			mw_mirth_table_Table_qnameZ_hard();
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mw_mirth_typedef_TypeDef_qnameZ_hard();
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mw_mirth_external_External_qnameZ_hard();
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mw_mirth_word_Word_qnameZ_hard();
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			mw_mirth_table_Field_qnameZ_hard();
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			mw_mirth_data_Tag_qname();
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			mw_mirth_variable_Variable_qname();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_def_Def_asZ_namespaceZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mfld_mirth_alias_Alias_ZTildetarget();
			mw_mirth_mirth_Prop_1_tryZ_forceZBang();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_def_Def_asZ_namespaceZAsk();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v0 = (0LL /* None */);
					push_u64(v0);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 2LL: { // DefPackage
			mtp_mirth_def_Def_DefPackage();
			mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 1LL: { // DefModule
			mtp_mirth_def_Def_DefModule();
			mtw_mirth_name_Namespace_NAMESPACEz_MODULE();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 3LL: { // DefData
			mtp_mirth_def_Def_DefData();
			mtw_mirth_tycon_Tycon_TYCONz_DATA();
			mtw_mirth_name_Namespace_NAMESPACEz_TYCON();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 4LL: { // DefTable
			mtp_mirth_def_Def_DefTable();
			mtw_mirth_tycon_Tycon_TYCONz_TABLE();
			mtw_mirth_name_Namespace_NAMESPACEz_TYCON();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 5LL: { // DefType
			mtp_mirth_def_Def_DefType();
			mw_mirth_typedef_TypeDef_target();
			mw_mirth_type_Type_tyconZAsk();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mtw_mirth_name_Namespace_NAMESPACEz_TYCON();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v1 = (0LL /* None */);
					push_u64(v1);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mtw_mirth_name_Namespace_NAMESPACEz_WORD();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* None */);
			push_u64(v3);
		} break;
	}
}
static void mw_mirth_def_Def_register (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_def_Def_qnameZ_soft();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			incref(v1);
			push_value(v1);
			push_value(v1);
			mw_mirth_name_QName_undefinedZ_softZAsk();
			VAL v2 = pop_value();
			if (VBOOL(v2)) {
			} else {
				mw_mirth_name_QName_ZToStr();
				STRLIT("qualified name already has definition: ", 39);
				VAL v3 = pop_value();
				VAL v4 = pop_value();
				push_value(v3);
				push_value(v4);
				mp_primZ_strZ_cat();
				mp_primZ_panic();
			}
			VAL v5 = pop_value();
			decref(v5);
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v6 = pop_value();
	incref(v6);
	push_value(v6);
	push_value(v6);
	mw_mirth_def_Def_name();
	mfld_mirth_name_Name_ZTildedefs();
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	mp_primZ_mutZ_get();
	mtw_std_list_List_1_Cons();
	push_value(v7);
	mp_primZ_mutZ_set();
}
static void mw_mirth_name_Name_index (void) {
}
static void mw_mirth_name_Name_fromZ_index (void) {
}
static void mw_mirth_name_Name_allocZBang (void) {
	mbuf_mirth_name_Name_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_name_Name_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_name_Name_ZToStr (void) {
	mfld_mirth_name_Name_ZTildeStr();
	mp_primZ_mutZ_get();
}
static void mw_mirth_name_Name_defs (void) {
	mfld_mirth_name_Name_ZTildedefs();
	mp_primZ_mutZ_get();
}
static void mw_mirth_name_Name_mangled (void) {
	mfld_mirth_name_Name_ZTildemangled();
	mw_std_lazzy_Lazzy_1_forceZBang();
}
static void mw_mirth_name_Name_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_name_Name_index();
	push_value(v0);
	mw_mirth_name_Name_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_name_Hash_ZToInt (void) {
}
static void mw_std_prim_Int_ZToHash (void) {
	mw_mirth_name_HASHz_MAX();
	mp_primZ_intZ_mod();
}
static void mw_mirth_name_HASHz_MAX (void) {
	int64_t v0 = (65536LL);
	push_i64(v0);
}
static void mw_mirth_name_hashZ_nameZAt (void) {
	mw_mirth_name_Hash_ZToInt();
	int64_t v0 = (8LL);
	VAL v1 = pop_value();
	int64_t v2 = (VI64(v1) * v0);
	push_i64(v2);
	mbuf_mirth_name_HASHz_BUF();
	VAL v3 = (MKU64(0LL /* +Unsafe */));
	VAL v4 = pop_value();
	push_resource(v3);
	push_value(v4);
	mp_primZ_ptrZ_add();
	mp_primZ_i64Z_get();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v5 = pop_value();
	incref(v5);
	int64_t v6 = (0LL);
	bool v7 = (VI64(v5) == v6);
	push_value(v5);
	if (v7) {
		VAL v8 = pop_value();
		decref(v8);
		uint64_t v9 = (0LL /* None */);
		push_u64(v9);
	} else {
		mw_mirth_name_Name_fromZ_index();
		mtw_std_maybe_Maybe_1_Some();
	}
}
static void mw_mirth_name_hashZ_nameZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_name_Name_index();
	mw_std_prim_Int_ZToI64();
	push_value(v0);
	mw_mirth_name_Hash_ZToInt();
	int64_t v1 = (8LL);
	VAL v2 = pop_value();
	int64_t v3 = (VI64(v2) * v1);
	push_i64(v3);
	mbuf_mirth_name_HASHz_BUF();
	VAL v4 = (MKU64(0LL /* +Unsafe */));
	VAL v5 = pop_value();
	push_resource(v4);
	push_value(v5);
	mp_primZ_ptrZ_add();
	mp_primZ_i64Z_set();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_prim_Str_hash (void) {
	int64_t v0 = (0LL);
	VAL v1 = pop_value();
	incref(v1);
	incref(v1);
	push_i64(v0);
	push_value(v1);
	mp_primZ_strZ_base();
	push_value(v1);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		int64_t v3 = (0LL);
		bool v4 = (v3 < VI64(v2));
		push_value(v2);
		if (!v4) break;
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		incref(v6);
		VAL v7 = (MKU64(0LL /* +Unsafe */));
		push_value(v6);
		push_resource(v7);
		mw_std_prim_Ptr_ZAtByte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_byte_Byte_ZToInt();
		int64_t v8 = (17LL);
		VAL v9 = pop_value();
		int64_t v10 = (VI64(v9) * v8);
		VAL v11 = pop_value();
		incref(v11);
		int64_t v12 = (7LL);
		push_value(v11);
		push_i64(v10);
		push_value(v11);
		push_i64(v12);
		mp_primZ_intZ_shl();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		uint64_t v15 = (VU64(v14) ^ VU64(v13));
		VAL v16 = pop_value();
		int64_t v17 = (27LL);
		push_u64(v15);
		push_value(v16);
		push_i64(v17);
		mp_primZ_intZ_shr();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		uint64_t v20 = (VU64(v19) ^ VU64(v18));
		int64_t v21 = (1LL);
		VAL v22 = (MKU64(0LL /* +Unsafe */));
		push_u64(v20);
		push_i64(v21);
		push_resource(v22);
		push_value(v6);
		mp_primZ_ptrZ_add();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		int64_t v23 = (1LL);
		push_value(v5);
		push_i64(v23);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
	}
	VAL v24 = pop_value();
	decref(v24);
	VAL v25 = pop_value();
	decref(v25);
	decref(v1);
	mw_std_prim_Int_ZToHash();
}
static void mw_mirth_name_Hash_next (void) {
	mw_mirth_name_Hash_ZToInt();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	mw_std_prim_Int_ZToHash();
}
static void mw_mirth_name_Hash_keepZ_goingZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_hashZ_nameZAt();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_ZToStr();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v3);
			push_value(v2);
			push_value(v4);
			mp_primZ_strZ_cmp();
			int64_t v5 = (0LL);
			VAL v6 = pop_value();
			incref(v6);
			bool v7 = (VI64(v6) == v5);
			push_value(v6);
			push_i64(v5);
			if (v7) {
				VAL v8 = pop_value();
				decref(v8);
				VAL v9 = pop_value();
				decref(v9);
				uint64_t v10 = (1LL /* EQ */);
				push_u64(v10);
			} else {
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				bool v13 = (VI64(v12) < VI64(v11));
				if (v13) {
					uint64_t v14 = (0LL /* LT */);
					push_u64(v14);
				} else {
					uint64_t v15 = (2LL /* GT */);
					push_u64(v15);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v16 = (1LL /* True */);
					push_u64(v16);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v17 = (0LL /* False */);
					push_u64(v17);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v18 = (1LL /* True */);
					push_u64(v18);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_prim_Str_ZToName (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_std_prim_Str_hash();
	while(1) {
		mw_mirth_name_Hash_keepZ_goingZAsk();
		VAL v1 = pop_value();
		if (!VBOOL(v1)) break;
		mw_mirth_name_Hash_next();
	}
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v2);
	mw_mirth_name_hashZ_nameZAt();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_name_Name_allocZBang();
			VAL v3 = pop_value();
			incref(v3);
			VAL v4 = pop_value();
			push_value(v3);
			push_value(v3);
			push_value(v4);
			mw_mirth_name_hashZ_nameZBang();
			VAL v5 = pop_value();
			incref(v5);
			VAL v6 = pop_value();
			push_value(v5);
			push_value(v6);
			push_value(v5);
			mfld_mirth_name_Name_ZTildeStr();
			mp_primZ_mutZ_set();
			uint64_t v7 = (0LL /* Nil */);
			VAL v8 = pop_value();
			incref(v8);
			push_value(v8);
			push_u64(v7);
			push_value(v8);
			mfld_mirth_name_Name_ZTildedefs();
			mp_primZ_mutZ_set();
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			push_value(v9);
			VAL v10 = (MKFNPTR(&mb_std_prim_Str_ZToName_2));
			push_value(v10);
			mtw_std_lazzy_Lazzy_1_LazzyDelay();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			incref(v12);
			push_value(v12);
			push_value(v11);
			push_value(v12);
			mfld_mirth_name_Name_ZTildemangled();
			mp_primZ_mutZ_set();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			decref(v14);
			VAL v15 = pop_value();
			decref(v15);
			push_value(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_Name_head (void) {
	mw_mirth_name_Name_ZToStr();
	VAL v0 = pop_value();
	int64_t v1 = (0LL);
	push_i64(v1);
	push_value(v0);
	mw_std_prim_Str_byteZAt();
}
static void mw_mirth_name_Name_tailZ_head (void) {
	mw_mirth_name_Name_ZToStr();
	VAL v0 = pop_value();
	int64_t v1 = (1LL);
	push_i64(v1);
	push_value(v0);
	mw_std_prim_Str_byteZAt();
}
static void mw_mirth_name_Name_canZ_beZ_relativeZAsk (void) {
	mw_mirth_name_Name_head();
	mw_std_byte_Byte_isZ_upper();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		uint64_t v1 = (0LL /* False */);
		push_u64(v1);
	} else {
		uint64_t v2 = (1LL /* True */);
		push_u64(v2);
	}
}
static void mw_mirth_name_Name_couldZ_beZ_labelZ_nameZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_Name_head();
	mw_std_byte_Byte_isZ_lower();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		uint64_t v2 = (1LL /* True */);
		push_u64(v2);
	} else {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_name_Name_head();
		uint64_t v4 = (43LL /* B'+' */);
		push_u64(v4);
		mw_std_byte_Byte_ZEqualZEqual();
		VAL v5 = pop_value();
		if (VBOOL(v5)) {
			VAL v6 = pop_value();
			incref(v6);
			push_value(v6);
			push_value(v6);
			mw_mirth_name_Name_tailZ_head();
			mw_std_byte_Byte_isZ_lower();
		} else {
			uint64_t v7 = (0LL /* False */);
			push_u64(v7);
		}
	}
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	decref(v9);
	push_value(v8);
}
static void mw_mirth_name_Name_couldZ_beZ_patternZ_varZAsk (void) {
	mw_mirth_name_Name_head();
	mw_std_byte_Byte_isZ_lower();
}
static void mw_mirth_name_Name_couldZ_beZ_typeZ_var (void) {
	mw_mirth_name_Name_head();
	mw_std_byte_Byte_isZ_lower();
}
static void mw_mirth_name_Name_couldZ_beZ_typeZ_con (void) {
	mw_mirth_name_Name_head();
	mw_std_byte_Byte_isZ_upper();
}
static void mw_mirth_name_Name_isZ_typeZ_hole (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_Name_head();
	uint64_t v1 = (63LL /* B'?' */);
	push_u64(v1);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	mw_mirth_name_Name_tailZ_head();
	VAL v4 = pop_value();
	incref(v4);
	uint64_t v5 = (0LL /* BNUL */);
	push_value(v4);
	push_value(v4);
	push_u64(v5);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	mw_std_byte_Byte_isZ_lower();
	VAL v8 = pop_value();
	if (VBOOL(v8)) {
		VAL v9 = pop_value();
		decref(v9);
		uint64_t v10 = (1LL /* True */);
		push_u64(v10);
	} else {
	}
	VAL v11 = pop_value();
	if (VBOOL(v11)) {
	} else {
		VAL v12 = pop_value();
		decref(v12);
		uint64_t v13 = (0LL /* False */);
		push_u64(v13);
	}
}
static void mw_mirth_name_Name_isZ_underscore (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_Name_head();
	uint64_t v1 = (95LL /* B'_' */);
	push_u64(v1);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	mw_mirth_name_Name_tailZ_head();
	uint64_t v4 = (0LL /* BNUL */);
	push_u64(v4);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
	} else {
		VAL v6 = pop_value();
		decref(v6);
		uint64_t v7 = (0LL /* False */);
		push_u64(v7);
	}
}
static void mw_mirth_name_Name_couldZ_beZ_stackZ_var (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_Name_head();
	uint64_t v1 = (42LL /* B'*' */);
	push_u64(v1);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	mw_mirth_name_Name_tailZ_head();
	mw_std_byte_Byte_isZ_lower();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
	} else {
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (0LL /* False */);
		push_u64(v6);
	}
}
static void mw_mirth_name_Name_couldZ_beZ_resourceZ_var (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_Name_head();
	uint64_t v1 = (43LL /* B'+' */);
	push_u64(v1);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	mw_mirth_name_Name_tailZ_head();
	mw_std_byte_Byte_isZ_lower();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
	} else {
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (0LL /* False */);
		push_u64(v6);
	}
}
static void mw_mirth_name_Name_couldZ_beZ_resourceZ_con (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_Name_head();
	uint64_t v1 = (43LL /* B'+' */);
	push_u64(v1);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	mw_mirth_name_Name_tailZ_head();
	mw_std_byte_Byte_isZ_upper();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
	} else {
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (0LL /* False */);
		push_u64(v6);
	}
}
static void mw_mirth_name_Name_couldZ_beZ_constructor (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_Name_head();
	switch (get_top_data_tag()) {
		case 43LL: { // B'+'
			(void)pop_u64();
			mw_mirth_name_Name_tailZ_head();
			mw_std_byte_Byte_isZ_upper();
		} break;
		default: {
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_std_byte_Byte_isZ_upper();
		} break;
	}
}
static void mw_mirth_name_Name_mangleZ_computeZBang (void) {
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	mw_mirth_name_Name_ZToStr();
	VAL v0 = pop_value();
	incref(v0);
	incref(v0);
	push_value(v0);
	mp_primZ_strZ_base();
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		int64_t v2 = (0LL);
		bool v3 = (v2 < VI64(v1));
		push_value(v1);
		if (!v3) break;
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		incref(v5);
		VAL v6 = (MKU64(0LL /* +Unsafe */));
		push_value(v5);
		push_resource(v6);
		mw_std_prim_Ptr_ZAtByte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_byte_Byte_zzencode();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		int64_t v7 = (1LL);
		VAL v8 = (MKU64(0LL /* +Unsafe */));
		push_i64(v7);
		push_resource(v8);
		push_value(v5);
		mp_primZ_ptrZ_add();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		int64_t v9 = (1LL);
		push_value(v4);
		push_i64(v9);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	decref(v0);
	mtp_std_str_ZPlusStr_ZPlusStr();
}
static void mw_mirth_name_Namespace_ZEqualZEqual (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // NAMESPACE_ROOT
			(void)pop_u64();
			switch (get_top_data_tag()) {
				case 0LL: { // NAMESPACE_ROOT
					(void)pop_u64();
					uint64_t v0 = (1LL /* True */);
					push_u64(v0);
				} break;
				default: {
					VAL v1 = pop_value();
					decref(v1);
					uint64_t v2 = (0LL /* False */);
					push_u64(v2);
				} break;
			}
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			push_value(v3);
			push_value(v4);
			switch (get_top_data_tag()) {
				case 1LL: { // NAMESPACE_PACKAGE
					mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
					VAL v5 = pop_value();
					VAL v6 = pop_value();
					push_value(v5);
					push_value(v6);
					mw_mirth_package_Package_ZEqualZEqual();
				} break;
				default: {
					VAL v7 = pop_value();
					decref(v7);
					VAL v8 = pop_value();
					decref(v8);
					uint64_t v9 = (0LL /* False */);
					push_u64(v9);
				} break;
			}
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			push_value(v10);
			push_value(v11);
			switch (get_top_data_tag()) {
				case 2LL: { // NAMESPACE_MODULE
					mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
					VAL v12 = pop_value();
					VAL v13 = pop_value();
					push_value(v12);
					push_value(v13);
					mw_mirth_module_Module_ZEqualZEqual();
				} break;
				default: {
					VAL v14 = pop_value();
					decref(v14);
					VAL v15 = pop_value();
					decref(v15);
					uint64_t v16 = (0LL /* False */);
					push_u64(v16);
				} break;
			}
		} break;
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			push_value(v17);
			push_value(v18);
			switch (get_top_data_tag()) {
				case 3LL: { // NAMESPACE_TYCON
					mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
					VAL v19 = pop_value();
					VAL v20 = pop_value();
					push_value(v19);
					push_value(v20);
					mw_mirth_tycon_Tycon_ZEqualZEqual();
				} break;
				default: {
					VAL v21 = pop_value();
					decref(v21);
					VAL v22 = pop_value();
					decref(v22);
					uint64_t v23 = (0LL /* False */);
					push_u64(v23);
				} break;
			}
		} break;
		case 4LL: { // NAMESPACE_WORD
			mtp_mirth_name_Namespace_NAMESPACEz_WORD();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			push_value(v24);
			push_value(v25);
			switch (get_top_data_tag()) {
				case 4LL: { // NAMESPACE_WORD
					mtp_mirth_name_Namespace_NAMESPACEz_WORD();
					VAL v26 = pop_value();
					VAL v27 = pop_value();
					push_value(v26);
					push_value(v27);
					mw_mirth_word_Word_ZEqualZEqual();
				} break;
				default: {
					VAL v28 = pop_value();
					decref(v28);
					VAL v29 = pop_value();
					decref(v29);
					uint64_t v30 = (0LL /* False */);
					push_u64(v30);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_Namespace_qname (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // NAMESPACE_ROOT
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			mw_mirth_package_Package_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			mw_mirth_module_Module_qname();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			mw_mirth_tycon_Tycon_qnameZ_hard();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 4LL: { // NAMESPACE_WORD
			mtp_mirth_name_Namespace_NAMESPACEz_WORD();
			mw_mirth_word_Word_qnameZ_hard();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_Namespace_moduleZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // NAMESPACE_ROOT
			(void)pop_u64();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* None */);
			push_u64(v2);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			mw_mirth_tycon_Tycon_qnameZ_hard();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 4, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_name_Namespace_moduleZAsk();
		} break;
		case 4LL: { // NAMESPACE_WORD
			mtp_mirth_name_Namespace_NAMESPACEz_WORD();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* None */);
			push_u64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_Namespace_prim (void) {
	mw_mirth_module_Module_prim();
	mtw_mirth_name_Namespace_NAMESPACEz_MODULE();
}
static void mw_mirth_name_Namespace_ZToStr (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // NAMESPACE_ROOT
			(void)pop_u64();
			STRLIT("<root>", 6);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			mw_mirth_package_Package_name();
			mw_mirth_name_Name_ZToStr();
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			mw_mirth_module_Module_qname();
			mw_mirth_name_QName_ZToStr();
		} break;
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			mw_mirth_tycon_Tycon_qnameZ_hard();
			mw_mirth_name_QName_ZToStr();
		} break;
		case 4LL: { // NAMESPACE_WORD
			mtp_mirth_name_Namespace_NAMESPACEz_WORD();
			mw_mirth_word_Word_qnameZ_hard();
			mw_mirth_name_QName_ZToStr();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_Namespace_mangled (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // NAMESPACE_ROOT
			(void)pop_u64();
			STRLIT("__root__", 8);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			mw_mirth_package_Package_name();
			mw_mirth_name_Name_mangled();
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			mw_mirth_module_Module_qname();
			mw_mirth_name_QName_mangled();
		} break;
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			mw_mirth_tycon_Tycon_qnameZ_hard();
			mw_mirth_name_QName_mangled();
		} break;
		case 4LL: { // NAMESPACE_WORD
			mtp_mirth_name_Namespace_NAMESPACEz_WORD();
			mw_mirth_word_Word_qnameZ_hard();
			mw_mirth_name_QName_mangled();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_QNAME0 (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	int64_t v2 = (0LL);
	lpush(&lbl_name, v0);
	lpush(&lbl_namespace, v1);
	lpush(&lbl_arity, MKI64(v2));
	mtw_mirth_name_QName_MKQNAME();
}
static void mw_mirth_name_QName_ZEqualZEqual (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // MKQNAME
			mtp_mirth_name_QName_MKQNAME();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // MKQNAME
			mtp_mirth_name_QName_MKQNAME();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_name));
	VAL v1 = (lpop(&lbl_name));
	push_value(v0);
	push_value(v1);
	mw_mirth_name_Name_ZEqualZEqual();
	VAL v2 = (lpop(&lbl_arity));
	VAL v3 = (lpop(&lbl_arity));
	bool v4 = (VI64(v2) == VI64(v3));
	if (v4) {
	} else {
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (0LL /* False */);
		push_u64(v6);
	}
	VAL v7 = (lpop(&lbl_namespace));
	VAL v8 = (lpop(&lbl_namespace));
	push_value(v7);
	push_value(v8);
	mw_mirth_name_Namespace_ZEqualZEqual();
	VAL v9 = pop_value();
	if (VBOOL(v9)) {
	} else {
		VAL v10 = pop_value();
		decref(v10);
		uint64_t v11 = (0LL /* False */);
		push_u64(v11);
	}
}
static void mw_mirth_name_QName_defZ_hardZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_name_Name_defs();
	uint64_t v1 = (0LL /* None */);
	VAL v2 = pop_value();
	push_u64(v1);
	push_value(v2);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v7);
		mw_mirth_def_Def_qnameZ_hard();
		mw_mirth_name_QName_ZEqualZEqual();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v7);
		if (VBOOL(v11)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (0LL /* None */);
			push_u64(v13);
		}
		VAL v14 = pop_value();
		push_value(v9);
		push_value(v8);
		push_value(v14);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				decref(v16);
				VAL v17 = pop_value();
				decref(v17);
				uint64_t v18 = (0LL /* Nil */);
				push_value(v15);
				push_u64(v18);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
	}
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	VAL v24 = pop_value();
	decref(v24);
	push_value(v23);
}
static void mw_mirth_name_QName_definedZ_hardZAsk (void) {
	mw_mirth_name_QName_defZ_hardZAsk();
	mw_std_maybe_Maybe_1_someZAsk();
}
static void mw_mirth_name_QName_defZ_softZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_name_Name_defs();
	VAL v1 = pop_value();
	mtw_std_maybe_Maybe_1_Some();
	uint64_t v2 = (0LL /* None */);
	push_u64(v2);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v7);
		mw_mirth_def_Def_qnameZ_soft();
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
				mw_std_maybe_Maybe_1_noneZAsk();
			} break;
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				push_value(v11);
				push_value(v12);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v13 = pop_value();
						VAL v14 = pop_value();
						push_value(v13);
						push_value(v14);
						mw_mirth_name_QName_ZEqualZEqual();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						VAL v15 = pop_value();
						decref(v15);
						uint64_t v16 = (0LL /* False */);
						push_u64(v16);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v17 = pop_value();
		push_value(v10);
		push_value(v7);
		if (VBOOL(v17)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v18 = pop_value();
			decref(v18);
			uint64_t v19 = (0LL /* None */);
			push_u64(v19);
		}
		VAL v20 = pop_value();
		push_value(v9);
		push_value(v8);
		push_value(v20);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				decref(v22);
				VAL v23 = pop_value();
				decref(v23);
				uint64_t v24 = (0LL /* Nil */);
				push_value(v21);
				push_u64(v24);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v25 = pop_value();
		VAL v26 = pop_value();
		push_value(v25);
		push_value(v26);
	}
	VAL v27 = pop_value();
	decref(v27);
	VAL v28 = pop_value();
	decref(v28);
	VAL v29 = pop_value();
	VAL v30 = pop_value();
	decref(v30);
	push_value(v29);
}
static void mw_mirth_name_QName_definedZ_softZAsk (void) {
	mw_mirth_name_QName_defZ_softZAsk();
	mw_std_maybe_Maybe_1_someZAsk();
}
static void mw_mirth_name_QName_undefinedZ_softZAsk (void) {
	mw_mirth_name_QName_defZ_softZAsk();
	mw_std_maybe_Maybe_1_noneZAsk();
}
static void mw_mirth_name_QName_prim (void) {
	VAL v0 = pop_value();
	lpush(&lbl_arity, v0);
	mw_std_prim_Str_ZToName();
	VAL v1 = pop_value();
	lpush(&lbl_name, v1);
	mw_mirth_name_Namespace_prim();
	VAL v2 = pop_value();
	lpush(&lbl_namespace, v2);
	mtw_mirth_name_QName_MKQNAME();
}
static void mw_mirth_name_QName_ZToStr (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // MKQNAME
			mtp_mirth_name_QName_MKQNAME();
			VAL v0 = (lpop(&lbl_namespace));
			push_value(v0);
			mw_mirth_name_Namespace_ZToStr();
			STRLIT(".", 1);
			mp_primZ_strZ_cat();
			VAL v1 = (lpop(&lbl_name));
			push_value(v1);
			mw_mirth_name_Name_ZToStr();
			mp_primZ_strZ_cat();
			VAL v2 = (lpop(&lbl_arity));
			incref(v2);
			int64_t v3 = (0LL);
			bool v4 = (VI64(v2) == v3);
			push_value(v2);
			if (v4) {
				VAL v5 = pop_value();
				decref(v5);
			} else {
				VAL v6 = pop_value();
				STRLIT("/", 1);
				push_value(v6);
				mp_primZ_intZ_toZ_str();
				mp_primZ_strZ_cat();
				mp_primZ_strZ_cat();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_QName_toZ_moduleZ_path (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			mw_mirth_package_Package_pathZ_orZ_search();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					STRLIT("No path defined for package", 27);
					mp_primZ_panic();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 4, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_name_Name_ZToStr();
			STRLIT(".mth", 4);
			mp_primZ_strZ_cat();
			mw_std_path_Path_join();
		} break;
		default: {
			VAL v3 = pop_value();
			decref(v3);
			STRLIT("expected module name", 20);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_name_QName_mangled (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // MKQNAME
			mtp_mirth_name_QName_MKQNAME();
			VAL v0 = (lpop(&lbl_namespace));
			push_value(v0);
			mw_mirth_name_Namespace_mangled();
			STRLIT("_", 1);
			mp_primZ_strZ_cat();
			VAL v1 = (lpop(&lbl_name));
			push_value(v1);
			mw_mirth_name_Name_mangled();
			mp_primZ_strZ_cat();
			VAL v2 = (lpop(&lbl_arity));
			incref(v2);
			int64_t v3 = (0LL);
			bool v4 = (v3 < VI64(v2));
			push_value(v2);
			if (v4) {
				VAL v5 = pop_value();
				STRLIT("_", 1);
				push_value(v5);
				mp_primZ_intZ_toZ_str();
				mp_primZ_strZ_cat();
				mp_primZ_strZ_cat();
			} else {
				VAL v6 = pop_value();
				decref(v6);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_DName_rootZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DName
			mtp_mirth_name_DName_DName();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_DName_parts (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DName
			mtp_mirth_name_DName_DName();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			decref(v1);
			push_value(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_DName_lastZ_name (void) {
	mw_mirth_name_DName_parts();
	mw_std_list_ListZPlus_1_last();
}
static void mw_mirth_name_DName_penultimateZ_nameZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DName
			mtp_mirth_name_DName_DName();
			mw_std_list_ListZPlus_1_unsnoc();
			VAL v0 = pop_value();
			decref(v0);
			mw_std_list_List_1_last();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v1 = pop_value();
					VAL v2 = pop_value();
					decref(v2);
					push_value(v1);
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_DName_isZ_relativeZAsk (void) {
	mw_mirth_name_DName_rootZAsk();
	mw_std_maybe_Maybe_1_noneZAsk();
}
static void mw_mirth_package_Package_index (void) {
}
static void mw_mirth_package_Package_allocZBang (void) {
	mbuf_mirth_package_Package_NUM();
	mp_primZ_u64Z_get();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mbuf_mirth_package_Package_NUM();
	mp_primZ_u64Z_set();
}
static void mw_mirth_package_Package_name (void) {
	mfld_mirth_package_Package_ZTildename();
	mp_primZ_mutZ_get();
}
static void mw_mirth_package_Package_qname (void) {
	uint64_t v0 = (0LL /* NAMESPACE_ROOT */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_mirth_package_Package_name();
	mw_mirth_name_QNAME0();
}
static void mw_mirth_package_Package_path (void) {
	mfld_mirth_package_Package_ZTildepath();
	mp_primZ_mutZ_get();
}
static void mw_mirth_package_Package_std (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_package_initZ_packagesZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 62, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	STRLIT("std", 3);
	mw_std_prim_Str_ZToName();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mfld_mirth_package_Package_ZTildename();
	mp_primZ_mutZ_set();
	uint64_t v2 = (0LL /* None */);
	VAL v3 = pop_value();
	push_u64(v2);
	push_value(v3);
	mfld_mirth_package_Package_ZTildepath();
	mp_primZ_mutZ_set();
}
static void mw_mirth_package_Package_pathZ_orZ_search (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_package_Package_path();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			uint64_t v3 = (0LL /* Nil */);
			push_u64(v3);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			push_value(v4);
			push_value(v5);
			while(1) {
				VAL v6 = pop_value();
				incref(v6);
				push_value(v6);
				push_value(v6);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v7 = pop_value();
				if (!VBOOL(v7)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				VAL r10 = pop_resource();
				VAL v11 = pop_value();
				incref(v11);
				push_value(v11);
				push_value(v8);
				push_value(v11);
				mw_mirth_package_Package_name();
				mw_mirth_name_Name_ZToStr();
				mw_std_path_Path_join();
				push_resource(r10);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
				push_value(v9);
				mw_std_list_List_1_uncons();
				VAL v12 = pop_value();
				VAL v13 = pop_value();
				push_value(v12);
				push_value(v13);
			}
			VAL v14 = pop_value();
			decref(v14);
			VAL v15 = pop_value();
			decref(v15);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			uint64_t v16 = (0LL /* None */);
			VAL v17 = pop_value();
			push_u64(v16);
			push_value(v17);
			mw_std_list_List_1_uncons();
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			push_value(v18);
			push_value(v19);
			while(1) {
				VAL v20 = pop_value();
				incref(v20);
				push_value(v20);
				push_value(v20);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v21 = pop_value();
				if (!VBOOL(v21)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				incref(v22);
				VAL r25 = pop_resource();
				push_value(v22);
				mw_std_prim_ZPlusWorld_isZ_directoryZAsk();
				VAL v26 = pop_value();
				push_resource(r25);
				push_value(v22);
				if (VBOOL(v26)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v27 = pop_value();
					decref(v27);
					uint64_t v28 = (0LL /* None */);
					push_u64(v28);
				}
				VAL v29 = pop_value();
				push_value(v24);
				push_value(v23);
				push_value(v29);
				switch (get_top_data_tag()) {
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						VAL v30 = pop_value();
						VAL v31 = pop_value();
						decref(v31);
						VAL v32 = pop_value();
						decref(v32);
						uint64_t v33 = (0LL /* Nil */);
						push_value(v30);
						push_u64(v33);
					} break;
				}
				mw_std_list_List_1_uncons();
				VAL v34 = pop_value();
				VAL v35 = pop_value();
				push_value(v34);
				push_value(v35);
			}
			VAL v36 = pop_value();
			decref(v36);
			VAL v37 = pop_value();
			decref(v37);
			VAL v38 = pop_value();
			incref(v38);
			VAL v39 = pop_value();
			push_value(v38);
			push_value(v38);
			push_value(v39);
			mfld_mirth_package_Package_ZTildepath();
			mp_primZ_mutZ_set();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_package_Package_pathZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mw_mirth_package_Package_path();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			incref(v3);
			incref(v2);
			push_value(v3);
			push_value(v2);
			push_value(v3);
			push_value(v2);
			mp_primZ_strZ_cmp();
			int64_t v4 = (0LL);
			VAL v5 = pop_value();
			incref(v5);
			bool v6 = (VI64(v5) == v4);
			push_value(v5);
			push_i64(v4);
			if (v6) {
				VAL v7 = pop_value();
				decref(v7);
				VAL v8 = pop_value();
				decref(v8);
				uint64_t v9 = (1LL /* EQ */);
				push_u64(v9);
			} else {
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				bool v12 = (VI64(v11) < VI64(v10));
				if (v12) {
					uint64_t v13 = (0LL /* LT */);
					push_u64(v13);
				} else {
					uint64_t v14 = (2LL /* GT */);
					push_u64(v14);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v15 = (0LL /* False */);
					push_u64(v15);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v16 = (1LL /* True */);
					push_u64(v16);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v17 = (0LL /* False */);
					push_u64(v17);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v18 = pop_value();
			if (VBOOL(v18)) {
				VAL v19 = pop_value();
				decref(v19);
				VAL v20 = pop_value();
				decref(v20);
				VAL v21 = pop_value();
				decref(v21);
			} else {
				STRLIT("", 0);
				mtw_std_str_ZPlusStr_ZPlusStr();
				STRLIT("Tried to set different path for the same package.", 49);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				STRLIT("\n\tPackage: ", 11);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				push_value(v23);
				push_value(v22);
				push_value(v24);
				mw_mirth_package_Package_name();
				mw_mirth_name_Name_ZToStr();
				mw_std_str_ZPlusStr_pushZ_strZBang();
				STRLIT("\n\tPath 1: ", 10);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				push_value(v25);
				push_value(v26);
				mw_std_prim_Str_showZThen();
				STRLIT("\n\tPath 2: ", 10);
				mw_std_str_ZPlusStr_pushZ_strZBang();
				mw_std_prim_Str_showZThen();
				mtp_std_str_ZPlusStr_ZPlusStr();
				mp_primZ_panic();
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mtw_std_maybe_Maybe_1_Some();
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			push_value(v27);
			push_value(v28);
			mfld_mirth_package_Package_ZTildepath();
			mp_primZ_mutZ_set();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_package_Package_newZBang (void) {
	mw_mirth_package_Package_allocZBang();
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mfld_mirth_package_Package_ZTildename();
	mp_primZ_mutZ_set();
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	push_value(v2);
	mfld_mirth_package_Package_ZTildepath();
	mp_primZ_mutZ_set();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mtw_mirth_def_Def_DefPackage();
	mw_mirth_def_Def_register();
}
static void mw_mirth_package_Package_newZ_orZ_pathZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_package_Package_find();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			incref(v1);
			VAL v3 = pop_value();
			push_value(v1);
			push_value(v3);
			push_value(v1);
			mw_mirth_package_Package_pathZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v4 = pop_value();
			mtw_std_maybe_Maybe_1_Some();
			push_value(v4);
			mw_mirth_package_Package_newZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_package_Package_find (void) {
	uint64_t v0 = (0LL /* NAMESPACE_ROOT */);
	VAL v1 = pop_value();
	push_u64(v0);
	push_value(v1);
	mw_mirth_name_QNAME0();
	mw_mirth_name_QName_defZ_softZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_def_Def_packageZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v2 = (0LL /* None */);
			push_u64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_package_Package_findZ_orZ_newZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_package_Package_find();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v1 = pop_value();
			incref(v1);
			uint64_t v2 = (0LL /* None */);
			push_value(v1);
			push_u64(v2);
			push_value(v1);
			mw_mirth_package_Package_newZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	decref(v4);
	push_value(v3);
}
static void mw_mirth_package_Package_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	mw_mirth_package_Package_index();
	push_value(v0);
	mw_mirth_package_Package_index();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	bool v3 = (VI64(v2) == VI64(v1));
	push_bool(v3);
}
static void mw_mirth_lexer_lexerZ_stackZ_pushZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mtw_std_list_List_1_Cons();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_lexer_lexerZ_stackZ_popZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_lexer_lexerZ_stackZ_drop (void) {
	mw_mirth_lexer_lexerZ_stackZ_popZBang();
	VAL v0 = pop_value();
	decref(v0);
}
static void mw_mirth_lexer_lexerZ_stackZ_peek (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_std_list_List_1_first();
}
static void mw_mirth_lexer_runZ_lexerZBang (void) {
	mw_mirth_module_Module_newZBang();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_lexerZ_module, v0);
	mw_mirth_module_Module_sourceZ_path();
	VAL r1 = pop_resource();
	mw_std_prim_ZPlusWorld_openZ_fileZBang();
	mw_std_file_ZPlusFileZAsk_unwrapZBang();
	mw_std_input_ZPlusInput_startZBang();
	VAL r2 = pop_resource();
	int64_t v3 = (1LL);
	lpush(&lbl_ZPlusinput, r2);
	push_resource(r1);
	push_i64(v3);
	mw_std_prim_Int_ZToRow();
	VAL v4 = pop_value();
	int64_t v5 = (1LL);
	lpush(&lbl_lexerZ_row, v4);
	push_i64(v5);
	mw_std_prim_Int_ZToCol();
	VAL v6 = pop_value();
	uint64_t v7 = (0LL /* Nil */);
	lpush(&lbl_lexerZ_col, v6);
	lpush(&lbl_lexerZ_stack, MKU64(v7));
	mw_mirth_token_Token_allocZ_noneZBang();
	VAL v8 = pop_value();
	incref(v8);
	push_value(v8);
	lpush(&lbl_lexerZ_lastZ_token, v8);
	mtw_mirth_lexer_ZPlusLexer_ZPlusLexer();
	while(1) {
		mw_mirth_lexer_ZPlusLexer_doneZAsk();
		VAL v9 = pop_value();
		if (VBOOL(v9)) {
			uint64_t v10 = (0LL /* False */);
			push_u64(v10);
		} else {
			uint64_t v11 = (1LL /* True */);
			push_u64(v11);
		}
		VAL v12 = pop_value();
		if (!VBOOL(v12)) break;
		mw_mirth_lexer_lexerZ_nextZBang();
	}
	uint64_t v13 = (0LL /* TokenNone */);
	push_u64(v13);
	mw_mirth_lexer_lexerZ_emitZBang();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Lexer
			mtp_mirth_lexer_ZPlusLexer_ZPlusLexer();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL r14 = pop_resource();
	VAL v15 = (lpop(&lbl_ZPlusinput));
	push_resource(v15);
	mw_std_input_ZPlusInput_endZBang();
	mw_std_file_ZPlusFile_closeZ_fileZBang();
	VAL v16 = (lpop(&lbl_lexerZ_stack));
	push_resource(r14);
	push_value(v16);
	mw_std_list_List_1_uncons();
	VAL v17 = pop_value();
	decref(v17);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			STRLIT("Mismatched left parenthesis.", 28);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v18 = (lpop(&lbl_lexerZ_row));
	VAL v19 = (lpop(&lbl_lexerZ_col));
	VAL v20 = (lpop(&lbl_lexerZ_lastZ_token));
	decref(v20);
	decref(v19);
	decref(v18);
	VAL v21 = (lpop(&lbl_lexerZ_module));
	push_value(v21);
	mw_mirth_token_Token_allocZ_noneZBang();
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	incref(v23);
	push_value(v23);
	push_value(v22);
	push_value(v23);
	mfld_mirth_module_Module_ZTildeend();
	mp_primZ_mutZ_set();
	VAL v24 = pop_value();
	VAL v25 = pop_value();
	push_value(v24);
	push_value(v25);
	mw_mirth_token_Token_succ();
	VAL v26 = pop_value();
	VAL v27 = pop_value();
	incref(v27);
	push_value(v27);
	push_value(v26);
	push_value(v27);
	mfld_mirth_module_Module_ZTildestart();
	mp_primZ_mutZ_set();
}
static void mw_mirth_lexer_ZPlusLexer_doneZAsk (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_std_input_ZPlusInput_doneZAsk();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_lexer_lexerZ_makeZBang (void) {
	mw_mirth_token_Token_allocZBang();
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	push_value(v0);
	mfld_mirth_token_Token_ZTildevalue();
	mp_primZ_mutZ_set();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mfld_mirth_token_Token_ZTildemodule();
	mp_primZ_mutZ_set();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v4);
	push_value(v5);
	mfld_mirth_token_Token_ZTilderow();
	mp_primZ_mutZ_set();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	push_value(v6);
	push_value(v7);
	mfld_mirth_token_Token_ZTildecol();
	mp_primZ_mutZ_set();
	VAL v8 = pop_value();
	incref(v8);
	push_value(v8);
	push_value(v8);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_lexer_lexerZ_emitZBang (void) {
	mw_mirth_lexer_lexerZ_makeZBang();
	VAL v0 = pop_value();
	decref(v0);
}
static void mw_mirth_lexer_lexerZ_nextZBang (void) {
	mw_mirth_lexer_lexerZ_peek();
	switch (get_top_data_tag()) {
		case 10LL: { // BLF
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_newlineZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 32LL: { // BSPACE
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 9LL: { // BHT
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 11LL: { // BVT
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 13LL: { // BCR
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 35LL: { // BHASH
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_skipZ_commentZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 44LL: { // BCOMMA
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_closeZ_colonsZBang();
			uint64_t v0 = (1LL /* TokenComma */);
			push_u64(v0);
			mw_mirth_lexer_lexerZ_emitZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 41LL: { // BRPAREN
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_closeZ_colonsZBang();
			mw_mirth_lexer_lexerZ_emitZ_rparenZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 93LL: { // BRSQUARE
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_closeZ_colonsZBang();
			mw_mirth_lexer_lexerZ_emitZ_rsquareZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 125LL: { // BRCURLY
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_closeZ_colonsZBang();
			mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 58LL: { // BCOLON
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang();
			mw_mirth_lexer_lexerZ_emitZ_lcolonZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 40LL: { // BLPAREN
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang();
			mw_mirth_lexer_lexerZ_emitZ_lparenZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 91LL: { // BLSQUARE
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang();
			mw_mirth_lexer_lexerZ_emitZ_lsquareZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 123LL: { // BLCURLY
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang();
			mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		case 34LL: { // BQUOTE
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang();
			mw_mirth_lexer_lexerZ_emitZ_stringZBang();
			mw_mirth_lexer_lexerZ_moveZBang();
		} break;
		default: {
			mw_std_byte_Byte_isZ_nameZ_byte();
			VAL v1 = pop_value();
			if (VBOOL(v1)) {
				mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang();
				mw_mirth_lexer_lexerZ_emitZ_nameZBang();
			} else {
				STRLIT("Unrecognized byte.", 18);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
			}
		} break;
	}
}
static void mw_mirth_lexer_lexerZ_newlineZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_location_Row_ZToInt();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	mw_std_prim_Int_ZToRow();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	int64_t v1 = (0LL);
	push_i64(v1);
	mw_std_prim_Int_ZToCol();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_lexer_lexerZ_emitZ_lcolonZBang (void) {
	uint64_t v0 = (5LL /* TokenLColonOpen */);
	push_u64(v0);
	mw_mirth_lexer_lexerZ_makeZBang();
	mw_mirth_lexer_lexerZ_stackZ_pushZBang();
}
static void mw_mirth_lexer_lexerZ_closeZ_colonsZBang (void) {
	mw_mirth_lexer_lexerZ_stackZ_peek();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			mw_mirth_token_Token_lcolonZ_openZAsk();
			VAL v1 = pop_value();
			push_value(v0);
			if (VBOOL(v1)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v2 = pop_value();
				decref(v2);
				uint64_t v3 = (0LL /* None */);
				push_u64(v3);
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v4 = (0LL /* None */);
			push_u64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_lexer_lexerZ_stackZ_drop();
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		push_value(v7);
		mtw_mirth_token_TokenValue_TokenRColon();
		mw_mirth_lexer_lexerZ_makeZBang();
		mtw_mirth_token_TokenValue_TokenLColon();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
		mfld_mirth_token_Token_ZTildevalue();
		mp_primZ_mutZ_set();
		mw_mirth_lexer_lexerZ_stackZ_peek();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v10 = pop_value();
				incref(v10);
				push_value(v10);
				mw_mirth_token_Token_lcolonZ_openZAsk();
				VAL v11 = pop_value();
				push_value(v10);
				if (VBOOL(v11)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v12 = pop_value();
					decref(v12);
					uint64_t v13 = (0LL /* None */);
					push_u64(v13);
				}
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v14 = (0LL /* None */);
				push_u64(v14);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
	VAL v15 = pop_value();
	decref(v15);
}
static void mw_mirth_lexer_lexerZ_prepareZ_forZ_atomZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_lcolonZ_openZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
	} else {
		mw_mirth_lexer_lexerZ_closeZ_colonsZBang();
	}
}
static void mw_mirth_lexer_lexerZ_prepareZ_forZ_argsZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_closeZ_colonsZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_lexer_lexerZ_emitZ_lparenZBang (void) {
	uint64_t v0 = (2LL /* TokenLParenOpen */);
	push_u64(v0);
	mw_mirth_lexer_lexerZ_makeZBang();
	mw_mirth_lexer_lexerZ_stackZ_pushZBang();
}
static void mw_mirth_lexer_lexerZ_emitZ_rparenZBang (void) {
	mw_mirth_lexer_lexerZ_stackZ_popZBang();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Mismatched right parenthesis.", 29);
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_token_Token_lparenZ_openZAsk();
			VAL v1 = pop_value();
			if (VBOOL(v1)) {
				VAL v2 = pop_value();
				incref(v2);
				push_value(v2);
				push_value(v2);
				mtw_mirth_token_TokenValue_TokenRParen();
				mw_mirth_lexer_lexerZ_makeZBang();
				mtw_mirth_token_TokenValue_TokenLParen();
				VAL v3 = pop_value();
				VAL v4 = pop_value();
				push_value(v3);
				push_value(v4);
				mfld_mirth_token_Token_ZTildevalue();
				mp_primZ_mutZ_set();
			} else {
				STRLIT("Mismatched right parenthesis.", 29);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_lexer_lexerZ_emitZ_lsquareZBang (void) {
	uint64_t v0 = (3LL /* TokenLSquareOpen */);
	push_u64(v0);
	mw_mirth_lexer_lexerZ_makeZBang();
	mw_mirth_lexer_lexerZ_stackZ_pushZBang();
}
static void mw_mirth_lexer_lexerZ_emitZ_rsquareZBang (void) {
	mw_mirth_lexer_lexerZ_stackZ_popZBang();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Mismatched right square bracket.", 32);
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_token_Token_lsquareZ_openZAsk();
			VAL v1 = pop_value();
			if (VBOOL(v1)) {
				VAL v2 = pop_value();
				incref(v2);
				push_value(v2);
				push_value(v2);
				mtw_mirth_token_TokenValue_TokenRSquare();
				mw_mirth_lexer_lexerZ_makeZBang();
				mtw_mirth_token_TokenValue_TokenLSquare();
				VAL v3 = pop_value();
				VAL v4 = pop_value();
				push_value(v3);
				push_value(v4);
				mfld_mirth_token_Token_ZTildevalue();
				mp_primZ_mutZ_set();
			} else {
				STRLIT("Mismatched right square bracket.", 32);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_lexer_lexerZ_emitZ_lcurlyZBang (void) {
	uint64_t v0 = (4LL /* TokenLCurlyOpen */);
	push_u64(v0);
	mw_mirth_lexer_lexerZ_makeZBang();
	mw_mirth_lexer_lexerZ_stackZ_pushZBang();
}
static void mw_mirth_lexer_lexerZ_emitZ_rcurlyZBang (void) {
	mw_mirth_lexer_lexerZ_stackZ_popZBang();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Mismatched right curly brace.", 29);
			mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_token_Token_lcurlyZ_openZAsk();
			VAL v1 = pop_value();
			if (VBOOL(v1)) {
				VAL v2 = pop_value();
				incref(v2);
				push_value(v2);
				push_value(v2);
				mtw_mirth_token_TokenValue_TokenRCurly();
				mw_mirth_lexer_lexerZ_makeZBang();
				mtw_mirth_token_TokenValue_TokenLCurly();
				VAL v3 = pop_value();
				VAL v4 = pop_value();
				push_value(v3);
				push_value(v4);
				mfld_mirth_token_Token_ZTildevalue();
				mp_primZ_mutZ_set();
			} else {
				STRLIT("Mismatched right curly brace.", 29);
				mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_lexer_lexerZ_emitZ_nameZBang (void) {
	VAL r0 = pop_resource();
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	push_resource(r0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_lexer_lexerZ_peek();
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mw_std_byte_Byte_isZ_nameZ_byte();
		VAL v2 = pop_value();
		if (!VBOOL(v2)) break;
		VAL r3 = pop_resource();
		mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang();
		push_resource(r3);
		mw_mirth_lexer_lexerZ_moveZBang();
		mw_mirth_lexer_lexerZ_peek();
	}
	VAL v4 = pop_value();
	decref(v4);
	VAL r5 = pop_resource();
	mw_std_str_ZPlusStr_isZ_docZ_startZAsk();
	VAL v6 = pop_value();
	push_resource(r5);
	if (VBOOL(v6)) {
		VAL v7 = pop_value();
		decref(v7);
		VAL v8 = pop_value();
		decref(v8);
		VAL v9 = pop_value();
		decref(v9);
		mw_mirth_lexer_lexerZ_skipZ_docZBang();
	} else {
		VAL r10 = pop_resource();
		mw_std_str_ZPlusStr_isZ_floatZAsk();
		VAL v11 = pop_value();
		if (VBOOL(v11)) {
			mw_std_str_ZPlusStr_floatZAsk();
			mtw_mirth_token_TokenValue_TokenF64();
		} else {
			mw_std_str_ZPlusStr_isZ_intZAsk();
			VAL v12 = pop_value();
			if (VBOOL(v12)) {
				mw_std_str_ZPlusStr_intZAsk();
				mtw_mirth_token_TokenValue_TokenInt();
			} else {
				mw_std_str_ZPlusStr_dnameZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mtw_mirth_token_TokenValue_TokenDName();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						mw_std_str_ZPlusStr_labelZ_tokenZAsk();
						switch (get_top_data_tag()) {
							case 1LL: { // Some
								mtp_std_maybe_Maybe_1_Some();
							} break;
							case 0LL: { // None
								(void)pop_u64();
								mw_std_str_ZPlusStr_nameZAsk();
								mtw_mirth_token_TokenValue_TokenName();
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								mp_primZ_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			}
		}
		push_resource(r10);
		mw_mirth_token_Token_allocZBang();
		VAL v13 = pop_value();
		incref(v13);
		VAL v14 = pop_value();
		push_value(v13);
		push_value(v14);
		push_value(v13);
		mfld_mirth_token_Token_ZTildevalue();
		mp_primZ_mutZ_set();
		VAL v15 = pop_value();
		incref(v15);
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
		push_value(v15);
		mfld_mirth_token_Token_ZTildecol();
		mp_primZ_mutZ_set();
		VAL v17 = pop_value();
		incref(v17);
		VAL v18 = pop_value();
		push_value(v17);
		push_value(v18);
		push_value(v17);
		mfld_mirth_token_Token_ZTilderow();
		mp_primZ_mutZ_set();
		VAL v19 = pop_value();
		incref(v19);
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
		push_value(v19);
		mfld_mirth_token_Token_ZTildemodule();
		mp_primZ_mutZ_set();
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[5];
			VAL t = *p; *p = u; decref(t);
		}
	}
	VAL r21 = pop_resource();
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v22 = pop_value();
	decref(v22);
	push_resource(r21);
}
static void mw_std_str_ZPlusStr_nameZAsk (void) {
	mw_std_str_ZPlusStr_dupZBang();
	mw_std_prim_Str_ZToName();
}
static void mw_std_str_ZPlusStr_firstZ_byte (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_str_ZPlusStr_byteZAt();
}
static void mw_std_str_ZPlusStr_secondZ_byte (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	mw_std_str_ZPlusStr_byteZAt();
}
static void mw_std_str_ZPlusStr_thirdZ_byte (void) {
	int64_t v0 = (2LL);
	push_i64(v0);
	mw_std_str_ZPlusStr_byteZAt();
}
static void mw_std_str_ZPlusStr_firstZ_twoZ_bytes (void) {
	int64_t v0 = (2LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	mw_std_str_ZPlusStr_takeZ_slice();
}
static void mw_std_str_ZPlusStr_dropZ_firstZ_byte (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	mw_std_str_ZPlusStr_dropZ_slice();
}
static void mw_std_str_ZPlusStr_dropZ_lastZ_byte (void) {
	VAL r0 = pop_resource();
	mw_std_str_ZPlusStr_numZ_bytesZAsk();
	int64_t v1 = (1LL);
	VAL v2 = pop_value();
	bool v3 = (v1 < VI64(v2));
	push_resource(r0);
	if (v3) {
		VAL r4 = pop_resource();
		mw_std_str_ZPlusStr_numZ_bytesZAsk();
		int64_t v5 = (1LL);
		push_resource(r4);
		push_i64(v5);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		mw_std_str_ZPlusStr_takeZ_slice();
	} else {
		STRLIT("", 0);
	}
}
static void mw_std_str_ZPlusStr_labelZ_tokenZAsk (void) {
	mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_str_ZPlusStr_labelZ_popZ_tokenZAsk (void) {
	mw_std_str_ZPlusStr_firstZ_byte();
	mw_std_byte_Byte_isZ_lower();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_std_str_ZPlusStr_lastZ_byte();
		uint64_t v1 = (62LL /* B'>' */);
		push_u64(v1);
		mw_std_byte_Byte_ZEqualZEqual();
	} else {
		uint64_t v2 = (0LL /* False */);
		push_u64(v2);
	}
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = (MKU64(0LL /* +Unsafe */));
		push_resource(v4);
		mw_std_str_ZPlusStr_dropZ_lastZ_byte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_prim_Str_ZToName();
		mw_mirth_label_Label_newZBang();
		mtw_mirth_token_TokenValue_TokenLabelPop();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		uint64_t v5 = (0LL /* None */);
		push_u64(v5);
	}
}
static void mw_std_str_ZPlusStr_labelZ_popZ_rZ_tokenZAsk (void) {
	mw_std_str_ZPlusStr_firstZ_byte();
	uint64_t v0 = (43LL /* B'+' */);
	push_u64(v0);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_std_str_ZPlusStr_secondZ_byte();
		mw_std_byte_Byte_isZ_lower();
		VAL v2 = pop_value();
		if (VBOOL(v2)) {
			mw_std_str_ZPlusStr_lastZ_byte();
			uint64_t v3 = (62LL /* B'>' */);
			push_u64(v3);
			mw_std_byte_Byte_ZEqualZEqual();
		} else {
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		}
	} else {
		uint64_t v5 = (0LL /* False */);
		push_u64(v5);
	}
	VAL v6 = pop_value();
	if (VBOOL(v6)) {
		VAL v7 = (MKU64(0LL /* +Unsafe */));
		push_resource(v7);
		mw_std_str_ZPlusStr_dropZ_lastZ_byte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_prim_Str_ZToName();
		mw_mirth_label_Label_newZBang();
		mtw_mirth_token_TokenValue_TokenLabelPopR();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		uint64_t v8 = (0LL /* None */);
		push_u64(v8);
	}
}
static void mw_std_str_ZPlusStr_labelZ_pushZ_tokenZAsk (void) {
	mw_std_str_ZPlusStr_firstZ_byte();
	uint64_t v0 = (62LL /* B'>' */);
	push_u64(v0);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_std_str_ZPlusStr_secondZ_byte();
		mw_std_byte_Byte_isZ_lower();
	} else {
		uint64_t v2 = (0LL /* False */);
		push_u64(v2);
	}
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = (MKU64(0LL /* +Unsafe */));
		push_resource(v4);
		mw_std_str_ZPlusStr_dropZ_firstZ_byte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_prim_Str_ZToName();
		mw_mirth_label_Label_newZBang();
		mtw_mirth_token_TokenValue_TokenLabelPush();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		uint64_t v5 = (0LL /* None */);
		push_u64(v5);
	}
}
static void mw_std_str_ZPlusStr_labelZ_pushZ_rZ_tokenZAsk (void) {
	VAL v0 = (MKU64(0LL /* +Unsafe */));
	push_resource(v0);
	mw_std_str_ZPlusStr_firstZ_twoZ_bytes();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	STRLIT(">+", 2);
	mp_primZ_strZ_cmp();
	int64_t v1 = (0LL);
	VAL v2 = pop_value();
	incref(v2);
	bool v3 = (VI64(v2) == v1);
	push_value(v2);
	push_i64(v1);
	if (v3) {
		VAL v4 = pop_value();
		decref(v4);
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (1LL /* EQ */);
		push_u64(v6);
	} else {
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		bool v9 = (VI64(v8) < VI64(v7));
		if (v9) {
			uint64_t v10 = (0LL /* LT */);
			push_u64(v10);
		} else {
			uint64_t v11 = (2LL /* GT */);
			push_u64(v11);
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // LT
			(void)pop_u64();
			uint64_t v12 = (0LL /* False */);
			push_u64(v12);
		} break;
		case 1LL: { // EQ
			(void)pop_u64();
			uint64_t v13 = (1LL /* True */);
			push_u64(v13);
		} break;
		case 2LL: { // GT
			(void)pop_u64();
			uint64_t v14 = (0LL /* False */);
			push_u64(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v15 = pop_value();
	if (VBOOL(v15)) {
		mw_std_str_ZPlusStr_thirdZ_byte();
		mw_std_byte_Byte_isZ_lower();
	} else {
		uint64_t v16 = (0LL /* False */);
		push_u64(v16);
	}
	VAL v17 = pop_value();
	if (VBOOL(v17)) {
		VAL v18 = (MKU64(0LL /* +Unsafe */));
		push_resource(v18);
		mw_std_str_ZPlusStr_dropZ_firstZ_byte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_prim_Str_ZToName();
		mw_mirth_label_Label_newZBang();
		mtw_mirth_token_TokenValue_TokenLabelPushR();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		uint64_t v19 = (0LL /* None */);
		push_u64(v19);
	}
}
static void mw_std_str_ZPlusStr_labelZ_getZ_tokenZAsk (void) {
	mw_std_str_ZPlusStr_firstZ_byte();
	uint64_t v0 = (64LL /* B'@' */);
	push_u64(v0);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_std_str_ZPlusStr_secondZ_byte();
		mw_std_byte_Byte_isZ_lower();
		VAL v2 = pop_value();
		if (VBOOL(v2)) {
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		} else {
			mw_std_str_ZPlusStr_secondZ_byte();
			uint64_t v4 = (43LL /* B'+' */);
			push_u64(v4);
			mw_std_byte_Byte_ZEqualZEqual();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				mw_std_str_ZPlusStr_thirdZ_byte();
				mw_std_byte_Byte_isZ_lower();
			} else {
				uint64_t v6 = (0LL /* False */);
				push_u64(v6);
			}
		}
	} else {
		uint64_t v7 = (0LL /* False */);
		push_u64(v7);
	}
	VAL v8 = pop_value();
	if (VBOOL(v8)) {
		VAL v9 = (MKU64(0LL /* +Unsafe */));
		push_resource(v9);
		mw_std_str_ZPlusStr_dropZ_firstZ_byte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_prim_Str_ZToName();
		mw_mirth_label_Label_newZBang();
		mtw_mirth_token_TokenValue_TokenLabelGet();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		uint64_t v10 = (0LL /* None */);
		push_u64(v10);
	}
}
static void mw_std_str_ZPlusStr_labelZ_setZ_tokenZAsk (void) {
	mw_std_str_ZPlusStr_firstZ_byte();
	uint64_t v0 = (33LL /* B'!' */);
	push_u64(v0);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_std_str_ZPlusStr_secondZ_byte();
		mw_std_byte_Byte_isZ_lower();
	} else {
		uint64_t v2 = (0LL /* False */);
		push_u64(v2);
	}
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = (MKU64(0LL /* +Unsafe */));
		push_resource(v4);
		mw_std_str_ZPlusStr_dropZ_firstZ_byte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_std_prim_Str_ZToName();
		mw_mirth_label_Label_newZBang();
		mtw_mirth_token_TokenValue_TokenLabelSet();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		uint64_t v5 = (0LL /* None */);
		push_u64(v5);
	}
}
static void mw_std_str_ZPlusStr_dnameZAsk (void) {
	uint64_t v0 = (46LL /* BDOT */);
	push_u64(v0);
	mw_std_str_ZPlusStr_splitZ_byte();
	mw_std_list_ListZPlus_1_uncons();
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* None */);
			push_u64(v2);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mp_primZ_strZ_numZ_bytes();
			mw_std_prim_Int_ZToNat();
			int64_t v5 = (0LL);
			VAL v6 = pop_value();
			bool v7 = (VI64(v6) == v5);
			if (v7) {
				VAL v8 = pop_value();
				decref(v8);
				uint64_t v9 = (0LL /* None */);
				push_u64(v9);
			} else {
				mw_std_prim_Str_ZToName();
				mtw_std_maybe_Maybe_1_Some();
			}
			uint64_t v10 = (0LL /* Nil */);
			push_value(v3);
			push_u64(v10);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			push_value(v11);
			push_value(v12);
			while(1) {
				VAL v13 = pop_value();
				incref(v13);
				push_value(v13);
				push_value(v13);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v14 = pop_value();
				if (!VBOOL(v14)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				VAL r17 = pop_resource();
				push_value(v15);
				mw_std_prim_Str_ZToName();
				push_resource(r17);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
				push_value(v16);
				mw_std_list_List_1_uncons();
				VAL v18 = pop_value();
				VAL v19 = pop_value();
				push_value(v18);
				push_value(v19);
			}
			VAL v20 = pop_value();
			decref(v20);
			VAL v21 = pop_value();
			decref(v21);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			mtw_mirth_name_DName_DName();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_str_ZPlusStr_isZ_docZ_startZAsk (void) {
	mw_std_str_ZPlusStr_dupZBang();
	STRLIT("|||", 3);
	mp_primZ_strZ_cmp();
	int64_t v0 = (0LL);
	VAL v1 = pop_value();
	incref(v1);
	bool v2 = (VI64(v1) == v0);
	push_value(v1);
	push_i64(v0);
	if (v2) {
		VAL v3 = pop_value();
		decref(v3);
		VAL v4 = pop_value();
		decref(v4);
		uint64_t v5 = (1LL /* EQ */);
		push_u64(v5);
	} else {
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		bool v8 = (VI64(v7) < VI64(v6));
		if (v8) {
			uint64_t v9 = (0LL /* LT */);
			push_u64(v9);
		} else {
			uint64_t v10 = (2LL /* GT */);
			push_u64(v10);
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // LT
			(void)pop_u64();
			uint64_t v11 = (0LL /* False */);
			push_u64(v11);
		} break;
		case 1LL: { // EQ
			(void)pop_u64();
			uint64_t v12 = (1LL /* True */);
			push_u64(v12);
		} break;
		case 2LL: { // GT
			(void)pop_u64();
			uint64_t v13 = (0LL /* False */);
			push_u64(v13);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_str_ZPlusStr_isZ_floatZAsk (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	int64_t v1 = (0LL);
	push_i64(v1);
	push_i64(v1);
	mw_std_str_ZPlusStr_byteZAt();
	mw_std_byte_Byte_isZ_sign();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		int64_t v3 = (1LL);
		push_i64(v3);
		mp_primZ_intZ_add();
	} else {
	}
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_str_ZPlusStr_byteZAt();
		mw_std_byte_Byte_isZ_digit();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		VAL v6 = pop_value();
		int64_t v7 = (1LL);
		push_i64(v7);
		mp_primZ_intZ_add();
		int64_t v8 = (1LL);
		push_value(v6);
		push_i64(v8);
		mp_primZ_intZ_add();
	}
	VAL v9 = pop_value();
	incref(v9);
	push_value(v9);
	push_value(v9);
	mw_std_str_ZPlusStr_byteZAt();
	uint64_t v10 = (46LL /* BDOT */);
	push_u64(v10);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v11 = pop_value();
	if (VBOOL(v11)) {
		VAL v12 = pop_value();
		int64_t v13 = (1LL);
		push_i64(v13);
		mp_primZ_intZ_add();
		int64_t v14 = (1LL);
		push_value(v12);
		push_i64(v14);
		mp_primZ_intZ_add();
		while(1) {
			VAL v15 = pop_value();
			incref(v15);
			push_value(v15);
			push_value(v15);
			mw_std_str_ZPlusStr_byteZAt();
			mw_std_byte_Byte_isZ_digit();
			VAL v16 = pop_value();
			if (!VBOOL(v16)) break;
			VAL v17 = pop_value();
			int64_t v18 = (1LL);
			push_i64(v18);
			mp_primZ_intZ_add();
			int64_t v19 = (1LL);
			push_value(v17);
			push_i64(v19);
			mp_primZ_intZ_add();
		}
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		int64_t v22 = (3LL);
		bool v23 = (VI64(v21) < v22);
		push_value(v20);
		if (v23) {
			uint64_t v24 = (0LL /* False */);
			push_u64(v24);
		} else {
			uint64_t v25 = (1LL /* True */);
			push_u64(v25);
		}
		VAL v26 = pop_value();
		if (VBOOL(v26)) {
			mw_std_str_ZPlusStr_numZ_bytesZAsk();
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			bool v29 = (VI64(v28) == VI64(v27));
			push_bool(v29);
		} else {
			VAL v30 = pop_value();
			decref(v30);
			uint64_t v31 = (0LL /* False */);
			push_u64(v31);
		}
	} else {
		VAL v32 = pop_value();
		decref(v32);
		VAL v33 = pop_value();
		decref(v33);
		uint64_t v34 = (0LL /* False */);
		push_u64(v34);
	}
}
static void mw_std_str_ZPlusStr_floatZ_sign (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_str_ZPlusStr_byteZAt();
	mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float();
}
static void mw_mirth_lexer_byteZ_signZ_valueZ_indexZ_float (void) {
	switch (get_top_data_tag()) {
		case 45LL: { // B'-'
			(void)pop_u64();
			uint64_t v0 = (45LL /* B'-' */);
			int64_t v1 = (1LL);
			push_u64(v0);
			push_i64(v1);
		} break;
		case 43LL: { // B'+'
			(void)pop_u64();
			uint64_t v2 = (43LL /* B'+' */);
			int64_t v3 = (1LL);
			push_u64(v2);
			push_i64(v3);
		} break;
		default: {
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (43LL /* B'+' */);
			int64_t v6 = (0LL);
			push_u64(v5);
			push_i64(v6);
		} break;
	}
}
static void mw_std_str_ZPlusStr_floatZAsk (void) {
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	int64_t v2 = (0LL);
	push_resource(r0);
	push_resource(r1);
	push_i64(v2);
	mw_std_str_ZPlusStr_floatZ_sign();
	VAL r3 = pop_resource();
	VAL v4 = pop_value();
	mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
	push_resource(r3);
	push_value(v4);
	mp_primZ_intZ_add();
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_str_ZPlusStr_numZ_bytesZAsk();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		bool v8 = (VI64(v7) < VI64(v6));
		if (!v8) break;
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		mw_std_str_ZPlusStr_byteZAt();
		VAL r10 = pop_resource();
		mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
		int64_t v11 = (1LL);
		push_resource(r10);
		push_value(v9);
		push_i64(v11);
		mp_primZ_intZ_add();
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL r13 = pop_resource();
	VAL r14 = pop_resource();
	push_resource(r13);
	push_resource(r14);
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL v15 = pop_value();
	incref(v15);
	incref(v15);
	push_value(v15);
	mp_primZ_strZ_base();
	push_value(v15);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	VAL v16 = pop_value();
	VAL v17 = pop_value();
	incref(v17);
	VAL v18 = (MKU64(0LL /* +Unsafe */));
	push_value(v17);
	push_value(v16);
	push_resource(v18);
	push_value(v17);
	mp_primZ_ptrZ_add();
	mp_primZ_u8Z_get();
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Unsafe
			(void)pop_resource();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	int64_t v19 = (0LL);
	VAL v20 = pop_value();
	bool v21 = (VI64(v20) == v19);
	if (v21) {
	} else {
		STRLIT("tried to use Str as CStr, but Str is not zero terminated", 56);
		mp_primZ_panic();
	}
	mext_mirth_lexer_stringz_toz_float64();
	decref(v15);
}
static void mw_std_str_ZPlusStr_isZ_intZAsk (void) {
	mw_std_str_ZPlusStr_isZ_decZ_intZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		uint64_t v1 = (1LL /* True */);
		push_u64(v1);
	} else {
		mw_std_str_ZPlusStr_isZ_hexZ_intZAsk();
	}
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		uint64_t v3 = (1LL /* True */);
		push_u64(v3);
	} else {
		mw_std_str_ZPlusStr_isZ_octZ_intZAsk();
	}
}
static void mw_std_str_ZPlusStr_isZ_decZ_intZAsk (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	int64_t v1 = (0LL);
	push_i64(v1);
	push_i64(v1);
	mw_std_str_ZPlusStr_byteZAt();
	mw_std_byte_Byte_isZ_sign();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		int64_t v3 = (1LL);
		push_i64(v3);
		mp_primZ_intZ_add();
	} else {
	}
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_str_ZPlusStr_byteZAt();
		mw_std_byte_Byte_isZ_digit();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		VAL v6 = pop_value();
		int64_t v7 = (1LL);
		push_i64(v7);
		mp_primZ_intZ_add();
		int64_t v8 = (1LL);
		push_value(v6);
		push_i64(v8);
		mp_primZ_intZ_add();
	}
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	int64_t v11 = (0LL);
	bool v12 = (v11 < VI64(v10));
	push_value(v9);
	if (v12) {
		mw_std_str_ZPlusStr_numZ_bytesZAsk();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		bool v15 = (VI64(v14) == VI64(v13));
		push_bool(v15);
	} else {
		VAL v16 = pop_value();
		decref(v16);
		uint64_t v17 = (0LL /* False */);
		push_u64(v17);
	}
}
static void mw_std_str_ZPlusStr_isZ_hexZ_intZAsk (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	int64_t v1 = (0LL);
	push_i64(v1);
	push_i64(v1);
	mw_std_str_ZPlusStr_byteZAt();
	mw_std_byte_Byte_isZ_sign();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		int64_t v3 = (1LL);
		push_i64(v3);
		mp_primZ_intZ_add();
	} else {
	}
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mw_std_str_ZPlusStr_byteZAt();
	uint64_t v5 = (48LL /* B'0' */);
	push_u64(v5);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v6 = pop_value();
	if (VBOOL(v6)) {
		int64_t v7 = (1LL);
		push_i64(v7);
		mp_primZ_intZ_add();
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		mw_std_str_ZPlusStr_byteZAt();
		uint64_t v9 = (120LL /* B'x' */);
		push_u64(v9);
		mw_std_byte_Byte_ZEqualZEqual();
		VAL v10 = pop_value();
		if (VBOOL(v10)) {
			int64_t v11 = (1LL);
			push_i64(v11);
			mp_primZ_intZ_add();
			while(1) {
				VAL v12 = pop_value();
				incref(v12);
				push_value(v12);
				push_value(v12);
				mw_std_str_ZPlusStr_byteZAt();
				mw_std_byte_Byte_isZ_hexdigit();
				VAL v13 = pop_value();
				if (!VBOOL(v13)) break;
				VAL v14 = pop_value();
				int64_t v15 = (1LL);
				push_i64(v15);
				mp_primZ_intZ_add();
				int64_t v16 = (1LL);
				push_value(v14);
				push_i64(v16);
				mp_primZ_intZ_add();
			}
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			int64_t v19 = (0LL);
			bool v20 = (v19 < VI64(v18));
			push_value(v17);
			if (v20) {
				mw_std_str_ZPlusStr_numZ_bytesZAsk();
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				bool v23 = (VI64(v22) == VI64(v21));
				push_bool(v23);
			} else {
				VAL v24 = pop_value();
				decref(v24);
				uint64_t v25 = (0LL /* False */);
				push_u64(v25);
			}
		} else {
			VAL v26 = pop_value();
			decref(v26);
			VAL v27 = pop_value();
			decref(v27);
			uint64_t v28 = (0LL /* False */);
			push_u64(v28);
		}
	} else {
		VAL v29 = pop_value();
		decref(v29);
		VAL v30 = pop_value();
		decref(v30);
		uint64_t v31 = (0LL /* False */);
		push_u64(v31);
	}
}
static void mw_std_str_ZPlusStr_isZ_octZ_intZAsk (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	int64_t v1 = (0LL);
	push_i64(v1);
	push_i64(v1);
	mw_std_str_ZPlusStr_byteZAt();
	mw_std_byte_Byte_isZ_sign();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		int64_t v3 = (1LL);
		push_i64(v3);
		mp_primZ_intZ_add();
	} else {
	}
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mw_std_str_ZPlusStr_byteZAt();
	uint64_t v5 = (48LL /* B'0' */);
	push_u64(v5);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v6 = pop_value();
	if (VBOOL(v6)) {
		int64_t v7 = (1LL);
		push_i64(v7);
		mp_primZ_intZ_add();
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		mw_std_str_ZPlusStr_byteZAt();
		uint64_t v9 = (111LL /* B'o' */);
		push_u64(v9);
		mw_std_byte_Byte_ZEqualZEqual();
		VAL v10 = pop_value();
		if (VBOOL(v10)) {
			int64_t v11 = (1LL);
			push_i64(v11);
			mp_primZ_intZ_add();
			while(1) {
				VAL v12 = pop_value();
				incref(v12);
				push_value(v12);
				push_value(v12);
				mw_std_str_ZPlusStr_byteZAt();
				uint64_t v13 = (48LL /* B'0' */);
				uint64_t v14 = (55LL /* B'7' */);
				push_u64(v13);
				push_u64(v14);
				mw_std_byte_Byte_inZ_range();
				VAL v15 = pop_value();
				if (!VBOOL(v15)) break;
				VAL v16 = pop_value();
				int64_t v17 = (1LL);
				push_i64(v17);
				mp_primZ_intZ_add();
				int64_t v18 = (1LL);
				push_value(v16);
				push_i64(v18);
				mp_primZ_intZ_add();
			}
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			int64_t v21 = (0LL);
			bool v22 = (v21 < VI64(v20));
			push_value(v19);
			if (v22) {
				mw_std_str_ZPlusStr_numZ_bytesZAsk();
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				bool v25 = (VI64(v24) == VI64(v23));
				push_bool(v25);
			} else {
				VAL v26 = pop_value();
				decref(v26);
				uint64_t v27 = (0LL /* False */);
				push_u64(v27);
			}
		} else {
			VAL v28 = pop_value();
			decref(v28);
			VAL v29 = pop_value();
			decref(v29);
			uint64_t v30 = (0LL /* False */);
			push_u64(v30);
		}
	} else {
		VAL v31 = pop_value();
		decref(v31);
		VAL v32 = pop_value();
		decref(v32);
		uint64_t v33 = (0LL /* False */);
		push_u64(v33);
	}
}
static void mw_std_str_ZPlusStr_intZAsk (void) {
	mw_std_str_ZPlusStr_isZ_decZ_intZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_std_str_ZPlusStr_decZ_intZAsk();
	} else {
		mw_std_str_ZPlusStr_isZ_hexZ_intZAsk();
		VAL v1 = pop_value();
		if (VBOOL(v1)) {
			mw_std_str_ZPlusStr_hexZ_intZAsk();
		} else {
			mw_std_str_ZPlusStr_octZ_intZAsk();
		}
	}
}
static void mw_std_str_ZPlusStr_intZ_sign (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_str_ZPlusStr_byteZAt();
	mw_mirth_lexer_byteZ_signZ_valueZ_index();
}
static void mw_mirth_lexer_byteZ_signZ_valueZ_index (void) {
	switch (get_top_data_tag()) {
		case 45LL: { // B'-'
			(void)pop_u64();
			int64_t v0 = (-1LL);
			int64_t v1 = (0LL);
			int64_t v2 = (1LL);
			push_i64(v0);
			push_i64(v1);
			push_i64(v2);
		} break;
		case 43LL: { // B'+'
			(void)pop_u64();
			int64_t v3 = (1LL);
			int64_t v4 = (0LL);
			int64_t v5 = (1LL);
			push_i64(v3);
			push_i64(v4);
			push_i64(v5);
		} break;
		default: {
			VAL v6 = pop_value();
			decref(v6);
			int64_t v7 = (1LL);
			int64_t v8 = (0LL);
			int64_t v9 = (0LL);
			push_i64(v7);
			push_i64(v8);
			push_i64(v9);
		} break;
	}
}
static void mw_std_str_ZPlusStr_decZ_intZAsk (void) {
	mw_std_str_ZPlusStr_intZ_sign();
	while(1) {
		VAL v0 = pop_value();
		incref(v0);
		push_value(v0);
		push_value(v0);
		mw_std_str_ZPlusStr_numZ_bytesZAsk();
		VAL v1 = pop_value();
		VAL v2 = pop_value();
		bool v3 = (VI64(v2) < VI64(v1));
		if (!v3) break;
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		mw_std_str_ZPlusStr_byteZAt();
		mw_std_byte_Byte_ZToInt();
		VAL v5 = pop_value();
		int64_t v6 = (10LL);
		VAL v7 = pop_value();
		int64_t v8 = (VI64(v7) * v6);
		int64_t v9 = (48LL);
		push_i64(v8);
		push_value(v5);
		push_i64(v9);
		mp_primZ_intZ_sub();
		mp_primZ_intZ_add();
		int64_t v10 = (1LL);
		push_value(v4);
		push_i64(v10);
		mp_primZ_intZ_add();
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	int64_t v14 = (VI64(v13) * VI64(v12));
	push_i64(v14);
}
static void mw_std_str_ZPlusStr_hexZ_intZAsk (void) {
	mw_std_str_ZPlusStr_intZ_sign();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_add();
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_str_ZPlusStr_numZ_bytesZAsk();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_std_str_ZPlusStr_byteZAt();
		VAL v7 = pop_value();
		int64_t v8 = (16LL);
		VAL v9 = pop_value();
		int64_t v10 = (VI64(v9) * v8);
		push_i64(v10);
		push_value(v7);
		mw_mirth_lexer_hexdigitZ_value();
		mp_primZ_intZ_add();
		int64_t v11 = (1LL);
		push_value(v6);
		push_i64(v11);
		mp_primZ_intZ_add();
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	int64_t v15 = (VI64(v14) * VI64(v13));
	push_i64(v15);
}
static void mw_std_str_ZPlusStr_octZ_intZAsk (void) {
	mw_std_str_ZPlusStr_intZ_sign();
	int64_t v0 = (1LL);
	push_i64(v0);
	mp_primZ_intZ_add();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_add();
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_str_ZPlusStr_numZ_bytesZAsk();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_std_str_ZPlusStr_byteZAt();
		mw_std_byte_Byte_ZToInt();
		VAL v7 = pop_value();
		int64_t v8 = (8LL);
		VAL v9 = pop_value();
		int64_t v10 = (VI64(v9) * v8);
		int64_t v11 = (48LL);
		push_i64(v10);
		push_value(v7);
		push_i64(v11);
		mp_primZ_intZ_sub();
		mp_primZ_intZ_add();
		int64_t v12 = (1LL);
		push_value(v6);
		push_i64(v12);
		mp_primZ_intZ_add();
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	int64_t v16 = (VI64(v15) * VI64(v14));
	push_i64(v16);
}
static void mw_mirth_lexer_hexdigitZ_value (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_std_byte_Byte_isZ_digit();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_std_byte_Byte_ZToInt();
		int64_t v2 = (48LL);
		push_i64(v2);
		mp_primZ_intZ_sub();
	} else {
		mw_std_byte_Byte_ZToInt();
		int64_t v3 = (55LL);
		push_i64(v3);
		mp_primZ_intZ_sub();
	}
}
static void mw_mirth_lexer_lexerZ_emitZ_stringZBang (void) {
	VAL r0 = pop_resource();
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	uint64_t v1 = (0LL /* TokenNone */);
	push_resource(r0);
	push_u64(v1);
	mw_mirth_lexer_lexerZ_makeZBang();
	mw_mirth_lexer_lexerZ_moveZBang();
	mw_mirth_lexer_lexerZ_peek();
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_byte_Byte_isZ_stringZ_end();
		VAL v3 = pop_value();
		if (VBOOL(v3)) {
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} else {
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		}
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang();
		mw_mirth_lexer_lexerZ_moveZBang();
		mw_mirth_lexer_lexerZ_peek();
	}
	uint64_t v7 = (34LL /* BQUOTE */);
	push_u64(v7);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v8 = pop_value();
	if (VBOOL(v8)) {
	} else {
		STRLIT("String literal is missing end quote (\").", 40);
		VAL r9 = pop_resource();
		VAL r10 = pop_resource();
		push_resource(r9);
		mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang();
		VAL r11 = pop_resource();
		push_resource(r10);
		push_resource(r11);
	}
	VAL r12 = pop_resource();
	mtp_std_str_ZPlusStr_ZPlusStr();
	mtw_mirth_token_TokenValue_TokenStr();
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	push_resource(r12);
	push_value(v13);
	push_value(v14);
	mfld_mirth_token_Token_ZTildevalue();
	mp_primZ_mutZ_set();
}
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_byteZBang (void) {
	switch (get_top_data_tag()) {
		case 92LL: { // B'\'
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_moveZBang();
			mw_mirth_lexer_lexerZ_peek();
			mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang();
		} break;
		default: {
			VAL r0 = pop_resource();
			mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang();
			push_resource(r0);
		} break;
	}
}
static void mw_mirth_lexer_lexerZ_pushZ_stringZ_escapeZ_byteZBang (void) {
	switch (get_top_data_tag()) {
		case 10LL: { // BLF
			(void)pop_u64();
			mw_mirth_lexer_lexerZ_newlineZBang();
		} break;
		case 110LL: { // B'n'
			(void)pop_u64();
			uint64_t v0 = (10LL /* BLF */);
			VAL r1 = pop_resource();
			push_u64(v0);
			mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
			push_resource(r1);
		} break;
		case 114LL: { // B'r'
			(void)pop_u64();
			uint64_t v2 = (13LL /* BCR */);
			VAL r3 = pop_resource();
			push_u64(v2);
			mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
			push_resource(r3);
		} break;
		case 116LL: { // B't'
			(void)pop_u64();
			uint64_t v4 = (9LL /* BHT */);
			VAL r5 = pop_resource();
			push_u64(v4);
			mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
			push_resource(r5);
		} break;
		case 92LL: { // B'\'
			(void)pop_u64();
			uint64_t v6 = (92LL /* B'\' */);
			VAL r7 = pop_resource();
			push_u64(v6);
			mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
			push_resource(r7);
		} break;
		case 34LL: { // BQUOTE
			(void)pop_u64();
			uint64_t v8 = (34LL /* BQUOTE */);
			VAL r9 = pop_resource();
			push_u64(v8);
			mw_std_str_ZPlusStr_pushZ_byteZ_asciiZBang();
			push_resource(r9);
		} break;
		default: {
			VAL r10 = pop_resource();
			mw_std_str_ZPlusStr_pushZ_byteZ_unsafeZBang();
			push_resource(r10);
			STRLIT("Unknown character escape sequence.", 34);
			VAL r11 = pop_resource();
			VAL r12 = pop_resource();
			push_resource(r11);
			mw_mirth_lexer_lexerZ_emitZ_warningZBang();
			VAL r13 = pop_resource();
			push_resource(r12);
			push_resource(r13);
		} break;
	}
}
static void mw_mirth_lexer_lexerZ_skipZ_commentZBang (void) {
	while(1) {
		mw_mirth_lexer_lexerZ_commentZ_endZAsk();
		VAL v0 = pop_value();
		if (VBOOL(v0)) {
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} else {
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		}
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_mirth_lexer_lexerZ_moveZBang();
	}
	mw_mirth_lexer_lexerZ_peek();
	uint64_t v4 = (10LL /* BLF */);
	push_u64(v4);
	mw_std_byte_Byte_ZEqualZEqual();
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
		mw_mirth_lexer_lexerZ_newlineZBang();
	} else {
	}
}
static void mw_mirth_lexer_lexerZ_skipZ_docZBang (void) {
	while(1) {
		mw_mirth_lexer_lexerZ_commentZ_endZAsk();
		VAL v0 = pop_value();
		if (VBOOL(v0)) {
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} else {
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		}
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_mirth_lexer_lexerZ_moveZBang();
	}
}
static void mw_mirth_lexer_lexerZ_commentZ_endZAsk (void) {
	mw_mirth_lexer_ZPlusLexer_doneZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		uint64_t v1 = (1LL /* True */);
		push_u64(v1);
	} else {
		mw_mirth_lexer_lexerZ_peek();
		VAL v2 = pop_value();
		incref(v2);
		uint64_t v3 = (10LL /* BLF */);
		push_value(v2);
		push_value(v2);
		push_u64(v3);
		mw_std_byte_Byte_ZEqualZEqual();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		decref(v5);
		push_value(v4);
	}
}
static void mw_mirth_lexer_lexerZ_peek (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_std_input_ZPlusInput_peek();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_lexer_lexerZ_moveZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_std_input_ZPlusInput_moveZBang();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_location_Col_ZToInt();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_add();
	mw_std_prim_Int_ZToCol();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_lexer_lexerZ_location (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	lpush(&lbl_module, v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v1 = pop_value();
	lpush(&lbl_row, v1);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	lpush(&lbl_col, v2);
	mtw_mirth_location_Location_Location();
}
static void mw_mirth_lexer_lexerZ_emitZ_warningZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_lexer_lexerZ_location();
	VAL r1 = pop_resource();
	push_value(v0);
	mw_mirth_mirth_ZPlusMirth_emitZ_warningZ_atZBang();
	push_resource(r1);
}
static void mw_mirth_lexer_lexerZ_emitZ_fatalZ_errorZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_lexer_lexerZ_location();
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	push_value(v0);
	push_resource(r1);
	push_resource(r2);
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZ_atZBang();
}
static void mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang (void) {
	VAL v0 = pop_value();
	lpush(&lbl_token, v0);
	mw_mirth_var_Ctx0();
	VAL v1 = pop_value();
	uint64_t v2 = (0LL /* False */);
	uint64_t v3 = (1LL /* True */);
	lpush(&lbl_ctx, v1);
	lpush(&lbl_allowZ_typeZ_holes, MKU64(v2));
	lpush(&lbl_allowZ_implicitZ_typeZ_vars, MKU64(v3));
	mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab();
}
static void mw_mirth_elab_ZPlusTypeElab_rdrop (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +TypeElab
			mtp_mirth_elab_ZPlusTypeElab_ZPlusTypeElab();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_ctx));
	VAL v1 = (lpop(&lbl_token));
	decref(v1);
	decref(v0);
	VAL v2 = (lpop(&lbl_allowZ_typeZ_holes));
	decref(v2);
	VAL v3 = (lpop(&lbl_allowZ_implicitZ_typeZ_vars));
	decref(v3);
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_runZ_endZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("expected type signature", 23);
		VAL r1 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		push_resource(r1);
	} else {
	}
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang();
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_sigZ_dashesZAsk();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r3 = pop_resource();
		mw_mirth_token_Token_succ();
		push_resource(r3);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang();
	} else {
		VAL v4 = pop_value();
		mw_mirth_type_T0();
		push_value(v4);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_runZ_endZAsk();
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("expected right paren or comma", 29);
		VAL r6 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		push_resource(r6);
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	mw_std_list_List_1_uncons();
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	push_value(v10);
	push_value(v11);
	while(1) {
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		push_value(v12);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v13 = pop_value();
		if (!VBOOL(v13)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v14);
		mw_mirth_type_TZMul();
		push_value(v15);
		mw_std_list_List_1_uncons();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		push_value(v16);
		push_value(v17);
	}
	VAL v18 = pop_value();
	decref(v18);
	VAL v19 = pop_value();
	decref(v19);
	push_value(v7);
	mw_mirth_type_TZ_ZTo();
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZ_paramsZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_lparenZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			decref(v0);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			mw_mirth_token_Token_next();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			mw_mirth_token_Token_args();
			uint64_t v1 = (0LL /* Nil */);
			push_u64(v1);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_uncons();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			while(1) {
				VAL v4 = pop_value();
				incref(v4);
				push_value(v4);
				push_value(v4);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v5 = pop_value();
				if (!VBOOL(v5)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				VAL r8 = pop_resource();
				push_value(v6);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 5, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
				mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang();
				mtw_mirth_type_Type_TMorphism();
				push_resource(r8);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
				push_value(v7);
				mw_std_list_List_1_uncons();
				VAL v9 = pop_value();
				VAL v10 = pop_value();
				push_value(v9);
				push_value(v10);
			}
			VAL v11 = pop_value();
			decref(v11);
			VAL v12 = pop_value();
			decref(v12);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			VAL v13 = pop_value();
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL t = *p; *p = u; decref(t);
			}
			push_value(v13);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v14 = (0LL /* Nil */);
			push_u64(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_sigZ_stackZ_varZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang();
	} else {
		mw_mirth_type_T0();
	}
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang();
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang (void) {
	while(1) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		mw_mirth_token_Token_sigZ_stackZ_endZAsk();
		VAL v0 = pop_value();
		if (VBOOL(v0)) {
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} else {
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		}
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang();
		mw_mirth_type_StackTypePart_cons();
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang();
	switch (get_top_data_tag()) {
		case 0LL: { // STPCons
			mtp_mirth_type_StackTypePart_STPCons();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			decref(v1);
			push_value(v0);
		} break;
		case 1LL: { // STPConsLabel
			mtp_mirth_type_StackTypePart_STPConsLabel();
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			decref(v3);
			STRLIT("Expected type, not label.", 25);
			VAL r4 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
			uint64_t v5 = (0LL /* TYPE_ERROR */);
			push_resource(r4);
			push_u64(v5);
		} break;
		case 2LL: { // STPWith
			mtp_mirth_type_StackTypePart_STPWith();
			VAL v6 = pop_value();
			decref(v6);
			STRLIT("Expected type, not resource.", 28);
			VAL r7 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
			uint64_t v8 = (0LL /* TYPE_ERROR */);
			push_resource(r7);
			push_u64(v8);
		} break;
		case 3LL: { // STPWithLabel
			mtp_mirth_type_StackTypePart_STPWithLabel();
			VAL v9 = pop_value();
			decref(v9);
			VAL v10 = pop_value();
			decref(v10);
			STRLIT("Expected type, not labelled resource.", 37);
			VAL r11 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
			uint64_t v12 = (0LL /* TYPE_ERROR */);
			push_resource(r11);
			push_u64(v12);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_argZ_endZAsk();
	VAL v13 = pop_value();
	if (VBOOL(v13)) {
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("Unexpected token after type.", 28);
		VAL r14 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		push_resource(r14);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang();
	switch (get_top_data_tag()) {
		case 0LL: { // STPCons
			mtp_mirth_type_StackTypePart_STPCons();
			VAL v0 = pop_value();
			decref(v0);
			STRLIT("Expected resource, not type.", 28);
			VAL r1 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
			uint64_t v2 = (0LL /* TYPE_ERROR */);
			push_resource(r1);
			push_u64(v2);
		} break;
		case 1LL: { // STPConsLabel
			mtp_mirth_type_StackTypePart_STPConsLabel();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = pop_value();
			decref(v4);
			STRLIT("Expected resource, not label.", 29);
			VAL r5 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
			uint64_t v6 = (0LL /* TYPE_ERROR */);
			push_resource(r5);
			push_u64(v6);
		} break;
		case 2LL: { // STPWith
			mtp_mirth_type_StackTypePart_STPWith();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			decref(v8);
			push_value(v7);
		} break;
		case 3LL: { // STPWithLabel
			mtp_mirth_type_StackTypePart_STPWithLabel();
			VAL v9 = pop_value();
			decref(v9);
			VAL v10 = pop_value();
			decref(v10);
			STRLIT("Expected resource, not label.", 29);
			VAL r11 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
			uint64_t v12 = (0LL /* TYPE_ERROR */);
			push_resource(r11);
			push_u64(v12);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_argZ_endZAsk();
	VAL v13 = pop_value();
	if (VBOOL(v13)) {
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("Unexpected token after resource.", 32);
		VAL r14 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		push_resource(r14);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_couldZ_beZ_sigZ_labelZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang();
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		mw_mirth_token_Token_sigZ_typeZ_varZAsk();
		VAL v1 = pop_value();
		if (VBOOL(v1)) {
			mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang();
			mtw_mirth_type_StackTypePart_STPCons();
		} else {
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			mw_mirth_token_Token_sigZ_typeZ_conZAsk();
			VAL v2 = pop_value();
			if (VBOOL(v2)) {
				mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang();
				mtw_mirth_type_StackTypePart_STPCons();
			} else {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 5, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				mw_mirth_token_Token_sigZ_resourceZ_varZAsk();
				VAL v3 = pop_value();
				if (VBOOL(v3)) {
					mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang();
					mtw_mirth_type_StackTypePart_STPWith();
				} else {
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 5, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					mw_mirth_token_Token_sigZ_resourceZ_conZAsk();
					VAL v4 = pop_value();
					if (VBOOL(v4)) {
						mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang();
						mtw_mirth_type_StackTypePart_STPWith();
					} else {
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 5, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						mw_mirth_token_Token_patZ_underscoreZAsk();
						VAL v5 = pop_value();
						if (VBOOL(v5)) {
							mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang();
							mtw_mirth_type_StackTypePart_STPCons();
						} else {
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 5, v);
								VAL* p = &VTUP(v)->cells[2];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							mw_mirth_token_Token_sigZ_typeZ_holeZAsk();
							VAL v6 = pop_value();
							if (VBOOL(v6)) {
								mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang();
								mtw_mirth_type_StackTypePart_STPCons();
							} else {
								{
									VAL v = pop_resource();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 5, v);
									VAL* p = &VTUP(v)->cells[2];
									VAL u = *p;
									incref(u);
									push_resource(v);
									push_value(u);
								}
								mw_mirth_token_Token_lsquareZAsk();
								switch (get_top_data_tag()) {
									case 1LL: { // Some
										mtp_std_maybe_Maybe_1_Some();
										VAL v7 = pop_value();
										decref(v7);
										mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang();
										mtw_mirth_type_StackTypePart_STPCons();
									} break;
									case 0LL: { // None
										(void)pop_u64();
										{
											VAL v = pop_resource();
											ASSERT1(IS_TUP(v), v);
											ASSERT1(VTUPLEN(v) == 5, v);
											VAL* p = &VTUP(v)->cells[2];
											VAL u = *p;
											incref(u);
											push_resource(v);
											push_value(u);
										}
										STRLIT("Expected type, got unknown token.", 33);
										VAL r8 = pop_resource();
										mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
										push_resource(r8);
										{
											VAL v = pop_resource();
											ASSERT1(IS_TUP(v), v);
											ASSERT1(VTUPLEN(v) == 5, v);
											VAL* p = &VTUP(v)->cells[2];
											VAL u = *p;
											incref(u);
											push_resource(v);
											push_value(u);
										}
										VAL r9 = pop_resource();
										mw_mirth_token_Token_next();
										push_resource(r9);
										{
											VAL v = top_resource();
											VAL u = pop_value();
											ASSERT1(IS_TUP(v), v);
											ASSERT1(VTUPLEN(v) == 5, v);
											VAL* p = &VTUP(v)->cells[2];
											VAL t = *p; *p = u; decref(t);
										}
										uint64_t v10 = (0LL /* TYPE_ERROR */);
										push_u64(v10);
										mtw_mirth_type_StackTypePart_STPCons();
									} break;
									default: {
										push_value(mkstr("unexpected fallthrough in match\n", 32));
										mp_primZ_panic();
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_labelZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_next();
	VAL v0 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_nameZAsk();
	mw_std_maybe_Maybe_1_unwrap();
	mw_mirth_label_Label_newZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r1 = pop_resource();
	mw_mirth_token_Token_argsZ_1();
	push_resource(r1);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v2);
	mw_mirth_label_Label_isZ_resourceZ_labelZAsk();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_argZBang();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		push_value(v5);
		mtw_mirth_type_StackTypePart_STPWithLabel();
	} else {
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
		mtw_mirth_type_StackTypePart_STPConsLabel();
	}
	push_value(v0);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_varZBang (void) {
	mw_mirth_type_TYPEz_STACK();
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_mirth_type_StackType_STVar();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_varZBang (void) {
	mw_mirth_type_TYPEz_TYPE();
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_mirth_type_Type_TVar();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* TYPE_ERROR */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_varZBang (void) {
	mw_mirth_type_TYPEz_RESOURCE();
	mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_mirth_type_Type_TVar();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* TYPE_ERROR */);
			push_u64(v0);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_implicitZ_varZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_nameZAsk();
	mw_std_maybe_Maybe_1_unwrap();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_var_Ctx_lookup();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			incref(v1);
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_var_Var_type();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r3 = pop_resource();
			VAL v4 = pop_value();
			lpush(&lbl_token, v4);
			mtw_mirth_type_ZPlusGamma_ZPlusGamma();
			mw_mirth_type_Type_unifyZBang();
			mw_mirth_type_ZPlusGamma_rdrop();
			VAL v5 = pop_value();
			decref(v5);
			push_resource(r3);
			push_value(v1);
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				mw_mirth_var_Var_newZBang();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 5, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r7 = pop_resource();
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				incref(v9);
				push_value(v9);
				push_value(v8);
				push_value(v9);
				mw_mirth_var_Ctx_new();
				push_resource(r7);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 5, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL t = *p; *p = u; decref(t);
				}
				mtw_std_maybe_Maybe_1_Some();
			} else {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 5, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				STRLIT("Implicit type variable not allowed here.", 40);
				VAL r10 = pop_resource();
				mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
				VAL v11 = pop_value();
				decref(v11);
				VAL v12 = pop_value();
				decref(v12);
				uint64_t v13 = (0LL /* None */);
				push_resource(r10);
				push_u64(v13);
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r14 = pop_resource();
	mw_mirth_token_Token_argsZ_0();
	push_resource(r14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r15 = pop_resource();
	mw_mirth_token_Token_succ();
	push_resource(r15);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_elab_resolveZ_defZ_beginZBang (void) {
	VAL v0 = (lpop(&lbl_ignoreZ_lastZ_name));
	incref(v0);
	lpush(&lbl_ignoreZ_lastZ_name, v0);
	if (VBOOL(v0)) {
		VAL v1 = (lpop(&lbl_token));
		incref(v1);
		push_value(v1);
		lpush(&lbl_token, v1);
		mw_mirth_token_Token_penultimateZ_nameZAsk();
	} else {
		VAL v2 = (lpop(&lbl_token));
		incref(v2);
		push_value(v2);
		lpush(&lbl_token, v2);
		mw_mirth_token_Token_lastZ_nameZAsk();
	}
	mw_std_maybe_Maybe_1_unwrap();
	mw_mirth_name_Name_defs();
	VAL v3 = pop_value();
	uint64_t v4 = (0LL /* Nil */);
	lpush(&lbl_candidates, v3);
	lpush(&lbl_rejected, MKU64(v4));
	mtw_mirth_elab_ZPlusResolveDef_ZPlusResolveDef();
}
static void mw_mirth_elab_resolveZ_defZ_endZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown();
			uint64_t v0 = (0LL /* None */);
			push_u64(v0);
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			switch (get_top_data_tag()) {
				case 0LL: { // Nil
					(void)pop_u64();
					mw_mirth_elab_ZPlusResolveDef_rdrop();
					mtw_std_maybe_Maybe_1_Some();
				} break;
				default: {
					uint64_t v1 = (0LL /* Nil */);
					push_u64(v1);
					mw_std_list_List_1_reverse();
					mtw_std_list_ZPlusList_1_ZPlusList();
					mw_std_list_List_1_uncons();
					VAL v2 = pop_value();
					VAL v3 = pop_value();
					push_value(v2);
					push_value(v3);
					while(1) {
						VAL v4 = pop_value();
						incref(v4);
						push_value(v4);
						push_value(v4);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v5 = pop_value();
						if (!VBOOL(v5)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v6 = pop_value();
						VAL v7 = pop_value();
						VAL r8 = pop_resource();
						incref(v6);
						VAL v9 = pop_value();
						incref(v9);
						VAL r10 = pop_resource();
						push_value(v9);
						push_value(v6);
						push_value(v9);
						mw_mirth_def_Def_sameZ_resolvedZAsk();
						VAL v11 = pop_value();
						push_resource(r10);
						if (VBOOL(v11)) {
							uint64_t v12 = (0LL /* False */);
							push_u64(v12);
						} else {
							uint64_t v13 = (1LL /* True */);
							push_u64(v13);
						}
						VAL v14 = pop_value();
						push_value(v6);
						if (VBOOL(v14)) {
							mtw_std_maybe_Maybe_1_Some();
						} else {
							VAL v15 = pop_value();
							decref(v15);
							uint64_t v16 = (0LL /* None */);
							push_u64(v16);
						}
						push_resource(r8);
						switch (get_top_data_tag()) {
							case 1LL: { // Some
								mtp_std_maybe_Maybe_1_Some();
								mtp_std_list_ZPlusList_1_ZPlusList();
								mtw_std_list_List_1_Cons();
								mtw_std_list_ZPlusList_1_ZPlusList();
							} break;
							case 0LL: { // None
								(void)pop_u64();
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								mp_primZ_panic();
							}
						}
						push_value(v7);
						mw_std_list_List_1_uncons();
						VAL v17 = pop_value();
						VAL v18 = pop_value();
						push_value(v17);
						push_value(v18);
					}
					VAL v19 = pop_value();
					decref(v19);
					VAL v20 = pop_value();
					decref(v20);
					mtp_std_list_ZPlusList_1_ZPlusList();
					mw_std_list_List_1_reverse();
					switch (get_top_data_tag()) {
						case 0LL: { // Nil
							(void)pop_u64();
							mw_mirth_elab_ZPlusResolveDef_rdrop();
							mtw_std_maybe_Maybe_1_Some();
						} break;
						default: {
							VAL v21 = pop_value();
							decref(v21);
							VAL v22 = pop_value();
							decref(v22);
							mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous();
							uint64_t v23 = (0LL /* None */);
							push_u64(v23);
						} break;
					}
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusResolveDef_rdrop (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +ResolveDef
			mtp_mirth_elab_ZPlusResolveDef_ZPlusResolveDef();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_sort));
	VAL v1 = (lpop(&lbl_token));
	decref(v1);
	decref(v0);
	VAL v2 = (lpop(&lbl_candidates));
	VAL v3 = (lpop(&lbl_rejected));
	decref(v3);
	decref(v2);
	VAL v4 = (lpop(&lbl_reportZ_ambiguousZ_asZ_warning));
	decref(v4);
	VAL v5 = (lpop(&lbl_ignoreZ_lastZ_name));
	decref(v5);
}
static void mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_ambiguous (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("Can't resolve ", 14);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL r1 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		push_resource(r1);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(" due to previous errors. Candidates are:", 40);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(" ", 1);
		VAL r2 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[3];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		push_resource(r2);
		mw_std_list_List_1_uncons();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		push_value(v3);
		push_value(v4);
		while(1) {
			VAL v5 = pop_value();
			incref(v5);
			push_value(v5);
			push_value(v5);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v6 = pop_value();
			if (!VBOOL(v6)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v7 = pop_value();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			push_value(v7);
			push_value(v9);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			VAL r10 = pop_resource();
			VAL r11 = pop_resource();
			mw_mirth_def_Def_qnameZ_hard();
			mw_mirth_name_QName_ZToStr();
			push_resource(r11);
			push_resource(r10);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(", ", 2);
			push_value(v8);
			mw_std_list_List_1_uncons();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			push_value(v12);
			push_value(v13);
		}
		VAL v14 = pop_value();
		decref(v14);
		VAL v15 = pop_value();
		decref(v15);
		VAL v16 = pop_value();
		decref(v16);
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL r17 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang();
		push_resource(r17);
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("Ambiguous ", 10);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL r18 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		push_resource(r18);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(". Can't decide between:", 23);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(" ", 1);
		VAL r19 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[3];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		push_resource(r19);
		mw_std_list_List_1_uncons();
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		push_value(v20);
		push_value(v21);
		while(1) {
			VAL v22 = pop_value();
			incref(v22);
			push_value(v22);
			push_value(v22);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v23 = pop_value();
			if (!VBOOL(v23)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			push_value(v24);
			push_value(v26);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			VAL r27 = pop_resource();
			VAL r28 = pop_resource();
			mw_mirth_def_Def_qnameZ_hard();
			mw_mirth_name_QName_ZToStr();
			push_resource(r28);
			push_resource(r27);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(", ", 2);
			push_value(v25);
			mw_std_list_List_1_uncons();
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			push_value(v29);
			push_value(v30);
		}
		VAL v31 = pop_value();
		decref(v31);
		VAL v32 = pop_value();
		decref(v32);
		VAL v33 = pop_value();
		decref(v33);
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL r34 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		push_resource(r34);
	}
	mw_mirth_elab_ZPlusResolveDef_rdrop();
}
static void mw_mirth_elab_ZPlusResolveDef_resolveZ_defZ_unknown (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	VAL r0 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r0);
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			STRLIT("Unknown ", 8);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			VAL r1 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			push_resource(r1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(" name, possibly a misspelling.", 30);
			mw_std_str_ZPlusStr_pushZ_strZBang();
		} break;
		case 1LL: { // Cons
			mtp_std_list_List_1_Cons();
			switch (get_top_data_tag()) {
				case 0LL: { // Nil
					(void)pop_u64();
					switch (get_top_data_tag()) {
						case 0LL: { // RD_WRONG_SORT
							mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT();
							STRLIT("Expected a ", 11);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r2 = pop_resource();
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[1];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							push_resource(r2);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							STRLIT(", but ", 6);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r3 = pop_resource();
							VAL r4 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							mw_mirth_name_QName_ZToStr();
							push_resource(r4);
							push_resource(r3);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							STRLIT(" is not a ", 10);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r5 = pop_resource();
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[1];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							push_resource(r5);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							STRLIT(".", 1);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						case 2LL: { // RD_NOT_VISIBLE
							mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE();
							STRLIT("Not visible in current scope: ", 30);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r6 = pop_resource();
							VAL r7 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							mw_mirth_name_QName_ZToStr();
							push_resource(r7);
							push_resource(r6);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						case 3LL: { // RD_NOT_IMPORTED
							mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED();
							STRLIT("Not imported in current scope: ", 31);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r8 = pop_resource();
							VAL r9 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							mw_mirth_name_QName_ZToStr();
							push_resource(r9);
							push_resource(r8);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						case 1LL: { // RD_WRONG_ARITY
							mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY();
							VAL r10 = pop_resource();
							VAL r11 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							VAL v12 = pop_value();
							incref(v12);
							push_value(v12);
							push_value(v12);
							mw_mirth_name_QName_ZToStr();
							push_resource(r11);
							push_resource(r10);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							STRLIT(" expects ", 9);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							{
								VAL v = pop_value();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 4, v);
								VAL* p = &VTUP(v)->cells[3];
								VAL u = *p;
								incref(u);
								decref(v);
								push_value(u);
							}
							mp_primZ_intZ_toZ_str();
							mw_std_str_ZPlusStr_pushZ_strZBang();
							STRLIT(" arguments, but got ", 20);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r13 = pop_resource();
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[2];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							push_resource(r13);
							mw_mirth_token_Token_numZ_args();
							mp_primZ_intZ_toZ_str();
							mw_std_str_ZPlusStr_pushZ_strZBang();
							STRLIT(".", 1);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						case 4LL: { // RD_WRONG_QUALIFIER
							mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER();
							STRLIT("Qualified name not found. Perhaps you meant: ", 45);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r14 = pop_resource();
							VAL r15 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							mw_mirth_name_QName_ZToStr();
							push_resource(r15);
							push_resource(r14);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						case 5LL: { // RD_WRONG_CONSTRUCTOR
							mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR();
							STRLIT("Constructor is for a different type: ", 37);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r16 = pop_resource();
							VAL r17 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							mw_mirth_name_QName_ZToStr();
							push_resource(r17);
							push_resource(r16);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						case 7LL: { // RD_METHOD_WRONG_TYPE
							mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE();
							STRLIT("Method is for a different type: ", 32);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r18 = pop_resource();
							VAL r19 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							mw_mirth_name_QName_ZToStr();
							push_resource(r19);
							push_resource(r18);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						case 6LL: { // RD_METHOD_NOT_AVAILABLE
							mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE();
							STRLIT("Method is not available for current stack: ", 43);
							mw_std_str_ZPlusStr_pushZ_strZBang();
							VAL r20 = pop_resource();
							VAL r21 = pop_resource();
							mw_mirth_def_Def_qnameZ_hard();
							mw_mirth_name_QName_ZToStr();
							push_resource(r21);
							push_resource(r20);
							mw_std_str_ZPlusStr_pushZ_strZBang();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					mtw_std_list_List_1_Cons();
					STRLIT("Multiple definitions for name, but none are suitable:", 53);
					mw_std_str_ZPlusStr_pushZ_strZBang();
					VAL v22 = pop_value();
					STRLIT(" ", 1);
					push_value(v22);
					mw_std_list_List_1_uncons();
					VAL v23 = pop_value();
					VAL v24 = pop_value();
					push_value(v23);
					push_value(v24);
					while(1) {
						VAL v25 = pop_value();
						incref(v25);
						push_value(v25);
						push_value(v25);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v26 = pop_value();
						if (!VBOOL(v26)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v27 = pop_value();
						VAL v28 = pop_value();
						VAL v29 = pop_value();
						push_value(v27);
						push_value(v29);
						mw_std_str_ZPlusStr_pushZ_strZBang();
						switch (get_top_data_tag()) {
							case 0LL: { // RD_WRONG_SORT
								mtp_mirth_elab_RejectedDef_RDz_WRONGz_SORT();
								VAL r30 = pop_resource();
								VAL r31 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								mw_mirth_name_QName_ZToStr();
								push_resource(r31);
								push_resource(r30);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" is not a ", 10);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								VAL r32 = pop_resource();
								{
									VAL v = pop_resource();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 7, v);
									VAL* p = &VTUP(v)->cells[1];
									VAL u = *p;
									incref(u);
									push_resource(v);
									push_value(u);
								}
								push_resource(r32);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							case 2LL: { // RD_NOT_VISIBLE
								mtp_mirth_elab_RejectedDef_RDz_NOTz_VISIBLE();
								VAL r33 = pop_resource();
								VAL r34 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								mw_mirth_name_QName_ZToStr();
								push_resource(r34);
								push_resource(r33);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" is not visible in current scope", 32);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							case 3LL: { // RD_NOT_IMPORTED
								mtp_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED();
								VAL r35 = pop_resource();
								VAL r36 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								mw_mirth_name_QName_ZToStr();
								push_resource(r36);
								push_resource(r35);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" is not imported in current scope", 33);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							case 1LL: { // RD_WRONG_ARITY
								mtp_mirth_elab_RejectedDef_RDz_WRONGz_ARITY();
								VAL r37 = pop_resource();
								VAL r38 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								VAL v39 = pop_value();
								incref(v39);
								push_value(v39);
								push_value(v39);
								mw_mirth_name_QName_ZToStr();
								push_resource(r38);
								push_resource(r37);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" expects ", 9);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								{
									VAL v = pop_value();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 4, v);
									VAL* p = &VTUP(v)->cells[3];
									VAL u = *p;
									incref(u);
									decref(v);
									push_value(u);
								}
								mp_primZ_intZ_toZ_str();
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" arguments", 10);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							case 4LL: { // RD_WRONG_QUALIFIER
								mtp_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER();
								VAL r40 = pop_resource();
								VAL r41 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								mw_mirth_name_QName_ZToStr();
								push_resource(r41);
								push_resource(r40);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" doesn't match the given qualified name", 39);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							case 5LL: { // RD_WRONG_CONSTRUCTOR
								mtp_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR();
								VAL r42 = pop_resource();
								VAL r43 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								mw_mirth_name_QName_ZToStr();
								push_resource(r43);
								push_resource(r42);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" is constructor for a different type", 36);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							case 7LL: { // RD_METHOD_WRONG_TYPE
								mtp_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE();
								VAL r44 = pop_resource();
								VAL r45 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								mw_mirth_name_QName_ZToStr();
								push_resource(r45);
								push_resource(r44);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" is method for a different type", 31);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							case 6LL: { // RD_METHOD_NOT_AVAILABLE
								mtp_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE();
								VAL r46 = pop_resource();
								VAL r47 = pop_resource();
								mw_mirth_def_Def_qnameZ_hard();
								mw_mirth_name_QName_ZToStr();
								push_resource(r47);
								push_resource(r46);
								mw_std_str_ZPlusStr_pushZ_strZBang();
								STRLIT(" is not avaliable for current stack", 35);
								mw_std_str_ZPlusStr_pushZ_strZBang();
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								mp_primZ_panic();
							}
						}
						STRLIT(", ", 2);
						push_value(v28);
						mw_std_list_List_1_uncons();
						VAL v48 = pop_value();
						VAL v49 = pop_value();
						push_value(v48);
						push_value(v49);
					}
					VAL v50 = pop_value();
					decref(v50);
					VAL v51 = pop_value();
					decref(v51);
					VAL v52 = pop_value();
					decref(v52);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mtp_std_str_ZPlusStr_ZPlusStr();
	VAL r53 = pop_resource();
	mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
	push_resource(r53);
	mw_mirth_elab_ZPlusResolveDef_rdrop();
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_arity (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_numZ_args();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v0 = (0LL /* Nil */);
	uint64_t v1 = (0LL /* Nil */);
	VAL v2 = pop_value();
	push_u64(v0);
	push_u64(v1);
	push_value(v2);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		incref(v11);
		incref(v7);
		VAL r12 = pop_resource();
		push_value(v11);
		push_value(v7);
		push_value(v11);
		push_value(v7);
		mw_mirth_def_Def_arity();
		push_resource(r12);
		mw_mirth_elab_arityZ_compatibleZAsk();
		VAL v13 = pop_value();
		if (VBOOL(v13)) {
			mtw_std_either_Either_2_Right();
		} else {
			mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY();
			mtw_std_either_Either_2_Left();
		}
		VAL v14 = pop_value();
		push_value(v10);
		push_value(v9);
		push_value(v14);
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				VAL v17 = pop_value();
				push_value(v15);
				push_value(v17);
				mtw_std_list_List_1_Cons();
				push_value(v16);
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				VAL v18 = pop_value();
				VAL v19 = pop_value();
				push_value(v18);
				push_value(v19);
				mtw_std_list_List_1_Cons();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v8);
		mw_std_list_List_1_uncons();
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		push_value(v20);
		push_value(v21);
	}
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	mw_std_list_List_1_reverse();
	push_value(v24);
	mw_std_list_List_1_reverse();
	VAL v25 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r26 = pop_resource();
	mw_std_list_List_1_cat();
	push_resource(r26);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
	}
	push_value(v25);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v27 = pop_value();
	decref(v27);
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[3];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			uint64_t v0 = (0LL /* Nil */);
			uint64_t v1 = (0LL /* Nil */);
			VAL v2 = pop_value();
			push_u64(v0);
			push_u64(v1);
			push_value(v2);
			mw_std_list_List_1_uncons();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			push_value(v3);
			push_value(v4);
			while(1) {
				VAL v5 = pop_value();
				incref(v5);
				push_value(v5);
				push_value(v5);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v6 = pop_value();
				if (!VBOOL(v6)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				incref(v11);
				incref(v7);
				VAL r12 = pop_resource();
				push_value(v11);
				push_value(v7);
				push_value(v11);
				push_value(v7);
				mw_mirth_def_Def_qnameZ_hard();
				push_resource(r12);
				mw_mirth_name_QName_climbZ_upZ_dnameZAsk();
				mw_std_list_List_1_emptyZAsk();
				VAL v13 = pop_value();
				if (VBOOL(v13)) {
					uint64_t v14 = (0LL /* False */);
					push_u64(v14);
				} else {
					uint64_t v15 = (1LL /* True */);
					push_u64(v15);
				}
				VAL v16 = pop_value();
				if (VBOOL(v16)) {
					mtw_std_either_Either_2_Right();
				} else {
					mtw_mirth_elab_RejectedDef_RDz_WRONGz_QUALIFIER();
					mtw_std_either_Either_2_Left();
				}
				VAL v17 = pop_value();
				push_value(v10);
				push_value(v9);
				push_value(v17);
				switch (get_top_data_tag()) {
					case 0LL: { // Left
						mtp_std_either_Either_2_Left();
						VAL v18 = pop_value();
						VAL v19 = pop_value();
						VAL v20 = pop_value();
						push_value(v18);
						push_value(v20);
						mtw_std_list_List_1_Cons();
						push_value(v19);
					} break;
					case 1LL: { // Right
						mtp_std_either_Either_2_Right();
						VAL v21 = pop_value();
						VAL v22 = pop_value();
						push_value(v21);
						push_value(v22);
						mtw_std_list_List_1_Cons();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				push_value(v8);
				mw_std_list_List_1_uncons();
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				push_value(v23);
				push_value(v24);
			}
			VAL v25 = pop_value();
			decref(v25);
			VAL v26 = pop_value();
			decref(v26);
			VAL v27 = pop_value();
			mw_std_list_List_1_reverse();
			push_value(v27);
			mw_std_list_List_1_reverse();
			VAL v28 = pop_value();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r29 = pop_resource();
			mw_std_list_List_1_cat();
			push_resource(r29);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL t = *p; *p = u; decref(t);
			}
			push_value(v28);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[3];
				VAL t = *p; *p = u; decref(t);
			}
			VAL v30 = pop_value();
			decref(v30);
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusResolveDef_filterZ_roots (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			decref(v0);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[3];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			uint64_t v1 = (0LL /* Nil */);
			uint64_t v2 = (0LL /* Nil */);
			VAL v3 = pop_value();
			push_u64(v1);
			push_u64(v2);
			push_value(v3);
			mw_std_list_List_1_uncons();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			push_value(v4);
			push_value(v5);
			while(1) {
				VAL v6 = pop_value();
				incref(v6);
				push_value(v6);
				push_value(v6);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v7 = pop_value();
				if (!VBOOL(v7)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				incref(v12);
				incref(v8);
				VAL r13 = pop_resource();
				push_value(v12);
				push_value(v8);
				push_value(v12);
				push_value(v8);
				mw_mirth_def_Def_qnameZ_hard();
				push_resource(r13);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 4, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				uint64_t v16 = (0LL /* None */);
				push_value(v14);
				push_u64(v16);
				push_value(v15);
				mw_std_list_List_1_uncons();
				VAL v17 = pop_value();
				VAL v18 = pop_value();
				push_value(v17);
				push_value(v18);
				while(1) {
					VAL v19 = pop_value();
					incref(v19);
					push_value(v19);
					push_value(v19);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v20 = pop_value();
					if (!VBOOL(v20)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v21 = pop_value();
					VAL v22 = pop_value();
					VAL v23 = pop_value();
					incref(v21);
					VAL v24 = pop_value();
					incref(v24);
					push_value(v24);
					push_value(v21);
					mw_mirth_name_Namespace_ZEqualZEqual();
					VAL v25 = pop_value();
					push_value(v24);
					push_value(v21);
					if (VBOOL(v25)) {
						mtw_std_maybe_Maybe_1_Some();
					} else {
						VAL v26 = pop_value();
						decref(v26);
						uint64_t v27 = (0LL /* None */);
						push_u64(v27);
					}
					VAL v28 = pop_value();
					push_value(v23);
					push_value(v22);
					push_value(v28);
					switch (get_top_data_tag()) {
						case 0LL: { // None
							(void)pop_u64();
						} break;
						default: {
							VAL v29 = pop_value();
							VAL v30 = pop_value();
							decref(v30);
							VAL v31 = pop_value();
							decref(v31);
							uint64_t v32 = (0LL /* Nil */);
							push_value(v29);
							push_u64(v32);
						} break;
					}
					mw_std_list_List_1_uncons();
					VAL v33 = pop_value();
					VAL v34 = pop_value();
					push_value(v33);
					push_value(v34);
				}
				VAL v35 = pop_value();
				decref(v35);
				VAL v36 = pop_value();
				decref(v36);
				VAL v37 = pop_value();
				VAL v38 = pop_value();
				decref(v38);
				push_value(v37);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v39 = pop_value();
				if (VBOOL(v39)) {
					uint64_t v40 = (1LL /* True */);
					push_u64(v40);
				} else {
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL v41 = pop_value();
					VAL v42 = pop_value();
					incref(v42);
					VAL r43 = pop_resource();
					push_value(v42);
					push_value(v41);
					push_value(v42);
					mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk();
					push_resource(r43);
				}
				VAL v44 = pop_value();
				if (VBOOL(v44)) {
					mtw_std_either_Either_2_Right();
				} else {
					VAL v45 = pop_value();
					incref(v45);
					VAL r46 = pop_resource();
					push_value(v45);
					push_value(v45);
					mw_mirth_def_Def_qnameZ_hard();
					push_resource(r46);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 4, v);
						VAL* p = &VTUP(v)->cells[1];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					switch (get_top_data_tag()) {
						case 3LL: { // NAMESPACE_TYCON
							mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
							VAL v47 = pop_value();
							decref(v47);
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[2];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							mw_mirth_token_Token_nameZAsk();
							mw_std_maybe_Maybe_1_unwrap();
							mw_mirth_name_Name_canZ_beZ_relativeZAsk();
							VAL v48 = pop_value();
							if (VBOOL(v48)) {
								VAL v49 = pop_value();
								VAL v50 = pop_value();
								incref(v50);
								push_value(v50);
								push_value(v49);
								push_value(v50);
								mw_std_list_List_1_emptyZAsk();
								VAL v51 = pop_value();
								if (VBOOL(v51)) {
									mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE();
								} else {
									mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE();
								}
							} else {
								mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED();
							}
						} break;
						default: {
							VAL v52 = pop_value();
							decref(v52);
							mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED();
						} break;
					}
					mtw_std_either_Either_2_Left();
				}
				VAL v53 = pop_value();
				push_value(v11);
				push_value(v10);
				push_value(v53);
				switch (get_top_data_tag()) {
					case 0LL: { // Left
						mtp_std_either_Either_2_Left();
						VAL v54 = pop_value();
						VAL v55 = pop_value();
						VAL v56 = pop_value();
						push_value(v54);
						push_value(v56);
						mtw_std_list_List_1_Cons();
						push_value(v55);
					} break;
					case 1LL: { // Right
						mtp_std_either_Either_2_Right();
						VAL v57 = pop_value();
						VAL v58 = pop_value();
						push_value(v57);
						push_value(v58);
						mtw_std_list_List_1_Cons();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				push_value(v9);
				mw_std_list_List_1_uncons();
				VAL v59 = pop_value();
				VAL v60 = pop_value();
				push_value(v59);
				push_value(v60);
			}
			VAL v61 = pop_value();
			decref(v61);
			VAL v62 = pop_value();
			decref(v62);
			VAL v63 = pop_value();
			mw_std_list_List_1_reverse();
			push_value(v63);
			mw_std_list_List_1_reverse();
			VAL v64 = pop_value();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r65 = pop_resource();
			mw_std_list_List_1_cat();
			push_resource(r65);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL t = *p; *p = u; decref(t);
			}
			push_value(v64);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[3];
				VAL t = *p; *p = u; decref(t);
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v66 = pop_value();
			incref(v66);
			push_value(v66);
			push_value(v66);
			mw_mirth_name_DName_isZ_relativeZAsk();
			VAL v67 = pop_value();
			if (VBOOL(v67)) {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[5];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL v68 = pop_value();
				if (VBOOL(v68)) {
					uint64_t v69 = (0LL /* False */);
					push_u64(v69);
				} else {
					uint64_t v70 = (1LL /* True */);
					push_u64(v70);
				}
			} else {
				uint64_t v71 = (0LL /* False */);
				push_u64(v71);
			}
			VAL v72 = pop_value();
			if (VBOOL(v72)) {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				uint64_t v73 = (0LL /* Nil */);
				uint64_t v74 = (0LL /* Nil */);
				VAL v75 = pop_value();
				push_u64(v73);
				push_u64(v74);
				push_value(v75);
				mw_std_list_List_1_uncons();
				VAL v76 = pop_value();
				VAL v77 = pop_value();
				push_value(v76);
				push_value(v77);
				while(1) {
					VAL v78 = pop_value();
					incref(v78);
					push_value(v78);
					push_value(v78);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v79 = pop_value();
					if (!VBOOL(v79)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v80 = pop_value();
					VAL v81 = pop_value();
					VAL v82 = pop_value();
					VAL v83 = pop_value();
					VAL v84 = pop_value();
					incref(v84);
					incref(v80);
					VAL r85 = pop_resource();
					push_value(v84);
					push_value(v80);
					push_value(v84);
					push_value(v80);
					mw_mirth_def_Def_qnameZ_hard();
					push_resource(r85);
					mw_mirth_name_QName_climbZ_upZ_dnameZAsk();
					uint64_t v86 = (0LL /* None */);
					VAL v87 = pop_value();
					push_u64(v86);
					push_value(v87);
					mw_std_list_List_1_uncons();
					VAL v88 = pop_value();
					VAL v89 = pop_value();
					push_value(v88);
					push_value(v89);
					while(1) {
						VAL v90 = pop_value();
						incref(v90);
						push_value(v90);
						push_value(v90);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v91 = pop_value();
						if (!VBOOL(v91)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v92 = pop_value();
						VAL v93 = pop_value();
						VAL v94 = pop_value();
						incref(v92);
						VAL v95 = pop_value();
						VAL v96 = pop_value();
						VAL v97 = pop_value();
						incref(v97);
						uint64_t v98 = (0LL /* None */);
						push_value(v97);
						push_value(v96);
						push_value(v95);
						push_value(v92);
						push_u64(v98);
						push_value(v97);
						mw_std_list_List_1_uncons();
						VAL v99 = pop_value();
						VAL v100 = pop_value();
						push_value(v99);
						push_value(v100);
						while(1) {
							VAL v101 = pop_value();
							incref(v101);
							push_value(v101);
							push_value(v101);
							mw_std_maybe_Maybe_1_someZAsk();
							VAL v102 = pop_value();
							if (!VBOOL(v102)) break;
							mw_std_maybe_Maybe_1_unwrap();
							VAL v103 = pop_value();
							VAL v104 = pop_value();
							VAL v105 = pop_value();
							incref(v103);
							VAL v106 = pop_value();
							incref(v106);
							push_value(v106);
							push_value(v103);
							mw_mirth_name_Namespace_ZEqualZEqual();
							VAL v107 = pop_value();
							push_value(v106);
							push_value(v103);
							if (VBOOL(v107)) {
								mtw_std_maybe_Maybe_1_Some();
							} else {
								VAL v108 = pop_value();
								decref(v108);
								uint64_t v109 = (0LL /* None */);
								push_u64(v109);
							}
							VAL v110 = pop_value();
							push_value(v105);
							push_value(v104);
							push_value(v110);
							switch (get_top_data_tag()) {
								case 0LL: { // None
									(void)pop_u64();
								} break;
								default: {
									VAL v111 = pop_value();
									VAL v112 = pop_value();
									decref(v112);
									VAL v113 = pop_value();
									decref(v113);
									uint64_t v114 = (0LL /* Nil */);
									push_value(v111);
									push_u64(v114);
								} break;
							}
							mw_std_list_List_1_uncons();
							VAL v115 = pop_value();
							VAL v116 = pop_value();
							push_value(v115);
							push_value(v116);
						}
						VAL v117 = pop_value();
						decref(v117);
						VAL v118 = pop_value();
						decref(v118);
						VAL v119 = pop_value();
						VAL v120 = pop_value();
						decref(v120);
						push_value(v119);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v121 = pop_value();
						push_value(v92);
						if (VBOOL(v121)) {
							mtw_std_maybe_Maybe_1_Some();
						} else {
							VAL v122 = pop_value();
							decref(v122);
							uint64_t v123 = (0LL /* None */);
							push_u64(v123);
						}
						VAL v124 = pop_value();
						push_value(v94);
						push_value(v93);
						push_value(v124);
						switch (get_top_data_tag()) {
							case 0LL: { // None
								(void)pop_u64();
							} break;
							default: {
								VAL v125 = pop_value();
								VAL v126 = pop_value();
								decref(v126);
								VAL v127 = pop_value();
								decref(v127);
								uint64_t v128 = (0LL /* Nil */);
								push_value(v125);
								push_u64(v128);
							} break;
						}
						mw_std_list_List_1_uncons();
						VAL v129 = pop_value();
						VAL v130 = pop_value();
						push_value(v129);
						push_value(v130);
					}
					VAL v131 = pop_value();
					decref(v131);
					VAL v132 = pop_value();
					decref(v132);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v133 = pop_value();
					if (VBOOL(v133)) {
						mtw_std_either_Either_2_Right();
					} else {
						VAL v134 = pop_value();
						VAL v135 = pop_value();
						VAL v136 = pop_value();
						incref(v136);
						push_value(v136);
						push_value(v135);
						push_value(v134);
						push_value(v136);
						mw_std_list_List_1_emptyZAsk();
						VAL v137 = pop_value();
						if (VBOOL(v137)) {
							mtw_mirth_elab_RejectedDef_RDz_METHODz_NOTz_AVAILABLE();
						} else {
							mtw_mirth_elab_RejectedDef_RDz_METHODz_WRONGz_TYPE();
						}
						mtw_std_either_Either_2_Left();
					}
					VAL v138 = pop_value();
					push_value(v83);
					push_value(v82);
					push_value(v138);
					switch (get_top_data_tag()) {
						case 0LL: { // Left
							mtp_std_either_Either_2_Left();
							VAL v139 = pop_value();
							VAL v140 = pop_value();
							VAL v141 = pop_value();
							push_value(v139);
							push_value(v141);
							mtw_std_list_List_1_Cons();
							push_value(v140);
						} break;
						case 1LL: { // Right
							mtp_std_either_Either_2_Right();
							VAL v142 = pop_value();
							VAL v143 = pop_value();
							push_value(v142);
							push_value(v143);
							mtw_std_list_List_1_Cons();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					push_value(v81);
					mw_std_list_List_1_uncons();
					VAL v144 = pop_value();
					VAL v145 = pop_value();
					push_value(v144);
					push_value(v145);
				}
				VAL v146 = pop_value();
				decref(v146);
				VAL v147 = pop_value();
				decref(v147);
				VAL v148 = pop_value();
				mw_std_list_List_1_reverse();
				push_value(v148);
				mw_std_list_List_1_reverse();
				VAL v149 = pop_value();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r150 = pop_resource();
				mw_std_list_List_1_cat();
				push_resource(r150);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL t = *p; *p = u; decref(t);
				}
				push_value(v149);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL t = *p; *p = u; decref(t);
				}
			} else {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				uint64_t v151 = (0LL /* Nil */);
				uint64_t v152 = (0LL /* Nil */);
				VAL v153 = pop_value();
				push_u64(v151);
				push_u64(v152);
				push_value(v153);
				mw_std_list_List_1_uncons();
				VAL v154 = pop_value();
				VAL v155 = pop_value();
				push_value(v154);
				push_value(v155);
				while(1) {
					VAL v156 = pop_value();
					incref(v156);
					push_value(v156);
					push_value(v156);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v157 = pop_value();
					if (!VBOOL(v157)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v158 = pop_value();
					VAL v159 = pop_value();
					VAL v160 = pop_value();
					VAL v161 = pop_value();
					VAL v162 = pop_value();
					incref(v162);
					incref(v158);
					VAL r163 = pop_resource();
					push_value(v162);
					push_value(v158);
					push_value(v162);
					push_value(v158);
					mw_mirth_def_Def_qnameZ_hard();
					push_resource(r163);
					mw_mirth_name_QName_climbZ_upZ_dnameZAsk();
					uint64_t v164 = (0LL /* None */);
					VAL v165 = pop_value();
					push_u64(v164);
					push_value(v165);
					mw_std_list_List_1_uncons();
					VAL v166 = pop_value();
					VAL v167 = pop_value();
					push_value(v166);
					push_value(v167);
					while(1) {
						VAL v168 = pop_value();
						incref(v168);
						push_value(v168);
						push_value(v168);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v169 = pop_value();
						if (!VBOOL(v169)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v170 = pop_value();
						VAL v171 = pop_value();
						VAL v172 = pop_value();
						incref(v170);
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 7, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							push_resource(v);
							push_value(u);
						}
						VAL r173 = pop_resource();
						push_value(v170);
						mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk();
						VAL v174 = pop_value();
						push_resource(r173);
						push_value(v170);
						if (VBOOL(v174)) {
							mtw_std_maybe_Maybe_1_Some();
						} else {
							VAL v175 = pop_value();
							decref(v175);
							uint64_t v176 = (0LL /* None */);
							push_u64(v176);
						}
						VAL v177 = pop_value();
						push_value(v172);
						push_value(v171);
						push_value(v177);
						switch (get_top_data_tag()) {
							case 0LL: { // None
								(void)pop_u64();
							} break;
							default: {
								VAL v178 = pop_value();
								VAL v179 = pop_value();
								decref(v179);
								VAL v180 = pop_value();
								decref(v180);
								uint64_t v181 = (0LL /* Nil */);
								push_value(v178);
								push_u64(v181);
							} break;
						}
						mw_std_list_List_1_uncons();
						VAL v182 = pop_value();
						VAL v183 = pop_value();
						push_value(v182);
						push_value(v183);
					}
					VAL v184 = pop_value();
					decref(v184);
					VAL v185 = pop_value();
					decref(v185);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v186 = pop_value();
					if (VBOOL(v186)) {
						mtw_std_either_Either_2_Right();
					} else {
						mtw_mirth_elab_RejectedDef_RDz_NOTz_IMPORTED();
						mtw_std_either_Either_2_Left();
					}
					VAL v187 = pop_value();
					push_value(v161);
					push_value(v160);
					push_value(v187);
					switch (get_top_data_tag()) {
						case 0LL: { // Left
							mtp_std_either_Either_2_Left();
							VAL v188 = pop_value();
							VAL v189 = pop_value();
							VAL v190 = pop_value();
							push_value(v188);
							push_value(v190);
							mtw_std_list_List_1_Cons();
							push_value(v189);
						} break;
						case 1LL: { // Right
							mtp_std_either_Either_2_Right();
							VAL v191 = pop_value();
							VAL v192 = pop_value();
							push_value(v191);
							push_value(v192);
							mtw_std_list_List_1_Cons();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					push_value(v159);
					mw_std_list_List_1_uncons();
					VAL v193 = pop_value();
					VAL v194 = pop_value();
					push_value(v193);
					push_value(v194);
				}
				VAL v195 = pop_value();
				decref(v195);
				VAL v196 = pop_value();
				decref(v196);
				VAL v197 = pop_value();
				mw_std_list_List_1_reverse();
				push_value(v197);
				mw_std_list_List_1_reverse();
				VAL v198 = pop_value();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r199 = pop_resource();
				mw_std_list_List_1_cat();
				push_resource(r199);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL t = *p; *p = u; decref(t);
				}
				push_value(v198);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL t = *p; *p = u; decref(t);
				}
			}
			VAL v200 = pop_value();
			decref(v200);
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v201 = pop_value();
	decref(v201);
}
static void mw_mirth_elab_defZ_isZ_importedZ_atZ_tokenZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_def_Def_qnameZ_hard();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // NAMESPACE_ROOT
			(void)pop_u64();
			VAL v1 = pop_value();
			decref(v1);
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			VAL v4 = pop_value();
			decref(v4);
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (1LL /* True */);
			push_u64(v7);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			decref(v9);
			push_value(v8);
			mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk();
		} break;
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			push_value(v11);
			push_value(v12);
			push_value(v10);
			mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk();
			VAL v13 = pop_value();
			if (VBOOL(v13)) {
				mw_mirth_def_Def_tagZAsk();
				mw_std_maybe_Maybe_1_ZToBool();
			} else {
				VAL v14 = pop_value();
				decref(v14);
				uint64_t v15 = (0LL /* False */);
				push_u64(v15);
			}
		} break;
		case 4LL: { // NAMESPACE_WORD
			mtp_mirth_name_Namespace_NAMESPACEz_WORD();
			VAL v16 = pop_value();
			decref(v16);
			VAL v17 = pop_value();
			decref(v17);
			VAL v18 = pop_value();
			decref(v18);
			uint64_t v19 = (0LL /* False */);
			push_u64(v19);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_tyconZ_isZ_visibleZ_atZ_tokenZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // TYCON_DATA
			mtp_mirth_tycon_Tycon_TYCONz_DATA();
			mw_mirth_data_Data_headZAsk();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_token_Token_module();
					mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v0 = pop_value();
					decref(v0);
					uint64_t v1 = (1LL /* True */);
					push_u64(v1);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 1LL: { // TYCON_TABLE
			mtp_mirth_tycon_Tycon_TYCONz_TABLE();
			mw_mirth_table_Table_head();
			mw_mirth_token_Token_module();
			mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk();
		} break;
		case 2LL: { // TYCON_PRIM
			mtp_mirth_tycon_Tycon_TYCONz_PRIM();
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (1LL /* True */);
			push_u64(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // NAMESPACE_ROOT
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 1LL: { // NAMESPACE_PACKAGE
			mtp_mirth_name_Namespace_NAMESPACEz_PACKAGE();
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (1LL /* True */);
			push_u64(v4);
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk();
		} break;
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			mw_mirth_tycon_Tycon_qnameZ_hard();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 4, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_elab_namespaceZ_isZ_importedZ_atZ_tokenZAsk();
		} break;
		case 4LL: { // NAMESPACE_WORD
			mtp_mirth_name_Namespace_NAMESPACEz_WORD();
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* False */);
			push_u64(v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_name_QName_climbZ_upZ_nameZAsk (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v0);
	lpush(&lbl_name, v1);
	push_value(v0);
	lpush(&lbl_qname, v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v2 = (lpop(&lbl_name));
	incref(v2);
	push_value(v2);
	lpush(&lbl_name, v2);
	mw_mirth_name_Name_ZEqualZEqual();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = (lpop(&lbl_qname));
		incref(v4);
		push_value(v4);
		lpush(&lbl_qname, v4);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 4, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		uint64_t v5 = (0LL /* Nil */);
		push_u64(v5);
		mtw_std_list_List_1_Cons();
	} else {
		uint64_t v6 = (0LL /* Nil */);
		push_u64(v6);
	}
	VAL v7 = pop_value();
	VAL v8 = (lpop(&lbl_name));
	lpush(&lbl_accum, v7);
	push_value(v8);
	mw_mirth_name_Name_defs();
	mw_std_list_List_1_uncons();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	while(1) {
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		push_value(v11);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v12 = pop_value();
		if (!VBOOL(v12)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		push_value(v13);
		switch (get_top_data_tag()) {
			case 0LL: { // DefAlias
				mtp_mirth_def_Def_DefAlias();
				VAL v15 = pop_value();
				incref(v15);
				push_value(v15);
				push_value(v15);
				mw_mirth_alias_Alias_target();
				mw_mirth_def_Def_qnameZ_hard();
				VAL v16 = (lpop(&lbl_qname));
				incref(v16);
				push_value(v16);
				lpush(&lbl_qname, v16);
				mw_mirth_name_QName_ZEqualZEqual();
				VAL v17 = pop_value();
				if (VBOOL(v17)) {
					mw_mirth_alias_Alias_namespaceZ_hard();
					VAL v18 = (lpop(&lbl_accum));
					push_value(v18);
					mtw_std_list_List_1_Cons();
					VAL v19 = pop_value();
					lpush(&lbl_accum, v19);
				} else {
					VAL v20 = pop_value();
					decref(v20);
				}
			} break;
			case 5LL: { // DefType
				mtp_mirth_def_Def_DefType();
				VAL v21 = pop_value();
				incref(v21);
				push_value(v21);
				push_value(v21);
				mw_mirth_typedef_TypeDef_target();
				mw_mirth_type_Type_tyconZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mw_mirth_tycon_Tycon_qnameZ_hard();
						VAL v22 = (lpop(&lbl_qname));
						incref(v22);
						push_value(v22);
						lpush(&lbl_qname, v22);
						mw_mirth_name_QName_ZEqualZEqual();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						uint64_t v23 = (0LL /* False */);
						push_u64(v23);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				VAL v24 = pop_value();
				if (VBOOL(v24)) {
					mw_mirth_typedef_TypeDef_namespace();
					VAL v25 = (lpop(&lbl_accum));
					push_value(v25);
					mtw_std_list_List_1_Cons();
					VAL v26 = pop_value();
					lpush(&lbl_accum, v26);
				} else {
					VAL v27 = pop_value();
					decref(v27);
				}
			} break;
			default: {
				VAL v28 = pop_value();
				decref(v28);
			} break;
		}
		push_value(v14);
		mw_std_list_List_1_uncons();
		VAL v29 = pop_value();
		VAL v30 = pop_value();
		push_value(v29);
		push_value(v30);
	}
	VAL v31 = pop_value();
	decref(v31);
	VAL v32 = pop_value();
	decref(v32);
	VAL v33 = (lpop(&lbl_qname));
	decref(v33);
	VAL v34 = (lpop(&lbl_accum));
	push_value(v34);
}
static void mw_mirth_name_QName_climbZ_upZ_dnameZAsk (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	mw_mirth_name_DName_rootZAsk();
	mw_std_maybe_Maybe_1_ZToList();
	push_value(v1);
	mw_mirth_name_DName_parts();
	mw_std_list_ListZPlus_1_unsnoc();
	VAL v2 = pop_value();
	mw_std_list_List_1_cat();
	push_value(v2);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = pop_value();
		decref(v4);
		mw_std_list_List_1_unsnoc();
		mw_std_maybe_Maybe_1_unwrap();
	} else {
	}
	VAL r5 = pop_resource();
	push_value(v0);
	mw_mirth_name_QName_climbZ_upZ_nameZAsk();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_resource(r5);
	push_value(v6);
	push_value(v7);
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	while(1) {
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v10);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v11 = pop_value();
		if (!VBOOL(v11)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		uint64_t v15 = (0LL /* Nil */);
		push_value(v12);
		push_value(v14);
		push_u64(v15);
		mw_std_list_List_1_reverse();
		mtw_std_list_ZPlusList_1_ZPlusList();
		mw_std_list_List_1_uncons();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		push_value(v16);
		push_value(v17);
		while(1) {
			VAL v18 = pop_value();
			incref(v18);
			push_value(v18);
			push_value(v18);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v19 = pop_value();
			if (!VBOOL(v19)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v20 = pop_value();
			VAL v21 = pop_value();
			VAL r22 = pop_resource();
			VAL r23 = pop_resource();
			push_value(v20);
			mw_mirth_name_Namespace_qname();
			push_resource(r23);
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					incref(v25);
					VAL r26 = pop_resource();
					push_value(v25);
					push_value(v25);
					push_value(v24);
					mw_mirth_name_QName_climbZ_upZ_nameZAsk();
					push_resource(r26);
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v27 = (0LL /* Nil */);
					push_u64(v27);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			push_resource(r22);
			mw_std_list_List_1_uncons();
			VAL v28 = pop_value();
			VAL v29 = pop_value();
			push_value(v28);
			push_value(v29);
			while(1) {
				VAL v30 = pop_value();
				incref(v30);
				push_value(v30);
				push_value(v30);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v31 = pop_value();
				if (!VBOOL(v31)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v32 = pop_value();
				VAL v33 = pop_value();
				push_value(v32);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
				push_value(v33);
				mw_std_list_List_1_uncons();
				VAL v34 = pop_value();
				VAL v35 = pop_value();
				push_value(v34);
				push_value(v35);
			}
			VAL v36 = pop_value();
			decref(v36);
			VAL v37 = pop_value();
			decref(v37);
			push_value(v21);
			mw_std_list_List_1_uncons();
			VAL v38 = pop_value();
			VAL v39 = pop_value();
			push_value(v38);
			push_value(v39);
		}
		VAL v40 = pop_value();
		decref(v40);
		VAL v41 = pop_value();
		decref(v41);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mw_std_list_List_1_reverse();
		VAL v42 = pop_value();
		VAL v43 = pop_value();
		decref(v43);
		push_value(v42);
		push_value(v13);
		mw_std_list_List_1_uncons();
		VAL v44 = pop_value();
		VAL v45 = pop_value();
		push_value(v44);
		push_value(v45);
	}
	VAL v46 = pop_value();
	decref(v46);
	VAL v47 = pop_value();
	decref(v47);
}
static void mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang (void) {
	uint64_t v0 = (0LL /* False */);
	uint64_t v1 = (0LL /* False */);
	lpush(&lbl_reportZ_ambiguousZ_asZ_warning, MKU64(v0));
	lpush(&lbl_ignoreZ_lastZ_name, MKU64(v1));
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	lpush(&lbl_token, v2);
	STRLIT("type", 4);
	VAL v3 = pop_value();
	VAL r4 = pop_resource();
	lpush(&lbl_sort, v3);
	mw_mirth_elab_resolveZ_defZ_beginZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v5 = (0LL /* Nil */);
	uint64_t v6 = (0LL /* Nil */);
	VAL v7 = pop_value();
	push_u64(v5);
	push_u64(v6);
	push_value(v7);
	mw_std_list_List_1_uncons();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	while(1) {
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v10);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v11 = pop_value();
		if (!VBOOL(v11)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		incref(v12);
		VAL r16 = pop_resource();
		push_value(v12);
		push_value(v12);
		mw_mirth_def_Def_definesZ_aZ_typeZAsk();
		VAL v17 = pop_value();
		push_resource(r16);
		if (VBOOL(v17)) {
			mtw_std_either_Either_2_Right();
		} else {
			mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT();
			mtw_std_either_Either_2_Left();
		}
		VAL v18 = pop_value();
		push_value(v15);
		push_value(v14);
		push_value(v18);
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				VAL v19 = pop_value();
				VAL v20 = pop_value();
				VAL v21 = pop_value();
				push_value(v19);
				push_value(v21);
				mtw_std_list_List_1_Cons();
				push_value(v20);
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				push_value(v22);
				push_value(v23);
				mtw_std_list_List_1_Cons();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v13);
		mw_std_list_List_1_uncons();
		VAL v24 = pop_value();
		VAL v25 = pop_value();
		push_value(v24);
		push_value(v25);
	}
	VAL v26 = pop_value();
	decref(v26);
	VAL v27 = pop_value();
	decref(v27);
	VAL v28 = pop_value();
	mw_std_list_List_1_reverse();
	push_value(v28);
	mw_std_list_List_1_reverse();
	VAL v29 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r30 = pop_resource();
	mw_std_list_List_1_cat();
	push_resource(r30);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
	}
	push_value(v29);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_elab_ZPlusResolveDef_filterZ_arity();
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers();
	uint64_t v31 = (0LL /* Nil */);
	push_u64(v31);
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots();
	mw_mirth_elab_resolveZ_defZ_endZBang();
	push_resource(r4);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			switch (get_top_data_tag()) {
				case 3LL: { // DefData
					mtp_mirth_def_Def_DefData();
					mtw_mirth_type_Type_TData();
				} break;
				case 4LL: { // DefTable
					mtp_mirth_def_Def_DefTable();
					mtw_mirth_type_Type_TTable();
				} break;
				case 5LL: { // DefType
					mtp_mirth_def_Def_DefType();
					VAL r32 = pop_resource();
					mw_mirth_typedef_TypeDef_target();
					push_resource(r32);
				} break;
				default: {
					VAL v33 = pop_value();
					decref(v33);
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 5, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					STRLIT("compiler bug: resolve-type-con-name! doesn't understand type", 60);
					VAL r34 = pop_resource();
					mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
					uint64_t v35 = (0LL /* TYPE_ERROR */);
					push_resource(r34);
					push_u64(v35);
				} break;
			}
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v36 = (0LL /* None */);
			push_u64(v36);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v37 = (0LL /* TYPE_ERROR */);
			push_u64(v37);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_ZToStr();
			STRLIT("Mut", 3);
			mp_primZ_strZ_cmp();
			int64_t v0 = (0LL);
			VAL v1 = pop_value();
			incref(v1);
			bool v2 = (VI64(v1) == v0);
			push_value(v1);
			push_i64(v0);
			if (v2) {
				VAL v3 = pop_value();
				decref(v3);
				VAL v4 = pop_value();
				decref(v4);
				uint64_t v5 = (1LL /* EQ */);
				push_u64(v5);
			} else {
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				bool v8 = (VI64(v7) < VI64(v6));
				if (v8) {
					uint64_t v9 = (0LL /* LT */);
					push_u64(v9);
				} else {
					uint64_t v10 = (2LL /* GT */);
					push_u64(v10);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v11 = (0LL /* False */);
					push_u64(v11);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v12 = (1LL /* True */);
					push_u64(v12);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v13 = (0LL /* False */);
					push_u64(v13);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v14 = (0LL /* False */);
			push_u64(v14);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v15 = pop_value();
	if (VBOOL(v15)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		mw_mirth_token_Token_next();
		VAL v16 = pop_value();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r17 = pop_resource();
		mw_mirth_token_Token_argsZ_1();
		push_resource(r17);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang();
		mtw_mirth_type_Type_TMut();
		push_value(v16);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
	} else {
		mw_mirth_elab_ZPlusTypeElab_resolveZ_typeZ_conZ_nameZBang();
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r18 = pop_resource();
		mw_mirth_token_Token_next();
		push_resource(r18);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_resourceZ_conZBang (void) {
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_conZBang();
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argsZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_hasZ_argsZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL v1 = pop_value();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		mw_mirth_token_Token_args();
		mw_std_list_List_1_uncons();
		VAL v2 = pop_value();
		VAL v3 = pop_value();
		push_value(v2);
		push_value(v3);
		while(1) {
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v5 = pop_value();
			if (!VBOOL(v5)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			push_value(v6);
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL t = *p; *p = u; decref(t);
			}
			mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang();
			mtw_mirth_type_Type_TApp();
			push_value(v7);
			mw_std_list_List_1_uncons();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			push_value(v8);
			push_value(v9);
		}
		VAL v10 = pop_value();
		decref(v10);
		VAL v11 = pop_value();
		decref(v11);
		push_value(v1);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
	} else {
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_holeZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r1 = pop_resource();
		mw_mirth_token_Token_argsZ_0();
		push_resource(r1);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		mw_mirth_token_Token_nameZAsk();
		mw_std_maybe_Maybe_1_unwrap();
		mtw_mirth_type_Type_THole();
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("type holes are not allowed here", 31);
		VAL r2 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		uint64_t v3 = (0LL /* TYPE_ERROR */);
		push_resource(r2);
		push_u64(v3);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r4 = pop_resource();
	mw_mirth_token_Token_next();
	push_resource(r4);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_dontZ_careZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r1 = pop_resource();
		mw_mirth_token_Token_argsZ_0();
		uint64_t v2 = (1LL /* TYPE_DONT_CARE */);
		push_resource(r1);
		push_u64(v2);
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 5, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		STRLIT("underscore is not allowed here", 30);
		VAL r3 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		uint64_t v4 = (0LL /* TYPE_ERROR */);
		push_resource(r3);
		push_u64(v4);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r5 = pop_resource();
	mw_mirth_token_Token_next();
	push_resource(r5);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_quoteZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_next();
	VAL v0 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r1 = pop_resource();
	mw_mirth_token_Token_argsZ_1();
	push_resource(r1);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_sigZ_hasZ_dashesZAsk();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang();
		mw_mirth_type_ArrowType_ZToType();
	} else {
		mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang();
		mw_mirth_type_StackType_ZToType();
	}
	push_value(v0);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_elab_elabZ_typeZ_unifyZBang (void) {
	VAL v0 = pop_value();
	lpush(&lbl_token, v0);
	mtw_mirth_type_ZPlusGamma_ZPlusGamma();
	mw_mirth_type_Type_unifyZBang();
	mtp_mirth_type_ZPlusGamma_ZPlusGamma();
	VAL v1 = (lpop(&lbl_token));
	push_value(v1);
}
static void mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang (void) {
	VAL v0 = pop_value();
	lpush(&lbl_token, v0);
	mtw_mirth_type_ZPlusGamma_ZPlusGamma();
	mw_mirth_type_StackType_unifyZBang();
	mtp_mirth_type_ZPlusGamma_ZPlusGamma();
	VAL v1 = (lpop(&lbl_token));
	push_value(v1);
}
static void mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang (void) {
	VAL v0 = pop_value();
	lpush(&lbl_token, v0);
	mw_mirth_var_Ctx0();
	VAL v1 = pop_value();
	uint64_t v2 = (0LL /* False */);
	uint64_t v3 = (0LL /* False */);
	lpush(&lbl_ctx, v1);
	lpush(&lbl_allowZ_typeZ_holes, MKU64(v2));
	lpush(&lbl_allowZ_implicitZ_typeZ_vars, MKU64(v3));
	mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab();
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_argZBang();
	mw_mirth_elab_ZPlusTypeElab_rdrop();
}
static void mw_mirth_elab_abZ_tokenZAt (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_elab_abZ_tokenZBang (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r0 = pop_resource();
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[3];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(8);
			tup->size = 8;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = u;
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
			decref(v);
			push_value(MKTUP(tup,8));
		}
	}
	push_resource(r0);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
}
static void mw_mirth_elab_abZ_typeZAt (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_elab_abZ_typeZBang (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r0 = pop_resource();
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[6];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(8);
			tup->size = 8;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = u;
			tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
			decref(v);
			push_value(MKTUP(tup,8));
		}
	}
	push_resource(r0);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
}
static void mw_mirth_elab_abZ_ctxZAt (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_elab_abZ_homeZAt (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
}
static void mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1 (void) {
	{
		VAL v0 = pop_value();
		VAL var_f = v0;
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mfld_mirth_word_Word_ZTildectxZ_type();
		mw_mirth_mirth_Prop_1_tryZ_forceZBang();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mp_primZ_packZ_uncons();
				VAL v2 = pop_value();
				mp_primZ_packZ_uncons();
				VAL v3 = pop_value();
				VAL v4 = pop_value();
				decref(v4);
				VAL v5 = pop_value();
				incref(v5);
				push_value(v3);
				push_value(v2);
				push_value(v5);
				mw_mirth_word_Word_body();
				push_value(v5);
				mtw_mirth_arrow_Home_HomeWord();
				incref(var_f);
				VAL v6 = (var_f);
				push_value(v6);
				{
					VAL v7 = pop_value();
					VAL var_f = v7;
					VAL v8 = pop_value();
					VAL v9 = pop_value();
					mw_mirth_type_ArrowType_unpack();
					VAL v10 = pop_value();
					VAL v11 = pop_value();
					VAL v12 = pop_value();
					push_value(v10);
					push_value(v12);
					push_value(v11);
					push_value(v9);
					push_value(v8);
					VAL v13 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_homZBang_1_1));
					push_value(v13);
					incref(var_f);
					VAL v14 = (var_f);
					push_value(v14);
					mp_primZ_packZ_cons();
					{
						VAL v15 = pop_value();
						VAL var_f = v15;
						VAL v16 = pop_value();
						VAL v17 = pop_value();
						incref(v17);
						VAL v18 = pop_value();
						incref(v18);
						VAL v19 = pop_value();
						uint64_t v20 = (0LL /* Nil */);
						lpush(&lbl_home, v16);
						lpush(&lbl_tokenZ_start, v17);
						lpush(&lbl_tokenZ_end, v17);
						lpush(&lbl_dom, v18);
						lpush(&lbl_cod, v18);
						lpush(&lbl_ctx, v19);
						lpush(&lbl_atoms, MKU64(v20));
						mtw_mirth_arrow_Arrow_Arrow();
						VAL v21 = pop_value();
						lpush(&lbl_arrow, v21);
						mtw_mirth_elab_ZPlusAB_ZPlusAB();
						incref(var_f);
						run_value(var_f);
						mtp_mirth_elab_ZPlusAB_ZPlusAB();
						VAL v22 = (lpop(&lbl_arrow));
						decref(var_f);
						push_value(v22);
					}
					decref(var_f);
				}
			} break;
			case 0LL: { // None
				(void)pop_u64();
				VAL v23 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1_2));
				push_value(v23);
				incref(var_f);
				VAL v24 = (var_f);
				push_value(v24);
				mp_primZ_packZ_cons();
				{
					VAL v25 = pop_value();
					VAL var_f = v25;
					VAL v26 = pop_value();
					incref(v26);
					push_value(v26);
					incref(var_f);
					run_value(var_f);
					decref(var_f);
					push_value(v26);
				}
				VAL v27 = pop_value();
				VAL v28 = pop_value();
				incref(v28);
				lpush(&lbl_word, v27);
				push_value(v28);
				lpush(&lbl_arrow, v28);
				mw_mirth_arrow_Arrow_ctxZ_type();
				mw_mirth_type_ArrowType_rigidifyZ_sigZBang();
				VAL v29 = pop_value();
				VAL v30 = pop_value();
				incref(v30);
				incref(v29);
				push_value(v30);
				push_value(v29);
				mp_primZ_packZ_nil();
				push_value(v30);
				mp_primZ_packZ_cons();
				push_value(v29);
				mp_primZ_packZ_cons();
				VAL v31 = (lpop(&lbl_word));
				incref(v31);
				push_value(v31);
				lpush(&lbl_word, v31);
				mtw_mirth_mirth_PropLabel_WordType();
				mw_mirth_mirth_PropLabel_prop();
				VAL v32 = (lpop(&lbl_word));
				incref(v32);
				push_value(v32);
				lpush(&lbl_word, v32);
				mfld_mirth_word_Word_ZTildectxZ_type();
				mp_primZ_mutZ_set();
				uint64_t v33 = (0LL /* False */);
				VAL v34 = (lpop(&lbl_word));
				incref(v34);
				push_u64(v33);
				push_value(v34);
				lpush(&lbl_word, v34);
				mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk();
				mp_primZ_mutZ_set();
				VAL v35 = (lpop(&lbl_word));
				decref(v35);
				mw_mirth_type_ArrowType_unpack();
				VAL v36 = (lpop(&lbl_arrow));
				push_value(v36);
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[6];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(8);
						tup->size = 8;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = u;
						tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
						decref(v);
						push_value(MKTUP(tup,8));
					}
				}
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[5];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(8);
						tup->size = 8;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = u;
						tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
						tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
						decref(v);
						push_value(MKTUP(tup,8));
					}
				}
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[4];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(8);
						tup->size = 8;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = u;
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
						tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
						decref(v);
						push_value(MKTUP(tup,8));
					}
				}
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		decref(var_f);
	}
}
static void mw_mirth_elab_guessZ_initialZ_ctxZ_type (void) {
	VAL v0 = pop_value();
	lpush(&lbl_word, v0);
	mw_mirth_var_Ctx0();
	VAL v1 = pop_value();
	lpush(&lbl_ctx, v1);
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v2 = pop_value();
	lpush(&lbl_dom, v2);
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v3 = pop_value();
	VAL v4 = (lpop(&lbl_word));
	incref(v4);
	lpush(&lbl_cod, v3);
	push_value(v4);
	lpush(&lbl_word, v4);
	mw_mirth_word_Word_namespaceZ_hard();
	switch (get_top_data_tag()) {
		case 3LL: { // NAMESPACE_TYCON
			mtp_mirth_name_Namespace_NAMESPACEz_TYCON();
			mw_mirth_tycon_Tycon_fullZ_typeZ_fresh();
			VAL v5 = (lpop(&lbl_word));
			incref(v5);
			push_value(v5);
			lpush(&lbl_word, v5);
			mw_mirth_word_Word_name();
			mw_mirth_name_Name_canZ_beZ_relativeZAsk();
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				VAL v7 = (lpop(&lbl_dom));
				VAL v8 = pop_value();
				push_value(v7);
				push_value(v8);
				mw_mirth_type_TZMulZPlus();
				VAL v9 = pop_value();
				lpush(&lbl_dom, v9);
			} else {
				VAL v10 = (lpop(&lbl_cod));
				VAL v11 = pop_value();
				push_value(v10);
				push_value(v11);
				mw_mirth_type_TZMulZPlus();
				VAL v12 = pop_value();
				lpush(&lbl_cod, v12);
			}
		} break;
		case 2LL: { // NAMESPACE_MODULE
			mtp_mirth_name_Namespace_NAMESPACEz_MODULE();
			VAL v13 = pop_value();
			decref(v13);
			VAL v14 = (lpop(&lbl_word));
			incref(v14);
			push_value(v14);
			lpush(&lbl_word, v14);
			mw_mirth_word_Word_name();
			mw_mirth_name_Name_ZToStr();
			STRLIT("main", 4);
			mp_primZ_strZ_cmp();
			int64_t v15 = (0LL);
			VAL v16 = pop_value();
			incref(v16);
			bool v17 = (VI64(v16) == v15);
			push_value(v16);
			push_i64(v15);
			if (v17) {
				VAL v18 = pop_value();
				decref(v18);
				VAL v19 = pop_value();
				decref(v19);
				uint64_t v20 = (1LL /* EQ */);
				push_u64(v20);
			} else {
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				bool v23 = (VI64(v22) < VI64(v21));
				if (v23) {
					uint64_t v24 = (0LL /* LT */);
					push_u64(v24);
				} else {
					uint64_t v25 = (2LL /* GT */);
					push_u64(v25);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v26 = (0LL /* False */);
					push_u64(v26);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v27 = (1LL /* True */);
					push_u64(v27);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v28 = (0LL /* False */);
					push_u64(v28);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v29 = pop_value();
			if (VBOOL(v29)) {
				mw_mirth_type_T0();
				mw_mirth_type_RESOURCEz_WORLD();
				mw_mirth_type_TZPlus();
				VAL v30 = (lpop(&lbl_dom));
				decref(v30);
				VAL v31 = pop_value();
				lpush(&lbl_dom, v31);
				mw_mirth_type_T0();
				mw_mirth_type_RESOURCEz_WORLD();
				mw_mirth_type_TZPlus();
				VAL v32 = (lpop(&lbl_cod));
				decref(v32);
				VAL v33 = pop_value();
				lpush(&lbl_cod, v33);
			} else {
			}
		} break;
		default: {
			VAL v34 = pop_value();
			decref(v34);
		} break;
	}
	VAL v35 = (lpop(&lbl_word));
	incref(v35);
	push_value(v35);
	lpush(&lbl_word, v35);
	mw_mirth_word_Word_arity();
	mw_std_prim_Int_ZToNat();
	while(1) {
		VAL v36 = pop_value();
		incref(v36);
		int64_t v37 = (0LL);
		bool v38 = (v37 < VI64(v36));
		push_value(v36);
		if (!v38) break;
		VAL v39 = pop_value();
		VAL v40 = (lpop(&lbl_dom));
		push_value(v40);
		mw_mirth_type_MetaVar_newZBang();
		mtw_mirth_type_StackType_STMeta();
		mw_mirth_type_MetaVar_newZBang();
		mtw_mirth_type_StackType_STMeta();
		mw_mirth_type_TZ_ZTo();
		mw_mirth_type_ArrowType_ZToType();
		mw_mirth_type_TZMul();
		VAL v41 = pop_value();
		int64_t v42 = (1LL);
		lpush(&lbl_dom, v41);
		push_value(v39);
		push_i64(v42);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
	}
	VAL v43 = pop_value();
	decref(v43);
	VAL v44 = (lpop(&lbl_ctx));
	VAL v45 = (lpop(&lbl_dom));
	VAL v46 = (lpop(&lbl_cod));
	push_value(v44);
	push_value(v45);
	push_value(v46);
	mw_mirth_type_TZ_ZTo();
	VAL v47 = pop_value();
	VAL v48 = pop_value();
	incref(v48);
	incref(v47);
	push_value(v48);
	push_value(v47);
	mp_primZ_packZ_nil();
	push_value(v48);
	mp_primZ_packZ_cons();
	push_value(v47);
	mp_primZ_packZ_cons();
	VAL v49 = (lpop(&lbl_word));
	incref(v49);
	push_value(v49);
	lpush(&lbl_word, v49);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop();
	VAL v50 = (lpop(&lbl_word));
	incref(v50);
	push_value(v50);
	lpush(&lbl_word, v50);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	uint64_t v51 = (1LL /* True */);
	VAL v52 = (lpop(&lbl_word));
	incref(v52);
	push_u64(v51);
	push_value(v52);
	lpush(&lbl_word, v52);
	mfld_mirth_word_Word_ZTildeinferringZ_typeZAsk();
	mp_primZ_mutZ_set();
	VAL v53 = (lpop(&lbl_word));
	decref(v53);
}
static void mw_mirth_elab_abZ_unifyZ_typeZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_elab_abZ_typeZAt();
	push_value(v0);
	mw_mirth_elab_abZ_tokenZAt();
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	lpush(&lbl_token, v2);
	mtw_mirth_type_ZPlusGamma_ZPlusGamma();
	mw_mirth_type_StackType_unifyZBang();
	mw_mirth_type_ZPlusGamma_rdrop();
	push_resource(r1);
	mw_mirth_elab_abZ_typeZBang();
}
static void mw_mirth_elab_abZ_atomZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_elab_abZ_tokenZBang();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_elab_abZ_typeZBang();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r2 = pop_resource();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	mw_mirth_elab_abZ_optimizzedZ_snocZBang();
	push_value(v3);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[7];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(8);
			tup->size = 8;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = u;
			decref(v);
			push_value(MKTUP(tup,8));
		}
	}
	push_resource(r2);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
}
static void mw_mirth_elab_abZ_optimizzedZ_snocZBang (void) {
	while(1) {
		VAL v0 = pop_value();
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v0);
		push_value(v1);
		mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk();
		VAL v2 = pop_value();
		if (VBOOL(v2)) {
			mw_mirth_elab_atomZ_acceptsZ_argsZAsk();
		} else {
			uint64_t v3 = (0LL /* False */);
			push_u64(v3);
		}
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		push_value(v5);
		push_value(v6);
		mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
	}
	uint64_t v9 = (0LL /* Nil */);
	push_u64(v9);
	mtw_std_list_List_1_Cons();
	mw_std_list_List_1_cat();
}
static void mw_mirth_elab_atomZ_acceptsZ_argsZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v2);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[5];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_std_list_List_1_len();
			push_value(v1);
			mw_mirth_word_Word_arity();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			bool v5 = (VI64(v4) < VI64(v3));
			push_bool(v5);
		} break;
		case 1LL: { // OpPrim
			mtp_mirth_arrow_Op_OpPrim();
			switch (get_top_data_tag()) {
				case 4LL: { // PRIM_CORE_DIP
					(void)pop_u64();
					VAL v6 = pop_value();
					incref(v6);
					push_value(v6);
					push_value(v6);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						VAL* p = &VTUP(v)->cells[5];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mw_std_list_List_1_len();
					int64_t v7 = (1LL);
					push_i64(v7);
					mw_std_prim_Int_ZToNat();
					VAL v8 = pop_value();
					VAL v9 = pop_value();
					bool v10 = (VI64(v9) < VI64(v8));
					push_bool(v10);
				} break;
				case 13LL: { // PRIM_CORE_RDIP
					(void)pop_u64();
					VAL v11 = pop_value();
					incref(v11);
					push_value(v11);
					push_value(v11);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						VAL* p = &VTUP(v)->cells[5];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mw_std_list_List_1_len();
					int64_t v12 = (1LL);
					push_i64(v12);
					mw_std_prim_Int_ZToNat();
					VAL v13 = pop_value();
					VAL v14 = pop_value();
					bool v15 = (VI64(v14) < VI64(v13));
					push_bool(v15);
				} break;
				case 5LL: { // PRIM_CORE_IF
					(void)pop_u64();
					VAL v16 = pop_value();
					incref(v16);
					push_value(v16);
					push_value(v16);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						VAL* p = &VTUP(v)->cells[5];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mw_std_list_List_1_len();
					int64_t v17 = (2LL);
					push_i64(v17);
					mw_std_prim_Int_ZToNat();
					VAL v18 = pop_value();
					VAL v19 = pop_value();
					bool v20 = (VI64(v19) < VI64(v18));
					push_bool(v20);
				} break;
				case 6LL: { // PRIM_CORE_WHILE
					(void)pop_u64();
					VAL v21 = pop_value();
					incref(v21);
					push_value(v21);
					push_value(v21);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						VAL* p = &VTUP(v)->cells[5];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mw_std_list_List_1_len();
					int64_t v22 = (2LL);
					push_i64(v22);
					mw_std_prim_Int_ZToNat();
					VAL v23 = pop_value();
					VAL v24 = pop_value();
					bool v25 = (VI64(v24) < VI64(v23));
					push_bool(v25);
				} break;
				default: {
					VAL v26 = pop_value();
					decref(v26);
					uint64_t v27 = (0LL /* False */);
					push_u64(v27);
				} break;
			}
		} break;
		default: {
			VAL v28 = pop_value();
			decref(v28);
			uint64_t v29 = (0LL /* False */);
			push_u64(v29);
		} break;
	}
}
static void mw_mirth_elab_atomsZ_hasZ_lastZ_blockZAsk (void) {
	mw_std_list_List_1_last();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			switch (get_top_data_tag()) {
				case 14LL: { // OpBlockPush
					mtp_mirth_arrow_Op_OpBlockPush();
					VAL v1 = pop_value();
					decref(v1);
					uint64_t v2 = (1LL /* True */);
					push_u64(v2);
				} break;
				default: {
					VAL v3 = pop_value();
					decref(v3);
					uint64_t v4 = (0LL /* False */);
					push_u64(v4);
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_atomsZ_turnZ_lastZ_blockZ_toZ_arg (void) {
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v0 = (0LL /* Nil */);
			push_u64(v0);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_std_list_ListZPlus_1_unsnoc();
			VAL v1 = pop_value();
			incref(v1);
			push_value(v1);
			push_value(v1);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			switch (get_top_data_tag()) {
				case 14LL: { // OpBlockPush
					mtp_mirth_arrow_Op_OpBlockPush();
					VAL v2 = pop_value();
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						VAL* p = &VTUP(v)->cells[6];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					VAL v3 = pop_value();
					VAL v4 = pop_value();
					VAL v5 = pop_value();
					push_value(v4);
					push_value(v3);
					push_value(v5);
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[6];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(9);
							tup->size = 9;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
							tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
							tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
							tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
							tup->cells[6] = u;
							tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
							tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
							decref(v);
							push_value(MKTUP(tup,9));
						}
					}
					VAL v6 = pop_value();
					incref(v6);
					push_value(v2);
					push_value(v6);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						VAL* p = &VTUP(v)->cells[5];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mtw_std_list_List_1_Cons();
					push_value(v6);
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 9, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[5];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(9);
							tup->size = 9;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
							tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
							tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
							tup->cells[5] = u;
							tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
							tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
							tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
							decref(v);
							push_value(MKTUP(tup,9));
						}
					}
					VAL v7 = pop_value();
					VAL v8 = pop_value();
					push_value(v7);
					push_value(v8);
				} break;
				default: {
					VAL v9 = pop_value();
					decref(v9);
					uint64_t v10 = (0LL /* Nil */);
					push_u64(v10);
					mtw_std_list_List_1_Cons();
					mw_std_list_List_1_cat();
				} break;
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_abZ_opZBang (void) {
	mw_mirth_elab_abZ_ctxZAt();
	VAL v0 = pop_value();
	lpush(&lbl_ctx, v0);
	mw_mirth_elab_abZ_tokenZAt();
	VAL v1 = pop_value();
	lpush(&lbl_token, v1);
	mw_mirth_elab_abZ_homeZAt();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	VAL r4 = pop_resource();
	lpush(&lbl_home, v2);
	push_value(v3);
	lpush(&lbl_op, v3);
	mw_mirth_elab_elabZ_opZ_freshZ_sigZBang();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_resource(r4);
	lpush(&lbl_subst, v6);
	push_value(v5);
	mw_mirth_elab_abZ_expandZ_opsigZBang();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	uint64_t v9 = (0LL /* Nil */);
	lpush(&lbl_cod, v7);
	lpush(&lbl_dom, v8);
	lpush(&lbl_args, MKU64(v9));
	mtw_mirth_arrow_Atom_Atom();
	mw_mirth_elab_abZ_atomZBang();
}
static void mw_mirth_elab_abZ_expandZ_opsigZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // OPSIG_ID
			(void)pop_u64();
			mw_mirth_elab_abZ_typeZAt();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
		} break;
		case 1LL: { // OPSIG_PUSH
			mtp_mirth_elab_OpSig_OPSIGz_PUSH();
			VAL v1 = pop_value();
			mw_mirth_elab_abZ_typeZAt();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v2);
			push_value(v1);
			mtw_mirth_type_StackType_STCons();
		} break;
		case 2LL: { // OPSIG_APPLY
			mtp_mirth_elab_OpSig_OPSIGz_APPLY();
			VAL v3 = pop_value();
			mw_mirth_elab_abZ_typeZAt();
			push_value(v3);
			mw_mirth_type_ArrowType_unpack();
			VAL v4 = pop_value();
			mw_mirth_elab_abZ_tokenZAt();
			VAL r5 = pop_resource();
			mw_mirth_elab_elabZ_stackZ_typeZ_unifyZBang();
			VAL v6 = pop_value();
			decref(v6);
			push_resource(r5);
			push_value(v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_abZ_intZBang (void) {
	mtw_mirth_arrow_Op_OpInt();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_f64ZBang (void) {
	mtw_mirth_arrow_Op_OpF64();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_strZBang (void) {
	mtw_mirth_arrow_Op_OpStr();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_bufferZBang (void) {
	mtw_mirth_arrow_Op_OpBuffer();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_variableZBang (void) {
	mtw_mirth_arrow_Op_OpVariable();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_fieldZBang (void) {
	mtw_mirth_arrow_Op_OpField();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_varZBang (void) {
	mtw_mirth_arrow_Op_OpVar();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_tagZBang (void) {
	mtw_mirth_arrow_Op_OpTag();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_primZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_prim_Prim_ZTildetype();
	mp_primZ_mutZ_isZ_set();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mtw_mirth_arrow_Op_OpPrim();
		mw_mirth_elab_abZ_opZBang();
	} else {
		mw_mirth_elab_abZ_tokenZAt();
		STRLIT("prim does not have type", 23);
		VAL r2 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		push_resource(r2);
	}
}
static void mw_mirth_elab_abZ_wordZBang (void) {
	mtw_mirth_arrow_Op_OpWord();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_externalZBang (void) {
	mtw_mirth_arrow_Op_OpExternal();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_coerceZBang (void) {
	mtw_mirth_arrow_Op_OpCoerce();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_labelZ_pushZBang (void) {
	mtw_mirth_arrow_Op_OpLabelPush();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_labelZ_popZBang (void) {
	mtw_mirth_arrow_Op_OpLabelPop();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_labelZ_pushZ_rZBang (void) {
	mtw_mirth_arrow_Op_OpLabelPushR();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_abZ_labelZ_popZ_rZBang (void) {
	mtw_mirth_arrow_Op_OpLabelPopR();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_elabZ_opZ_freshZ_sigZBang (void) {
	mw_mirth_type_Subst_nil();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	switch (get_top_data_tag()) {
		case 0LL: { // OpNone
			(void)pop_u64();
			uint64_t v2 = (0LL /* OPSIG_ID */);
			push_u64(v2);
		} break;
		case 7LL: { // OpInt
			mtp_mirth_arrow_Op_OpInt();
			mtw_mirth_type_Value_VALUEz_INT();
			mtw_mirth_type_Type_TValue();
			mtw_mirth_elab_OpSig_OPSIGz_PUSH();
		} break;
		case 8LL: { // OpF64
			mtp_mirth_arrow_Op_OpF64();
			mtw_mirth_type_Value_VALUEz_F64();
			mtw_mirth_type_Type_TValue();
			mtw_mirth_elab_OpSig_OPSIGz_PUSH();
		} break;
		case 9LL: { // OpStr
			mtp_mirth_arrow_Op_OpStr();
			mtw_mirth_type_Value_VALUEz_STR();
			mtw_mirth_type_Type_TValue();
			mtw_mirth_elab_OpSig_OPSIGz_PUSH();
		} break;
		case 4LL: { // OpBuffer
			mtp_mirth_arrow_Op_OpBuffer();
			VAL v3 = pop_value();
			decref(v3);
			mw_mirth_type_TYPEz_PTR();
			mtw_mirth_elab_OpSig_OPSIGz_PUSH();
		} break;
		case 5LL: { // OpVariable
			mtp_mirth_arrow_Op_OpVariable();
			mw_mirth_variable_Variable_type();
			mtw_mirth_type_Type_TMut();
			mtw_mirth_elab_OpSig_OPSIGz_PUSH();
		} break;
		case 10LL: { // OpTag
			mtp_mirth_arrow_Op_OpTag();
			mw_mirth_data_Tag_type();
			mw_mirth_type_ArrowType_freshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mw_mirth_word_Word_inferringZ_typeZAsk();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				mw_mirth_word_Word_type();
			} else {
				mw_mirth_word_Word_type();
				mw_mirth_type_ArrowType_freshenZ_sig();
			}
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 1LL: { // OpPrim
			mtp_mirth_arrow_Op_OpPrim();
			mw_mirth_prim_Prim_type();
			mw_mirth_type_ArrowType_freshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 3LL: { // OpExternal
			mtp_mirth_arrow_Op_OpExternal();
			mw_mirth_external_External_type();
			mw_mirth_type_ArrowType_freshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 6LL: { // OpField
			mtp_mirth_arrow_Op_OpField();
			mw_mirth_table_Field_type();
			mw_mirth_type_ArrowType_freshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 14LL: { // OpBlockPush
			mtp_mirth_arrow_Op_OpBlockPush();
			mw_mirth_elab_elabZ_blockZ_sigZBang();
		} break;
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			mw_mirth_arrow_Block_type();
			mw_mirth_type_ArrowType_semifreshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			mw_mirth_elab_elabZ_varZ_sigZBang();
		} break;
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			mw_mirth_elab_elabZ_matchZ_sigZBang();
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			mw_mirth_elab_elabZ_lambdaZ_sigZBang();
		} break;
		case 16LL: { // OpCoerce
			mtp_mirth_arrow_Op_OpCoerce();
			mw_mirth_elab_elabZ_coerceZ_sigZBang();
		} break;
		case 17LL: { // OpLabelPush
			mtp_mirth_arrow_Op_OpLabelPush();
			mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang();
		} break;
		case 18LL: { // OpLabelPop
			mtp_mirth_arrow_Op_OpLabelPop();
			mw_mirth_elab_elabZ_labelZ_popZ_sigZBang();
		} break;
		case 19LL: { // OpLabelPushR
			mtp_mirth_arrow_Op_OpLabelPushR();
			mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang();
		} break;
		case 20LL: { // OpLabelPopR
			mtp_mirth_arrow_Op_OpLabelPopR();
			mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang();
		} break;
		case 21LL: { // OpDataGetTag
			mtp_mirth_arrow_Op_OpDataGetTag();
			mw_mirth_elab_dataZ_getZ_tagZ_type();
			mw_mirth_type_ArrowType_freshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 22LL: { // OpDataGetLabel
			mtp_mirth_arrow_Op_OpDataGetLabel();
			mw_mirth_elab_dataZ_getZ_labelZ_type();
			mw_mirth_type_ArrowType_freshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		case 23LL: { // OpDataSetLabel
			mtp_mirth_arrow_Op_OpDataSetLabel();
			mw_mirth_elab_dataZ_setZ_labelZ_type();
			mw_mirth_type_ArrowType_freshenZ_sig();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_dataZ_getZ_tagZ_type (void) {
	mw_mirth_data_Data_fullZ_type();
	mw_std_either_Either_2_leftZAsk();
	mw_std_maybe_Maybe_1_unwrap();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
}
static void mw_mirth_elab_elabZ_coerceZ_sigZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // CoerceUnsafe
			(void)pop_u64();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_StackType_STMeta();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_Type_TMeta();
			mw_mirth_type_TZMul();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_Type_TMeta();
			mw_mirth_type_TZMul();
			mw_mirth_type_TZ_ZTo();
			mtw_mirth_elab_OpSig_OPSIGz_APPLY();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_blockZ_sigZBang (void) {
	mtw_mirth_type_Value_VALUEz_BLOCK();
	mtw_mirth_type_Type_TValue();
	mtw_mirth_elab_OpSig_OPSIGz_PUSH();
}
static void mw_mirth_elab_elabZ_matchZ_sigZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_type_TZ_ZTo();
	mtw_mirth_elab_OpSig_OPSIGz_APPLY();
}
static void mw_mirth_elab_elabZ_lambdaZ_sigZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v0);
	mw_mirth_arrow_Lambda_cod();
	mw_mirth_type_TZ_ZTo();
	mtw_mirth_elab_OpSig_OPSIGz_APPLY();
}
static void mw_mirth_elab_elabZ_varZ_sigZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_var_Var_autoZ_runZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_var_Var_type();
		mw_mirth_type_Type_morphismZAsk();
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_type_ArrowType_semifreshenZ_sig();
		mtw_mirth_elab_OpSig_OPSIGz_APPLY();
	} else {
		mw_mirth_var_Var_type();
		mtw_mirth_elab_OpSig_OPSIGz_PUSH();
	}
}
static void mw_mirth_elab_elabZ_labelZ_pushZ_sigZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_Type_TMeta();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	incref(v1);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	push_value(v1);
	push_value(v0);
	mtw_mirth_type_StackType_STConsLabel();
	VAL v3 = pop_value();
	mtw_mirth_type_StackType_STCons();
	push_value(v3);
	mw_mirth_type_TZ_ZTo();
	mtw_mirth_elab_OpSig_OPSIGz_APPLY();
}
static void mw_mirth_elab_elabZ_labelZ_popZ_sigZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_Type_TMeta();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	incref(v1);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	push_value(v1);
	push_value(v0);
	mtw_mirth_type_StackType_STConsLabel();
	VAL v3 = pop_value();
	mtw_mirth_type_StackType_STCons();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	mw_mirth_type_TZ_ZTo();
	mtw_mirth_elab_OpSig_OPSIGz_APPLY();
}
static void mw_mirth_elab_elabZ_labelZ_pushZ_rZ_sigZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_Type_TMeta();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	incref(v1);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	push_value(v1);
	push_value(v0);
	mtw_mirth_type_StackType_STWithLabel();
	VAL v3 = pop_value();
	mtw_mirth_type_StackType_STWith();
	push_value(v3);
	mw_mirth_type_TZ_ZTo();
	mtw_mirth_elab_OpSig_OPSIGz_APPLY();
}
static void mw_mirth_elab_elabZ_labelZ_popZ_rZ_sigZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_Type_TMeta();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	incref(v1);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	push_value(v1);
	push_value(v0);
	mtw_mirth_type_StackType_STWithLabel();
	VAL v3 = pop_value();
	mtw_mirth_type_StackType_STWith();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	mw_mirth_type_TZ_ZTo();
	mtw_mirth_elab_OpSig_OPSIGz_APPLY();
}
static void mw_mirth_elab_elabZ_arrowZ_homZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v0);
	mw_mirth_elab_elabZ_arrowZ_fwdZBang();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v3);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v4 = pop_value();
	lpush(&lbl_token, v4);
	mtw_mirth_type_ZPlusGamma_ZPlusGamma();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v5);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v2);
	mw_mirth_type_StackType_unifyZBang();
	mw_mirth_type_ZPlusGamma_rdrop();
	VAL v6 = pop_value();
	decref(v6);
}
static void mw_mirth_elab_elabZ_arrowZ_fwdZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = pop_value();
	uint64_t v4 = (0LL /* Nil */);
	lpush(&lbl_home, v0);
	lpush(&lbl_tokenZ_start, v1);
	lpush(&lbl_tokenZ_end, v1);
	lpush(&lbl_dom, v2);
	lpush(&lbl_cod, v2);
	lpush(&lbl_ctx, v3);
	lpush(&lbl_atoms, MKU64(v4));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v5 = pop_value();
	lpush(&lbl_arrow, v5);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	mw_mirth_elab_elabZ_atomsZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v6 = (lpop(&lbl_arrow));
	push_value(v6);
}
static void mw_mirth_elab_elabZ_atomsZBang (void) {
	while(1) {
		mw_mirth_elab_abZ_tokenZAt();
		mw_mirth_token_Token_runZ_endZAsk();
		VAL v0 = pop_value();
		if (VBOOL(v0)) {
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} else {
			uint64_t v2 = (1LL /* True */);
			push_u64(v2);
		}
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_mirth_elab_elabZ_atomZBang();
		mw_mirth_elab_abZ_tokenZAt();
		mw_mirth_token_Token_next();
		mw_mirth_elab_abZ_tokenZBang();
	}
}
static void mw_mirth_elab_elabZ_atomZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_token_Token_value();
	switch (get_top_data_tag()) {
		case 17LL: { // TokenName
			mtp_mirth_token_TokenValue_TokenName();
			mw_mirth_elab_elabZ_atomZ_nameZBang();
		} break;
		case 18LL: { // TokenDName
			mtp_mirth_token_TokenValue_TokenDName();
			mw_mirth_elab_elabZ_atomZ_dnameZBang();
		} break;
		case 14LL: { // TokenInt
			mtp_mirth_token_TokenValue_TokenInt();
			mw_mirth_elab_abZ_intZBang();
		} break;
		case 16LL: { // TokenStr
			mtp_mirth_token_TokenValue_TokenStr();
			mw_mirth_elab_abZ_strZBang();
		} break;
		case 15LL: { // TokenF64
			mtp_mirth_token_TokenValue_TokenF64();
			mw_mirth_elab_abZ_f64ZBang();
		} break;
		case 8LL: { // TokenLSquare
			mtp_mirth_token_TokenValue_TokenLSquare();
			VAL v0 = pop_value();
			decref(v0);
			mw_mirth_elab_elabZ_atomZ_blockZBang();
		} break;
		case 10LL: { // TokenLCurly
			mtp_mirth_token_TokenValue_TokenLCurly();
			VAL v1 = pop_value();
			decref(v1);
			mw_mirth_elab_elabZ_atomZ_assertZBang();
		} break;
		case 20LL: { // TokenLabelPush
			mtp_mirth_token_TokenValue_TokenLabelPush();
			mw_mirth_elab_abZ_tokenZAt();
			VAL r2 = pop_resource();
			mw_mirth_token_Token_argsZ_0();
			push_resource(r2);
			mw_mirth_elab_abZ_labelZ_pushZBang();
		} break;
		case 19LL: { // TokenLabelPop
			mtp_mirth_token_TokenValue_TokenLabelPop();
			mw_mirth_elab_abZ_tokenZAt();
			VAL r3 = pop_resource();
			mw_mirth_token_Token_argsZ_0();
			push_resource(r3);
			mw_mirth_elab_abZ_labelZ_popZBang();
		} break;
		case 22LL: { // TokenLabelPushR
			mtp_mirth_token_TokenValue_TokenLabelPushR();
			mw_mirth_elab_abZ_tokenZAt();
			VAL r4 = pop_resource();
			mw_mirth_token_Token_argsZ_0();
			push_resource(r4);
			mw_mirth_elab_abZ_labelZ_pushZ_rZBang();
		} break;
		case 21LL: { // TokenLabelPopR
			mtp_mirth_token_TokenValue_TokenLabelPopR();
			mw_mirth_elab_abZ_tokenZAt();
			VAL r5 = pop_resource();
			mw_mirth_token_Token_argsZ_0();
			push_resource(r5);
			mw_mirth_elab_abZ_labelZ_popZ_rZBang();
		} break;
		case 23LL: { // TokenLabelGet
			mtp_mirth_token_TokenValue_TokenLabelGet();
			mw_mirth_elab_elabZ_labelZ_getZBang();
		} break;
		case 24LL: { // TokenLabelSet
			mtp_mirth_token_TokenValue_TokenLabelSet();
			mw_mirth_elab_elabZ_labelZ_setZBang();
		} break;
		default: {
			mw_mirth_elab_abZ_tokenZAt();
			STRLIT("Unexpected token in elab-atom!", 30);
			VAL r6 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			push_resource(r6);
		} break;
	}
}
static void mw_mirth_elab_elabZ_labelZ_getZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_label_Label_isZ_resourceZ_labelZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_elab_abZ_labelZ_popZ_rZBang();
		mw_mirth_elab_abZ_tokenZAt();
		VAL v3 = pop_value();
		incref(v3);
		VAL r4 = pop_resource();
		push_value(v3);
		push_value(v3);
		mw_mirth_token_Token_argsZ_1();
		push_resource(r4);
		mw_mirth_elab_abZ_tokenZBang();
		mw_mirth_elab_elabZ_atomsZBang();
		mw_mirth_elab_abZ_tokenZBang();
		mw_mirth_elab_abZ_labelZ_pushZ_rZBang();
	} else {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_mirth_elab_abZ_labelZ_popZBang();
		mw_mirth_elab_abZ_tokenZAt();
		mw_mirth_token_Token_numZ_args();
		int64_t v6 = (0LL);
		VAL v7 = pop_value();
		bool v8 = (VI64(v7) == v6);
		if (v8) {
			uint64_t v9 = (1LL /* PRIM_CORE_DUP */);
			push_u64(v9);
			mw_mirth_elab_abZ_primZBang();
		} else {
			mw_mirth_elab_abZ_tokenZAt();
			VAL v10 = pop_value();
			incref(v10);
			VAL r11 = pop_resource();
			push_value(v10);
			push_value(v10);
			mw_mirth_token_Token_argsZ_1();
			push_resource(r11);
			mw_mirth_elab_abZ_tokenZBang();
			mw_mirth_elab_elabZ_atomsZBang();
			mw_mirth_elab_abZ_tokenZBang();
		}
		mw_mirth_elab_abZ_labelZ_pushZBang();
	}
}
static void mw_mirth_elab_elabZ_labelZ_setZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	VAL r0 = pop_resource();
	mw_mirth_token_Token_argsZ_0();
	VAL v1 = pop_value();
	incref(v1);
	push_resource(r0);
	push_value(v1);
	push_value(v1);
	mw_mirth_elab_abZ_labelZ_popZBang();
	uint64_t v2 = (2LL /* PRIM_CORE_DROP */);
	push_u64(v2);
	mw_mirth_elab_abZ_primZBang();
	mw_mirth_elab_abZ_labelZ_pushZBang();
}
static void mw_mirth_elab_elabZ_atomZ_blockZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	VAL r0 = pop_resource();
	mw_mirth_token_Token_argsZ_1();
	push_resource(r0);
	mw_mirth_elab_elabZ_blockZ_atZBang();
}
static void mw_mirth_elab_elabZ_blockZ_atZBang (void) {
	mw_mirth_elab_abZ_ctxZAt();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_elab_abZ_homeZAt();
	VAL r2 = pop_resource();
	VAL v3 = (MKFNPTR(&mb_mirth_elab_elabZ_blockZ_atZBang_1));
	push_value(v3);
	mw_mirth_arrow_Block_newZ_deferredZBang_1();
	push_resource(r2);
	mtw_mirth_arrow_Op_OpBlockPush();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_elabZ_argsZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_token_Token_args();
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_elab_elabZ_blockZ_atZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_elab_elabZ_noZ_argsZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	VAL r0 = pop_resource();
	mw_mirth_token_Token_argsZ_0();
	push_resource(r0);
}
static void mw_mirth_elab_arityZ_compatibleZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (-1LL);
	bool v2 = (VI64(v0) == v1);
	VAL v3 = pop_value();
	bool v4 = (VI64(v3) == VI64(v0));
	push_bool(v4);
	if (v2) {
		VAL v5 = pop_value();
		decref(v5);
		uint64_t v6 = (1LL /* True */);
		push_u64(v6);
	} else {
	}
}
static void mw_mirth_elab_elabZ_atomZ_nameZBang (void) {
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_var_Ctx_lookup();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_elab_elabZ_argsZBang();
			mw_mirth_elab_abZ_varZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_atomZ_dnameZBang (void) {
	VAL v0 = pop_value();
	decref(v0);
	mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang();
}
static void mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk (void) {
	mw_mirth_token_Token_value();
	switch (get_top_data_tag()) {
		case 17LL: { // TokenName
			mtp_mirth_token_TokenValue_TokenName();
			mw_mirth_name_Name_canZ_beZ_relativeZAsk();
		} break;
		case 18LL: { // TokenDName
			mtp_mirth_token_TokenValue_TokenDName();
			mw_mirth_name_DName_isZ_relativeZAsk();
		} break;
		default: {
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
	}
}
static void mw_mirth_elab_elabZ_atomZ_resolveZ_defZBang (void) {
	mw_mirth_elab_abZ_typeZAt();
	mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		uint64_t v1 = (0LL /* False */);
		push_u64(v1);
	} else {
		uint64_t v2 = (1LL /* True */);
		push_u64(v2);
	}
	VAL v3 = pop_value();
	lpush(&lbl_reportZ_ambiguousZ_asZ_warning, v3);
	mw_mirth_elab_abZ_tokenZAt();
	VAL v4 = pop_value();
	lpush(&lbl_token, v4);
	STRLIT("word", 4);
	VAL v5 = pop_value();
	uint64_t v6 = (0LL /* False */);
	VAL r7 = pop_resource();
	lpush(&lbl_sort, v5);
	lpush(&lbl_ignoreZ_lastZ_name, MKU64(v6));
	lpush(&lbl_ZPlusab, r7);
	mw_mirth_elab_resolveZ_defZ_beginZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v8 = (0LL /* Nil */);
	uint64_t v9 = (0LL /* Nil */);
	VAL v10 = pop_value();
	push_u64(v8);
	push_u64(v9);
	push_value(v10);
	mw_std_list_List_1_uncons();
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	push_value(v11);
	push_value(v12);
	while(1) {
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v13);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v14 = pop_value();
		if (!VBOOL(v14)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		incref(v15);
		VAL r19 = pop_resource();
		push_value(v15);
		push_value(v15);
		mw_mirth_def_Def_callableZAsk();
		VAL v20 = pop_value();
		push_resource(r19);
		if (VBOOL(v20)) {
			mtw_std_either_Either_2_Right();
		} else {
			mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT();
			mtw_std_either_Either_2_Left();
		}
		VAL v21 = pop_value();
		push_value(v18);
		push_value(v17);
		push_value(v21);
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				VAL v24 = pop_value();
				push_value(v22);
				push_value(v24);
				mtw_std_list_List_1_Cons();
				push_value(v23);
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				push_value(v25);
				push_value(v26);
				mtw_std_list_List_1_Cons();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v16);
		mw_std_list_List_1_uncons();
		VAL v27 = pop_value();
		VAL v28 = pop_value();
		push_value(v27);
		push_value(v28);
	}
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	decref(v30);
	VAL v31 = pop_value();
	mw_std_list_List_1_reverse();
	push_value(v31);
	mw_std_list_List_1_reverse();
	VAL v32 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r33 = pop_resource();
	mw_std_list_List_1_cat();
	push_resource(r33);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
	}
	push_value(v32);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_elab_ZPlusResolveDef_filterZ_arity();
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_canZ_beZ_relativeZ_nameZ_orZ_dnameZAsk();
	VAL v34 = pop_value();
	if (VBOOL(v34)) {
		VAL v35 = (lpop(&lbl_ZPlusab));
		push_resource(v35);
		mw_mirth_elab_abZ_typeZAt();
		VAL r36 = pop_resource();
		lpush(&lbl_ZPlusab, r36);
		mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk();
		VAL v37 = pop_value();
		if (VBOOL(v37)) {
			VAL v38 = (lpop(&lbl_ZPlusab));
			push_resource(v38);
			mw_mirth_elab_abZ_typeZAt();
			VAL r39 = pop_resource();
			lpush(&lbl_ZPlusab, r39);
			mw_mirth_type_StackType_topZ_namespaces();
			mw_mirth_elab_ZPlusResolveDef_filterZ_roots();
		} else {
		}
	} else {
		uint64_t v40 = (0LL /* Nil */);
		push_u64(v40);
		mw_mirth_elab_ZPlusResolveDef_filterZ_roots();
	}
	mw_mirth_elab_resolveZ_defZ_endZBang();
	VAL v41 = (lpop(&lbl_ZPlusab));
	push_resource(v41);
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_elab_elabZ_atomZ_failedZBang();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_elab_elabZ_atomZ_defZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_atomZ_failedZBang (void) {
	uint64_t v0 = (0LL /* STACK_TYPE_ERROR */);
	push_u64(v0);
	mw_mirth_elab_abZ_typeZBang();
}
static void mw_mirth_elab_elabZ_atomZ_defZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			VAL r0 = pop_resource();
			mw_mirth_alias_Alias_target();
			push_resource(r0);
			mw_mirth_elab_elabZ_atomZ_defZBang();
		} break;
		case 9LL: { // DefBuffer
			mtp_mirth_def_Def_DefBuffer();
			mw_mirth_elab_elabZ_noZ_argsZBang();
			mw_mirth_elab_abZ_bufferZBang();
		} break;
		case 10LL: { // DefVariable
			mtp_mirth_def_Def_DefVariable();
			mw_mirth_elab_elabZ_noZ_argsZBang();
			mw_mirth_elab_abZ_variableZBang();
		} break;
		case 11LL: { // DefExternal
			mtp_mirth_def_Def_DefExternal();
			mw_mirth_elab_elabZ_noZ_argsZBang();
			mw_mirth_elab_abZ_externalZBang();
		} break;
		case 12LL: { // DefField
			mtp_mirth_def_Def_DefField();
			mw_mirth_elab_elabZ_noZ_argsZBang();
			mw_mirth_elab_abZ_fieldZBang();
		} break;
		case 8LL: { // DefWord
			mtp_mirth_def_Def_DefWord();
			mw_mirth_elab_elabZ_argsZBang();
			mw_mirth_elab_abZ_wordZBang();
		} break;
		case 6LL: { // DefTag
			mtp_mirth_def_Def_DefTag();
			mw_mirth_elab_elabZ_argsZBang();
			mw_mirth_elab_abZ_tagZBang();
		} break;
		case 7LL: { // DefPrim
			mtp_mirth_def_Def_DefPrim();
			mw_mirth_elab_elabZ_primZBang();
		} break;
		default: {
			VAL r1 = pop_resource();
			mw_mirth_def_Def_qnameZ_hard();
			push_resource(r1);
			mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang();
		} break;
	}
}
static void mw_mirth_elab_elabZ_atomZ_notZ_aZ_wordZBang (void) {
	mw_mirth_elab_abZ_typeZAt();
	mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk();
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		VAL v1 = pop_value();
		mw_mirth_elab_abZ_tokenZAt();
		STRLIT("Not a word: ", 12);
		VAL r2 = pop_resource();
		push_value(v1);
		mw_mirth_name_QName_ZToStr();
		push_resource(r2);
		mp_primZ_strZ_cat();
		VAL r3 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		push_resource(r3);
	} else {
		VAL v4 = pop_value();
		decref(v4);
	}
	mw_mirth_elab_elabZ_atomZ_failedZBang();
}
static void mw_mirth_elab_elabZ_primZBang (void) {
	switch (get_top_data_tag()) {
		case 10LL: { // PRIM_CORE_MATCH
			(void)pop_u64();
			mw_mirth_elab_elabZ_atomZ_matchZBang();
		} break;
		case 11LL: { // PRIM_CORE_LAMBDA
			(void)pop_u64();
			mw_mirth_elab_elabZ_atomZ_lambdaZBang();
		} break;
		default: {
			mw_mirth_elab_elabZ_argsZBang();
			mw_mirth_elab_abZ_primZBang();
		} break;
	}
}
static void mw_mirth_elab_elabZ_atomZ_assertZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	VAL r0 = pop_resource();
	mw_mirth_token_Token_argsZ_1();
	VAL v1 = pop_value();
	push_resource(r0);
	lpush(&lbl_token, v1);
	mw_mirth_elab_abZ_ctxZAt();
	VAL v2 = pop_value();
	uint64_t v3 = (1LL /* True */);
	uint64_t v4 = (0LL /* False */);
	lpush(&lbl_ctx, v2);
	lpush(&lbl_allowZ_typeZ_holes, MKU64(v3));
	lpush(&lbl_allowZ_implicitZ_typeZ_vars, MKU64(v4));
	mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab();
	VAL r5 = pop_resource();
	VAL r6 = pop_resource();
	push_resource(r5);
	mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZBang();
	VAL r7 = pop_resource();
	push_resource(r6);
	push_resource(r7);
	mw_mirth_elab_ZPlusTypeElab_rdrop();
	VAL v8 = pop_value();
	mw_mirth_elab_abZ_typeZAt();
	push_value(v8);
	mw_mirth_elab_abZ_tokenZAt();
	VAL r9 = pop_resource();
	VAL v10 = pop_value();
	lpush(&lbl_token, v10);
	mtw_mirth_type_ZPlusGamma_ZPlusGamma();
	mw_mirth_type_StackType_unifyZBang();
	mw_mirth_type_ZPlusGamma_rdrop();
	VAL v11 = pop_value();
	decref(v11);
	push_resource(r9);
}
static void mw_mirth_elab_elabZ_atomZ_matchZBang (void) {
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v0 = pop_value();
	lpush(&lbl_cod, v0);
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_token_Token_succ();
	mw_mirth_token_Token_lcurlyZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			decref(v1);
			mw_mirth_elab_abZ_tokenZAt();
			mw_mirth_token_Token_succ();
			mw_mirth_token_Token_succ();
			VAL v2 = pop_value();
			lpush(&lbl_body, v2);
			mw_mirth_elab_abZ_tokenZAt();
			mw_mirth_token_Token_succ();
			mw_mirth_elab_abZ_tokenZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_elab_abZ_tokenZAt();
			VAL r3 = pop_resource();
			mw_mirth_token_Token_argsZPlus();
			push_resource(r3);
			mw_std_list_ListZPlus_1_first();
			VAL v4 = pop_value();
			lpush(&lbl_body, v4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_elab_elabZ_matchZ_atZBang();
}
static void mw_mirth_elab_elabZ_matchZ_atZBang (void) {
	mw_mirth_elab_abZ_ctxZAt();
	VAL v0 = pop_value();
	lpush(&lbl_ctx, v0);
	mw_mirth_elab_abZ_typeZAt();
	VAL v1 = pop_value();
	lpush(&lbl_dom, v1);
	mw_mirth_elab_abZ_tokenZAt();
	VAL v2 = pop_value();
	lpush(&lbl_token, v2);
	mw_mirth_elab_abZ_homeZAt();
	VAL v3 = pop_value();
	uint64_t v4 = (0LL /* Nil */);
	VAL r5 = pop_resource();
	lpush(&lbl_home, v3);
	lpush(&lbl_cases, MKU64(v4));
	mtw_mirth_match_ZPlusMatch_ZPlusMatch();
	mw_mirth_elab_elabZ_matchZ_casesZBang();
	mw_mirth_elab_elabZ_matchZ_exhaustiveZBang();
	mw_mirth_match_ZPlusMatch_freezze();
	push_resource(r5);
	mtw_mirth_arrow_Op_OpMatch();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_elabZ_matchZ_casesZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_lcurlyZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			decref(v0);
			mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_matchZ_casesZ_curlyZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_token_Token_runZ_tokens();
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_token_Token_lcurlyZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v6 = pop_value();
				decref(v6);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("Expected a pattern match case of the form { ... -> ... }", 56);
				VAL r7 = pop_resource();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
				push_resource(r7);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL r8 = pop_resource();
		mw_mirth_token_Token_argsZ_1();
		push_resource(r8);
		mw_mirth_elab_elabZ_matchZ_caseZBang();
		VAL v9 = pop_value();
		decref(v9);
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_elab_elabZ_matchZ_casesZ_argsZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	while(1) {
		VAL v0 = pop_value();
		incref(v0);
		push_value(v0);
		push_value(v0);
		mw_mirth_token_Token_argsZ_endZAsk();
		VAL v1 = pop_value();
		if (VBOOL(v1)) {
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} else {
			uint64_t v3 = (1LL /* True */);
			push_u64(v3);
		}
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_mirth_elab_elabZ_matchZ_caseZBang();
	}
	VAL v5 = pop_value();
	decref(v5);
}
static void mw_mirth_elab_elabZ_matchZ_caseZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_runZ_arrowZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Expected pattern match case ... -> ...", 38);
			VAL r1 = pop_resource();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			push_resource(r1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	incref(v2);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	push_value(v2);
	mw_mirth_token_Token_ZEqualZEqual();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
		STRLIT("expected pattern", 16);
		VAL r5 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		push_resource(r5);
	} else {
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	incref(v6);
	push_value(v7);
	push_value(v6);
	push_value(v7);
	push_value(v6);
	mw_mirth_token_Token_prev();
	mw_mirth_token_Token_ZEqualZEqual();
	VAL v8 = pop_value();
	if (VBOOL(v8)) {
	} else {
		STRLIT("multi-part pattern not supported", 32);
		VAL r9 = pop_resource();
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		push_resource(r9);
	}
	VAL v10 = pop_value();
	mw_mirth_token_Token_patZ_tokens();
	incref(v10);
	push_value(v10);
	mw_mirth_token_Token_prev();
	push_value(v10);
	mw_mirth_token_Token_succ();
	VAL v11 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v12 = pop_value();
	VAL v13 = pop_value();
	incref(v13);
	lpush(&lbl_home, v12);
	lpush(&lbl_tokenZ_start, v13);
	lpush(&lbl_tokenZ_end, v13);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v14 = pop_value();
	incref(v14);
	uint64_t v15 = (0LL /* Nil */);
	lpush(&lbl_outerZ_ctx, v14);
	lpush(&lbl_innerZ_ctx, v14);
	lpush(&lbl_saved, MKU64(v15));
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v16 = pop_value();
	incref(v16);
	uint64_t v17 = (0LL /* Nil */);
	lpush(&lbl_mid, v16);
	lpush(&lbl_cod, v16);
	lpush(&lbl_atoms, MKU64(v17));
	mtw_mirth_match_Pattern_Pattern();
	VAL r18 = pop_resource();
	mw_mirth_match_Pattern_thaw();
	mw_mirth_elab_elabZ_patternZBang();
	mw_mirth_match_ZPlusPattern_freezze();
	VAL v19 = pop_value();
	incref(v19);
	push_resource(r18);
	push_value(v11);
	push_value(v19);
	lpush(&lbl_pattern, v19);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v20 = (lpop(&lbl_pattern));
	incref(v20);
	push_value(v20);
	lpush(&lbl_pattern, v20);
	mw_mirth_match_Pattern_dom();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_type_TZ_ZTo();
	VAL v21 = pop_value();
	VAL v22 = pop_value();
	VAL v23 = pop_value();
	push_value(v22);
	push_value(v21);
	push_value(v23);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v24 = (lpop(&lbl_pattern));
	VAL r25 = pop_resource();
	VAL v26 = pop_value();
	VAL v27 = pop_value();
	mw_mirth_type_ArrowType_unpack();
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	VAL v30 = pop_value();
	incref(v27);
	incref(v29);
	uint64_t v31 = (0LL /* Nil */);
	push_value(v28);
	lpush(&lbl_home, v26);
	lpush(&lbl_tokenZ_start, v27);
	lpush(&lbl_tokenZ_end, v27);
	lpush(&lbl_dom, v29);
	lpush(&lbl_cod, v29);
	lpush(&lbl_ctx, v30);
	lpush(&lbl_atoms, MKU64(v31));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v32 = pop_value();
	lpush(&lbl_arrow, v32);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v33 = pop_value();
	mw_mirth_elab_elabZ_atomsZBang();
	mw_mirth_elab_abZ_tokenZAt();
	VAL v34 = pop_value();
	incref(v34);
	push_value(v34);
	push_value(v34);
	mw_mirth_token_Token_commaZAsk();
	VAL v35 = pop_value();
	if (VBOOL(v35)) {
		mw_mirth_token_Token_succ();
	} else {
	}
	push_value(v33);
	mw_mirth_elab_abZ_unifyZ_typeZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v36 = (lpop(&lbl_arrow));
	push_resource(r25);
	lpush(&lbl_pattern, v24);
	lpush(&lbl_body, v36);
	mtw_mirth_match_Case_CASE();
	mw_mirth_match_ZPlusMatch_addZ_case();
}
static void mw_mirth_elab_elabZ_patternZBang (void) {
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_elab_elabZ_patternZ_atomZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_elab_elabZ_patternZ_atomZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r1 = pop_resource();
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(10);
			tup->size = 10;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = u;
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
			tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
			tup->cells[9] = VTUP(v)->cells[9]; incref(tup->cells[9]);
			decref(v);
			push_value(MKTUP(tup,10));
		}
	}
	push_resource(r1);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v2);
	mw_mirth_token_Token_patZ_underscoreZAsk();
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
		VAL v4 = pop_value();
		decref(v4);
		mw_mirth_match_ZPlusPattern_underscoreZBang();
	} else {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v6 = pop_value();
				decref(v6);
				VAL v7 = pop_value();
				lpush(&lbl_token, v7);
				STRLIT("constructor", 11);
				VAL v8 = pop_value();
				lpush(&lbl_sort, v8);
				{
					VAL v = top_resource();
					incref(v);
					push_value(v);
				}
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 10, v);
					VAL* p = &VTUP(v)->cells[7];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk();
				VAL v9 = pop_value();
				if (VBOOL(v9)) {
					uint64_t v10 = (0LL /* False */);
					push_u64(v10);
				} else {
					uint64_t v11 = (1LL /* True */);
					push_u64(v11);
				}
				VAL v12 = pop_value();
				uint64_t v13 = (0LL /* False */);
				VAL r14 = pop_resource();
				lpush(&lbl_reportZ_ambiguousZ_asZ_warning, v12);
				lpush(&lbl_ignoreZ_lastZ_name, MKU64(v13));
				lpush(&lbl_ZPluspat, r14);
				mw_mirth_elab_resolveZ_defZ_beginZBang();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				uint64_t v15 = (0LL /* Nil */);
				uint64_t v16 = (0LL /* Nil */);
				VAL v17 = pop_value();
				push_u64(v15);
				push_u64(v16);
				push_value(v17);
				mw_std_list_List_1_uncons();
				VAL v18 = pop_value();
				VAL v19 = pop_value();
				push_value(v18);
				push_value(v19);
				while(1) {
					VAL v20 = pop_value();
					incref(v20);
					push_value(v20);
					push_value(v20);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v21 = pop_value();
					if (!VBOOL(v21)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v22 = pop_value();
					VAL v23 = pop_value();
					VAL v24 = pop_value();
					VAL v25 = pop_value();
					incref(v22);
					push_value(v22);
					push_value(v22);
					mw_mirth_def_Def_tagZAsk();
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v26 = pop_value();
					if (VBOOL(v26)) {
						mtw_std_either_Either_2_Right();
					} else {
						mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT();
						mtw_std_either_Either_2_Left();
					}
					VAL v27 = pop_value();
					push_value(v25);
					push_value(v24);
					push_value(v27);
					switch (get_top_data_tag()) {
						case 0LL: { // Left
							mtp_std_either_Either_2_Left();
							VAL v28 = pop_value();
							VAL v29 = pop_value();
							VAL v30 = pop_value();
							push_value(v28);
							push_value(v30);
							mtw_std_list_List_1_Cons();
							push_value(v29);
						} break;
						case 1LL: { // Right
							mtp_std_either_Either_2_Right();
							VAL v31 = pop_value();
							VAL v32 = pop_value();
							push_value(v31);
							push_value(v32);
							mtw_std_list_List_1_Cons();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					push_value(v23);
					mw_std_list_List_1_uncons();
					VAL v33 = pop_value();
					VAL v34 = pop_value();
					push_value(v33);
					push_value(v34);
				}
				VAL v35 = pop_value();
				decref(v35);
				VAL v36 = pop_value();
				decref(v36);
				VAL v37 = pop_value();
				mw_std_list_List_1_reverse();
				push_value(v37);
				mw_std_list_List_1_reverse();
				VAL v38 = pop_value();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r39 = pop_resource();
				mw_std_list_List_1_cat();
				push_resource(r39);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL t = *p; *p = u; decref(t);
				}
				push_value(v38);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[3];
					VAL t = *p; *p = u; decref(t);
				}
				mw_mirth_elab_ZPlusResolveDef_filterZ_arity();
				mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers();
				VAL v40 = (lpop(&lbl_ZPluspat));
				push_resource(v40);
				{
					VAL v = top_resource();
					incref(v);
					push_value(v);
				}
				VAL r41 = pop_resource();
				lpush(&lbl_ZPluspat, r41);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 10, v);
					VAL* p = &VTUP(v)->cells[7];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_type_StackType_topZ_typesZ_areZ_fineZAsk();
				VAL v42 = pop_value();
				if (VBOOL(v42)) {
					VAL v43 = (lpop(&lbl_ZPluspat));
					push_resource(v43);
					{
						VAL v = top_resource();
						incref(v);
						push_value(v);
					}
					VAL r44 = pop_resource();
					lpush(&lbl_ZPluspat, r44);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 10, v);
						VAL* p = &VTUP(v)->cells[7];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mw_mirth_type_StackType_topZ_namespaces();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					mw_mirth_token_Token_nameZAsk();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v45 = pop_value();
							decref(v45);
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[3];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							uint64_t v46 = (0LL /* Nil */);
							uint64_t v47 = (0LL /* Nil */);
							VAL v48 = pop_value();
							push_u64(v46);
							push_u64(v47);
							push_value(v48);
							mw_std_list_List_1_uncons();
							VAL v49 = pop_value();
							VAL v50 = pop_value();
							push_value(v49);
							push_value(v50);
							while(1) {
								VAL v51 = pop_value();
								incref(v51);
								push_value(v51);
								push_value(v51);
								mw_std_maybe_Maybe_1_someZAsk();
								VAL v52 = pop_value();
								if (!VBOOL(v52)) break;
								mw_std_maybe_Maybe_1_unwrap();
								VAL v53 = pop_value();
								VAL v54 = pop_value();
								VAL v55 = pop_value();
								VAL v56 = pop_value();
								VAL v57 = pop_value();
								incref(v57);
								incref(v53);
								VAL r58 = pop_resource();
								push_value(v57);
								push_value(v53);
								push_value(v57);
								push_value(v53);
								mw_mirth_def_Def_qnameZ_hard();
								push_resource(r58);
								{
									VAL v = pop_value();
									ASSERT1(IS_TUP(v), v);
									ASSERT1(VTUPLEN(v) == 4, v);
									VAL* p = &VTUP(v)->cells[1];
									VAL u = *p;
									incref(u);
									decref(v);
									push_value(u);
								}
								VAL v59 = pop_value();
								VAL v60 = pop_value();
								uint64_t v61 = (0LL /* None */);
								push_value(v59);
								push_u64(v61);
								push_value(v60);
								mw_std_list_List_1_uncons();
								VAL v62 = pop_value();
								VAL v63 = pop_value();
								push_value(v62);
								push_value(v63);
								while(1) {
									VAL v64 = pop_value();
									incref(v64);
									push_value(v64);
									push_value(v64);
									mw_std_maybe_Maybe_1_someZAsk();
									VAL v65 = pop_value();
									if (!VBOOL(v65)) break;
									mw_std_maybe_Maybe_1_unwrap();
									VAL v66 = pop_value();
									VAL v67 = pop_value();
									VAL v68 = pop_value();
									incref(v66);
									VAL v69 = pop_value();
									incref(v69);
									push_value(v69);
									push_value(v66);
									mw_mirth_name_Namespace_ZEqualZEqual();
									VAL v70 = pop_value();
									push_value(v69);
									push_value(v66);
									if (VBOOL(v70)) {
										mtw_std_maybe_Maybe_1_Some();
									} else {
										VAL v71 = pop_value();
										decref(v71);
										uint64_t v72 = (0LL /* None */);
										push_u64(v72);
									}
									VAL v73 = pop_value();
									push_value(v68);
									push_value(v67);
									push_value(v73);
									switch (get_top_data_tag()) {
										case 0LL: { // None
											(void)pop_u64();
										} break;
										default: {
											VAL v74 = pop_value();
											VAL v75 = pop_value();
											decref(v75);
											VAL v76 = pop_value();
											decref(v76);
											uint64_t v77 = (0LL /* Nil */);
											push_value(v74);
											push_u64(v77);
										} break;
									}
									mw_std_list_List_1_uncons();
									VAL v78 = pop_value();
									VAL v79 = pop_value();
									push_value(v78);
									push_value(v79);
								}
								VAL v80 = pop_value();
								decref(v80);
								VAL v81 = pop_value();
								decref(v81);
								VAL v82 = pop_value();
								VAL v83 = pop_value();
								decref(v83);
								push_value(v82);
								mw_std_maybe_Maybe_1_someZAsk();
								VAL v84 = pop_value();
								if (VBOOL(v84)) {
									mtw_std_either_Either_2_Right();
								} else {
									mtw_mirth_elab_RejectedDef_RDz_WRONGz_CONSTRUCTOR();
									mtw_std_either_Either_2_Left();
								}
								VAL v85 = pop_value();
								push_value(v56);
								push_value(v55);
								push_value(v85);
								switch (get_top_data_tag()) {
									case 0LL: { // Left
										mtp_std_either_Either_2_Left();
										VAL v86 = pop_value();
										VAL v87 = pop_value();
										VAL v88 = pop_value();
										push_value(v86);
										push_value(v88);
										mtw_std_list_List_1_Cons();
										push_value(v87);
									} break;
									case 1LL: { // Right
										mtp_std_either_Either_2_Right();
										VAL v89 = pop_value();
										VAL v90 = pop_value();
										push_value(v89);
										push_value(v90);
										mtw_std_list_List_1_Cons();
									} break;
									default: {
										push_value(mkstr("unexpected fallthrough in match\n", 32));
										mp_primZ_panic();
									}
								}
								push_value(v54);
								mw_std_list_List_1_uncons();
								VAL v91 = pop_value();
								VAL v92 = pop_value();
								push_value(v91);
								push_value(v92);
							}
							VAL v93 = pop_value();
							decref(v93);
							VAL v94 = pop_value();
							decref(v94);
							VAL v95 = pop_value();
							mw_std_list_List_1_reverse();
							push_value(v95);
							mw_std_list_List_1_reverse();
							VAL v96 = pop_value();
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[4];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							VAL r97 = pop_resource();
							mw_std_list_List_1_cat();
							push_resource(r97);
							{
								VAL v = top_resource();
								VAL u = pop_value();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[4];
								VAL t = *p; *p = u; decref(t);
							}
							push_value(v96);
							{
								VAL v = top_resource();
								VAL u = pop_value();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								VAL* p = &VTUP(v)->cells[3];
								VAL t = *p; *p = u; decref(t);
							}
							VAL v98 = pop_value();
							decref(v98);
						} break;
						case 0LL: { // None
							(void)pop_u64();
							mw_mirth_elab_ZPlusResolveDef_filterZ_roots();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} else {
				}
				mw_mirth_elab_resolveZ_defZ_endZBang();
				VAL v99 = (lpop(&lbl_ZPluspat));
				push_resource(v99);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mw_mirth_def_Def_tagZAsk();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						uint64_t v100 = (0LL /* None */);
						push_u64(v100);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						mw_mirth_match_ZPlusPattern_tagZBang();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						uint64_t v101 = (0LL /* STACK_TYPE_ERROR */);
						push_u64(v101);
						{
							VAL v = top_resource();
							incref(v);
							push_value(v);
						}
						VAL r102 = pop_resource();
						{
							VAL v = pop_value();
							VAL u = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 10, v);
							if (VTUP(v)->refs == 1) {
								VAL* p = &VTUP(v)->cells[7];
								VAL t = *p; *p = u; decref(t);
								push_value(v);
							} else {
								TUP *tup = tup_new(10);
								tup->size = 10;
								tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
								tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
								tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
								tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
								tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
								tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
								tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
								tup->cells[7] = u;
								tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
								tup->cells[9] = VTUP(v)->cells[9]; incref(tup->cells[9]);
								decref(v);
								push_value(MKTUP(tup,10));
							}
						}
						push_resource(r102);
						{
							VAL v = pop_resource();
							push_resource(pop_value());
							decref(v);
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("Expected constructor name.", 26);
				VAL r103 = pop_resource();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
				push_resource(r103);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
}
static void mw_mirth_elab_elabZ_expandZ_tensorZBang (void) {
	VAL v0 = pop_value();
	lpush(&lbl_tok, v0);
	mw_mirth_type_StackType_forceZ_consZAskZBang();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mp_primZ_packZ_uncons();
			VAL v1 = pop_value();
			mp_primZ_packZ_uncons();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = (lpop(&lbl_tok));
			push_value(v2);
			push_value(v1);
			push_value(v4);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v5 = (0LL /* STACK_TYPE_ERROR */);
			uint64_t v6 = (0LL /* TYPE_ERROR */);
			VAL v7 = (lpop(&lbl_tok));
			incref(v7);
			push_u64(v5);
			push_u64(v6);
			push_value(v7);
			push_value(v7);
			STRLIT("expected tuple type", 19);
			mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_lambdaZ_paramZAsk (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_patternZ_varZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_token_Token_argsZ_0();
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		mw_mirth_token_Token_next();
		mw_mirth_type_MetaVar_newZBang();
		mtw_mirth_type_Type_TMeta();
		push_value(v3);
		mw_mirth_token_Token_nameZAsk();
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_var_Var_newZBang();
		mtw_std_maybe_Maybe_1_Some();
	} else {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_token_Token_lsquareZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v5 = pop_value();
				decref(v5);
				VAL v6 = pop_value();
				incref(v6);
				push_value(v6);
				push_value(v6);
				mw_mirth_token_Token_succ();
				mw_mirth_token_Token_patternZ_varZAsk();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v7 = (0LL /* False */);
				push_u64(v7);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			push_value(v9);
			mw_mirth_token_Token_succ();
			mw_mirth_token_Token_succ();
			mw_mirth_token_Token_rsquareZAsk();
			mw_std_maybe_Maybe_1_ZToBool();
		} else {
			uint64_t v10 = (0LL /* False */);
			push_u64(v10);
		}
		VAL v11 = pop_value();
		if (VBOOL(v11)) {
			VAL v12 = pop_value();
			incref(v12);
			push_value(v12);
			push_value(v12);
			mw_mirth_token_Token_succ();
			mw_mirth_token_Token_argsZ_0();
			VAL v13 = pop_value();
			incref(v13);
			push_value(v13);
			mw_mirth_token_Token_next();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_StackType_STMeta();
			mw_mirth_type_MetaVar_newZBang();
			mtw_mirth_type_StackType_STMeta();
			mw_mirth_type_TZ_ZTo();
			mtw_mirth_type_Type_TMorphism();
			push_value(v13);
			mw_mirth_token_Token_succ();
			mw_mirth_token_Token_nameZAsk();
			mw_std_maybe_Maybe_1_unwrap();
			mw_mirth_var_Var_newZ_autoZ_runZBang();
			mtw_std_maybe_Maybe_1_Some();
		} else {
			uint64_t v14 = (0LL /* None */);
			push_u64(v14);
		}
	}
}
static void mw_mirth_elab_elabZ_atomZ_lambdaZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	VAL r0 = pop_resource();
	mw_mirth_token_Token_argsZ_1();
	uint64_t v1 = (0LL /* Nil */);
	push_resource(r0);
	push_u64(v1);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	mw_mirth_elab_elabZ_lambdaZ_paramZAsk();
	push_resource(r3);
	push_resource(r2);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		VAL r6 = pop_resource();
		VAL r7 = pop_resource();
		mw_mirth_elab_elabZ_lambdaZ_paramZAsk();
		push_resource(r7);
		push_resource(r6);
	}
	VAL v8 = pop_value();
	decref(v8);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v9 = pop_value();
	VAL r10 = pop_resource();
	mw_mirth_elab_expectZ_tokenZ_arrow();
	push_resource(r10);
	mw_mirth_token_Token_succ();
	incref(v9);
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_elab_abZ_typeZAt();
	push_value(v9);
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	push_value(v11);
	push_value(v12);
	while(1) {
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v13);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v14 = pop_value();
		if (!VBOOL(v14)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		incref(v15);
		push_value(v15);
		mw_mirth_var_Ctx_new();
		push_value(v15);
		push_value(v17);
		mw_mirth_elab_abZ_tokenZAt();
		VAL r18 = pop_resource();
		mw_mirth_elab_elabZ_expandZ_tensorZBang();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		push_resource(r18);
		push_value(v21);
		push_value(v20);
		push_value(v22);
		mw_mirth_var_Var_type();
		VAL r23 = pop_resource();
		push_value(v19);
		mw_mirth_elab_elabZ_typeZ_unifyZBang();
		VAL v24 = pop_value();
		decref(v24);
		VAL v25 = pop_value();
		decref(v25);
		push_resource(r23);
		push_value(v16);
		mw_std_list_List_1_uncons();
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		push_value(v26);
		push_value(v27);
	}
	VAL v28 = pop_value();
	decref(v28);
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	VAL v31 = pop_value();
	VAL v32 = pop_value();
	push_value(v31);
	push_value(v30);
	push_value(v32);
	mw_mirth_elab_abZ_homeZAt();
	VAL r33 = pop_resource();
	VAL v34 = pop_value();
	VAL v35 = pop_value();
	incref(v35);
	VAL v36 = pop_value();
	incref(v36);
	VAL v37 = pop_value();
	uint64_t v38 = (0LL /* Nil */);
	lpush(&lbl_home, v34);
	lpush(&lbl_tokenZ_start, v35);
	lpush(&lbl_tokenZ_end, v35);
	lpush(&lbl_dom, v36);
	lpush(&lbl_cod, v36);
	lpush(&lbl_ctx, v37);
	lpush(&lbl_atoms, MKU64(v38));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v39 = pop_value();
	lpush(&lbl_arrow, v39);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	mw_mirth_elab_elabZ_atomsZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v40 = (lpop(&lbl_arrow));
	push_resource(r33);
	lpush(&lbl_params, v9);
	lpush(&lbl_body, v40);
	mw_mirth_elab_abZ_ctxZAt();
	VAL v41 = pop_value();
	lpush(&lbl_outerZ_ctx, v41);
	mw_mirth_elab_abZ_typeZAt();
	VAL v42 = pop_value();
	lpush(&lbl_dom, v42);
	mw_mirth_elab_abZ_tokenZAt();
	VAL v43 = pop_value();
	lpush(&lbl_token, v43);
	mtw_mirth_arrow_Lambda_Lambda();
	mtw_mirth_arrow_Op_OpLambda();
	mw_mirth_elab_abZ_opZBang();
}
static void mw_mirth_elab_elabZ_matchZ_exhaustiveZBang (void) {
	mw_mirth_match_ZPlusMatch_freezze();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_match_Match_isZ_exhaustiveZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
	} else {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		STRLIT("Pattern match not exhaustive.", 29);
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
	}
	mw_mirth_match_Match_thaw();
}
static void mw_mirth_elab_elabZ_moduleZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_module_Module_start();
	mw_mirth_elab_elabZ_moduleZ_headerZBang();
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mw_mirth_token_Token_moduleZ_endZAsk();
		VAL v2 = pop_value();
		if (VBOOL(v2)) {
			uint64_t v3 = (0LL /* False */);
			push_u64(v3);
		} else {
			uint64_t v4 = (1LL /* True */);
			push_u64(v4);
		}
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_mirth_elab_elabZ_moduleZ_declZBang();
	}
	VAL v6 = pop_value();
	decref(v6);
}
static void mw_mirth_elab_elabZ_moduleZ_packageZ_name (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Expected module name. (1)", 25);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	mw_mirth_token_Token_argsZ_0();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v3);
	mw_mirth_name_DName_rootZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v4 = pop_value();
			decref(v4);
			STRLIT("Expected module name. (2)", 25);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	mw_mirth_name_DName_parts();
	mw_std_list_List_1_ZDivL1();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v7 = pop_value();
			decref(v7);
			STRLIT("Expected module name. (3)", 25);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v8 = pop_value();
	mw_mirth_package_Package_findZ_orZ_newZBang();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	decref(v10);
	push_value(v9);
	push_value(v8);
}
static void mw_mirth_elab_elabZ_moduleZ_qname (void) {
	mw_mirth_elab_elabZ_moduleZ_packageZ_name();
	VAL v0 = pop_value();
	mtw_mirth_name_Namespace_NAMESPACEz_PACKAGE();
	push_value(v0);
	mw_mirth_name_QNAME0();
}
static void mw_mirth_elab_elabZ_moduleZ_headerZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_moduleZ_headerZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		mw_mirth_token_Token_next();
		push_value(v2);
		mw_mirth_token_Token_argsZ_1();
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_elab_elabZ_moduleZ_packageZ_name();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v5);
		push_value(v4);
		push_value(v6);
		mw_mirth_token_Token_module();
		VAL v7 = pop_value();
		incref(v7);
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
		push_value(v7);
		mfld_mirth_module_Module_ZTildename();
		mp_primZ_mutZ_set();
		VAL v9 = pop_value();
		incref(v9);
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
		push_value(v9);
		mfld_mirth_module_Module_ZTildepackage();
		mp_primZ_mutZ_set();
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		push_value(v11);
		mw_mirth_module_Module_qname();
		mw_mirth_name_QName_definedZ_softZAsk();
		VAL v12 = pop_value();
		if (VBOOL(v12)) {
			VAL v13 = pop_value();
			decref(v13);
			STRLIT("Module name already taken.", 26);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} else {
		}
		VAL v14 = pop_value();
		incref(v14);
		push_value(v14);
		push_value(v14);
		mtw_mirth_def_Def_DefModule();
		mw_mirth_def_Def_register();
		mw_mirth_elab_checkZ_moduleZ_path();
	} else {
		VAL v15 = pop_value();
		incref(v15);
		push_value(v15);
		push_value(v15);
		STRLIT("Expected module header.", 23);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
}
static void mw_mirth_elab_checkZ_moduleZ_path (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_module_Module_path();
	mw_std_path_Path_splitZ_last();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			mw_mirth_module_Module_qname();
			mw_mirth_name_QName_toZ_moduleZ_path();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			incref(v4);
			incref(v3);
			push_value(v4);
			push_value(v3);
			push_value(v4);
			push_value(v3);
			mp_primZ_strZ_cmp();
			int64_t v5 = (0LL);
			VAL v6 = pop_value();
			incref(v6);
			bool v7 = (VI64(v6) == v5);
			push_value(v6);
			push_i64(v5);
			if (v7) {
				VAL v8 = pop_value();
				decref(v8);
				VAL v9 = pop_value();
				decref(v9);
				uint64_t v10 = (1LL /* EQ */);
				push_u64(v10);
			} else {
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				bool v13 = (VI64(v12) < VI64(v11));
				if (v13) {
					uint64_t v14 = (0LL /* LT */);
					push_u64(v14);
				} else {
					uint64_t v15 = (2LL /* GT */);
					push_u64(v15);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v16 = (0LL /* False */);
					push_u64(v16);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v17 = (1LL /* True */);
					push_u64(v17);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v18 = (0LL /* False */);
					push_u64(v18);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v19 = pop_value();
			if (VBOOL(v19)) {
			} else {
				STRLIT("expected module name to match path\n", 35);
				VAL v20 = pop_value();
				VAL v21 = pop_value();
				push_value(v20);
				push_value(v21);
				mp_primZ_strZ_cat();
				STRLIT("\n", 1);
				mp_primZ_strZ_cat();
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				push_value(v22);
				push_value(v23);
				mp_primZ_strZ_cat();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			}
			VAL v24 = pop_value();
			decref(v24);
			VAL v25 = pop_value();
			decref(v25);
			VAL v26 = pop_value();
			decref(v26);
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mtw_std_str_ZPlusStr_ZPlusStr();
			mw_std_str_ZPlusStr_numZ_bytesZAsk();
			uint64_t v27 = (0LL /* None */);
			push_u64(v27);
			while(1) {
				VAL v28 = pop_value();
				incref(v28);
				push_value(v28);
				push_value(v28);
				mw_std_maybe_Maybe_1_noneZAsk();
				VAL v29 = pop_value();
				if (VBOOL(v29)) {
					VAL v30 = pop_value();
					VAL v31 = pop_value();
					incref(v31);
					int64_t v32 = (0LL);
					bool v33 = (v32 < VI64(v31));
					push_value(v31);
					push_value(v30);
					push_bool(v33);
				} else {
					uint64_t v34 = (0LL /* False */);
					push_u64(v34);
				}
				VAL v35 = pop_value();
				if (!VBOOL(v35)) break;
				VAL v36 = pop_value();
				decref(v36);
				int64_t v37 = (1LL);
				push_i64(v37);
				mp_primZ_intZ_sub();
				VAL v38 = pop_value();
				incref(v38);
				push_value(v38);
				mw_std_str_ZPlusStr_byteZAt();
				VAL r39 = pop_resource();
				uint64_t v40 = (46LL /* BDOT */);
				push_u64(v40);
				mw_std_byte_Byte_ZEqualZEqual();
				VAL v41 = pop_value();
				push_resource(r39);
				push_value(v38);
				if (VBOOL(v41)) {
					VAL v42 = pop_value();
					incref(v42);
					push_value(v42);
					push_value(v42);
					mtw_std_maybe_Maybe_1_Some();
				} else {
					uint64_t v43 = (0LL /* None */);
					push_u64(v43);
				}
			}
			VAL v44 = pop_value();
			VAL v45 = pop_value();
			decref(v45);
			push_value(v44);
			mtp_std_str_ZPlusStr_ZPlusStr();
			VAL v46 = pop_value();
			VAL v47 = pop_value();
			push_value(v46);
			push_value(v47);
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v48 = (MKU64(0LL /* +Unsafe */));
					VAL v49 = pop_value();
					VAL v50 = pop_value();
					incref(v49);
					incref(v50);
					int64_t v51 = (1LL);
					push_resource(v48);
					push_value(v49);
					push_value(v50);
					push_value(v49);
					push_i64(v51);
					mp_primZ_intZ_add();
					push_value(v50);
					mw_std_prim_Str_dropZ_slice();
					VAL v52 = pop_value();
					VAL v53 = pop_value();
					mw_std_prim_Int_ZToNat();
					push_value(v53);
					mw_std_prim_Str_takeZ_slice();
					push_value(v52);
					switch (get_top_resource_data_tag()) {
						case 0LL: { // +Unsafe
							(void)pop_resource();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v54 = (0LL /* None */);
					push_u64(v54);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			STRLIT("mth", 3);
			mtw_std_maybe_Maybe_1_Some();
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					mw_std_maybe_Maybe_1_noneZAsk();
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v55 = pop_value();
					VAL v56 = pop_value();
					push_value(v55);
					push_value(v56);
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v57 = pop_value();
							VAL v58 = pop_value();
							push_value(v57);
							push_value(v58);
							mp_primZ_strZ_cmp();
							int64_t v59 = (0LL);
							VAL v60 = pop_value();
							incref(v60);
							bool v61 = (VI64(v60) == v59);
							push_value(v60);
							push_i64(v59);
							if (v61) {
								VAL v62 = pop_value();
								decref(v62);
								VAL v63 = pop_value();
								decref(v63);
								uint64_t v64 = (1LL /* EQ */);
								push_u64(v64);
							} else {
								VAL v65 = pop_value();
								VAL v66 = pop_value();
								bool v67 = (VI64(v66) < VI64(v65));
								if (v67) {
									uint64_t v68 = (0LL /* LT */);
									push_u64(v68);
								} else {
									uint64_t v69 = (2LL /* GT */);
									push_u64(v69);
								}
							}
							switch (get_top_data_tag()) {
								case 0LL: { // LT
									(void)pop_u64();
									uint64_t v70 = (0LL /* False */);
									push_u64(v70);
								} break;
								case 1LL: { // EQ
									(void)pop_u64();
									uint64_t v71 = (1LL /* True */);
									push_u64(v71);
								} break;
								case 2LL: { // GT
									(void)pop_u64();
									uint64_t v72 = (0LL /* False */);
									push_u64(v72);
								} break;
								default: {
									push_value(mkstr("unexpected fallthrough in match\n", 32));
									mp_primZ_panic();
								}
							}
						} break;
						case 0LL: { // None
							(void)pop_u64();
							VAL v73 = pop_value();
							decref(v73);
							uint64_t v74 = (0LL /* False */);
							push_u64(v74);
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v75 = pop_value();
			if (VBOOL(v75)) {
			} else {
				VAL v76 = pop_value();
				VAL v77 = pop_value();
				VAL v78 = pop_value();
				VAL v79 = pop_value();
				incref(v79);
				push_value(v79);
				push_value(v78);
				push_value(v77);
				push_value(v76);
				push_value(v79);
				STRLIT("expected .mth extension for mirth file", 38);
				mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang();
			}
			VAL v80 = pop_value();
			VAL v81 = pop_value();
			VAL v82 = pop_value();
			incref(v82);
			push_value(v82);
			push_value(v81);
			push_value(v80);
			push_value(v82);
			mw_mirth_module_Module_name();
			mw_mirth_name_Name_ZToStr();
			mp_primZ_strZ_cmp();
			int64_t v83 = (0LL);
			VAL v84 = pop_value();
			incref(v84);
			bool v85 = (VI64(v84) == v83);
			push_value(v84);
			push_i64(v83);
			if (v85) {
				VAL v86 = pop_value();
				decref(v86);
				VAL v87 = pop_value();
				decref(v87);
				uint64_t v88 = (1LL /* EQ */);
				push_u64(v88);
			} else {
				VAL v89 = pop_value();
				VAL v90 = pop_value();
				bool v91 = (VI64(v90) < VI64(v89));
				if (v91) {
					uint64_t v92 = (0LL /* LT */);
					push_u64(v92);
				} else {
					uint64_t v93 = (2LL /* GT */);
					push_u64(v93);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v94 = (0LL /* False */);
					push_u64(v94);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v95 = (1LL /* True */);
					push_u64(v95);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v96 = (0LL /* False */);
					push_u64(v96);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v97 = pop_value();
			if (VBOOL(v97)) {
			} else {
				VAL v98 = pop_value();
				VAL v99 = pop_value();
				VAL v100 = pop_value();
				incref(v100);
				push_value(v100);
				push_value(v99);
				push_value(v98);
				push_value(v100);
				STRLIT("expected module name to match file name", 39);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			}
			VAL v101 = pop_value();
			VAL v102 = pop_value();
			incref(v102);
			push_value(v102);
			push_value(v101);
			push_value(v102);
			mw_mirth_module_Module_package();
			mw_mirth_package_Package_pathZBang();
			VAL v103 = pop_value();
			decref(v103);
			VAL v104 = pop_value();
			decref(v104);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_moduleZ_declZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("unknown declaration", 19);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_name_Name_defs();
	uint64_t v1 = (0LL /* None */);
	VAL v2 = pop_value();
	push_u64(v1);
	push_value(v2);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v7);
		mw_mirth_def_Def_primZAsk();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v8);
		push_value(v10);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				decref(v12);
				VAL v13 = pop_value();
				decref(v13);
				uint64_t v14 = (0LL /* Nil */);
				push_value(v11);
				push_u64(v14);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_value(v15);
		push_value(v16);
	}
	VAL v17 = pop_value();
	decref(v17);
	VAL v18 = pop_value();
	decref(v18);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("unknown declaration", 19);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 91LL: { // PRIM_SYNTAX_IMPORT
			(void)pop_u64();
			mw_mirth_elab_elabZ_moduleZ_importZBang();
		} break;
		case 92LL: { // PRIM_SYNTAX_ALIAS
			(void)pop_u64();
			mw_mirth_elab_elabZ_aliasZBang();
		} break;
		case 93LL: { // PRIM_SYNTAX_INLINE
			(void)pop_u64();
			mw_mirth_elab_elabZ_inlineZBang();
		} break;
		case 94LL: { // PRIM_SYNTAX_DEF
			(void)pop_u64();
			mw_mirth_elab_elabZ_defZBang();
		} break;
		case 95LL: { // PRIM_SYNTAX_DEF_MISSING
			(void)pop_u64();
			mw_mirth_elab_elabZ_defZ_missingZBang();
		} break;
		case 96LL: { // PRIM_SYNTAX_DEF_TYPE
			(void)pop_u64();
			mw_mirth_elab_elabZ_defZ_typeZBang();
		} break;
		case 100LL: { // PRIM_SYNTAX_DEF_EXTERNAL
			(void)pop_u64();
			VAL v19 = pop_value();
			incref(v19);
			push_value(v19);
			push_value(v19);
			STRLIT("def-external", 12);
			VAL v20 = pop_value();
			lpush(&lbl_old, v20);
			STRLIT("external", 8);
			VAL v21 = pop_value();
			lpush(&lbl_new, v21);
			mw_mirth_mirth_ZPlusMirth_emitZ_deprecatedZBang();
			mw_mirth_elab_elabZ_externalZBang();
		} break;
		case 99LL: { // PRIM_SYNTAX_EXTERNAL
			(void)pop_u64();
			mw_mirth_elab_elabZ_externalZBang();
		} break;
		case 97LL: { // PRIM_SYNTAX_BUFFER
			(void)pop_u64();
			mw_mirth_elab_elabZ_bufferZBang();
		} break;
		case 98LL: { // PRIM_SYNTAX_VARIABLE
			(void)pop_u64();
			mw_mirth_elab_elabZ_variableZBang();
		} break;
		case 102LL: { // PRIM_SYNTAX_TABLE
			(void)pop_u64();
			mw_mirth_elab_elabZ_tableZBang();
		} break;
		case 103LL: { // PRIM_SYNTAX_FIELD
			(void)pop_u64();
			mw_mirth_elab_elabZ_fieldZBang();
		} break;
		case 104LL: { // PRIM_SYNTAX_DATA
			(void)pop_u64();
			mw_mirth_elab_elabZ_dataZBang();
		} break;
		case 105LL: { // PRIM_SYNTAX_STRUCT
			(void)pop_u64();
			mw_mirth_elab_elabZ_structZBang();
		} break;
		case 101LL: { // PRIM_SYNTAX_EMBED_STR
			(void)pop_u64();
			mw_mirth_elab_elabZ_embedZ_strZBang();
		} break;
		default: {
			VAL v22 = pop_value();
			decref(v22);
			STRLIT("unknown declaration", 19);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
	}
}
static void mw_mirth_elab_loadZ_module (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_QName_defZ_softZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_def_Def_moduleZAsk();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v1 = pop_value();
					decref(v1);
					STRLIT("module name already taken", 25);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			decref(v3);
			push_value(v2);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_name_QName_toZ_moduleZ_path();
			mw_mirth_lexer_runZ_lexerZBang();
			mw_mirth_elab_elabZ_moduleZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_moduleZ_importZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_1();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mw_mirth_elab_elabZ_moduleZ_qname();
	mw_mirth_elab_loadZ_module();
	VAL v2 = pop_value();
	mw_mirth_token_Token_module();
	push_value(v2);
	mw_mirth_module_Module_addZ_importZBang();
}
static void mw_mirth_elab_parseZ_data (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_numZ_args();
	int64_t v1 = (0LL);
	VAL v2 = pop_value();
	bool v3 = (v1 < VI64(v2));
	if (v3) {
		mw_mirth_token_Token_succ();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_token_Token_lparenZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v5 = pop_value();
				decref(v5);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("expected left parenthesis '('", 29);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
		mw_mirth_elab_parseZ_dataZ_header();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		incref(v7);
		lpush(&lbl_header, v6);
		push_value(v7);
		push_value(v7);
		mw_mirth_token_Token_commaZAsk();
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			mw_mirth_token_Token_succ();
		} else {
		}
		mw_mirth_elab_parseZ_dataZ_tags();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		incref(v10);
		lpush(&lbl_tags, v9);
		push_value(v10);
		push_value(v10);
		mw_mirth_token_Token_rparenZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v11 = pop_value();
				decref(v11);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("expected right parenthesis ')'", 30);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
	} else {
		mw_mirth_token_Token_succ();
		mw_mirth_elab_parseZ_dataZ_header();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		incref(v13);
		lpush(&lbl_header, v12);
		push_value(v13);
		push_value(v13);
		mw_mirth_token_Token_lcurlyZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v14 = pop_value();
				decref(v14);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("expected left curly brace '{'", 29);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
		mw_mirth_elab_parseZ_dataZ_tags();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		incref(v16);
		lpush(&lbl_tags, v15);
		push_value(v16);
		push_value(v16);
		mw_mirth_token_Token_rcurlyZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v17 = pop_value();
				decref(v17);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("expected right curly brace '}'", 30);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
	}
	mtw_mirth_elab_SyntaxData_SyntaxData();
}
static void mw_mirth_elab_parseZ_dataZ_header (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_head, v0);
	mw_mirth_token_Token_next();
	VAL v1 = (lpop(&lbl_head));
	incref(v1);
	push_value(v1);
	lpush(&lbl_head, v1);
	mw_mirth_token_Token_lastZ_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_constructor();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
	} else {
		VAL v4 = (lpop(&lbl_head));
		incref(v4);
		push_value(v4);
		lpush(&lbl_head, v4);
		STRLIT("Expected type name.", 19);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
	mtw_mirth_elab_SyntaxDataHeader_SyntaxDataHeader();
}
static void mw_mirth_elab_parseZ_dataZ_tags (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	while(1) {
		VAL r1 = pop_resource();
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_token_Token_argZ_endZAsk();
		VAL v3 = pop_value();
		if (VBOOL(v3)) {
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} else {
			uint64_t v5 = (1LL /* True */);
			push_u64(v5);
		}
		VAL v6 = pop_value();
		push_resource(r1);
		if (!VBOOL(v6)) break;
		VAL r7 = pop_resource();
		mw_mirth_elab_parseZ_dataZ_tag();
		push_resource(r7);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
	}
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
}
static void mw_mirth_elab_parseZ_dataZ_tag (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_intZAsk();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	lpush(&lbl_valueZAsk, v1);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v2 = pop_value();
			decref(v2);
			mw_mirth_token_Token_succ();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v3);
	mw_mirth_token_Token_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			mw_mirth_name_Name_couldZ_beZ_constructor();
			VAL v5 = pop_value();
			push_value(v4);
			if (VBOOL(v5)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v6 = pop_value();
				decref(v6);
				uint64_t v7 = (0LL /* None */);
				push_u64(v7);
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v8 = (0LL /* None */);
			push_u64(v8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Expected constructor name.", 26);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v9 = pop_value();
	lpush(&lbl_name, v9);
	mw_mirth_token_Token_succ();
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	push_value(v10);
	mw_mirth_token_Token_arrowZAsk();
	VAL v11 = pop_value();
	if (VBOOL(v11)) {
		mw_mirth_token_Token_succ();
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		push_value(v12);
		mtw_std_maybe_Maybe_1_Some();
		VAL v13 = pop_value();
		lpush(&lbl_sigZAsk, v13);
		mw_mirth_token_Token_sigZ_nextZ_stackZ_end();
		VAL v14 = pop_value();
		incref(v14);
		push_value(v14);
		push_value(v14);
		mw_mirth_token_Token_argZ_endZAsk();
		VAL v15 = pop_value();
		if (VBOOL(v15)) {
		} else {
			STRLIT("Expected comma.", 15);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
	} else {
		VAL v16 = pop_value();
		incref(v16);
		push_value(v16);
		push_value(v16);
		mw_mirth_token_Token_lsquareZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v17 = pop_value();
				decref(v17);
				mw_mirth_token_Token_succ();
				VAL v18 = pop_value();
				incref(v18);
				push_value(v18);
				push_value(v18);
				mtw_std_maybe_Maybe_1_Some();
				VAL v19 = pop_value();
				lpush(&lbl_sigZAsk, v19);
				mw_mirth_token_Token_sigZ_nextZ_stackZ_end();
				VAL v20 = pop_value();
				incref(v20);
				push_value(v20);
				push_value(v20);
				mw_mirth_token_Token_rsquareZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v21 = pop_value();
						decref(v21);
					} break;
					case 0LL: { // None
						(void)pop_u64();
						STRLIT("Expected right square bracket ']'", 33);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				mw_mirth_token_Token_succ();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v22 = (0LL /* None */);
				lpush(&lbl_sigZAsk, MKU64(v22));
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
	VAL v23 = pop_value();
	incref(v23);
	push_value(v23);
	push_value(v23);
	mw_mirth_token_Token_commaZAsk();
	VAL v24 = pop_value();
	if (VBOOL(v24)) {
		mw_mirth_token_Token_succ();
	} else {
	}
	mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag();
}
static void mw_mirth_elab_parseZ_struct (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_numZ_args();
	int64_t v1 = (0LL);
	VAL v2 = pop_value();
	bool v3 = (v1 < VI64(v2));
	if (v3) {
		mw_mirth_token_Token_succ();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_token_Token_lparenZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v5 = pop_value();
				decref(v5);
				STRLIT("Expected left parenthesis '('", 29);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
		mw_mirth_elab_parseZ_dataZ_header();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		incref(v7);
		lpush(&lbl_header, v6);
		push_value(v7);
		push_value(v7);
		mw_mirth_token_Token_commaZAsk();
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			mw_mirth_token_Token_succ();
		} else {
		}
		mw_mirth_elab_parseZ_structZ_tag();
		uint64_t v9 = (0LL /* Nil */);
		push_u64(v9);
		mtw_std_list_List_1_Cons();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		incref(v11);
		lpush(&lbl_tags, v10);
		push_value(v11);
		push_value(v11);
		mw_mirth_token_Token_rparenZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v12 = pop_value();
				decref(v12);
				STRLIT("Expected right parenthesis ')'", 30);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
	} else {
		mw_mirth_token_Token_succ();
		mw_mirth_elab_parseZ_dataZ_header();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		incref(v14);
		lpush(&lbl_header, v13);
		push_value(v14);
		push_value(v14);
		mw_mirth_token_Token_lcurlyZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v15 = pop_value();
				decref(v15);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("expected left curly brace '{'", 29);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
		mw_mirth_elab_parseZ_structZ_tag();
		uint64_t v16 = (0LL /* Nil */);
		push_u64(v16);
		mtw_std_list_List_1_Cons();
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		incref(v18);
		lpush(&lbl_tags, v17);
		push_value(v18);
		push_value(v18);
		mw_mirth_token_Token_rcurlyZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v19 = pop_value();
				decref(v19);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("expected right curly brace '}'", 30);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_succ();
	}
	mtw_mirth_elab_SyntaxData_SyntaxData();
}
static void mw_mirth_elab_parseZ_structZ_tag (void) {
	VAL v0 = (lpop(&lbl_header));
	incref(v0);
	push_value(v0);
	lpush(&lbl_header, v0);
	{
	}
	mw_mirth_token_Token_lastZ_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			incref(v1);
			push_value(v1);
			mw_mirth_name_Name_couldZ_beZ_constructor();
			VAL v2 = pop_value();
			push_value(v1);
			if (VBOOL(v2)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v3 = pop_value();
				decref(v3);
				uint64_t v4 = (0LL /* None */);
				push_u64(v4);
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v5 = (0LL /* None */);
			push_u64(v5);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v6 = (lpop(&lbl_header));
			incref(v6);
			push_value(v6);
			lpush(&lbl_header, v6);
			{
			}
			STRLIT("expected constructor name", 25);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v7 = pop_value();
	uint64_t v8 = (0LL /* None */);
	VAL v9 = pop_value();
	incref(v9);
	lpush(&lbl_name, v7);
	lpush(&lbl_valueZAsk, MKU64(v8));
	push_value(v9);
	push_value(v9);
	mtw_std_maybe_Maybe_1_Some();
	VAL v10 = pop_value();
	lpush(&lbl_sigZAsk, v10);
	mw_mirth_token_Token_sigZ_nextZ_stackZ_end();
	mtw_mirth_elab_SyntaxDataTag_SyntaxDataTag();
}
static void mw_mirth_elab_elabZ_dataZBang (void) {
	mw_mirth_elab_parseZ_data();
	mw_mirth_elab_elabZ_dataZ_auxZBang();
}
static void mw_mirth_elab_elabZ_structZBang (void) {
	mw_mirth_elab_parseZ_struct();
	mw_mirth_elab_elabZ_dataZ_auxZBang();
}
static void mw_mirth_elab_elabZ_dataZ_auxZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // SyntaxData
			mtp_mirth_elab_SyntaxData_SyntaxData();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_data_Data_allocZBang();
	uint64_t v0 = (0LL /* Nil */);
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_u64(v0);
	push_value(v1);
	mfld_mirth_data_Data_ZTildetags();
	mp_primZ_mutZ_set();
	VAL v2 = (lpop(&lbl_header));
	push_value(v2);
	mw_mirth_elab_elabZ_dataZ_headerZBang();
	VAL v3 = (lpop(&lbl_tags));
	push_value(v3);
	mw_std_list_List_1_uncons();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v7 = pop_value();
		if (!VBOOL(v7)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		mw_mirth_elab_elabZ_dataZ_tagZBang();
		push_value(v9);
		mw_std_list_List_1_uncons();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v11);
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
	mw_mirth_elab_elabZ_dataZ_doneZBang();
}
static void mw_mirth_elab_elabZ_dataZ_headerZBang (void) {
	mtp_mirth_elab_SyntaxDataHeader_SyntaxDataHeader();
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_head));
	incref(v1);
	lpush(&lbl_data, v0);
	push_value(v1);
	lpush(&lbl_head, v1);
	mw_mirth_token_Token_lastZ_nameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_name_Name_couldZ_beZ_constructor();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v3 = pop_value();
	if (VBOOL(v3)) {
	} else {
		VAL v4 = (lpop(&lbl_head));
		incref(v4);
		push_value(v4);
		lpush(&lbl_head, v4);
		STRLIT("Expected type name.", 19);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
	mw_mirth_elab_elabZ_defZ_head();
	VAL v5 = (lpop(&lbl_head));
	incref(v5);
	push_value(v5);
	lpush(&lbl_head, v5);
	mtw_std_maybe_Maybe_1_Some();
	VAL v6 = (lpop(&lbl_data));
	incref(v6);
	push_value(v6);
	lpush(&lbl_data, v6);
	mfld_mirth_data_Data_ZTildeheadZAsk();
	mp_primZ_mutZ_set();
	VAL v7 = (lpop(&lbl_arity));
	VAL v8 = (lpop(&lbl_data));
	incref(v8);
	push_value(v7);
	push_value(v8);
	lpush(&lbl_data, v8);
	mfld_mirth_data_Data_ZTildearity();
	mp_primZ_mutZ_set();
	VAL v9 = (lpop(&lbl_name));
	VAL v10 = (lpop(&lbl_data));
	incref(v10);
	push_value(v9);
	push_value(v10);
	lpush(&lbl_data, v10);
	mfld_mirth_data_Data_ZTildename();
	mp_primZ_mutZ_set();
	VAL v11 = (lpop(&lbl_data));
	incref(v11);
	push_value(v11);
	lpush(&lbl_data, v11);
	mtw_mirth_mirth_PropLabel_DataQName();
	VAL v12 = pop_value();
	lpush(&lbl_label, v12);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v13 = (lpop(&lbl_data));
	incref(v13);
	push_value(v13);
	lpush(&lbl_data, v13);
	mfld_mirth_data_Data_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v14 = (lpop(&lbl_head));
	incref(v14);
	push_value(v14);
	lpush(&lbl_head, v14);
	mw_mirth_token_Token_args();
	VAL v15 = (lpop(&lbl_data));
	incref(v15);
	push_value(v15);
	lpush(&lbl_data, v15);
	mtw_mirth_mirth_PropLabel_DataParams();
	VAL v16 = (MKFNPTR(&mb_mirth_elab_elabZ_dataZ_headerZBang_2));
	push_value(v16);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v17 = (lpop(&lbl_data));
	incref(v17);
	push_value(v17);
	lpush(&lbl_data, v17);
	mfld_mirth_data_Data_ZTildeparams();
	mp_primZ_mutZ_set();
	VAL v18 = (lpop(&lbl_data));
	incref(v18);
	push_value(v18);
	lpush(&lbl_data, v18);
	mtw_mirth_def_Def_DefData();
	mw_mirth_def_Def_register();
	VAL v19 = (lpop(&lbl_head));
	decref(v19);
	VAL v20 = (lpop(&lbl_data));
	push_value(v20);
}
static void mw_mirth_elab_elabZ_dataZ_paramsZBang (void) {
	mw_mirth_var_Ctx0();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_mirth_token_Token_sigZ_typeZ_varZAsk();
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
		} else {
			STRLIT("expected type variable", 22);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_value(v9);
		mw_mirth_token_Token_nameZAsk();
		mw_std_maybe_Maybe_1_unwrap();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		push_value(v11);
		push_value(v10);
		push_value(v12);
		mw_mirth_var_Ctx_lookup();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v13 = pop_value();
				decref(v13);
				STRLIT("duplicate parameter name", 24);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_nameZAsk();
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_type_TYPEz_TYPE();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v14);
		push_value(v15);
		mw_mirth_var_Var_newZBang();
		mw_mirth_var_Ctx_new();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		push_value(v16);
		push_value(v17);
	}
	VAL v18 = pop_value();
	decref(v18);
	VAL v19 = pop_value();
	decref(v19);
	mw_mirth_var_Ctx_ZToList();
}
static void mw_mirth_elab_elabZ_dataZ_tagZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	lpush(&lbl_syn, v0);
	lpush(&lbl_dat, v1);
	mw_mirth_data_Tag_allocZBang();
	VAL v2 = pop_value();
	VAL v3 = (lpop(&lbl_dat));
	incref(v3);
	VAL v4 = (lpop(&lbl_syn));
	incref(v4);
	lpush(&lbl_tag, v2);
	push_value(v3);
	lpush(&lbl_dat, v3);
	push_value(v4);
	lpush(&lbl_syn, v4);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	int64_t v5 = (0LL);
	push_i64(v5);
	mw_mirth_data_dataZ_qname();
	VAL v6 = (lpop(&lbl_tag));
	incref(v6);
	push_value(v6);
	lpush(&lbl_tag, v6);
	mfld_mirth_data_Tag_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v7 = (lpop(&lbl_syn));
	incref(v7);
	push_value(v7);
	lpush(&lbl_syn, v7);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v8 = (lpop(&lbl_tag));
	incref(v8);
	push_value(v8);
	lpush(&lbl_tag, v8);
	mfld_mirth_data_Tag_ZTildesigZAsk();
	mp_primZ_mutZ_set();
	VAL v9 = (lpop(&lbl_syn));
	incref(v9);
	push_value(v9);
	lpush(&lbl_syn, v9);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 4, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v10 = (lpop(&lbl_tag));
			incref(v10);
			push_value(v10);
			lpush(&lbl_tag, v10);
			mfld_mirth_data_Tag_ZTildevalue();
			mp_primZ_mutZ_set();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v11 = (lpop(&lbl_dat));
	incref(v11);
	VAL v12 = (lpop(&lbl_tag));
	incref(v12);
	push_value(v11);
	lpush(&lbl_dat, v11);
	push_value(v12);
	lpush(&lbl_tag, v12);
	mfld_mirth_data_Tag_ZTildedata();
	mp_primZ_mutZ_set();
	VAL v13 = (lpop(&lbl_tag));
	incref(v13);
	VAL v14 = (lpop(&lbl_dat));
	incref(v14);
	push_value(v13);
	lpush(&lbl_tag, v13);
	push_value(v14);
	lpush(&lbl_dat, v14);
	mw_mirth_data_Data_addZ_tagZBang();
	VAL v15 = (lpop(&lbl_tag));
	incref(v15);
	push_value(v15);
	lpush(&lbl_tag, v15);
	mtw_mirth_def_Def_DefTag();
	mw_mirth_def_Def_register();
	VAL v16 = (lpop(&lbl_tag));
	incref(v16);
	incref(v16);
	push_value(v16);
	push_value(v16);
	lpush(&lbl_tag, v16);
	mtw_mirth_mirth_PropLabel_TagType();
	VAL v17 = (MKFNPTR(&mb_mirth_elab_elabZ_dataZ_tagZBang_1));
	push_value(v17);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v18 = (lpop(&lbl_tag));
	incref(v18);
	push_value(v18);
	lpush(&lbl_tag, v18);
	mfld_mirth_data_Tag_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v19 = (lpop(&lbl_tag));
	incref(v19);
	push_value(v19);
	lpush(&lbl_tag, v19);
	mw_mirth_data_Tag_numZ_typeZ_inputsZ_fromZ_sig();
	VAL v20 = (lpop(&lbl_tag));
	incref(v20);
	push_value(v20);
	lpush(&lbl_tag, v20);
	mfld_mirth_data_Tag_ZTildenumZ_typeZ_inputs();
	mp_primZ_mutZ_set();
	VAL v21 = (lpop(&lbl_tag));
	incref(v21);
	push_value(v21);
	lpush(&lbl_tag, v21);
	mw_mirth_data_Tag_numZ_resourceZ_inputsZ_fromZ_sig();
	VAL v22 = (lpop(&lbl_tag));
	incref(v22);
	push_value(v22);
	lpush(&lbl_tag, v22);
	mfld_mirth_data_Tag_ZTildenumZ_resourceZ_inputs();
	mp_primZ_mutZ_set();
	VAL v23 = (lpop(&lbl_tag));
	incref(v23);
	push_value(v23);
	lpush(&lbl_tag, v23);
	mw_mirth_data_Tag_labelZ_inputsZ_fromZ_sig();
	VAL v24 = (lpop(&lbl_tag));
	incref(v24);
	push_value(v24);
	lpush(&lbl_tag, v24);
	mfld_mirth_data_Tag_ZTildelabelZ_inputs();
	mp_primZ_mutZ_set();
	VAL v25 = (lpop(&lbl_tag));
	incref(v25);
	push_value(v25);
	lpush(&lbl_tag, v25);
	mw_mirth_data_Tag_outputsZ_resourceZAsk();
	VAL v26 = pop_value();
	if (VBOOL(v26)) {
		uint64_t v27 = (0LL /* False */);
		push_u64(v27);
	} else {
		uint64_t v28 = (1LL /* True */);
		push_u64(v28);
	}
	VAL v29 = (lpop(&lbl_tag));
	incref(v29);
	push_value(v29);
	lpush(&lbl_tag, v29);
	mw_mirth_data_Tag_numZ_resourceZ_inputs();
	int64_t v30 = (0LL);
	VAL v31 = pop_value();
	bool v32 = (v30 < VI64(v31));
	if (v32) {
	} else {
		VAL v33 = pop_value();
		decref(v33);
		uint64_t v34 = (0LL /* False */);
		push_u64(v34);
	}
	VAL v35 = pop_value();
	if (VBOOL(v35)) {
		VAL v36 = (lpop(&lbl_tag));
		incref(v36);
		push_value(v36);
		lpush(&lbl_tag, v36);
		mw_mirth_data_Tag_sigZAsk();
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_token_Token_runZ_tokens();
		uint64_t v37 = (0LL /* None */);
		VAL v38 = pop_value();
		push_u64(v37);
		push_value(v38);
		mw_std_list_List_1_uncons();
		VAL v39 = pop_value();
		VAL v40 = pop_value();
		push_value(v39);
		push_value(v40);
		while(1) {
			VAL v41 = pop_value();
			incref(v41);
			push_value(v41);
			push_value(v41);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v42 = pop_value();
			if (!VBOOL(v42)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v43 = pop_value();
			VAL v44 = pop_value();
			VAL v45 = pop_value();
			incref(v43);
			incref(v43);
			push_value(v43);
			mw_mirth_token_Token_sigZ_resourceZ_conZAsk();
			VAL v46 = pop_value();
			push_value(v43);
			if (VBOOL(v46)) {
				VAL v47 = pop_value();
				decref(v47);
				uint64_t v48 = (1LL /* True */);
				push_u64(v48);
			} else {
				mw_mirth_token_Token_sigZ_resourceZ_varZAsk();
			}
			VAL v49 = pop_value();
			push_value(v43);
			if (VBOOL(v49)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v50 = pop_value();
				decref(v50);
				uint64_t v51 = (0LL /* None */);
				push_u64(v51);
			}
			VAL v52 = pop_value();
			push_value(v45);
			push_value(v44);
			push_value(v52);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v53 = pop_value();
					VAL v54 = pop_value();
					decref(v54);
					VAL v55 = pop_value();
					decref(v55);
					uint64_t v56 = (0LL /* Nil */);
					push_value(v53);
					push_u64(v56);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v57 = pop_value();
			VAL v58 = pop_value();
			push_value(v57);
			push_value(v58);
		}
		VAL v59 = pop_value();
		decref(v59);
		VAL v60 = pop_value();
		decref(v60);
		mw_std_maybe_Maybe_1_unwrap();
		STRLIT("Value type cannot contain resource.", 35);
		mw_mirth_mirth_ZPlusMirth_emitZ_errorZBang();
	} else {
	}
	VAL v61 = (lpop(&lbl_tag));
	VAL v62 = (lpop(&lbl_syn));
	decref(v62);
	decref(v61);
	VAL v63 = (lpop(&lbl_dat));
	push_value(v63);
}
static void mw_mirth_elab_dataZ_wordZ_newZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	incref(v1);
	lpush(&lbl_arity, v0);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mw_std_prim_Str_ZToName();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	lpush(&lbl_name, v2);
	push_value(v5);
	push_value(v5);
	mw_mirth_data_Data_headZAsk();
	mw_std_maybe_Maybe_1_unwrap();
	VAL v6 = pop_value();
	incref(v6);
	lpush(&lbl_body, v6);
	lpush(&lbl_head, v6);
	push_value(v4);
	push_value(v3);
	mw_mirth_data_dataZ_wordZ_qname();
	VAL v7 = pop_value();
	uint64_t v8 = (0LL /* None */);
	lpush(&lbl_qname, v7);
	lpush(&lbl_sigZAsk, MKU64(v8));
	mw_mirth_word_Word_newZBang();
	VAL v9 = (lpop(&lbl_qname));
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	push_value(v9);
	push_value(v10);
	mtw_mirth_mirth_PropLabel_WordQName();
	mw_mirth_mirth_PropLabel_prop();
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	incref(v12);
	push_value(v12);
	push_value(v11);
	push_value(v12);
	mfld_mirth_word_Word_ZTildeqname();
	mp_primZ_mutZ_set();
}
static void mw_mirth_elab_elabZ_dataZ_doneZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_dat, v0);
	mw_mirth_data_Data_isZ_valueZ_typeZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = (lpop(&lbl_dat));
		incref(v2);
		push_value(v2);
		lpush(&lbl_dat, v2);
		STRLIT("tag", 3);
		int64_t v3 = (0LL);
		push_i64(v3);
		mw_mirth_elab_dataZ_wordZ_newZBang();
		VAL v4 = pop_value();
		VAL v5 = (lpop(&lbl_dat));
		incref(v5);
		lpush(&lbl_tag, v4);
		push_value(v5);
		lpush(&lbl_dat, v5);
		mw_mirth_data_Data_params();
		mw_std_list_List_1_ZToCtx();
		VAL v6 = (lpop(&lbl_dat));
		incref(v6);
		push_value(v6);
		lpush(&lbl_dat, v6);
		mw_mirth_elab_dataZ_getZ_tagZ_type();
		VAL v7 = (lpop(&lbl_tag));
		incref(v7);
		push_value(v7);
		lpush(&lbl_tag, v7);
		mtw_mirth_mirth_PropLabel_WordType();
		mw_mirth_mirth_PropLabel_prop2();
		VAL v8 = (lpop(&lbl_tag));
		incref(v8);
		push_value(v8);
		lpush(&lbl_tag, v8);
		mfld_mirth_word_Word_ZTildectxZ_type();
		mp_primZ_mutZ_set();
		VAL v9 = (lpop(&lbl_tag));
		incref(v9);
		incref(v9);
		lpush(&lbl_tag, v9);
		push_value(v9);
		VAL v10 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot24ZRParen_0));
		push_value(v10);
		mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
		incref(v9);
		push_value(v9);
		mtw_mirth_mirth_PropLabel_WordArrow();
		mw_mirth_mirth_PropLabel_prop();
		incref(v9);
		VAL v11 = pop_value();
		push_value(v9);
		push_value(v11);
		push_value(v9);
		mfld_mirth_word_Word_ZTildearrow();
		mp_primZ_mutZ_set();
		mw_mirth_word_Word_makeZ_inlineZBang();
		VAL v12 = (lpop(&lbl_tag));
		decref(v12);
	} else {
	}
	VAL v13 = (lpop(&lbl_dat));
	incref(v13);
	push_value(v13);
	lpush(&lbl_dat, v13);
	mw_mirth_data_Data_isZ_enumZAsk();
	VAL v14 = pop_value();
	if (VBOOL(v14)) {
		VAL v15 = (lpop(&lbl_dat));
		incref(v15);
		push_value(v15);
		lpush(&lbl_dat, v15);
		STRLIT("from-tag-unsafe", 15);
		int64_t v16 = (0LL);
		push_i64(v16);
		mw_mirth_elab_dataZ_wordZ_newZBang();
		VAL v17 = pop_value();
		lpush(&lbl_ftag, v17);
		mw_mirth_var_Ctx0();
		mw_mirth_type_TYPEz_INT();
		mw_mirth_type_T1();
		VAL v18 = (lpop(&lbl_dat));
		incref(v18);
		push_value(v18);
		lpush(&lbl_dat, v18);
		mtw_mirth_type_Type_TData();
		mw_mirth_type_T1();
		mw_mirth_type_TZ_ZTo();
		VAL v19 = (lpop(&lbl_ftag));
		incref(v19);
		push_value(v19);
		lpush(&lbl_ftag, v19);
		mtw_mirth_mirth_PropLabel_WordType();
		mw_mirth_mirth_PropLabel_prop2();
		VAL v20 = (lpop(&lbl_ftag));
		incref(v20);
		push_value(v20);
		lpush(&lbl_ftag, v20);
		mfld_mirth_word_Word_ZTildectxZ_type();
		mp_primZ_mutZ_set();
		VAL v21 = (lpop(&lbl_ftag));
		incref(v21);
		incref(v21);
		lpush(&lbl_ftag, v21);
		push_value(v21);
		VAL v22 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot57ZRParen_0));
		push_value(v22);
		mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
		incref(v21);
		push_value(v21);
		mtw_mirth_mirth_PropLabel_WordArrow();
		mw_mirth_mirth_PropLabel_prop();
		incref(v21);
		VAL v23 = pop_value();
		push_value(v21);
		push_value(v23);
		push_value(v21);
		mfld_mirth_word_Word_ZTildearrow();
		mp_primZ_mutZ_set();
		mw_mirth_word_Word_makeZ_inlineZBang();
		VAL v24 = (lpop(&lbl_ftag));
		decref(v24);
	} else {
	}
	VAL v25 = (lpop(&lbl_dat));
	incref(v25);
	push_value(v25);
	lpush(&lbl_dat, v25);
	mw_mirth_data_Data_tags();
	mw_std_list_List_1_ZDivL1();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v26 = pop_value();
			VAL v27 = (lpop(&lbl_dat));
			incref(v27);
			lpush(&lbl_tag, v26);
			push_value(v27);
			lpush(&lbl_dat, v27);
			STRLIT("/", 1);
			VAL v28 = (lpop(&lbl_tag));
			incref(v28);
			push_value(v28);
			lpush(&lbl_tag, v28);
			mw_mirth_data_Tag_name();
			mw_mirth_name_Name_ZToStr();
			mp_primZ_strZ_cat();
			int64_t v29 = (0LL);
			push_i64(v29);
			mw_mirth_elab_dataZ_wordZ_newZBang();
			VAL v30 = pop_value();
			incref(v30);
			push_value(v30);
			lpush(&lbl_untag, v30);
			mtw_std_maybe_Maybe_1_Some();
			VAL v31 = (lpop(&lbl_tag));
			incref(v31);
			push_value(v31);
			lpush(&lbl_tag, v31);
			mfld_mirth_data_Tag_ZTildeuntag();
			mp_primZ_mutZ_set();
			VAL v32 = (lpop(&lbl_tag));
			incref(v32);
			VAL v33 = (lpop(&lbl_untag));
			incref(v33);
			push_value(v32);
			lpush(&lbl_tag, v32);
			push_value(v33);
			lpush(&lbl_untag, v33);
			mtw_mirth_mirth_PropLabel_WordType();
			VAL v34 = (MKFNPTR(&mb_mirth_elab_elabZ_dataZ_doneZBang_5));
			push_value(v34);
			mw_mirth_mirth_PropLabel_prop_1();
			VAL v35 = (lpop(&lbl_untag));
			incref(v35);
			push_value(v35);
			lpush(&lbl_untag, v35);
			mfld_mirth_word_Word_ZTildectxZ_type();
			mp_primZ_mutZ_set();
			VAL v36 = (lpop(&lbl_tag));
			incref(v36);
			VAL v37 = (lpop(&lbl_untag));
			incref(v37);
			push_value(v36);
			lpush(&lbl_tag, v36);
			push_value(v37);
			lpush(&lbl_untag, v37);
			mtw_mirth_mirth_PropLabel_WordArrow();
			VAL v38 = (MKFNPTR(&mb_mirth_elab_elabZ_dataZ_doneZBang_6));
			push_value(v38);
			mw_mirth_mirth_PropLabel_prop_1();
			VAL v39 = (lpop(&lbl_untag));
			incref(v39);
			push_value(v39);
			lpush(&lbl_untag, v39);
			mfld_mirth_word_Word_ZTildearrow();
			mp_primZ_mutZ_set();
			VAL v40 = (lpop(&lbl_untag));
			incref(v40);
			push_value(v40);
			lpush(&lbl_untag, v40);
			mw_mirth_word_Word_makeZ_inlineZBang();
			VAL v41 = (lpop(&lbl_tag));
			incref(v41);
			push_value(v41);
			lpush(&lbl_tag, v41);
			mw_mirth_elab_createZ_projectorsZBang();
			VAL v42 = (lpop(&lbl_tag));
			VAL v43 = (lpop(&lbl_untag));
			decref(v43);
			decref(v42);
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v44 = (lpop(&lbl_dat));
	incref(v44);
	incref(v44);
	push_value(v44);
	push_value(v44);
	lpush(&lbl_dat, v44);
	mtw_mirth_mirth_PropLabel_DataCType();
	VAL v45 = (MKFNPTR(&mb_mirth_elab_elabZ_dataZ_doneZBang_12));
	push_value(v45);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v46 = (lpop(&lbl_dat));
	incref(v46);
	push_value(v46);
	lpush(&lbl_dat, v46);
	mfld_mirth_data_Data_ZTildectypeZAsk();
	mp_primZ_mutZ_set();
	VAL v47 = (lpop(&lbl_dat));
	decref(v47);
}
static void mw_mirth_data_Tag_outputZ_type (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_type();
	mw_mirth_type_ArrowType_cod();
	mw_mirth_type_StackType_expand();
	switch (get_top_data_tag()) {
		case 5LL: { // STCons
			mtp_mirth_type_StackType_STCons();
			mtw_std_either_Either_2_Left();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			decref(v3);
			push_value(v1);
		} break;
		case 7LL: { // STWith
			mtp_mirth_type_StackType_STWith();
			mtw_std_either_Either_2_Right();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
			push_value(v4);
		} break;
		default: {
			VAL v7 = pop_value();
			decref(v7);
			VAL v8 = pop_value();
			STRLIT("Unexpected output type for constructor ", 39);
			push_value(v8);
			mw_mirth_data_Tag_qname();
			mw_mirth_name_QName_ZToStr();
			mp_primZ_strZ_cat();
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_outputZ_type();
	switch (get_top_data_tag()) {
		case 0LL: { // Left
			mtp_std_either_Either_2_Left();
			mw_mirth_type_Type_exceptZ_field();
			mtw_std_either_Either_2_Left();
		} break;
		case 1LL: { // Right
			mtp_std_either_Either_2_Right();
			mw_mirth_type_Resource_exceptZ_field();
			mtw_std_either_Either_2_Right();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_data_Tag_projectZ_inputZ_label (void) {
	mw_mirth_data_Tag_type();
	mw_mirth_type_ArrowType_dom();
	mw_mirth_type_StackType_labelZ_topZAsk();
}
static void mw_mirth_elab_dataZ_getZ_labelZ_type (void) {
	{
		VAL v0 = pop_value();
		VAL var_lbl = v0;
		VAL v1 = pop_value();
		VAL var_tag = v1;
		incref(var_lbl);
		VAL v2 = (var_lbl);
		push_value(v2);
		incref(var_tag);
		VAL v3 = (var_tag);
		push_value(v3);
		mw_mirth_data_Tag_projectZ_inputZ_label();
		mw_std_maybe_Maybe_1_unwrap();
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				mw_mirth_type_T0();
				incref(var_tag);
				VAL v4 = (var_tag);
				push_value(v4);
				mw_mirth_data_Tag_outputZ_type();
				mw_mirth_type_TZMulZPlus();
				VAL v5 = pop_value();
				VAL v6 = pop_value();
				push_value(v5);
				push_value(v6);
				mw_mirth_type_T1();
				incref(var_tag);
				VAL v7 = (var_tag);
				push_value(v7);
				mw_mirth_data_Tag_data();
				mw_mirth_data_Data_isZ_resourceZAsk();
				VAL v8 = (MKFNPTR(&mb_mirth_elab_dataZ_getZ_labelZ_type_0));
				push_value(v8);
				incref(var_tag);
				VAL v9 = (var_tag);
				push_value(v9);
				mp_primZ_packZ_cons();
				{
					VAL v10 = pop_value();
					VAL var_f = v10;
					VAL v11 = pop_value();
					if (VBOOL(v11)) {
						incref(var_f);
						run_value(var_f);
					} else {
					}
					decref(var_f);
				}
				mw_mirth_type_TZ_ZTo();
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				mw_mirth_type_T0();
				incref(var_tag);
				VAL v12 = (var_tag);
				push_value(v12);
				mw_mirth_data_Tag_outputZ_type();
				mw_mirth_type_TZMulZPlus();
				mw_mirth_type_T0();
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				VAL v15 = pop_value();
				push_value(v14);
				push_value(v13);
				push_value(v15);
				mw_mirth_type_TZPlus();
				incref(var_lbl);
				VAL v16 = (var_lbl);
				push_value(v16);
				incref(var_tag);
				VAL v17 = (var_tag);
				push_value(v17);
				mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field();
				mw_mirth_type_TZMulZPlus();
				mw_mirth_type_TZ_ZTo();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		decref(var_lbl);
		decref(var_tag);
	}
}
static void mw_mirth_elab_dataZ_setZ_labelZ_type (void) {
	{
		VAL v0 = pop_value();
		VAL var_lbl = v0;
		VAL v1 = pop_value();
		VAL var_tag = v1;
		incref(var_lbl);
		VAL v2 = (var_lbl);
		push_value(v2);
		incref(var_tag);
		VAL v3 = (var_tag);
		push_value(v3);
		mw_mirth_data_Tag_projectZ_inputZ_label();
		mw_std_maybe_Maybe_1_unwrap();
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				mw_mirth_type_T1();
				incref(var_tag);
				VAL v4 = (var_tag);
				push_value(v4);
				mw_mirth_data_Tag_outputZ_type();
				mw_mirth_type_TZMulZPlus();
				mw_mirth_type_T0();
				incref(var_tag);
				VAL v5 = (var_tag);
				push_value(v5);
				mw_mirth_data_Tag_outputZ_type();
				mw_mirth_type_TZMulZPlus();
				mw_mirth_type_TZ_ZTo();
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				mw_mirth_type_T0();
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				push_value(v6);
				push_value(v7);
				mw_mirth_type_TZPlus();
				incref(var_lbl);
				VAL v8 = (var_lbl);
				push_value(v8);
				incref(var_tag);
				VAL v9 = (var_tag);
				push_value(v9);
				mw_mirth_data_Tag_outputZ_typeZ_exceptZ_field();
				mw_mirth_type_TZMulZPlus();
				mw_mirth_type_T0();
				incref(var_tag);
				VAL v10 = (var_tag);
				push_value(v10);
				mw_mirth_data_Tag_outputZ_type();
				mw_mirth_type_TZMulZPlus();
				mw_mirth_type_TZ_ZTo();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		decref(var_lbl);
		decref(var_tag);
	}
}
static void mw_mirth_elab_createZ_projectorsZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_data();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	mw_mirth_data_Tag_untag();
	mw_std_maybe_Maybe_1_unwrap();
	{
		VAL v3 = pop_value();
		VAL var_untag = v3;
		VAL v4 = pop_value();
		VAL var_dat = v4;
		VAL v5 = pop_value();
		VAL var_tag = v5;
		incref(var_tag);
		VAL v6 = (var_tag);
		push_value(v6);
		mw_mirth_data_Tag_labelZ_inputs();
		VAL v7 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_0));
		push_value(v7);
		incref(var_dat);
		VAL v8 = (var_dat);
		push_value(v8);
		mp_primZ_packZ_cons();
		incref(var_tag);
		VAL v9 = (var_tag);
		push_value(v9);
		mp_primZ_packZ_cons();
		{
			VAL v10 = pop_value();
			VAL var_f = v10;
			mw_std_list_List_1_reverse();
			incref(var_f);
			VAL v11 = (var_f);
			push_value(v11);
			{
				VAL v12 = pop_value();
				VAL var_f = v12;
				VAL v13 = (MKFNPTR(&mb_std_list_List_1_for_1_0));
				push_value(v13);
				VAL v14 = (MKFNPTR(&mb_std_list_List_1_for_1_1));
				push_value(v14);
				incref(var_f);
				VAL v15 = (var_f);
				push_value(v15);
				mp_primZ_packZ_cons();
				{
					VAL v16 = pop_value();
					VAL var_g = v16;
					VAL v17 = pop_value();
					VAL var_f = v17;
					incref(var_f);
					run_value(var_f);
					while(1) {
						VAL v18 = pop_value();
						incref(v18);
						push_value(v18);
						push_value(v18);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v19 = pop_value();
						if (!VBOOL(v19)) break;
						mw_std_maybe_Maybe_1_unwrap();
						incref(var_g);
						run_value(var_g);
						incref(var_f);
						run_value(var_f);
					}
					VAL v20 = pop_value();
					decref(v20);
					decref(var_g);
					decref(var_f);
				}
				VAL v21 = pop_value();
				decref(v21);
				decref(var_f);
			}
			decref(var_f);
		}
		decref(var_untag);
		decref(var_dat);
		decref(var_tag);
	}
}
static void mw_mirth_elab_expectZ_tokenZ_arrow (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_arrowZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
	} else {
		STRLIT("Expected arrow.", 15);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
}
static void mw_mirth_elab_parseZ_alias (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_succ();
	mw_mirth_token_Token_lparenZAsk();
	mw_std_maybe_Maybe_1_ZToBool();
	VAL v1 = pop_value();
	incref(v1);
	lpush(&lbl_hasZ_paren, v1);
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		mw_mirth_token_Token_next();
		push_value(v2);
		mw_mirth_token_Token_argsZ_2();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		lpush(&lbl_target, v3);
		lpush(&lbl_head, v4);
	} else {
		mw_mirth_token_Token_next();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		lpush(&lbl_head, v5);
		mw_mirth_token_Token_next();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		lpush(&lbl_target, v6);
		mw_mirth_token_Token_next();
	}
	VAL v7 = (lpop(&lbl_head));
	incref(v7);
	push_value(v7);
	lpush(&lbl_head, v7);
	mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v8 = pop_value();
			decref(v8);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v9 = (lpop(&lbl_head));
			incref(v9);
			push_value(v9);
			lpush(&lbl_head, v9);
			STRLIT("expected alias name", 19);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v10 = (lpop(&lbl_target));
	incref(v10);
	push_value(v10);
	lpush(&lbl_target, v10);
	mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v11 = pop_value();
			decref(v11);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v12 = (lpop(&lbl_target));
			incref(v12);
			push_value(v12);
			lpush(&lbl_target, v12);
			STRLIT("expected alias target, which must be a name", 43);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v13 = (lpop(&lbl_target));
	incref(v13);
	push_value(v13);
	lpush(&lbl_target, v13);
	mw_mirth_token_Token_argsZ_0();
	VAL v14 = (lpop(&lbl_hasZ_paren));
	incref(v14);
	lpush(&lbl_hasZ_paren, v14);
	if (VBOOL(v14)) {
		VAL v15 = (lpop(&lbl_head));
		incref(v15);
		push_value(v15);
		lpush(&lbl_head, v15);
		mw_mirth_token_Token_next();
		mw_mirth_token_Token_argZ_endZAsk();
		VAL v16 = pop_value();
		if (VBOOL(v16)) {
		} else {
			VAL v17 = (lpop(&lbl_head));
			incref(v17);
			push_value(v17);
			lpush(&lbl_head, v17);
			STRLIT("expected comma after alias name", 31);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
		VAL v18 = (lpop(&lbl_target));
		incref(v18);
		push_value(v18);
		lpush(&lbl_target, v18);
		mw_mirth_token_Token_succ();
		mw_mirth_token_Token_argZ_endZAsk();
		VAL v19 = pop_value();
		if (VBOOL(v19)) {
		} else {
			VAL v20 = (lpop(&lbl_head));
			incref(v20);
			push_value(v20);
			lpush(&lbl_head, v20);
			STRLIT("expected end of arguments after alias target", 44);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
	} else {
	}
	VAL v21 = (lpop(&lbl_hasZ_paren));
	decref(v21);
}
static void mw_mirth_elab_elabZ_aliasZBang (void) {
	mw_mirth_elab_parseZ_alias();
	mw_mirth_elab_elabZ_defZ_head();
	mw_mirth_alias_Alias_newZBang();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mtw_mirth_mirth_PropLabel_AliasQName();
	VAL v1 = pop_value();
	lpush(&lbl_label, v1);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mfld_mirth_alias_Alias_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v4 = (lpop(&lbl_target));
	VAL v5 = pop_value();
	incref(v5);
	incref(v5);
	push_value(v5);
	push_value(v4);
	push_value(v5);
	push_value(v5);
	mtw_mirth_mirth_PropLabel_AliasTarget();
	VAL v6 = (MKFNPTR(&mb_mirth_elab_elabZ_aliasZBang_0));
	push_value(v6);
	mw_mirth_mirth_PropLabel_prop2_1();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v8);
	mfld_mirth_alias_Alias_ZTildetarget();
	mp_primZ_mutZ_set();
}
static void mw_mirth_elab_elabZ_defZ_missingZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_args();
	mw_std_list_List_1_len();
	int64_t v1 = (3LL);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	bool v4 = (VI64(v3) < VI64(v2));
	if (v4) {
		STRLIT("def-missing expects at least three arguments", 44);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	} else {
	}
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v5);
	mw_mirth_token_Token_succ();
	mw_mirth_token_Token_succ();
	mw_mirth_elab_elabZ_defZ_qname();
	mw_mirth_name_QName_definedZ_hardZAsk();
	VAL v6 = pop_value();
	if (VBOOL(v6)) {
		mw_mirth_token_Token_next();
	} else {
		mw_mirth_elab_elabZ_defZBang();
	}
}
static void mw_mirth_elab_elabZ_inlineZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_1();
	VAL v1 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v2 = (1LL /* True */);
	push_value(v1);
	push_u64(v2);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_token_Token_argZ_endZAsk();
		VAL v4 = pop_value();
		if (VBOOL(v4)) {
			uint64_t v5 = (0LL /* False */);
			push_u64(v5);
		} else {
			uint64_t v6 = (1LL /* True */);
			push_u64(v6);
		}
		VAL v7 = pop_value();
		if (!VBOOL(v7)) break;
		mw_mirth_elab_elabZ_moduleZ_declZBang();
	}
	VAL v8 = pop_value();
	decref(v8);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_elab_parseZ_def (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_args();
	mw_std_list_List_1_emptyZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_token_Token_next();
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		lpush(&lbl_head, v2);
		mw_mirth_token_Token_next();
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_token_Token_lsquareZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v4 = pop_value();
				decref(v4);
				VAL v5 = pop_value();
				incref(v5);
				push_value(v5);
				push_value(v5);
				mw_mirth_token_Token_argsZ_1();
				mtw_std_maybe_Maybe_1_Some();
				VAL v6 = pop_value();
				lpush(&lbl_sigZAsk, v6);
				mw_mirth_token_Token_next();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v7 = (0LL /* None */);
				lpush(&lbl_sigZAsk, MKU64(v7));
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		mw_mirth_token_Token_lcurlyZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v9 = pop_value();
				decref(v9);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("expected { ... }", 16);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v10);
		mw_mirth_token_Token_argsZPlus();
		VAL v11 = pop_value();
		lpush(&lbl_body, v11);
		mw_mirth_token_Token_next();
	} else {
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		mw_mirth_token_Token_next();
		incref(v12);
		push_value(v12);
		push_value(v12);
		mw_mirth_token_Token_args();
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v13);
		mw_std_list_List_1_len();
		int64_t v14 = (3LL);
		push_i64(v14);
		mw_std_prim_Int_ZToNat();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		bool v17 = (VI64(v16) < VI64(v15));
		if (v17) {
			VAL v18 = pop_value();
			decref(v18);
			STRLIT("def(...) expects at least three arguments", 41);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} else {
		}
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		decref(v20);
		push_value(v19);
		mw_std_list_List_1_ZToListZPlus();
		mw_std_maybe_Maybe_1_unwrap();
		mw_std_list_ListZPlus_1_uncons();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		lpush(&lbl_head, v22);
		push_value(v21);
		mw_std_list_List_1_ZToListZPlus();
		mw_std_maybe_Maybe_1_unwrap();
		mw_std_list_ListZPlus_1_uncons();
		VAL v23 = pop_value();
		mtw_std_maybe_Maybe_1_Some();
		VAL v24 = pop_value();
		lpush(&lbl_sigZAsk, v24);
		push_value(v23);
		mw_std_list_List_1_ZToListZPlus();
		mw_std_maybe_Maybe_1_unwrap();
		VAL v25 = pop_value();
		VAL v26 = (lpop(&lbl_head));
		incref(v26);
		lpush(&lbl_body, v25);
		push_value(v26);
		lpush(&lbl_head, v26);
		mw_mirth_token_Token_next();
		mw_mirth_token_Token_argZ_endZAsk();
		VAL v27 = pop_value();
		if (VBOOL(v27)) {
		} else {
			VAL v28 = (lpop(&lbl_head));
			incref(v28);
			push_value(v28);
			lpush(&lbl_head, v28);
			mw_mirth_token_Token_next();
			STRLIT("expected comma after word name", 30);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
	}
	VAL v29 = (lpop(&lbl_body));
	push_value(v29);
	mw_std_list_ListZPlus_1_uncons();
	mw_std_list_List_1_emptyZAsk();
	VAL v30 = pop_value();
	if (VBOOL(v30)) {
		uint64_t v31 = (1LL /* True */);
		push_u64(v31);
	} else {
		VAL v32 = pop_value();
		incref(v32);
		push_value(v32);
		push_value(v32);
		mw_mirth_token_Token_runZ_arrowZAsk();
		mw_std_maybe_Maybe_1_ZToBool();
	}
	VAL v33 = pop_value();
	if (VBOOL(v33)) {
	} else {
		STRLIT("expected match case", 19);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
	VAL v34 = pop_value();
	lpush(&lbl_body, v34);
	mtw_mirth_elab_SyntaxDef_SyntaxDef();
}
static void mw_mirth_elab_elabZ_defZBang (void) {
	mw_mirth_elab_parseZ_def();
	switch (get_top_data_tag()) {
		case 0LL: { // SyntaxDef
			mtp_mirth_elab_SyntaxDef_SyntaxDef();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_elab_elabZ_defZ_head();
	mw_mirth_word_Word_newZBang();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_word, v0);
	mtw_mirth_mirth_PropLabel_WordQName();
	VAL v1 = pop_value();
	lpush(&lbl_label, v1);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v2 = (lpop(&lbl_word));
	incref(v2);
	push_value(v2);
	lpush(&lbl_word, v2);
	mfld_mirth_word_Word_ZTildeqname();
	mp_primZ_mutZ_set();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v3 = (lpop(&lbl_word));
	incref(v3);
	push_value(v3);
	lpush(&lbl_word, v3);
	mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk();
	mp_primZ_mutZ_set();
	VAL v4 = (lpop(&lbl_word));
	incref(v4);
	incref(v4);
	push_value(v4);
	push_value(v4);
	lpush(&lbl_word, v4);
	mtw_mirth_mirth_PropLabel_WordType();
	VAL v5 = (MKFNPTR(&mb_mirth_elab_elabZ_defZBang_0));
	push_value(v5);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v6 = (lpop(&lbl_word));
	incref(v6);
	push_value(v6);
	lpush(&lbl_word, v6);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v7 = (lpop(&lbl_word));
	incref(v7);
	incref(v7);
	push_value(v7);
	push_value(v7);
	lpush(&lbl_word, v7);
	mtw_mirth_mirth_PropLabel_WordParams();
	VAL v8 = (MKFNPTR(&mb_mirth_elab_elabZ_defZBang_2));
	push_value(v8);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v9 = (lpop(&lbl_word));
	incref(v9);
	push_value(v9);
	lpush(&lbl_word, v9);
	mfld_mirth_word_Word_ZTildeparams();
	mp_primZ_mutZ_set();
	VAL v10 = (lpop(&lbl_word));
	incref(v10);
	incref(v10);
	push_value(v10);
	push_value(v10);
	lpush(&lbl_word, v10);
	mtw_mirth_mirth_PropLabel_WordArrow();
	VAL v11 = (MKFNPTR(&mb_mirth_elab_elabZ_defZBang_3));
	push_value(v11);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v12 = (lpop(&lbl_word));
	incref(v12);
	push_value(v12);
	lpush(&lbl_word, v12);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v13 = (lpop(&lbl_word));
	decref(v13);
}
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		push_value(v4);
		mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
	}
	VAL v9 = pop_value();
	decref(v9);
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_atomZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mw_mirth_word_Word_preferZ_inlineZAsk();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		incref(v3);
		push_value(v4);
		push_value(v3);
		push_value(v4);
		push_value(v3);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 9, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang();
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 9, v);
			VAL* p = &VTUP(v)->cells[5];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_std_list_List_1_uncons();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		push_value(v5);
		push_value(v6);
		while(1) {
			VAL v7 = pop_value();
			incref(v7);
			push_value(v7);
			push_value(v7);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v8 = pop_value();
			if (!VBOOL(v8)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			incref(v11);
			push_value(v11);
			push_value(v11);
			push_value(v9);
			mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang();
			push_value(v10);
			mw_std_list_List_1_uncons();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			push_value(v12);
			push_value(v13);
		}
		VAL v14 = pop_value();
		decref(v14);
		VAL v15 = pop_value();
		decref(v15);
		VAL v16 = pop_value();
		decref(v16);
	} else {
		VAL v17 = pop_value();
		decref(v17);
		VAL v18 = pop_value();
		decref(v18);
	}
}
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_argZBang (void) {
	mw_mirth_arrow_Block_arrow();
	mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang();
}
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_opZBang (void) {
	switch (get_top_data_tag()) {
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			mw_mirth_arrow_Block_arrow();
			mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang();
		} break;
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			incref(v1);
			incref(v0);
			push_value(v1);
			push_value(v0);
			push_value(v1);
			push_value(v0);
			mw_mirth_word_Word_ZEqualZEqual();
			VAL v2 = pop_value();
			if (VBOOL(v2)) {
				VAL v3 = pop_value();
				decref(v3);
				mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang();
			} else {
				VAL v4 = pop_value();
				incref(v4);
				push_value(v4);
				push_value(v4);
				mw_mirth_word_Word_preferZ_inlineZAsk();
				VAL v5 = pop_value();
				if (VBOOL(v5)) {
					mfld_mirth_word_Word_ZTildearrow();
					mw_mirth_mirth_Prop_1_tryZ_forceZBang();
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang();
						} break;
						case 0LL: { // None
							(void)pop_u64();
							mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} else {
					VAL v6 = pop_value();
					decref(v6);
					VAL v7 = pop_value();
					decref(v7);
				}
			}
		} break;
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 8, v);
				VAL* p = &VTUP(v)->cells[7];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_std_list_List_1_uncons();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			push_value(v8);
			push_value(v9);
			while(1) {
				VAL v10 = pop_value();
				incref(v10);
				push_value(v10);
				push_value(v10);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v11 = pop_value();
				if (!VBOOL(v11)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v12 = pop_value();
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				incref(v14);
				push_value(v14);
				push_value(v14);
				push_value(v12);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang();
				push_value(v13);
				mw_std_list_List_1_uncons();
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				push_value(v15);
				push_value(v16);
			}
			VAL v17 = pop_value();
			decref(v17);
			VAL v18 = pop_value();
			decref(v18);
			VAL v19 = pop_value();
			decref(v19);
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 6, v);
				VAL* p = &VTUP(v)->cells[5];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang();
		} break;
		default: {
			VAL v20 = pop_value();
			decref(v20);
			VAL v21 = pop_value();
			decref(v21);
		} break;
	}
}
static void mw_mirth_elab_checkZ_inlineZ_recursionZ_failedZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_word_Word_preferZ_inlineZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		uint64_t v2 = (0LL /* False */);
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_u64(v2);
		push_value(v3);
		mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk();
		mp_primZ_mutZ_set();
		mw_mirth_word_Word_head();
		STRLIT("recursive word cannot be inlined", 32);
		mw_mirth_mirth_ZPlusMirth_emitZ_warningZBang();
	} else {
		VAL v4 = pop_value();
		decref(v4);
	}
}
static void mw_mirth_elab_elabZ_defZ_paramsZBang (void) {
	uint64_t v0 = (0LL /* Nil */);
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_u64(v0);
	push_value(v1);
	mw_mirth_word_Word_type();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v2);
	push_value(v4);
	mw_mirth_word_Word_head();
	VAL v5 = pop_value();
	mw_mirth_type_ArrowType_unpack();
	VAL v6 = pop_value();
	decref(v6);
	push_value(v5);
	mw_mirth_token_Token_args();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v8);
	while(1) {
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_value(v9);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v10 = pop_value();
		if (!VBOOL(v10)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		incref(v11);
		push_value(v11);
		push_value(v11);
		mw_mirth_token_Token_sigZ_paramZ_nameZAsk();
		VAL v13 = pop_value();
		if (VBOOL(v13)) {
		} else {
			STRLIT("expected parameter name", 23);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
		VAL v14 = pop_value();
		incref(v14);
		push_value(v14);
		push_value(v14);
		mw_mirth_token_Token_succ();
		VAL v15 = pop_value();
		incref(v15);
		push_value(v15);
		push_value(v15);
		mw_mirth_token_Token_runZ_endZAsk();
		VAL v16 = pop_value();
		if (VBOOL(v16)) {
			VAL v17 = pop_value();
			decref(v17);
		} else {
			STRLIT("expected right paren or comma", 29);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		}
		mw_mirth_elab_elabZ_expandZ_tensorZBang();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		incref(v19);
		push_value(v19);
		push_value(v18);
		push_value(v19);
		mw_mirth_type_Type_morphismZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v20 = pop_value();
				decref(v20);
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("need function type for param", 28);
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_token_Token_nameZAsk();
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_var_Var_newZ_autoZ_runZBang();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		push_value(v21);
		push_value(v23);
		mtw_std_list_List_1_Cons();
		push_value(v22);
		push_value(v12);
		mw_std_list_List_1_uncons();
		VAL v24 = pop_value();
		VAL v25 = pop_value();
		push_value(v24);
		push_value(v25);
	}
	VAL v26 = pop_value();
	decref(v26);
	VAL v27 = pop_value();
	decref(v27);
	VAL v28 = pop_value();
	decref(v28);
}
static void mw_mirth_elab_elabZ_defZ_bodyZBang (void) {
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_token_Token_runZ_arrowZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v0 = pop_value();
			decref(v0);
			uint64_t v1 = (1LL /* True */);
			push_u64(v1);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_elab_abZ_tokenZAt();
			mw_mirth_token_Token_lcurlyZAsk();
			mw_std_maybe_Maybe_1_someZAsk();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		lpush(&lbl_cod, v3);
		mw_mirth_elab_abZ_tokenZAt();
		VAL v4 = pop_value();
		lpush(&lbl_body, v4);
		mw_mirth_elab_elabZ_matchZ_atZBang();
	} else {
		mw_mirth_elab_elabZ_atomsZBang();
	}
}
static void mw_mirth_elab_parseZ_externalZ_decl (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_succ();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mw_mirth_token_Token_lparenZ_orZ_lcolonZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v2 = pop_value();
			decref(v2);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_token_Token_pred();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			uint64_t v3 = (36LL /* FGCyan */);
			push_u64(v3);
			mw_std_terminal_Sgr_emitZThen();
			STRLIT("external", 8);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			uint64_t v4 = (0LL /* Reset */);
			push_u64(v4);
			mw_std_terminal_Sgr_emitZThen();
			STRLIT(" requires arguments", 19);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	uint64_t v5 = (0LL /* Nil */);
	push_u64(v5);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_mirth_token_Token_succ();
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_mirth_token_Token_argsZ_endZAsk();
		VAL v7 = pop_value();
		if (VBOOL(v7)) {
			uint64_t v8 = (0LL /* False */);
			push_u64(v8);
		} else {
			uint64_t v9 = (1LL /* True */);
			push_u64(v9);
		}
		VAL v10 = pop_value();
		if (!VBOOL(v10)) break;
		VAL r11 = pop_resource();
		mw_mirth_elab_parseZ_externalZ_declZ_part();
		push_resource(r11);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
	}
	VAL v12 = pop_value();
	decref(v12);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
}
static void mw_mirth_elab_parseZ_externalZ_declZ_part (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_strZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			incref(v2);
			lpush(&lbl_code, v1);
			push_value(v2);
			lpush(&lbl_token, v2);
			mw_mirth_token_Token_succ();
			mtw_mirth_elab_ExternalDeclPart_EDPCode();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v3 = pop_value();
			incref(v3);
			incref(v3);
			lpush(&lbl_head, v3);
			push_value(v3);
			push_value(v3);
			mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v4 = pop_value();
					decref(v4);
				} break;
				case 0LL: { // None
					(void)pop_u64();
					STRLIT("expected external word name", 27);
					mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			mw_mirth_token_Token_succ();
			VAL v5 = pop_value();
			incref(v5);
			push_value(v5);
			push_value(v5);
			mw_mirth_token_Token_arrowZAsk();
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				mw_mirth_token_Token_succ();
				VAL v7 = pop_value();
				incref(v7);
				push_value(v7);
				push_value(v7);
				mw_mirth_token_Token_nameZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v8 = pop_value();
						decref(v8);
					} break;
					case 0LL: { // None
						(void)pop_u64();
						STRLIT("expected external symbol name", 29);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				VAL v9 = pop_value();
				incref(v9);
				push_value(v9);
				push_value(v9);
				mtw_std_maybe_Maybe_1_Some();
				VAL v10 = pop_value();
				lpush(&lbl_symbol, v10);
				mw_mirth_token_Token_succ();
			} else {
				uint64_t v11 = (0LL /* None */);
				lpush(&lbl_symbol, MKU64(v11));
			}
			VAL v12 = pop_value();
			incref(v12);
			push_value(v12);
			push_value(v12);
			mw_mirth_token_Token_lsquareZAsk();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v13 = pop_value();
					decref(v13);
					VAL v14 = pop_value();
					incref(v14);
					push_value(v14);
					push_value(v14);
					mw_mirth_token_Token_argsZ_1();
					VAL v15 = pop_value();
					lpush(&lbl_sig, v15);
					mw_mirth_token_Token_next();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					VAL v16 = pop_value();
					incref(v16);
					push_value(v16);
					push_value(v16);
					mw_mirth_token_Token_commaZAsk();
					VAL v17 = pop_value();
					if (VBOOL(v17)) {
					} else {
						STRLIT("expected type signature", 23);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
					}
					mw_mirth_token_Token_succ();
					VAL v18 = pop_value();
					incref(v18);
					push_value(v18);
					push_value(v18);
					mw_mirth_token_Token_argZ_endZAsk();
					VAL v19 = pop_value();
					if (VBOOL(v19)) {
						STRLIT("expected type signature", 23);
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
					} else {
					}
					VAL v20 = pop_value();
					incref(v20);
					push_value(v20);
					lpush(&lbl_sig, v20);
					mw_mirth_token_Token_nextZ_argZ_end();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			mtw_mirth_elab_ExternalDeclPart_EDPDef();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v21 = pop_value();
	VAL v22 = pop_value();
	incref(v22);
	push_value(v22);
	push_value(v22);
	mw_mirth_token_Token_commaZAsk();
	VAL v23 = pop_value();
	if (VBOOL(v23)) {
		mw_mirth_token_Token_succ();
	} else {
	}
	push_value(v21);
}
static void mw_mirth_elab_elabZ_externalZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_token, v0);
	mw_mirth_elab_parseZ_externalZ_decl();
	uint64_t v1 = (0LL /* Nil */);
	push_u64(v1);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		push_value(v6);
		mw_mirth_elab_elabZ_externalZ_blockZ_partZBang();
		push_resource(r8);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v13 = pop_value();
	lpush(&lbl_parts, v13);
	mw_mirth_external_ExternalBlock_allocZBang();
	VAL v14 = pop_value();
	VAL v15 = (lpop(&lbl_token));
	incref(v14);
	push_value(v15);
	push_value(v14);
	lpush(&lbl_extblock, v14);
	mfld_mirth_external_ExternalBlock_ZTildetoken();
	mp_primZ_mutZ_set();
	VAL v16 = (lpop(&lbl_parts));
	VAL v17 = (lpop(&lbl_extblock));
	incref(v17);
	push_value(v16);
	push_value(v17);
	lpush(&lbl_extblock, v17);
	mfld_mirth_external_ExternalBlock_ZTildeparts();
	mp_primZ_mutZ_set();
	VAL v18 = (lpop(&lbl_extblock));
	decref(v18);
}
static void mw_mirth_elab_elabZ_externalZ_blockZ_partZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // EDPCode
			mtp_mirth_elab_ExternalDeclPart_EDPCode();
			VAL v0 = (lpop(&lbl_token));
			decref(v0);
			VAL v1 = (lpop(&lbl_code));
			push_value(v1);
			mtw_mirth_external_ExternalBlockPart_EBPCode();
		} break;
		case 1LL: { // EDPDef
			mtp_mirth_elab_ExternalDeclPart_EDPDef();
			mw_mirth_elab_elabZ_externalZ_defZBang();
			mtw_mirth_external_ExternalBlockPart_EBPDef();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_externalZ_defZBang (void) {
	mw_mirth_elab_elabZ_defZ_head();
	VAL v0 = (lpop(&lbl_symbol));
	push_value(v0);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_token_Token_nameZAsk();
			mw_std_maybe_Maybe_1_unwrap();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v1 = (lpop(&lbl_name));
			incref(v1);
			push_value(v1);
			lpush(&lbl_name, v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_name_Name_ZToStr();
	VAL v2 = pop_value();
	lpush(&lbl_symbol, v2);
	mw_mirth_external_External_allocZBang();
	VAL v3 = pop_value();
	VAL v4 = (lpop(&lbl_name));
	incref(v3);
	push_value(v4);
	push_value(v3);
	lpush(&lbl_external, v3);
	mfld_mirth_external_External_ZTildename();
	mp_primZ_mutZ_set();
	VAL v5 = (lpop(&lbl_arity));
	VAL v6 = (lpop(&lbl_external));
	incref(v6);
	push_value(v5);
	push_value(v6);
	lpush(&lbl_external, v6);
	mfld_mirth_external_External_ZTildearity();
	mp_primZ_mutZ_set();
	VAL v7 = (lpop(&lbl_external));
	incref(v7);
	push_value(v7);
	lpush(&lbl_external, v7);
	mtw_mirth_mirth_PropLabel_ExternalQName();
	VAL v8 = pop_value();
	lpush(&lbl_label, v8);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v9 = (lpop(&lbl_external));
	incref(v9);
	push_value(v9);
	lpush(&lbl_external, v9);
	mfld_mirth_external_External_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v10 = (lpop(&lbl_symbol));
	VAL v11 = (lpop(&lbl_external));
	incref(v11);
	push_value(v10);
	push_value(v11);
	lpush(&lbl_external, v11);
	mfld_mirth_external_External_ZTildesymbol();
	mp_primZ_mutZ_set();
	VAL v12 = (lpop(&lbl_sig));
	VAL v13 = (lpop(&lbl_external));
	incref(v13);
	push_value(v12);
	push_value(v13);
	lpush(&lbl_external, v13);
	mfld_mirth_external_External_ZTildesig();
	mp_primZ_mutZ_set();
	VAL v14 = (lpop(&lbl_head));
	VAL v15 = (lpop(&lbl_external));
	incref(v15);
	push_value(v14);
	push_value(v15);
	lpush(&lbl_external, v15);
	mfld_mirth_external_External_ZTildehead();
	mp_primZ_mutZ_set();
	VAL v16 = (lpop(&lbl_external));
	incref(v16);
	incref(v16);
	lpush(&lbl_external, v16);
	push_value(v16);
	push_value(v16);
	mtw_mirth_mirth_PropLabel_ExternalType();
	VAL v17 = (MKFNPTR(&mb_mirth_elab_elabZ_externalZ_defZBang_2));
	push_value(v17);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v18 = (lpop(&lbl_external));
	incref(v18);
	push_value(v18);
	lpush(&lbl_external, v18);
	mfld_mirth_external_External_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v19 = (lpop(&lbl_external));
	incref(v19);
	incref(v19);
	lpush(&lbl_external, v19);
	push_value(v19);
	push_value(v19);
	mtw_mirth_mirth_PropLabel_ExternalCType();
	VAL v20 = (MKFNPTR(&mb_mirth_elab_elabZ_externalZ_defZBang_4));
	push_value(v20);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v21 = (lpop(&lbl_external));
	incref(v21);
	push_value(v21);
	lpush(&lbl_external, v21);
	mfld_mirth_external_External_ZTildectype();
	mp_primZ_mutZ_set();
	VAL v22 = (lpop(&lbl_external));
	incref(v22);
	push_value(v22);
	lpush(&lbl_external, v22);
	mtw_mirth_def_Def_DefExternal();
	mw_mirth_def_Def_register();
	VAL v23 = (lpop(&lbl_external));
	push_value(v23);
}
static void mw_mirth_elab_elabZ_defZ_externalZ_ctype (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_external_External_head();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v1 = pop_value();
	mtw_std_maybe_Maybe_1_Some();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_external_External_type();
	mw_mirth_type_ArrowType_ctype();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v2);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v3 = (0LL /* Nil */);
	push_u64(v3);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	push_value(v4);
	push_value(v5);
	while(1) {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v7 = pop_value();
		if (!VBOOL(v7)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		VAL r10 = pop_resource();
		incref(v8);
		push_value(v8);
		mw_mirth_type_CTypeStackPart_labelZAsk();
		mw_std_maybe_Maybe_1_noneZAsk();
		VAL v11 = pop_value();
		push_value(v8);
		if (VBOOL(v11)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (0LL /* None */);
			push_u64(v13);
		}
		push_resource(r10);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v9);
		mw_std_list_List_1_uncons();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		push_value(v14);
		push_value(v15);
	}
	VAL v16 = pop_value();
	decref(v16);
	VAL v17 = pop_value();
	decref(v17);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	uint64_t v18 = (0LL /* Nil */);
	push_u64(v18);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v19 = pop_value();
	VAL v20 = pop_value();
	push_value(v19);
	push_value(v20);
	while(1) {
		VAL v21 = pop_value();
		incref(v21);
		push_value(v21);
		push_value(v21);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v22 = pop_value();
		if (!VBOOL(v22)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		VAL r25 = pop_resource();
		incref(v23);
		push_value(v23);
		mw_mirth_type_CTypeStackPart_ctype();
		mw_mirth_type_CType_phantomZAsk();
		VAL v26 = pop_value();
		if (VBOOL(v26)) {
			uint64_t v27 = (0LL /* False */);
			push_u64(v27);
		} else {
			uint64_t v28 = (1LL /* True */);
			push_u64(v28);
		}
		VAL v29 = pop_value();
		push_value(v23);
		if (VBOOL(v29)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v30 = pop_value();
			decref(v30);
			uint64_t v31 = (0LL /* None */);
			push_u64(v31);
		}
		push_resource(r25);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v24);
		mw_std_list_List_1_uncons();
		VAL v32 = pop_value();
		VAL v33 = pop_value();
		push_value(v32);
		push_value(v33);
	}
	VAL v34 = pop_value();
	decref(v34);
	VAL v35 = pop_value();
	decref(v35);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_len();
	int64_t v36 = (1LL);
	push_i64(v36);
	mw_std_prim_Int_ZToNat();
	VAL v37 = pop_value();
	VAL v38 = pop_value();
	bool v39 = (VI64(v37) < VI64(v38));
	if (v39) {
		STRLIT("External has too many outputs.", 30);
		mw_mirth_mirth_ZPlusMirth_errorZBang();
	} else {
	}
	VAL v40 = pop_value();
	incref(v40);
	push_value(v40);
	push_value(v40);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v41 = (0LL /* Nil */);
	push_u64(v41);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v42 = pop_value();
	VAL v43 = pop_value();
	push_value(v42);
	push_value(v43);
	while(1) {
		VAL v44 = pop_value();
		incref(v44);
		push_value(v44);
		push_value(v44);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v45 = pop_value();
		if (!VBOOL(v45)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v46 = pop_value();
		VAL v47 = pop_value();
		VAL r48 = pop_resource();
		push_value(v46);
		mw_mirth_type_CTypeStackPart_labelZAsk();
		push_resource(r48);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v47);
		mw_std_list_List_1_uncons();
		VAL v49 = pop_value();
		VAL v50 = pop_value();
		push_value(v49);
		push_value(v50);
	}
	VAL v51 = pop_value();
	decref(v51);
	VAL v52 = pop_value();
	decref(v52);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v53 = pop_value();
	VAL v54 = pop_value();
	incref(v54);
	push_value(v54);
	push_value(v53);
	push_value(v54);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v55 = (0LL /* Nil */);
	push_u64(v55);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v56 = pop_value();
	VAL v57 = pop_value();
	push_value(v56);
	push_value(v57);
	while(1) {
		VAL v58 = pop_value();
		incref(v58);
		push_value(v58);
		push_value(v58);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v59 = pop_value();
		if (!VBOOL(v59)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v60 = pop_value();
		VAL v61 = pop_value();
		VAL r62 = pop_resource();
		push_value(v60);
		mw_mirth_type_CTypeStackPart_labelZAsk();
		push_resource(r62);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v61);
		mw_std_list_List_1_uncons();
		VAL v63 = pop_value();
		VAL v64 = pop_value();
		push_value(v63);
		push_value(v64);
	}
	VAL v65 = pop_value();
	decref(v65);
	VAL v66 = pop_value();
	decref(v66);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v67 = pop_value();
	VAL v68 = pop_value();
	uint64_t v69 = (0LL /* Nil */);
	push_value(v68);
	push_value(v67);
	push_u64(v69);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v70 = pop_value();
	VAL v71 = pop_value();
	push_value(v70);
	push_value(v71);
	while(1) {
		VAL v72 = pop_value();
		incref(v72);
		push_value(v72);
		push_value(v72);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v73 = pop_value();
		if (!VBOOL(v73)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v74 = pop_value();
		VAL v75 = pop_value();
		VAL r76 = pop_resource();
		incref(v74);
		VAL v77 = pop_value();
		incref(v77);
		uint64_t v78 = (0LL /* None */);
		push_value(v74);
		push_u64(v78);
		push_value(v77);
		mw_std_list_List_1_uncons();
		VAL v79 = pop_value();
		VAL v80 = pop_value();
		push_value(v79);
		push_value(v80);
		while(1) {
			VAL v81 = pop_value();
			incref(v81);
			push_value(v81);
			push_value(v81);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v82 = pop_value();
			if (!VBOOL(v82)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v83 = pop_value();
			VAL v84 = pop_value();
			VAL v85 = pop_value();
			incref(v83);
			VAL v86 = pop_value();
			incref(v86);
			push_value(v86);
			push_value(v83);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v87 = pop_value();
			push_value(v86);
			push_value(v83);
			if (VBOOL(v87)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v88 = pop_value();
				decref(v88);
				uint64_t v89 = (0LL /* None */);
				push_u64(v89);
			}
			VAL v90 = pop_value();
			push_value(v85);
			push_value(v84);
			push_value(v90);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v91 = pop_value();
					VAL v92 = pop_value();
					decref(v92);
					VAL v93 = pop_value();
					decref(v93);
					uint64_t v94 = (0LL /* Nil */);
					push_value(v91);
					push_u64(v94);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v95 = pop_value();
			VAL v96 = pop_value();
			push_value(v95);
			push_value(v96);
		}
		VAL v97 = pop_value();
		decref(v97);
		VAL v98 = pop_value();
		decref(v98);
		VAL v99 = pop_value();
		VAL v100 = pop_value();
		decref(v100);
		push_value(v99);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v101 = pop_value();
		if (VBOOL(v101)) {
			uint64_t v102 = (0LL /* False */);
			push_u64(v102);
		} else {
			uint64_t v103 = (1LL /* True */);
			push_u64(v103);
		}
		VAL v104 = pop_value();
		push_value(v77);
		push_value(v74);
		if (VBOOL(v104)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v105 = pop_value();
			decref(v105);
			uint64_t v106 = (0LL /* None */);
			push_u64(v106);
		}
		push_resource(r76);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v75);
		mw_std_list_List_1_uncons();
		VAL v107 = pop_value();
		VAL v108 = pop_value();
		push_value(v107);
		push_value(v108);
	}
	VAL v109 = pop_value();
	decref(v109);
	VAL v110 = pop_value();
	decref(v110);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v111 = pop_value();
	VAL v112 = pop_value();
	decref(v112);
	push_value(v111);
	mw_std_list_List_1_uncons();
	VAL v113 = pop_value();
	VAL v114 = pop_value();
	push_value(v113);
	push_value(v114);
	while(1) {
		VAL v115 = pop_value();
		incref(v115);
		push_value(v115);
		push_value(v115);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v116 = pop_value();
		if (!VBOOL(v116)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v117 = pop_value();
		VAL v118 = pop_value();
		push_value(v117);
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("Output label ", 13);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mw_mirth_label_Label_name();
		mw_mirth_name_Name_ZToStr();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(" not present in input", 21);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		mw_mirth_mirth_ZPlusMirth_errorZBang();
		push_value(v118);
		mw_std_list_List_1_uncons();
		VAL v119 = pop_value();
		VAL v120 = pop_value();
		push_value(v119);
		push_value(v120);
	}
	VAL v121 = pop_value();
	decref(v121);
	VAL v122 = pop_value();
	decref(v122);
	push_value(v1);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_elab_elabZ_defZ_typeZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_2();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	lpush(&lbl_target, v1);
	push_value(v2);
	lpush(&lbl_head, v2);
	mw_mirth_token_Token_argsZ_0();
	VAL v3 = (lpop(&lbl_head));
	incref(v3);
	push_value(v3);
	lpush(&lbl_head, v3);
	mw_mirth_token_Token_sigZ_typeZ_conZAsk();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
	} else {
		STRLIT("expected type constructor", 25);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
	mw_mirth_elab_elabZ_defZ_head();
	VAL v5 = (lpop(&lbl_head));
	push_value(v5);
	mtw_std_maybe_Maybe_1_Some();
	VAL v6 = pop_value();
	VAL v7 = (lpop(&lbl_arity));
	decref(v7);
	lpush(&lbl_head, v6);
	mw_mirth_typedef_TypeDef_newZBang();
	VAL v8 = (lpop(&lbl_target));
	VAL v9 = pop_value();
	incref(v9);
	push_value(v9);
	push_value(v8);
	push_value(v9);
	mtw_mirth_mirth_PropLabel_TypeDefTarget();
	VAL v10 = (MKFNPTR(&mb_mirth_elab_elabZ_defZ_typeZBang_2));
	push_value(v10);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	push_value(v11);
	push_value(v12);
	mfld_mirth_typedef_TypeDef_ZTildetarget();
	mp_primZ_mutZ_set();
}
static void mw_mirth_elab_elabZ_bufferZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_2();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v1);
	push_value(v2);
	push_value(v2);
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v4);
	push_value(v3);
	push_value(v5);
	push_value(v5);
	mw_mirth_token_Token_intZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("expected buffer size", 20);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
	mw_std_prim_Int_ZToNat();
	mw_mirth_buffer_Buffer_newZBang();
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_elab_elabZ_variableZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_2();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v1);
	push_value(v2);
	push_value(v2);
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined();
	mw_mirth_variable_Variable_newZBang();
	VAL v3 = pop_value();
	incref(v3);
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	push_value(v3);
	mtw_mirth_mirth_PropLabel_VariableType();
	VAL v5 = (MKFNPTR(&mb_mirth_elab_elabZ_variableZBang_1));
	push_value(v5);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	push_value(v6);
	push_value(v7);
	mfld_mirth_variable_Variable_ZTildetype();
	mp_primZ_mutZ_set();
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_elab_elabZ_tableZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_1();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	lpush(&lbl_head, v1);
	mw_mirth_token_Token_sigZ_typeZ_conZAsk();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
	} else {
		VAL v3 = (lpop(&lbl_head));
		incref(v3);
		push_value(v3);
		lpush(&lbl_head, v3);
		STRLIT("expected type name", 18);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
	VAL v4 = (lpop(&lbl_head));
	incref(v4);
	push_value(v4);
	lpush(&lbl_head, v4);
	mw_mirth_token_Token_argsZ_0();
	VAL v5 = (lpop(&lbl_head));
	incref(v5);
	push_value(v5);
	lpush(&lbl_head, v5);
	mw_mirth_token_Token_succ();
	mw_mirth_token_Token_argZ_endZAsk();
	VAL v6 = pop_value();
	if (VBOOL(v6)) {
	} else {
		VAL v7 = (lpop(&lbl_head));
		incref(v7);
		push_value(v7);
		lpush(&lbl_head, v7);
		mw_mirth_token_Token_succ();
		STRLIT("expected end of argument after table name", 41);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
	mw_mirth_elab_elabZ_defZ_head();
	VAL v8 = (lpop(&lbl_arity));
	decref(v8);
	mw_mirth_elab_tableZ_newZBang();
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_elab_elabZ_entryZ_point (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_name_QName_defZ_hardZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_def_Def_wordZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* None */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 4, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_name_Namespace_moduleZAsk();
			mw_std_maybe_Maybe_1_unwrap();
			mw_mirth_module_Module_start();
			STRLIT("can't find entry point ", 23);
			push_value(v2);
			mw_mirth_name_QName_ZToStr();
			mp_primZ_strZ_cat();
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	decref(v4);
	incref(v3);
	push_value(v3);
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_RESOURCEz_WORLD();
	mw_mirth_type_TZPlus();
	mw_mirth_type_T0();
	mw_mirth_type_RESOURCEz_WORLD();
	mw_mirth_type_TZPlus();
	mw_mirth_type_TZ_ZTo();
	push_value(v3);
	mw_mirth_word_Word_head();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v5);
	mtw_mirth_arrow_Home_HomeMain();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	mw_mirth_type_ArrowType_unpack();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	incref(v7);
	incref(v9);
	uint64_t v11 = (0LL /* Nil */);
	push_value(v8);
	lpush(&lbl_home, v6);
	lpush(&lbl_tokenZ_start, v7);
	lpush(&lbl_tokenZ_end, v7);
	lpush(&lbl_dom, v9);
	lpush(&lbl_cod, v9);
	lpush(&lbl_ctx, v10);
	lpush(&lbl_atoms, MKU64(v11));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v12 = pop_value();
	lpush(&lbl_arrow, v12);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v13 = pop_value();
	mw_mirth_elab_abZ_wordZBang();
	push_value(v13);
	mw_mirth_elab_abZ_unifyZ_typeZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v14 = (lpop(&lbl_arrow));
	push_value(v14);
}
static void mw_mirth_elab_elabZ_embedZ_strZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_2();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	lpush(&lbl_head, v2);
	mw_mirth_elab_elabZ_defZ_head();
	VAL v3 = (lpop(&lbl_arity));
	incref(v3);
	int64_t v4 = (0LL);
	bool v5 = (VI64(v3) == v4);
	lpush(&lbl_arity, v3);
	if (v5) {
	} else {
		VAL v6 = (lpop(&lbl_head));
		incref(v6);
		push_value(v6);
		lpush(&lbl_head, v6);
		STRLIT("expected no arguments", 21);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	}
	VAL v7 = pop_value();
	incref(v7);
	uint64_t v8 = (0LL /* None */);
	incref(v7);
	lpush(&lbl_body, v7);
	lpush(&lbl_sigZAsk, MKU64(v8));
	push_value(v7);
	push_value(v7);
	mw_mirth_token_Token_strZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("expected source path", 20);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL r9 = pop_resource();
	mw_std_prim_ZPlusWorld_openZ_fileZBang();
	mw_std_file_ZPlusFileZAsk_unwrapZBang();
	mw_std_file_ZPlusFile_readZ_fileZBang();
	mw_std_file_ZPlusFile_closeZ_fileZBang();
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	decref(v11);
	lpush(&lbl_contents, v10);
	push_resource(r9);
	mw_mirth_word_Word_newZBang();
	VAL v12 = pop_value();
	incref(v12);
	push_value(v12);
	push_value(v12);
	mtw_mirth_mirth_PropLabel_WordQName();
	VAL v13 = pop_value();
	lpush(&lbl_label, v13);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	incref(v15);
	push_value(v15);
	push_value(v14);
	push_value(v15);
	mfld_mirth_word_Word_ZTildeqname();
	mp_primZ_mutZ_set();
	mw_mirth_var_Ctx0();
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_STR();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v16 = pop_value();
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	incref(v18);
	push_value(v18);
	push_value(v17);
	push_value(v16);
	push_value(v18);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v19 = pop_value();
	VAL v20 = pop_value();
	incref(v20);
	push_value(v20);
	push_value(v19);
	push_value(v20);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v21 = pop_value();
	incref(v21);
	push_value(v21);
	VAL v22 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_embedZ_strZBangZDot58ZRParen_0));
	push_value(v22);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v21);
	push_value(v21);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v21);
	VAL v23 = pop_value();
	push_value(v21);
	push_value(v23);
	push_value(v21);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v24 = pop_value();
	decref(v24);
}
static void mw_mirth_elab_typecheckZ_everythingZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_name_Name_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_name_Name_defs();
		mw_std_list_List_1_uncons();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
		while(1) {
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			push_value(v9);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v10 = pop_value();
			if (!VBOOL(v10)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			incref(v11);
			push_value(v11);
			push_value(v11);
			mw_mirth_def_Def_qnameZ_hard();
			VAL v13 = pop_value();
			decref(v13);
			mw_mirth_def_Def_typecheckZBang();
			push_value(v12);
			mw_std_list_List_1_uncons();
			VAL v14 = pop_value();
			VAL v15 = pop_value();
			push_value(v14);
			push_value(v15);
		}
		VAL v16 = pop_value();
		decref(v16);
		VAL v17 = pop_value();
		decref(v17);
		int64_t v18 = (1LL);
		push_value(v6);
		push_i64(v18);
		mp_primZ_intZ_add();
	}
	VAL v19 = pop_value();
	decref(v19);
	int64_t v20 = (1LL);
	push_i64(v20);
	while(1) {
		VAL v21 = pop_value();
		incref(v21);
		push_value(v21);
		push_value(v21);
		mbuf_mirth_arrow_Block_NUM();
		mp_primZ_u64Z_get();
		int64_t v22 = (1LL);
		push_i64(v22);
		mp_primZ_intZ_add();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		bool v25 = (VI64(v24) < VI64(v23));
		if (!v25) break;
		VAL v26 = pop_value();
		incref(v26);
		push_value(v26);
		mw_mirth_arrow_Block_typecheckZBang();
		int64_t v27 = (1LL);
		push_value(v26);
		push_i64(v27);
		mp_primZ_intZ_add();
	}
	VAL v28 = pop_value();
	decref(v28);
	int64_t v29 = (1LL);
	push_i64(v29);
	while(1) {
		VAL v30 = pop_value();
		incref(v30);
		push_value(v30);
		push_value(v30);
		mbuf_mirth_external_External_NUM();
		mp_primZ_u64Z_get();
		int64_t v31 = (1LL);
		push_i64(v31);
		mp_primZ_intZ_add();
		VAL v32 = pop_value();
		VAL v33 = pop_value();
		bool v34 = (VI64(v33) < VI64(v32));
		if (!v34) break;
		VAL v35 = pop_value();
		incref(v35);
		push_value(v35);
		mw_mirth_external_External_ctype();
		VAL v36 = pop_value();
		decref(v36);
		int64_t v37 = (1LL);
		push_value(v35);
		push_i64(v37);
		mp_primZ_intZ_add();
	}
	VAL v38 = pop_value();
	decref(v38);
}
static void mw_mirth_elab_TABLEz_MAXz_COUNT (void) {
	int64_t v0 = (524288LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
}
static void mw_mirth_elab_tableZ_qname (void) {
	VAL v0 = pop_value();
	lpush(&lbl_arity, v0);
	mw_std_prim_Str_ZToName();
	VAL v1 = pop_value();
	lpush(&lbl_name, v1);
	mtw_mirth_tycon_Tycon_TYCONz_TABLE();
	mtw_mirth_name_Namespace_NAMESPACEz_TYCON();
	VAL v2 = pop_value();
	lpush(&lbl_namespace, v2);
	mtw_mirth_name_QName_MKQNAME();
}
static void mw_mirth_elab_tableZ_wordZ_newZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v0);
	push_value(v2);
	mw_mirth_table_Table_head();
	VAL v3 = pop_value();
	incref(v3);
	uint64_t v4 = (0LL /* None */);
	VAL v5 = pop_value();
	incref(v5);
	VAL v6 = pop_value();
	incref(v6);
	lpush(&lbl_head, v3);
	lpush(&lbl_body, v3);
	lpush(&lbl_sigZAsk, MKU64(v4));
	lpush(&lbl_arity, v5);
	push_value(v6);
	push_value(v5);
	push_value(v6);
	mw_std_prim_Str_ZToName();
	VAL v7 = pop_value();
	lpush(&lbl_name, v7);
	mw_mirth_elab_tableZ_qname();
	VAL v8 = pop_value();
	lpush(&lbl_qname, v8);
	mw_mirth_word_Word_newZBang();
	VAL v9 = (lpop(&lbl_qname));
	VAL v10 = pop_value();
	incref(v10);
	push_value(v10);
	push_value(v9);
	push_value(v10);
	mtw_mirth_mirth_PropLabel_WordQName();
	mw_mirth_mirth_PropLabel_prop();
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	incref(v12);
	push_value(v12);
	push_value(v11);
	push_value(v12);
	mfld_mirth_word_Word_ZTildeqname();
	mp_primZ_mutZ_set();
}
static void mw_mirth_elab_tableZ_newZBang (void) {
	mw_mirth_table_Table_allocZBang();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_tbl, v0);
	mtw_mirth_mirth_PropLabel_TableQName();
	VAL v1 = pop_value();
	lpush(&lbl_label, v1);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v2 = (lpop(&lbl_tbl));
	incref(v2);
	push_value(v2);
	lpush(&lbl_tbl, v2);
	mfld_mirth_table_Table_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v3 = (lpop(&lbl_head));
	VAL v4 = (lpop(&lbl_tbl));
	incref(v4);
	push_value(v3);
	push_value(v4);
	lpush(&lbl_tbl, v4);
	mfld_mirth_table_Table_ZTildehead();
	mp_primZ_mutZ_set();
	VAL v5 = (lpop(&lbl_name));
	VAL v6 = (lpop(&lbl_tbl));
	incref(v6);
	push_value(v5);
	push_value(v6);
	lpush(&lbl_tbl, v6);
	mfld_mirth_table_Table_ZTildename();
	mp_primZ_mutZ_set();
	mw_mirth_elab_TABLEz_MAXz_COUNT();
	VAL v7 = (lpop(&lbl_tbl));
	incref(v7);
	push_value(v7);
	lpush(&lbl_tbl, v7);
	mfld_mirth_table_Table_ZTildemaxZ_count();
	mp_primZ_mutZ_set();
	VAL v8 = (lpop(&lbl_tbl));
	incref(v8);
	push_value(v8);
	lpush(&lbl_tbl, v8);
	mtw_mirth_def_Def_DefTable();
	mw_mirth_def_Def_register();
	VAL v9 = (lpop(&lbl_tbl));
	incref(v9);
	push_value(v9);
	lpush(&lbl_tbl, v9);
	STRLIT("MAX", 3);
	int64_t v10 = (0LL);
	push_i64(v10);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v11 = pop_value();
	uint64_t v12 = (0LL /* Nil */);
	lpush(&lbl_word, v11);
	push_u64(v12);
	mw_mirth_type_T0();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v13 = (lpop(&lbl_word));
	incref(v13);
	push_value(v13);
	lpush(&lbl_word, v13);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v14 = (lpop(&lbl_word));
	incref(v14);
	push_value(v14);
	lpush(&lbl_word, v14);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v15 = (lpop(&lbl_word));
	incref(v15);
	push_value(v15);
	VAL v16 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot44ZRParen_0));
	push_value(v16);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v15);
	push_value(v15);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v15);
	VAL v17 = pop_value();
	push_value(v15);
	push_value(v17);
	push_value(v15);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v18 = pop_value();
	decref(v18);
	VAL v19 = (lpop(&lbl_tbl));
	incref(v19);
	push_value(v19);
	lpush(&lbl_tbl, v19);
	STRLIT("nil", 3);
	int64_t v20 = (0LL);
	push_i64(v20);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v21 = pop_value();
	uint64_t v22 = (0LL /* Nil */);
	lpush(&lbl_word, v21);
	push_u64(v22);
	mw_mirth_type_T0();
	VAL v23 = (lpop(&lbl_tbl));
	incref(v23);
	push_value(v23);
	lpush(&lbl_tbl, v23);
	mtw_mirth_type_Type_TTable();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v24 = (lpop(&lbl_word));
	incref(v24);
	push_value(v24);
	lpush(&lbl_word, v24);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v25 = (lpop(&lbl_word));
	incref(v25);
	push_value(v25);
	lpush(&lbl_word, v25);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v26 = (lpop(&lbl_word));
	incref(v26);
	push_value(v26);
	VAL v27 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot73ZRParen_0));
	push_value(v27);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v26);
	push_value(v26);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v26);
	VAL v28 = pop_value();
	push_value(v26);
	push_value(v28);
	push_value(v26);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = (lpop(&lbl_tbl));
	incref(v30);
	push_value(v30);
	lpush(&lbl_tbl, v30);
	mw_mirth_table_Table_head();
	VAL v31 = (lpop(&lbl_tbl));
	incref(v31);
	push_value(v31);
	lpush(&lbl_tbl, v31);
	STRLIT("NUM", 3);
	int64_t v32 = (0LL);
	push_i64(v32);
	mw_mirth_elab_tableZ_qname();
	int64_t v33 = (8LL);
	push_i64(v33);
	mw_std_prim_Int_ZToNat();
	mw_mirth_buffer_Buffer_newZBang();
	VAL v34 = (lpop(&lbl_tbl));
	incref(v34);
	push_value(v34);
	lpush(&lbl_tbl, v34);
	mfld_mirth_table_Table_ZTildenumZ_buffer();
	mp_primZ_mutZ_set();
	VAL v35 = (lpop(&lbl_tbl));
	incref(v35);
	push_value(v35);
	lpush(&lbl_tbl, v35);
	STRLIT("index", 5);
	int64_t v36 = (0LL);
	push_i64(v36);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v37 = pop_value();
	uint64_t v38 = (0LL /* Nil */);
	VAL v39 = (lpop(&lbl_tbl));
	incref(v39);
	lpush(&lbl_word, v37);
	push_u64(v38);
	push_value(v39);
	lpush(&lbl_tbl, v39);
	mtw_mirth_type_Type_TTable();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v40 = (lpop(&lbl_word));
	incref(v40);
	push_value(v40);
	lpush(&lbl_word, v40);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v41 = (lpop(&lbl_word));
	incref(v41);
	push_value(v41);
	lpush(&lbl_word, v41);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v42 = (lpop(&lbl_word));
	incref(v42);
	push_value(v42);
	VAL v43 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot116ZRParen_0));
	push_value(v43);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v42);
	push_value(v42);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v42);
	VAL v44 = pop_value();
	push_value(v42);
	push_value(v44);
	push_value(v42);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v45 = pop_value();
	decref(v45);
	VAL v46 = (lpop(&lbl_tbl));
	incref(v46);
	push_value(v46);
	lpush(&lbl_tbl, v46);
	STRLIT("from-index", 10);
	int64_t v47 = (0LL);
	push_i64(v47);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v48 = pop_value();
	uint64_t v49 = (0LL /* Nil */);
	VAL v50 = (lpop(&lbl_tbl));
	incref(v50);
	lpush(&lbl_word, v48);
	push_u64(v49);
	push_value(v50);
	lpush(&lbl_tbl, v50);
	mtw_mirth_type_Type_TTable();
	mw_mirth_type_T1();
	mw_mirth_type_TYPEz_INT();
	mw_mirth_type_T1();
	VAL v51 = pop_value();
	VAL v52 = pop_value();
	push_value(v51);
	push_value(v52);
	mw_mirth_type_TZ_ZTo();
	VAL v53 = (lpop(&lbl_word));
	incref(v53);
	push_value(v53);
	lpush(&lbl_word, v53);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v54 = (lpop(&lbl_word));
	incref(v54);
	push_value(v54);
	lpush(&lbl_word, v54);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v55 = (lpop(&lbl_word));
	incref(v55);
	push_value(v55);
	VAL v56 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot146ZRParen_0));
	push_value(v56);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v55);
	push_value(v55);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v55);
	VAL v57 = pop_value();
	push_value(v55);
	push_value(v57);
	push_value(v55);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v58 = pop_value();
	decref(v58);
	VAL v59 = (lpop(&lbl_tbl));
	incref(v59);
	push_value(v59);
	lpush(&lbl_tbl, v59);
	STRLIT("succ", 4);
	int64_t v60 = (0LL);
	push_i64(v60);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v61 = pop_value();
	uint64_t v62 = (0LL /* Nil */);
	VAL v63 = (lpop(&lbl_tbl));
	incref(v63);
	lpush(&lbl_word, v61);
	push_u64(v62);
	push_value(v63);
	lpush(&lbl_tbl, v63);
	mtw_mirth_type_Type_TTable();
	mw_mirth_type_T1();
	VAL v64 = pop_value();
	incref(v64);
	push_value(v64);
	push_value(v64);
	mw_mirth_type_TZ_ZTo();
	VAL v65 = (lpop(&lbl_word));
	incref(v65);
	push_value(v65);
	lpush(&lbl_word, v65);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v66 = (lpop(&lbl_word));
	incref(v66);
	push_value(v66);
	lpush(&lbl_word, v66);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v67 = (lpop(&lbl_word));
	incref(v67);
	push_value(v67);
	VAL v68 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot174ZRParen_0));
	push_value(v68);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v67);
	push_value(v67);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v67);
	VAL v69 = pop_value();
	push_value(v67);
	push_value(v69);
	push_value(v67);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v70 = pop_value();
	decref(v70);
	VAL v71 = (lpop(&lbl_tbl));
	incref(v71);
	push_value(v71);
	lpush(&lbl_tbl, v71);
	STRLIT("pred", 4);
	int64_t v72 = (0LL);
	push_i64(v72);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v73 = pop_value();
	uint64_t v74 = (0LL /* Nil */);
	VAL v75 = (lpop(&lbl_tbl));
	incref(v75);
	lpush(&lbl_word, v73);
	push_u64(v74);
	push_value(v75);
	lpush(&lbl_tbl, v75);
	mtw_mirth_type_Type_TTable();
	mw_mirth_type_T1();
	VAL v76 = pop_value();
	incref(v76);
	push_value(v76);
	push_value(v76);
	mw_mirth_type_TZ_ZTo();
	VAL v77 = (lpop(&lbl_word));
	incref(v77);
	push_value(v77);
	lpush(&lbl_word, v77);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v78 = (lpop(&lbl_word));
	incref(v78);
	push_value(v78);
	lpush(&lbl_word, v78);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v79 = (lpop(&lbl_word));
	incref(v79);
	push_value(v79);
	VAL v80 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot221ZRParen_0));
	push_value(v80);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v79);
	push_value(v79);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v79);
	VAL v81 = pop_value();
	push_value(v79);
	push_value(v81);
	push_value(v79);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v82 = pop_value();
	decref(v82);
	VAL v83 = (lpop(&lbl_tbl));
	incref(v83);
	push_value(v83);
	lpush(&lbl_tbl, v83);
	STRLIT("for", 3);
	int64_t v84 = (1LL);
	push_i64(v84);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v85 = pop_value();
	lpush(&lbl_word, v85);
	mw_mirth_type_TYPEz_STACK();
	STRLIT("*a", 2);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	VAL v86 = pop_value();
	incref(v86);
	push_value(v86);
	lpush(&lbl_va, v86);
	mtw_mirth_type_StackType_STVar();
	VAL v87 = (lpop(&lbl_tbl));
	incref(v87);
	push_value(v87);
	lpush(&lbl_tbl, v87);
	mtw_mirth_type_Type_TTable();
	mw_mirth_type_TZMul();
	VAL v88 = (lpop(&lbl_va));
	incref(v88);
	push_value(v88);
	lpush(&lbl_va, v88);
	mtw_mirth_type_StackType_STVar();
	mw_mirth_type_TZ_ZTo();
	mw_mirth_type_ArrowType_ZToType();
	STRLIT("f", 1);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZ_autoZ_runZBang();
	VAL v89 = pop_value();
	VAL v90 = (lpop(&lbl_va));
	incref(v90);
	lpush(&lbl_vx, v89);
	push_value(v90);
	lpush(&lbl_va, v90);
	mw_mirth_var_Ctx1();
	VAL v91 = (lpop(&lbl_va));
	incref(v91);
	push_value(v91);
	lpush(&lbl_va, v91);
	mtw_mirth_type_StackType_STVar();
	VAL v92 = (lpop(&lbl_vx));
	incref(v92);
	push_value(v92);
	lpush(&lbl_vx, v92);
	mw_mirth_var_Var_type();
	mw_mirth_type_TZMul();
	VAL v93 = (lpop(&lbl_va));
	incref(v93);
	push_value(v93);
	lpush(&lbl_va, v93);
	mtw_mirth_type_StackType_STVar();
	mw_mirth_type_TZ_ZTo();
	VAL v94 = (lpop(&lbl_word));
	incref(v94);
	push_value(v94);
	lpush(&lbl_word, v94);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v95 = (lpop(&lbl_word));
	incref(v95);
	push_value(v95);
	lpush(&lbl_word, v95);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v96 = (lpop(&lbl_vx));
	incref(v96);
	uint64_t v97 = (0LL /* Nil */);
	push_value(v96);
	lpush(&lbl_vx, v96);
	push_u64(v97);
	mtw_std_list_List_1_Cons();
	VAL v98 = (lpop(&lbl_word));
	incref(v98);
	push_value(v98);
	lpush(&lbl_word, v98);
	mtw_mirth_mirth_PropLabel_WordParams();
	mw_mirth_mirth_PropLabel_prop();
	VAL v99 = (lpop(&lbl_word));
	incref(v99);
	push_value(v99);
	lpush(&lbl_word, v99);
	mfld_mirth_word_Word_ZTildeparams();
	mp_primZ_mutZ_set();
	VAL v100 = (lpop(&lbl_word));
	incref(v100);
	push_value(v100);
	lpush(&lbl_word, v100);
	mw_mirth_word_Word_makeZ_inlineZBang();
	VAL v101 = (lpop(&lbl_word));
	incref(v101);
	push_value(v101);
	VAL v102 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot303ZRParen_0));
	push_value(v102);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v101);
	push_value(v101);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v101);
	VAL v103 = pop_value();
	push_value(v101);
	push_value(v103);
	push_value(v101);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v104 = pop_value();
	decref(v104);
	VAL v105 = (lpop(&lbl_va));
	VAL v106 = (lpop(&lbl_vx));
	decref(v106);
	decref(v105);
	VAL v107 = (lpop(&lbl_tbl));
	incref(v107);
	push_value(v107);
	lpush(&lbl_tbl, v107);
	STRLIT("alloc!", 6);
	int64_t v108 = (0LL);
	push_i64(v108);
	mw_mirth_elab_tableZ_wordZ_newZBang();
	VAL v109 = pop_value();
	uint64_t v110 = (0LL /* Nil */);
	lpush(&lbl_word, v109);
	push_u64(v110);
	mw_mirth_type_T0();
	VAL v111 = (lpop(&lbl_tbl));
	incref(v111);
	push_value(v111);
	lpush(&lbl_tbl, v111);
	mtw_mirth_type_Type_TTable();
	mw_mirth_type_T1();
	mw_mirth_type_TZ_ZTo();
	VAL v112 = (lpop(&lbl_word));
	incref(v112);
	push_value(v112);
	lpush(&lbl_word, v112);
	mtw_mirth_mirth_PropLabel_WordType();
	mw_mirth_mirth_PropLabel_prop2();
	VAL v113 = (lpop(&lbl_word));
	incref(v113);
	push_value(v113);
	lpush(&lbl_word, v113);
	mfld_mirth_word_Word_ZTildectxZ_type();
	mp_primZ_mutZ_set();
	VAL v114 = (lpop(&lbl_word));
	incref(v114);
	push_value(v114);
	VAL v115 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot373ZRParen_0));
	push_value(v115);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	incref(v114);
	push_value(v114);
	mtw_mirth_mirth_PropLabel_WordArrow();
	mw_mirth_mirth_PropLabel_prop();
	incref(v114);
	VAL v116 = pop_value();
	push_value(v114);
	push_value(v116);
	push_value(v114);
	mfld_mirth_word_Word_ZTildearrow();
	mp_primZ_mutZ_set();
	VAL v117 = pop_value();
	decref(v117);
	VAL v118 = (lpop(&lbl_tbl));
	push_value(v118);
}
static void mw_mirth_elab_resolveZ_defZ_namespace (void) {
	VAL v0 = pop_value();
	lpush(&lbl_token, v0);
	STRLIT("namespace", 9);
	VAL v1 = pop_value();
	uint64_t v2 = (1LL /* True */);
	uint64_t v3 = (0LL /* False */);
	lpush(&lbl_sort, v1);
	lpush(&lbl_ignoreZ_lastZ_name, MKU64(v2));
	lpush(&lbl_reportZ_ambiguousZ_asZ_warning, MKU64(v3));
	mw_mirth_elab_resolveZ_defZ_beginZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v4 = (0LL /* Nil */);
	uint64_t v5 = (0LL /* Nil */);
	VAL v6 = pop_value();
	push_u64(v4);
	push_u64(v5);
	push_value(v6);
	mw_std_list_List_1_uncons();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v8);
	while(1) {
		VAL v9 = pop_value();
		incref(v9);
		push_value(v9);
		push_value(v9);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v10 = pop_value();
		if (!VBOOL(v10)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		incref(v11);
		VAL r15 = pop_resource();
		push_value(v11);
		push_value(v11);
		mw_mirth_def_Def_exposedZ_tyconZAsk();
		push_resource(r15);
		mw_std_maybe_Maybe_1_ZToBool();
		VAL v16 = pop_value();
		if (VBOOL(v16)) {
			mtw_std_either_Either_2_Right();
		} else {
			mtw_mirth_elab_RejectedDef_RDz_WRONGz_SORT();
			mtw_std_either_Either_2_Left();
		}
		VAL v17 = pop_value();
		push_value(v14);
		push_value(v13);
		push_value(v17);
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				VAL v18 = pop_value();
				VAL v19 = pop_value();
				VAL v20 = pop_value();
				push_value(v18);
				push_value(v20);
				mtw_std_list_List_1_Cons();
				push_value(v19);
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				push_value(v21);
				push_value(v22);
				mtw_std_list_List_1_Cons();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v12);
		mw_std_list_List_1_uncons();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		push_value(v23);
		push_value(v24);
	}
	VAL v25 = pop_value();
	decref(v25);
	VAL v26 = pop_value();
	decref(v26);
	VAL v27 = pop_value();
	mw_std_list_List_1_reverse();
	push_value(v27);
	mw_std_list_List_1_reverse();
	VAL v28 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r29 = pop_resource();
	mw_std_list_List_1_cat();
	push_resource(r29);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
	}
	push_value(v28);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers();
	uint64_t v30 = (0LL /* Nil */);
	push_u64(v30);
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots();
	mw_mirth_elab_resolveZ_defZ_endZBang();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_def_Def_asZ_namespaceZAsk();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v31 = (0LL /* None */);
			push_u64(v31);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	lpush(&lbl_arity, v0);
	push_value(v1);
	push_value(v1);
	mw_mirth_name_DName_rootZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v2 = pop_value();
			decref(v2);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v3 = pop_value();
			decref(v3);
			STRLIT("relative name not allowed", 25);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_name_DName_lastZ_name();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	lpush(&lbl_name, v4);
	push_value(v5);
	push_value(v5);
	mw_mirth_elab_resolveZ_defZ_namespace();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	lpush(&lbl_namespace, v6);
	mtw_mirth_name_QName_MKQNAME();
}
static void mw_mirth_elab_moduleZ_visibleZ_fromZ_tokenZAsk (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_token_Token_module();
	mw_mirth_module_Module_visible();
}
static void mw_mirth_elab_elabZ_defZ_qname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("expected name", 13);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // Left
			mtp_std_either_Either_2_Left();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			incref(v2);
			lpush(&lbl_name, v1);
			push_value(v2);
			push_value(v2);
			mw_mirth_token_Token_module();
			mtw_mirth_name_Namespace_NAMESPACEz_MODULE();
			VAL v3 = pop_value();
			lpush(&lbl_namespace, v3);
			mw_mirth_token_Token_numZ_args();
			VAL v4 = pop_value();
			lpush(&lbl_arity, v4);
			mtw_mirth_name_QName_MKQNAME();
		} break;
		case 1LL: { // Right
			mtp_std_either_Either_2_Right();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			incref(v6);
			push_value(v6);
			push_value(v5);
			push_value(v6);
			mw_mirth_token_Token_numZ_args();
			mw_mirth_elab_elabZ_qnameZ_fromZ_nonrelativeZ_dname();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_elab_elabZ_defZ_qnameZ_undefined (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_elab_elabZ_defZ_qname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mw_mirth_name_QName_definedZ_softZAsk();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
		STRLIT("name already defined", 20);
		mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
	} else {
	}
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	decref(v5);
	push_value(v4);
}
static void mw_mirth_elab_elabZ_defZ_head (void) {
	VAL v0 = (lpop(&lbl_head));
	incref(v0);
	push_value(v0);
	lpush(&lbl_head, v0);
	mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v1 = (lpop(&lbl_head));
			incref(v1);
			push_value(v1);
			lpush(&lbl_head, v1);
			STRLIT("expected name", 13);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // Left
			mtp_std_either_Either_2_Left();
		} break;
		case 1LL: { // Right
			mtp_std_either_Either_2_Right();
			mw_mirth_name_DName_parts();
			mw_std_list_ListZPlus_1_last();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = pop_value();
	VAL v3 = (lpop(&lbl_head));
	incref(v3);
	lpush(&lbl_name, v2);
	push_value(v3);
	lpush(&lbl_head, v3);
	mw_mirth_token_Token_numZ_args();
	VAL v4 = pop_value();
	VAL v5 = (lpop(&lbl_head));
	incref(v5);
	lpush(&lbl_arity, v4);
	push_value(v5);
	lpush(&lbl_head, v5);
	VAL v6 = (MKFNPTR(&mb_mirth_elab_elabZ_defZ_head_3));
	push_value(v6);
	mtw_mirth_mirth_PropState_1_PSDelay();
	VAL v7 = pop_value();
	lpush(&lbl_state, v7);
}
static void mw_mirth_elab_parseZ_field (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	mw_mirth_token_Token_next();
	push_value(v0);
	mw_mirth_token_Token_argsZ_3();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	lpush(&lbl_valueZ_type, v1);
	lpush(&lbl_indexZ_type, v2);
	push_value(v3);
	lpush(&lbl_head, v3);
	mw_mirth_token_Token_nameZ_orZ_dnameZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v4 = pop_value();
			decref(v4);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			VAL v5 = (lpop(&lbl_head));
			incref(v5);
			push_value(v5);
			lpush(&lbl_head, v5);
			STRLIT("expected field name", 19);
			mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v6 = (lpop(&lbl_head));
	incref(v6);
	push_value(v6);
	lpush(&lbl_head, v6);
	mw_mirth_token_Token_argsZ_0();
}
static void mw_mirth_elab_elabZ_fieldZBang (void) {
	mw_mirth_elab_parseZ_field();
	mw_mirth_elab_elabZ_defZ_head();
	mw_mirth_table_Field_allocZBang();
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_name));
	incref(v0);
	push_value(v1);
	push_value(v0);
	lpush(&lbl_fld, v0);
	mfld_mirth_table_Field_ZTildename();
	mp_primZ_mutZ_set();
	VAL v2 = (lpop(&lbl_head));
	VAL v3 = (lpop(&lbl_fld));
	incref(v3);
	push_value(v2);
	push_value(v3);
	lpush(&lbl_fld, v3);
	mfld_mirth_table_Field_ZTildehead();
	mp_primZ_mutZ_set();
	VAL v4 = (lpop(&lbl_arity));
	incref(v4);
	int64_t v5 = (0LL);
	bool v6 = (VI64(v4) == v5);
	push_value(v4);
	if (v6) {
	} else {
		STRLIT("expected arity 0 in elab-field!", 31);
		mp_primZ_panic();
		mp_primZ_panic();
	}
	VAL v7 = pop_value();
	decref(v7);
	VAL v8 = (lpop(&lbl_fld));
	incref(v8);
	push_value(v8);
	lpush(&lbl_fld, v8);
	mtw_mirth_mirth_PropLabel_FieldQName();
	VAL v9 = pop_value();
	lpush(&lbl_label, v9);
	mtw_mirth_mirth_Prop_1_Prop();
	VAL v10 = (lpop(&lbl_fld));
	incref(v10);
	push_value(v10);
	lpush(&lbl_fld, v10);
	mfld_mirth_table_Field_ZTildeqname();
	mp_primZ_mutZ_set();
	VAL v11 = (lpop(&lbl_indexZ_type));
	VAL v12 = (lpop(&lbl_fld));
	incref(v12);
	push_value(v11);
	push_value(v12);
	lpush(&lbl_fld, v12);
	mtw_mirth_mirth_PropLabel_FieldIndexType();
	VAL v13 = (MKFNPTR(&mb_mirth_elab_elabZ_fieldZBang_2));
	push_value(v13);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v14 = (lpop(&lbl_fld));
	incref(v14);
	push_value(v14);
	lpush(&lbl_fld, v14);
	mfld_mirth_table_Field_ZTildeindexZ_type();
	mp_primZ_mutZ_set();
	VAL v15 = (lpop(&lbl_valueZ_type));
	VAL v16 = (lpop(&lbl_fld));
	incref(v16);
	push_value(v15);
	push_value(v16);
	lpush(&lbl_fld, v16);
	mtw_mirth_mirth_PropLabel_FieldValueType();
	VAL v17 = (MKFNPTR(&mb_mirth_elab_elabZ_fieldZBang_3));
	push_value(v17);
	mw_mirth_mirth_PropLabel_prop_1();
	VAL v18 = (lpop(&lbl_fld));
	incref(v18);
	push_value(v18);
	lpush(&lbl_fld, v18);
	mfld_mirth_table_Field_ZTildevalueZ_type();
	mp_primZ_mutZ_set();
	VAL v19 = (lpop(&lbl_fld));
	push_value(v19);
	mtw_mirth_def_Def_DefField();
	mw_mirth_def_Def_register();
}
static void mw_std_map_Map_2_empty (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
}
static void mw_std_map_Map_2_insert (void) {
	mtw_std_list_List_1_Cons();
}
static void mw_mirth_specializzer_runZ_specializzerZBang (void) {
	mw_mirth_specializzer_ZPlusSPCheck_beginZBang();
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang();
	mw_mirth_specializzer_ZPlusSPCheck_loopZBang();
	mw_mirth_specializzer_ZPlusSPCheck_endZBang();
}
static void mw_mirth_specializzer_ZPlusSPCheck_beginZBang (void) {
	uint64_t v0 = (0LL /* Nil */);
	lpush(&lbl_checklist, MKU64(v0));
	mtw_mirth_specializzer_ZPlusSPCheck_SPCHECK();
}
static void mw_mirth_specializzer_ZPlusSPCheck_endZBang (void) {
	mtp_mirth_specializzer_ZPlusSPCheck_SPCHECK();
	VAL v0 = (lpop(&lbl_checklist));
	decref(v0);
}
static void mw_mirth_specializzer_ZPlusSPCheck_loopZBang (void) {
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	VAL r0 = pop_resource();
	mw_std_list_List_1_uncons();
	push_resource(r0);
	{
		VAL v = pop_resource();
		push_resource(pop_value());
		decref(v);
	}
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v2 = pop_value();
		if (!VBOOL(v2)) break;
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang();
		{
			VAL v = top_resource();
			incref(v);
			push_value(v);
		}
		VAL r3 = pop_resource();
		mw_std_list_List_1_uncons();
		push_resource(r3);
		{
			VAL v = pop_resource();
			push_resource(pop_value());
			decref(v);
		}
	}
	VAL v4 = pop_value();
	decref(v4);
}
static void mw_mirth_specializzer_ZPlusSPCheck_doZ_itemZ_checkZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // SPCHECK_WORD
			mtp_mirth_specializzer_SPCheckItem_SPCHECKz_WORD();
			VAL v0 = pop_value();
			incref(v0);
			VAL r1 = pop_resource();
			push_value(v0);
			lpush(&lbl_w, v0);
			mw_mirth_word_Word_arrow();
			push_resource(r1);
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang();
			VAL v2 = (lpop(&lbl_w));
			incref(v2);
			push_value(v2);
			lpush(&lbl_w, v2);
			mtw_mirth_mirth_PropLabel_WordArrow();
			VAL r3 = pop_resource();
			mw_mirth_mirth_PropLabel_prop();
			VAL v4 = (lpop(&lbl_w));
			push_resource(r3);
			push_value(v4);
			mfld_mirth_word_Word_ZTildearrow();
			mp_primZ_mutZ_set();
		} break;
		case 1LL: { // SPCHECK_BLOCK
			mtp_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK();
			VAL v5 = pop_value();
			incref(v5);
			VAL r6 = pop_resource();
			push_value(v5);
			lpush(&lbl_b, v5);
			mw_mirth_arrow_Block_arrow();
			push_resource(r6);
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang();
			VAL v7 = (lpop(&lbl_b));
			incref(v7);
			push_value(v7);
			lpush(&lbl_b, v7);
			mtw_mirth_mirth_PropLabel_BlockArrow();
			VAL r8 = pop_resource();
			mw_mirth_mirth_PropLabel_prop();
			VAL v9 = (lpop(&lbl_b));
			push_resource(r8);
			push_value(v9);
			mfld_mirth_arrow_Block_ZTildearrow();
			mp_primZ_mutZ_set();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v1 = (0LL /* Nil */);
	push_u64(v1);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		push_value(v6);
		mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang();
		push_resource(r8);
		mw_std_list_List_1_uncons();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
		while(1) {
			VAL v11 = pop_value();
			incref(v11);
			push_value(v11);
			push_value(v11);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v12 = pop_value();
			if (!VBOOL(v12)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			push_value(v13);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mtw_std_list_List_1_Cons();
			mtw_std_list_ZPlusList_1_ZPlusList();
			push_value(v14);
			mw_std_list_List_1_uncons();
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			push_value(v15);
			push_value(v16);
		}
		VAL v17 = pop_value();
		decref(v17);
		VAL v18 = pop_value();
		decref(v18);
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
	}
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	decref(v22);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	push_value(v0);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[7];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(8);
			tup->size = 8;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = u;
			decref(v);
			push_value(MKTUP(tup,8));
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_atomZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // OpNone
			(void)pop_u64();
			uint64_t v1 = (0LL /* Nil */);
			push_u64(v1);
			mtw_std_list_List_1_Cons();
		} break;
		case 1LL: { // OpPrim
			mtp_mirth_arrow_Op_OpPrim();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang();
		} break;
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang();
		} break;
		case 3LL: { // OpExternal
			mtp_mirth_arrow_Op_OpExternal();
			VAL v2 = pop_value();
			decref(v2);
			uint64_t v3 = (0LL /* Nil */);
			push_u64(v3);
			mtw_std_list_List_1_Cons();
		} break;
		case 4LL: { // OpBuffer
			mtp_mirth_arrow_Op_OpBuffer();
			VAL v4 = pop_value();
			decref(v4);
			uint64_t v5 = (0LL /* Nil */);
			push_u64(v5);
			mtw_std_list_List_1_Cons();
		} break;
		case 5LL: { // OpVariable
			mtp_mirth_arrow_Op_OpVariable();
			VAL v6 = pop_value();
			decref(v6);
			uint64_t v7 = (0LL /* Nil */);
			push_u64(v7);
			mtw_std_list_List_1_Cons();
		} break;
		case 6LL: { // OpField
			mtp_mirth_arrow_Op_OpField();
			VAL v8 = pop_value();
			decref(v8);
			uint64_t v9 = (0LL /* Nil */);
			push_u64(v9);
			mtw_std_list_List_1_Cons();
		} break;
		case 7LL: { // OpInt
			mtp_mirth_arrow_Op_OpInt();
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (0LL /* Nil */);
			push_u64(v11);
			mtw_std_list_List_1_Cons();
		} break;
		case 8LL: { // OpF64
			mtp_mirth_arrow_Op_OpF64();
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (0LL /* Nil */);
			push_u64(v13);
			mtw_std_list_List_1_Cons();
		} break;
		case 9LL: { // OpStr
			mtp_mirth_arrow_Op_OpStr();
			VAL v14 = pop_value();
			decref(v14);
			uint64_t v15 = (0LL /* Nil */);
			push_u64(v15);
			mtw_std_list_List_1_Cons();
		} break;
		case 10LL: { // OpTag
			mtp_mirth_arrow_Op_OpTag();
			VAL v16 = pop_value();
			decref(v16);
			uint64_t v17 = (0LL /* Nil */);
			push_u64(v17);
			mtw_std_list_List_1_Cons();
		} break;
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang();
			mtw_mirth_arrow_Op_OpMatch();
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			push_value(v18);
			push_value(v19);
			{
				VAL v = pop_value();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				if (VTUP(v)->refs == 1) {
					VAL* p = &VTUP(v)->cells[4];
					VAL t = *p; *p = u; decref(t);
					push_value(v);
				} else {
					TUP *tup = tup_new(9);
					tup->size = 9;
					tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
					tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
					tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
					tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
					tup->cells[4] = u;
					tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
					tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
					tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
					tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
					decref(v);
					push_value(MKTUP(tup,9));
				}
			}
			uint64_t v20 = (0LL /* Nil */);
			push_u64(v20);
			mtw_std_list_List_1_Cons();
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang();
			mtw_mirth_arrow_Op_OpLambda();
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			push_value(v21);
			push_value(v22);
			{
				VAL v = pop_value();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 9, v);
				if (VTUP(v)->refs == 1) {
					VAL* p = &VTUP(v)->cells[4];
					VAL t = *p; *p = u; decref(t);
					push_value(v);
				} else {
					TUP *tup = tup_new(9);
					tup->size = 9;
					tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
					tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
					tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
					tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
					tup->cells[4] = u;
					tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
					tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
					tup->cells[7] = VTUP(v)->cells[7]; incref(tup->cells[7]);
					tup->cells[8] = VTUP(v)->cells[8]; incref(tup->cells[8]);
					decref(v);
					push_value(MKTUP(tup,9));
				}
			}
			uint64_t v23 = (0LL /* Nil */);
			push_u64(v23);
			mtw_std_list_List_1_Cons();
		} break;
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			VAL v24 = pop_value();
			decref(v24);
			uint64_t v25 = (0LL /* Nil */);
			push_u64(v25);
			mtw_std_list_List_1_Cons();
		} break;
		case 14LL: { // OpBlockPush
			mtp_mirth_arrow_Op_OpBlockPush();
			mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang();
			uint64_t v26 = (0LL /* Nil */);
			push_u64(v26);
			mtw_std_list_List_1_Cons();
		} break;
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang();
			uint64_t v27 = (0LL /* Nil */);
			push_u64(v27);
			mtw_std_list_List_1_Cons();
		} break;
		case 16LL: { // OpCoerce
			mtp_mirth_arrow_Op_OpCoerce();
			VAL v28 = pop_value();
			decref(v28);
			uint64_t v29 = (0LL /* Nil */);
			push_u64(v29);
			mtw_std_list_List_1_Cons();
		} break;
		case 17LL: { // OpLabelPush
			mtp_mirth_arrow_Op_OpLabelPush();
			VAL v30 = pop_value();
			decref(v30);
			uint64_t v31 = (0LL /* Nil */);
			push_u64(v31);
			mtw_std_list_List_1_Cons();
		} break;
		case 18LL: { // OpLabelPop
			mtp_mirth_arrow_Op_OpLabelPop();
			VAL v32 = pop_value();
			decref(v32);
			uint64_t v33 = (0LL /* Nil */);
			push_u64(v33);
			mtw_std_list_List_1_Cons();
		} break;
		case 19LL: { // OpLabelPushR
			mtp_mirth_arrow_Op_OpLabelPushR();
			VAL v34 = pop_value();
			decref(v34);
			uint64_t v35 = (0LL /* Nil */);
			push_u64(v35);
			mtw_std_list_List_1_Cons();
		} break;
		case 20LL: { // OpLabelPopR
			mtp_mirth_arrow_Op_OpLabelPopR();
			VAL v36 = pop_value();
			decref(v36);
			uint64_t v37 = (0LL /* Nil */);
			push_u64(v37);
			mtw_std_list_List_1_Cons();
		} break;
		case 21LL: { // OpDataGetTag
			mtp_mirth_arrow_Op_OpDataGetTag();
			VAL v38 = pop_value();
			decref(v38);
			uint64_t v39 = (0LL /* Nil */);
			push_u64(v39);
			mtw_std_list_List_1_Cons();
		} break;
		case 22LL: { // OpDataGetLabel
			mtp_mirth_arrow_Op_OpDataGetLabel();
			VAL v40 = pop_value();
			decref(v40);
			VAL v41 = pop_value();
			decref(v41);
			uint64_t v42 = (0LL /* Nil */);
			push_u64(v42);
			mtw_std_list_List_1_Cons();
		} break;
		case 23LL: { // OpDataSetLabel
			mtp_mirth_arrow_Op_OpDataSetLabel();
			VAL v43 = pop_value();
			decref(v43);
			VAL v44 = pop_value();
			decref(v44);
			uint64_t v45 = (0LL /* Nil */);
			push_u64(v45);
			mtw_std_list_List_1_Cons();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang (void) {
	mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang();
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_primZ_atomZBang (void) {
	VAL v0 = pop_value();
	decref(v0);
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	uint64_t v12 = (0LL /* Nil */);
	push_u64(v12);
	mtw_std_list_List_1_Cons();
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_wordZ_atomZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZToListZPlus();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* Nil */);
			push_u64(v4);
			mtw_std_list_List_1_Cons();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v5 = pop_value();
			incref(v5);
			push_value(v5);
			push_value(v5);
			mw_std_list_List_1_uncons();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			push_value(v6);
			push_value(v7);
			while(1) {
				VAL v8 = pop_value();
				incref(v8);
				push_value(v8);
				push_value(v8);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v9 = pop_value();
				if (!VBOOL(v9)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				push_value(v10);
				mw_mirth_specializzer_ZPlusSPCheck_checkZ_argZBang();
				push_value(v11);
				mw_std_list_List_1_uncons();
				VAL v12 = pop_value();
				VAL v13 = pop_value();
				push_value(v12);
				push_value(v13);
			}
			VAL v14 = pop_value();
			decref(v14);
			VAL v15 = pop_value();
			decref(v15);
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			incref(v17);
			push_value(v17);
			push_value(v16);
			push_value(v17);
			mw_mirth_word_Word_preferZ_inlineZAsk();
			VAL v18 = pop_value();
			if (VBOOL(v18)) {
				uint64_t v19 = (0LL /* False */);
				push_u64(v19);
			} else {
				uint64_t v20 = (1LL /* True */);
				push_u64(v20);
			}
			VAL v21 = pop_value();
			if (VBOOL(v21)) {
				uint64_t v22 = (1LL /* True */);
				push_u64(v22);
			} else {
				VAL v23 = pop_value();
				incref(v23);
				uint64_t v24 = (0LL /* None */);
				push_value(v23);
				push_u64(v24);
				push_value(v23);
				mw_std_list_List_1_uncons();
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				push_value(v25);
				push_value(v26);
				while(1) {
					VAL v27 = pop_value();
					incref(v27);
					push_value(v27);
					push_value(v27);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v28 = pop_value();
					if (!VBOOL(v28)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v29 = pop_value();
					VAL v30 = pop_value();
					VAL v31 = pop_value();
					incref(v29);
					VAL r32 = pop_resource();
					push_value(v29);
					mw_mirth_arrow_Arg_freeZ_vars();
					uint64_t v33 = (0LL /* None */);
					VAL v34 = pop_value();
					push_resource(r32);
					push_u64(v33);
					push_value(v34);
					mw_std_list_List_1_uncons();
					VAL v35 = pop_value();
					VAL v36 = pop_value();
					push_value(v35);
					push_value(v36);
					while(1) {
						VAL v37 = pop_value();
						incref(v37);
						push_value(v37);
						push_value(v37);
						mw_std_maybe_Maybe_1_someZAsk();
						VAL v38 = pop_value();
						if (!VBOOL(v38)) break;
						mw_std_maybe_Maybe_1_unwrap();
						VAL v39 = pop_value();
						VAL v40 = pop_value();
						VAL v41 = pop_value();
						incref(v39);
						push_value(v39);
						mw_mirth_var_Var_isZ_physicalZAsk();
						VAL v42 = pop_value();
						push_value(v39);
						if (VBOOL(v42)) {
							mtw_std_maybe_Maybe_1_Some();
						} else {
							VAL v43 = pop_value();
							decref(v43);
							uint64_t v44 = (0LL /* None */);
							push_u64(v44);
						}
						VAL v45 = pop_value();
						push_value(v41);
						push_value(v40);
						push_value(v45);
						switch (get_top_data_tag()) {
							case 0LL: { // None
								(void)pop_u64();
							} break;
							default: {
								VAL v46 = pop_value();
								VAL v47 = pop_value();
								decref(v47);
								VAL v48 = pop_value();
								decref(v48);
								uint64_t v49 = (0LL /* Nil */);
								push_value(v46);
								push_u64(v49);
							} break;
						}
						mw_std_list_List_1_uncons();
						VAL v50 = pop_value();
						VAL v51 = pop_value();
						push_value(v50);
						push_value(v51);
					}
					VAL v52 = pop_value();
					decref(v52);
					VAL v53 = pop_value();
					decref(v53);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v54 = pop_value();
					push_value(v29);
					if (VBOOL(v54)) {
						mtw_std_maybe_Maybe_1_Some();
					} else {
						VAL v55 = pop_value();
						decref(v55);
						uint64_t v56 = (0LL /* None */);
						push_u64(v56);
					}
					VAL v57 = pop_value();
					push_value(v31);
					push_value(v30);
					push_value(v57);
					switch (get_top_data_tag()) {
						case 0LL: { // None
							(void)pop_u64();
						} break;
						default: {
							VAL v58 = pop_value();
							VAL v59 = pop_value();
							decref(v59);
							VAL v60 = pop_value();
							decref(v60);
							uint64_t v61 = (0LL /* Nil */);
							push_value(v58);
							push_u64(v61);
						} break;
					}
					mw_std_list_List_1_uncons();
					VAL v62 = pop_value();
					VAL v63 = pop_value();
					push_value(v62);
					push_value(v63);
				}
				VAL v64 = pop_value();
				decref(v64);
				VAL v65 = pop_value();
				decref(v65);
				mw_std_maybe_Maybe_1_someZAsk();
			}
			VAL v66 = pop_value();
			if (VBOOL(v66)) {
				VAL v67 = pop_value();
				decref(v67);
				VAL v68 = pop_value();
				decref(v68);
				uint64_t v69 = (0LL /* Nil */);
				push_u64(v69);
				mtw_std_list_List_1_Cons();
			} else {
				VAL v70 = pop_value();
				VAL v71 = pop_value();
				VAL r72 = pop_resource();
				push_value(v70);
				push_value(v71);
				mw_mirth_specializzer_specializzeZ_wordZBang();
				VAL v73 = pop_value();
				incref(v73);
				push_resource(r72);
				push_value(v73);
				push_value(v73);
				mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang();
				VAL v74 = pop_value();
				VAL v75 = pop_value();
				VAL r76 = pop_resource();
				push_value(v74);
				push_value(v75);
				switch (get_top_data_tag()) {
					case 0LL: { // Atom
						mtp_mirth_arrow_Atom_Atom();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				VAL v77 = (lpop(&lbl_ctx));
				VAL v78 = (lpop(&lbl_dom));
				VAL v79 = (lpop(&lbl_cod));
				push_value(v77);
				push_value(v78);
				push_value(v79);
				mw_mirth_type_TZ_ZTo();
				VAL v80 = (lpop(&lbl_token));
				VAL v81 = (lpop(&lbl_home));
				VAL v82 = (lpop(&lbl_subst));
				VAL v83 = (lpop(&lbl_op));
				VAL v84 = (lpop(&lbl_args));
				decref(v84);
				decref(v83);
				decref(v82);
				mw_mirth_type_ArrowType_unpack();
				VAL v85 = pop_value();
				VAL v86 = pop_value();
				VAL v87 = pop_value();
				incref(v80);
				incref(v86);
				uint64_t v88 = (0LL /* Nil */);
				push_value(v85);
				lpush(&lbl_home, v81);
				lpush(&lbl_tokenZ_start, v80);
				lpush(&lbl_tokenZ_end, v80);
				lpush(&lbl_dom, v86);
				lpush(&lbl_cod, v86);
				lpush(&lbl_ctx, v87);
				lpush(&lbl_atoms, MKU64(v88));
				mtw_mirth_arrow_Arrow_Arrow();
				VAL v89 = pop_value();
				lpush(&lbl_arrow, v89);
				mtw_mirth_elab_ZPlusAB_ZPlusAB();
				VAL v90 = pop_value();
				mw_mirth_elab_abZ_wordZBang();
				push_value(v90);
				mw_mirth_elab_abZ_unifyZ_typeZBang();
				mtp_mirth_elab_ZPlusAB_ZPlusAB();
				VAL v91 = (lpop(&lbl_arrow));
				push_value(v91);
				push_resource(r76);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[7];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_matchZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v1 = (0LL /* Nil */);
	push_u64(v1);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		VAL r8 = pop_resource();
		push_value(v6);
		mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang();
		push_resource(r8);
		mtp_std_list_ZPlusList_1_ZPlusList();
		mtw_std_list_List_1_Cons();
		mtw_std_list_ZPlusList_1_ZPlusList();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	push_value(v0);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[7];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(8);
			tup->size = 8;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
			tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
			tup->cells[7] = u;
			decref(v);
			push_value(MKTUP(tup,8));
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_caseZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang();
	push_value(v0);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(3);
			tup->size = 3;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = u;
			decref(v);
			push_value(MKTUP(tup,3));
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_checkZ_lambdaZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_specializzer_ZPlusSPCheck_checkZ_arrowZBang();
	push_value(v0);
	{
		VAL v = pop_value();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		if (VTUP(v)->refs == 1) {
			VAL* p = &VTUP(v)->cells[5];
			VAL t = *p; *p = u; decref(t);
			push_value(v);
		} else {
			TUP *tup = tup_new(6);
			tup->size = 6;
			tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
			tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
			tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
			tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
			tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
			tup->cells[5] = u;
			decref(v);
			push_value(MKTUP(tup,6));
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_wordZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_word_Word_ZTildespZ_checked();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
	} else {
		uint64_t v4 = (1LL /* True */);
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_u64(v4);
		push_value(v5);
		mfld_mirth_word_Word_ZTildespZ_checked();
		mp_primZ_mutZ_set();
		mtw_mirth_specializzer_SPCheckItem_SPCHECKz_WORD();
		{
			VAL v = top_resource();
			incref(v);
			push_value(v);
		}
		VAL r6 = pop_resource();
		mtw_std_list_List_1_Cons();
		push_resource(r6);
		{
			VAL v = pop_resource();
			push_resource(pop_value());
			decref(v);
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPCheck_pushZ_checkZ_blockZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_arrow_Block_ZTildespZ_checked();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v1 = (0LL /* False */);
			push_u64(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		VAL v3 = pop_value();
		decref(v3);
	} else {
		uint64_t v4 = (1LL /* True */);
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_u64(v4);
		push_value(v5);
		mfld_mirth_arrow_Block_ZTildespZ_checked();
		mp_primZ_mutZ_set();
		mtw_mirth_specializzer_SPCheckItem_SPCHECKz_BLOCK();
		{
			VAL v = top_resource();
			incref(v);
			push_value(v);
		}
		VAL r6 = pop_resource();
		mtw_std_list_List_1_Cons();
		push_resource(r6);
		{
			VAL v = pop_resource();
			push_resource(pop_value());
			decref(v);
		}
	}
}
static void mw_mirth_specializzer_SPKey_ZEqualZEqual (void) {
	VAL v0 = pop_value();
	uint64_t v1 = (1LL /* True */);
	push_value(v0);
	push_u64(v1);
	while(1) {
		VAL v2 = pop_value();
		VAL v3 = pop_value();
		mw_std_list_List_1_uncons();
		push_value(v3);
		mw_std_list_List_1_uncons();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		push_value(v5);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
				mw_std_maybe_Maybe_1_noneZAsk();
			} break;
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				push_value(v7);
				push_value(v8);
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v9 = pop_value();
						VAL v10 = pop_value();
						push_value(v9);
						push_value(v10);
						mw_mirth_arrow_Arg_ZEqualZEqual();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						VAL v11 = pop_value();
						decref(v11);
						uint64_t v12 = (0LL /* False */);
						push_u64(v12);
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v13 = pop_value();
		push_value(v6);
		push_value(v4);
		push_value(v13);
		if (VBOOL(v2)) {
		} else {
			VAL v14 = pop_value();
			decref(v14);
			uint64_t v15 = (0LL /* False */);
			push_u64(v15);
		}
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		VAL v18 = pop_value();
		incref(v18);
		push_value(v18);
		push_value(v17);
		push_value(v16);
		push_value(v18);
		mw_std_list_List_1_emptyZAsk();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		incref(v21);
		push_value(v21);
		push_value(v20);
		push_value(v19);
		push_value(v21);
		mw_std_list_List_1_emptyZAsk();
		VAL v22 = pop_value();
		if (VBOOL(v22)) {
		} else {
			VAL v23 = pop_value();
			decref(v23);
			uint64_t v24 = (0LL /* False */);
			push_u64(v24);
		}
		VAL v25 = pop_value();
		if (VBOOL(v25)) {
			uint64_t v26 = (0LL /* False */);
			push_u64(v26);
		} else {
			uint64_t v27 = (1LL /* True */);
			push_u64(v27);
		}
		VAL v28 = pop_value();
		VAL v29 = pop_value();
		incref(v29);
		push_value(v29);
		push_value(v28);
		if (VBOOL(v29)) {
		} else {
			VAL v30 = pop_value();
			decref(v30);
			uint64_t v31 = (0LL /* False */);
			push_u64(v31);
		}
		VAL v32 = pop_value();
		if (!VBOOL(v32)) break;
	}
	VAL v33 = pop_value();
	VAL v34 = pop_value();
	decref(v34);
	VAL v35 = pop_value();
	decref(v35);
	push_value(v33);
}
static void mw_mirth_specializzer_SPKey_ZToStr (void) {
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	STRLIT("(", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v0 = pop_value();
	STRLIT("", 0);
	push_value(v0);
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL r7 = pop_resource();
		push_value(v5);
		mw_mirth_arrow_Arg_ZToStr();
		push_resource(r7);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(",", 1);
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
	STRLIT(")", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mtp_std_str_ZPlusStr_ZPlusStr();
}
static void mw_mirth_specializzer_SPKey_ZToName (void) {
	mw_mirth_specializzer_SPKey_ZToStr();
	mw_std_prim_Str_ZToName();
}
static void mw_mirth_word_Word_spZ_synthed (void) {
	mfld_mirth_word_Word_ZTildespZ_synthed();
	mw_std_prelude_ZAtZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_std_map_Map_2_empty();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_specializzer_specializzeZ_wordZBang (void) {
	{
		VAL v0 = pop_value();
		VAL var_w = v0;
		VAL v1 = pop_value();
		VAL var_k = v1;
		incref(var_k);
		VAL v2 = (var_k);
		push_value(v2);
		incref(var_w);
		VAL v3 = (var_w);
		push_value(v3);
		mw_mirth_word_Word_spZ_synthed();
		uint64_t v4 = (0LL /* None */);
		VAL v5 = pop_value();
		push_u64(v4);
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
		while(1) {
			VAL v8 = pop_value();
			incref(v8);
			push_value(v8);
			push_value(v8);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v9 = pop_value();
			if (!VBOOL(v9)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v10 = pop_value();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			incref(v10);
			VAL v13 = pop_value();
			incref(v13);
			push_value(v13);
			push_value(v10);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_specializzer_SPKey_ZEqualZEqual();
			VAL v14 = pop_value();
			push_value(v13);
			push_value(v10);
			if (VBOOL(v14)) {
				mtw_std_maybe_Maybe_1_Some();
			} else {
				VAL v15 = pop_value();
				decref(v15);
				uint64_t v16 = (0LL /* None */);
				push_u64(v16);
			}
			VAL v17 = pop_value();
			push_value(v12);
			push_value(v11);
			push_value(v17);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					VAL v18 = pop_value();
					VAL v19 = pop_value();
					decref(v19);
					VAL v20 = pop_value();
					decref(v20);
					uint64_t v21 = (0LL /* Nil */);
					push_value(v18);
					push_u64(v21);
				} break;
			}
			mw_std_list_List_1_uncons();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			push_value(v23);
		}
		VAL v24 = pop_value();
		decref(v24);
		VAL v25 = pop_value();
		decref(v25);
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		decref(v27);
		push_value(v26);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mtw_std_maybe_Maybe_1_Some();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				uint64_t v28 = (0LL /* None */);
				push_u64(v28);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				uint64_t v29 = (0LL /* False */);
				VAL v30 = pop_value();
				incref(v30);
				push_value(v30);
				push_u64(v29);
				push_value(v30);
				mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk();
				mp_primZ_mutZ_set();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				incref(var_w);
				VAL v31 = (var_w);
				push_value(v31);
				mw_mirth_word_Word_head();
				VAL v32 = pop_value();
				uint64_t v33 = (0LL /* None */);
				lpush(&lbl_head, v32);
				lpush(&lbl_sigZAsk, MKU64(v33));
				incref(var_w);
				VAL v34 = (var_w);
				push_value(v34);
				mw_mirth_word_Word_body();
				VAL v35 = pop_value();
				lpush(&lbl_body, v35);
				incref(var_k);
				VAL v36 = (var_k);
				push_value(v36);
				mw_mirth_specializzer_SPKey_ZToName();
				VAL v37 = pop_value();
				int64_t v38 = (0LL);
				lpush(&lbl_name, v37);
				lpush(&lbl_arity, MKI64(v38));
				mw_mirth_word_Word_newZBang();
				{
					VAL v39 = pop_value();
					VAL var_wZTick = v39;
					incref(var_w);
					VAL v40 = (var_w);
					push_value(v40);
					mtw_mirth_name_Namespace_NAMESPACEz_WORD();
					incref(var_k);
					VAL v41 = (var_k);
					push_value(v41);
					mw_mirth_specializzer_SPKey_ZToName();
					mw_mirth_name_QNAME0();
					incref(var_wZTick);
					VAL v42 = (var_wZTick);
					push_value(v42);
					mtw_mirth_mirth_PropLabel_WordQName();
					mw_mirth_mirth_PropLabel_prop();
					incref(var_wZTick);
					VAL v43 = (var_wZTick);
					push_value(v43);
					mfld_mirth_word_Word_ZTildeqname();
					mp_primZ_mutZ_set();
					incref(var_k);
					VAL v44 = (var_k);
					lpush(&lbl_key, v44);
					incref(var_wZTick);
					VAL v45 = (var_wZTick);
					lpush(&lbl_value, v45);
					mtw_std_map_KVPair_2_KVPair();
					incref(var_w);
					VAL v46 = (var_w);
					push_value(v46);
					mw_mirth_word_Word_spZ_synthed();
					mw_std_map_Map_2_insert();
					incref(var_w);
					VAL v47 = (var_w);
					push_value(v47);
					mfld_mirth_word_Word_ZTildespZ_synthed();
					mp_primZ_mutZ_set();
					incref(var_k);
					VAL v48 = (var_k);
					push_value(v48);
					incref(var_w);
					VAL v49 = (var_w);
					push_value(v49);
					incref(var_w);
					VAL v50 = (var_w);
					push_value(v50);
					mtw_mirth_mirth_PropLabel_WordType();
					VAL v51 = (MKFNPTR(&mb_mirth_specializzer_specializzeZ_wordZBang_1));
					push_value(v51);
					mw_mirth_mirth_PropLabel_prop2_1();
					incref(var_wZTick);
					VAL v52 = (var_wZTick);
					push_value(v52);
					mfld_mirth_word_Word_ZTildectxZ_type();
					mp_primZ_mutZ_set();
					uint64_t v53 = (1LL /* True */);
					push_u64(v53);
					incref(var_wZTick);
					VAL v54 = (var_wZTick);
					push_value(v54);
					mfld_mirth_word_Word_ZTildepreferZ_inlineZAsk();
					mp_primZ_mutZ_set();
					incref(var_k);
					VAL v55 = (var_k);
					push_value(v55);
					incref(var_w);
					VAL v56 = (var_w);
					push_value(v56);
					incref(var_wZTick);
					VAL v57 = (var_wZTick);
					push_value(v57);
					incref(var_wZTick);
					VAL v58 = (var_wZTick);
					push_value(v58);
					mtw_mirth_mirth_PropLabel_WordArrow();
					VAL v59 = (MKFNPTR(&mb_mirth_specializzer_specializzeZ_wordZBang_2));
					push_value(v59);
					mw_mirth_mirth_PropLabel_prop3_1();
					incref(var_wZTick);
					VAL v60 = (var_wZTick);
					push_value(v60);
					mfld_mirth_word_Word_ZTildearrow();
					mp_primZ_mutZ_set();
					incref(var_wZTick);
					VAL v61 = (var_wZTick);
					decref(var_wZTick);
					push_value(v61);
				}
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		decref(var_w);
		decref(var_k);
	}
}
static void mw_mirth_specializzer_specializzeZ_ctxZ_type (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	uint64_t v2 = (0LL /* SUBST_NIL */);
	push_u64(v2);
	push_value(v0);
	mw_mirth_type_ArrowType_freshen();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	decref(v4);
	VAL v5 = pop_value();
	incref(v5);
	push_value(v3);
	push_value(v5);
	push_value(v5);
	mw_std_list_ListZPlus_1_first();
	mw_mirth_arrow_Arg_token();
	VAL v6 = pop_value();
	lpush(&lbl_token, v6);
	mtw_mirth_type_ZPlusGamma_ZPlusGamma();
	VAL v7 = pop_value();
	uint64_t v8 = (0LL /* SUBST_NIL */);
	mw_mirth_type_ArrowType_unpack();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	push_value(v7);
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	push_value(v11);
	push_value(v12);
	while(1) {
		VAL v13 = pop_value();
		incref(v13);
		push_value(v13);
		push_value(v13);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v14 = pop_value();
		if (!VBOOL(v14)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		mw_mirth_type_StackType_forceZ_consZAskZBang();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("unexpected domain in specialize-ctx-type", 40);
				mp_primZ_panic();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mp_primZ_packZ_uncons();
		VAL v17 = pop_value();
		mp_primZ_packZ_uncons();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		decref(v19);
		push_value(v18);
		push_value(v17);
		push_value(v15);
		mw_mirth_arrow_Block_type();
		mtw_mirth_type_Type_TMorphism();
		mw_mirth_type_Type_unifyZBang();
		VAL v20 = pop_value();
		decref(v20);
		push_value(v16);
		mw_std_list_List_1_uncons();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		push_value(v21);
		push_value(v22);
	}
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	decref(v24);
	mw_mirth_type_ZPlusGamma_rdrop();
	VAL v25 = pop_value();
	VAL v26 = pop_value();
	push_value(v25);
	push_value(v26);
	mw_mirth_type_TZ_ZTo();
	VAL v27 = pop_value();
	mw_mirth_var_Ctx0();
	push_value(v27);
	mw_mirth_type_ArrowType_rigidifyZ_sigZBang();
}
static void mw_mirth_specializzer_synthZ_specializzedZ_wordZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	VAL v1 = pop_value();
	VAL r2 = pop_resource();
	lpush(&lbl_spword, v0);
	lpush(&lbl_spkey, v1);
	push_value(v0);
	mw_mirth_word_Word_arrow();
	push_resource(r2);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_ZDivL1();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("unexpected shape for synth-specialized-word!", 44);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			VAL v3 = pop_value();
			incref(v3);
			push_value(v3);
			push_value(v3);
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 6, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			VAL v4 = (lpop(&lbl_spkey));
			incref(v4);
			VAL v5 = pop_value();
			incref(v5);
			lpush(&lbl_spkey, v4);
			push_value(v5);
			push_value(v4);
			push_value(v5);
			mw_std_list_List_1_len();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			incref(v7);
			push_value(v7);
			push_value(v6);
			push_value(v7);
			mw_std_list_List_1_len();
			VAL v8 = pop_value();
			VAL v9 = pop_value();
			bool v10 = (VI64(v9) == VI64(v8));
			if (v10) {
			} else {
				STRLIT("wrong number of lambda params in synth-specialized-word!", 56);
				STRLIT("assertion failed: ", 18);
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				push_value(v11);
				push_value(v12);
				mp_primZ_strZ_cat();
				mp_primZ_panic();
			}
			uint64_t v13 = (0LL /* Nil */);
			push_u64(v13);
			mw_std_list_List_1_reverse();
			mtw_std_list_ZPlusList_1_ZPlusList();
			VAL r14 = pop_resource();
			mw_std_list_List_1_uncons();
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			mw_std_list_List_1_uncons();
			VAL v17 = pop_value();
			push_value(v16);
			switch (get_top_data_tag()) {
				case 0LL: { // None
					(void)pop_u64();
					VAL v18 = pop_value();
					decref(v18);
					uint64_t v19 = (0LL /* None */);
					push_u64(v19);
				} break;
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v20 = pop_value();
					VAL v21 = pop_value();
					push_value(v20);
					push_value(v21);
					switch (get_top_data_tag()) {
						case 0LL: { // None
							(void)pop_u64();
							VAL v22 = pop_value();
							decref(v22);
							uint64_t v23 = (0LL /* None */);
							push_u64(v23);
						} break;
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v24 = pop_value();
							VAL v25 = pop_value();
							lpush(&lbl_value, v25);
							lpush(&lbl_key, v24);
							mtw_std_map_KVPair_2_KVPair();
							mtw_std_maybe_Maybe_1_Some();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v26 = pop_value();
			push_value(v17);
			push_value(v15);
			push_value(v26);
			push_resource(r14);
			while(1) {
				VAL v27 = pop_value();
				incref(v27);
				push_value(v27);
				push_value(v27);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v28 = pop_value();
				if (!VBOOL(v28)) break;
				mw_std_maybe_Maybe_1_unwrap();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
				VAL r29 = pop_resource();
				mw_std_list_List_1_uncons();
				VAL v30 = pop_value();
				VAL v31 = pop_value();
				mw_std_list_List_1_uncons();
				VAL v32 = pop_value();
				push_value(v31);
				switch (get_top_data_tag()) {
					case 0LL: { // None
						(void)pop_u64();
						VAL v33 = pop_value();
						decref(v33);
						uint64_t v34 = (0LL /* None */);
						push_u64(v34);
					} break;
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v35 = pop_value();
						VAL v36 = pop_value();
						push_value(v35);
						push_value(v36);
						switch (get_top_data_tag()) {
							case 0LL: { // None
								(void)pop_u64();
								VAL v37 = pop_value();
								decref(v37);
								uint64_t v38 = (0LL /* None */);
								push_u64(v38);
							} break;
							case 1LL: { // Some
								mtp_std_maybe_Maybe_1_Some();
								VAL v39 = pop_value();
								VAL v40 = pop_value();
								lpush(&lbl_value, v40);
								lpush(&lbl_key, v39);
								mtw_std_map_KVPair_2_KVPair();
								mtw_std_maybe_Maybe_1_Some();
							} break;
							default: {
								push_value(mkstr("unexpected fallthrough in match\n", 32));
								mp_primZ_panic();
							}
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				VAL v41 = pop_value();
				push_value(v32);
				push_value(v30);
				push_value(v41);
				push_resource(r29);
			}
			VAL v42 = pop_value();
			decref(v42);
			mtp_std_list_ZPlusList_1_ZPlusList();
			mw_std_list_List_1_reverse();
			VAL v43 = pop_value();
			VAL v44 = pop_value();
			decref(v44);
			VAL v45 = pop_value();
			decref(v45);
			lpush(&lbl_spmap, v43);
			mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 6, v);
				VAL* p = &VTUP(v)->cells[5];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +SPSYNTH
					mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v46 = (lpop(&lbl_spkey));
			VAL v47 = (lpop(&lbl_spword));
			VAL v48 = (lpop(&lbl_spmap));
			decref(v48);
			decref(v47);
			decref(v46);
		} break;
		default: {
			STRLIT("unexpected shape", 16);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_atomZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SPSYNTH
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
			mw_mirth_elab_abZ_tokenZBang();
			mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v5 = pop_value();
		if (!VBOOL(v5)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang();
		push_value(v7);
		mw_std_list_List_1_uncons();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v8);
		push_value(v9);
	}
	VAL v10 = pop_value();
	decref(v10);
	VAL v11 = pop_value();
	decref(v11);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang();
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_argZBang (void) {
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang();
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_opZBang (void) {
	switch (get_top_data_tag()) {
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang();
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang();
		} break;
		case 14LL: { // OpBlockPush
			mtp_mirth_arrow_Op_OpBlockPush();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang();
		} break;
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang();
		} break;
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang();
		} break;
		default: {
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +SPSYNTH
					mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
					mw_mirth_elab_abZ_opZBang();
					mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_blockZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	VAL r1 = pop_resource();
	push_value(v0);
	push_value(v0);
	mw_mirth_arrow_Block_toZ_runZ_var();
	push_resource(r1);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			uint64_t v2 = (0LL /* None */);
			VAL v3 = pop_value();
			push_u64(v2);
			push_value(v3);
			mw_std_list_List_1_uncons();
			VAL v4 = pop_value();
			VAL v5 = pop_value();
			push_value(v4);
			push_value(v5);
			while(1) {
				VAL v6 = pop_value();
				incref(v6);
				push_value(v6);
				push_value(v6);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v7 = pop_value();
				if (!VBOOL(v7)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v8 = pop_value();
				VAL v9 = pop_value();
				VAL v10 = pop_value();
				incref(v8);
				VAL v11 = pop_value();
				incref(v11);
				push_value(v11);
				push_value(v8);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_var_Var_ZEqualZEqual();
				VAL v12 = pop_value();
				push_value(v11);
				push_value(v8);
				if (VBOOL(v12)) {
					mtw_std_maybe_Maybe_1_Some();
				} else {
					VAL v13 = pop_value();
					decref(v13);
					uint64_t v14 = (0LL /* None */);
					push_u64(v14);
				}
				VAL v15 = pop_value();
				push_value(v10);
				push_value(v9);
				push_value(v15);
				switch (get_top_data_tag()) {
					case 0LL: { // None
						(void)pop_u64();
					} break;
					default: {
						VAL v16 = pop_value();
						VAL v17 = pop_value();
						decref(v17);
						VAL v18 = pop_value();
						decref(v18);
						uint64_t v19 = (0LL /* Nil */);
						push_value(v16);
						push_u64(v19);
					} break;
				}
				mw_std_list_List_1_uncons();
				VAL v20 = pop_value();
				VAL v21 = pop_value();
				push_value(v20);
				push_value(v21);
			}
			VAL v22 = pop_value();
			decref(v22);
			VAL v23 = pop_value();
			decref(v23);
			VAL v24 = pop_value();
			VAL v25 = pop_value();
			decref(v25);
			push_value(v24);
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mtw_std_maybe_Maybe_1_Some();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v26 = (0LL /* None */);
					push_u64(v26);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v27 = (0LL /* None */);
			push_u64(v27);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +SPSYNTH
					mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
					mw_mirth_elab_abZ_tokenZAt();
					mw_mirth_elab_abZ_ctxZAt();
					mw_mirth_type_MetaVar_newZBang();
					mtw_mirth_type_StackType_STMeta();
					VAL v28 = pop_value();
					VAL v29 = pop_value();
					VAL v30 = pop_value();
					push_value(v29);
					push_value(v28);
					push_value(v30);
					mw_mirth_elab_abZ_homeZAt();
					VAL r31 = pop_resource();
					VAL v32 = pop_value();
					VAL v33 = pop_value();
					incref(v33);
					VAL v34 = pop_value();
					incref(v34);
					VAL v35 = pop_value();
					uint64_t v36 = (0LL /* Nil */);
					lpush(&lbl_home, v32);
					lpush(&lbl_tokenZ_start, v33);
					lpush(&lbl_tokenZ_end, v33);
					lpush(&lbl_dom, v34);
					lpush(&lbl_cod, v34);
					lpush(&lbl_ctx, v35);
					lpush(&lbl_atoms, MKU64(v36));
					mtw_mirth_arrow_Arrow_Arrow();
					VAL v37 = pop_value();
					lpush(&lbl_arrow, v37);
					mtw_mirth_elab_ZPlusAB_ZPlusAB();
					mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
					mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang();
					switch (get_top_resource_data_tag()) {
						case 0LL: { // +SPSYNTH
							mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
					mtp_mirth_elab_ZPlusAB_ZPlusAB();
					VAL v38 = (lpop(&lbl_arrow));
					push_value(v38);
					mw_mirth_arrow_Block_newZBang();
					push_resource(r31);
					mtw_mirth_arrow_Op_OpBlockPush();
					mw_mirth_elab_abZ_opZBang();
					mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v39 = pop_value();
			VAL v40 = pop_value();
			decref(v40);
			push_value(v39);
			mtw_mirth_arrow_Op_OpBlockPush();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +SPSYNTH
					mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
					mw_mirth_elab_abZ_opZBang();
					mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_runZBang (void) {
	VAL r0 = pop_resource();
	mw_mirth_arrow_Block_arrow();
	push_resource(r0);
	mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang();
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_varZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v1 = (0LL /* None */);
	VAL v2 = pop_value();
	push_u64(v1);
	push_value(v2);
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		incref(v7);
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v7);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_var_Var_ZEqualZEqual();
		VAL v11 = pop_value();
		push_value(v10);
		push_value(v7);
		if (VBOOL(v11)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (0LL /* None */);
			push_u64(v13);
		}
		VAL v14 = pop_value();
		push_value(v9);
		push_value(v8);
		push_value(v14);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				decref(v16);
				VAL v17 = pop_value();
				decref(v17);
				uint64_t v18 = (0LL /* Nil */);
				push_value(v15);
				push_u64(v18);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		push_value(v20);
	}
	VAL v21 = pop_value();
	decref(v21);
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	VAL v24 = pop_value();
	decref(v24);
	push_value(v23);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v25 = (0LL /* None */);
			push_u64(v25);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v26 = pop_value();
			VAL v27 = pop_value();
			decref(v27);
			push_value(v26);
			mtw_mirth_arrow_Op_OpBlockRun();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +SPSYNTH
					mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
					mw_mirth_elab_abZ_opZBang();
					mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 0LL: { // None
			(void)pop_u64();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +SPSYNTH
					mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
					mw_mirth_elab_abZ_varZBang();
					mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_matchZBang (void) {
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	lpush(&lbl_cod, v0);
	push_value(v1);
	push_value(v1);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	lpush(&lbl_body, v2);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SPSYNTH
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
			mw_mirth_elab_abZ_ctxZAt();
			VAL v3 = pop_value();
			lpush(&lbl_ctx, v3);
			mw_mirth_elab_abZ_typeZAt();
			VAL v4 = pop_value();
			lpush(&lbl_dom, v4);
			mw_mirth_elab_abZ_tokenZAt();
			VAL v5 = pop_value();
			lpush(&lbl_token, v5);
			mw_mirth_elab_abZ_homeZAt();
			VAL v6 = pop_value();
			uint64_t v7 = (0LL /* Nil */);
			VAL r8 = pop_resource();
			lpush(&lbl_home, v6);
			lpush(&lbl_cases, MKU64(v7));
			mtw_mirth_match_ZPlusMatch_ZPlusMatch();
			mw_std_list_List_1_uncons();
			VAL v9 = pop_value();
			VAL v10 = pop_value();
			push_value(v9);
			push_value(v10);
			while(1) {
				VAL v11 = pop_value();
				incref(v11);
				push_value(v11);
				push_value(v11);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v12 = pop_value();
				if (!VBOOL(v12)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				incref(v13);
				push_value(v13);
				push_value(v13);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 10, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				VAL v15 = pop_value();
				VAL v16 = pop_value();
				incref(v16);
				push_value(v16);
				push_value(v15);
				push_value(v16);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				VAL v17 = pop_value();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL v18 = pop_value();
				VAL v19 = pop_value();
				incref(v19);
				lpush(&lbl_home, v18);
				lpush(&lbl_tokenZ_start, v19);
				lpush(&lbl_tokenZ_end, v19);
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[4];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL v20 = pop_value();
				incref(v20);
				uint64_t v21 = (0LL /* Nil */);
				lpush(&lbl_outerZ_ctx, v20);
				lpush(&lbl_innerZ_ctx, v20);
				lpush(&lbl_saved, MKU64(v21));
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[5];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL v22 = pop_value();
				incref(v22);
				uint64_t v23 = (0LL /* Nil */);
				lpush(&lbl_mid, v22);
				lpush(&lbl_cod, v22);
				lpush(&lbl_atoms, MKU64(v23));
				mtw_mirth_match_Pattern_Pattern();
				VAL r24 = pop_resource();
				mw_mirth_match_Pattern_thaw();
				VAL v25 = pop_value();
				incref(v25);
				push_value(v25);
				push_value(v25);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 10, v);
					VAL* p = &VTUP(v)->cells[9];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_std_list_List_1_reverse();
				mw_std_list_List_1_uncons();
				VAL v26 = pop_value();
				VAL v27 = pop_value();
				push_value(v26);
				push_value(v27);
				while(1) {
					VAL v28 = pop_value();
					incref(v28);
					push_value(v28);
					push_value(v28);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v29 = pop_value();
					if (!VBOOL(v29)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v30 = pop_value();
					VAL v31 = pop_value();
					push_value(v30);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 8, v);
						VAL* p = &VTUP(v)->cells[7];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mw_mirth_match_ZPlusPattern_opZBang();
					push_value(v31);
					mw_std_list_List_1_uncons();
					VAL v32 = pop_value();
					VAL v33 = pop_value();
					push_value(v32);
					push_value(v33);
				}
				VAL v34 = pop_value();
				decref(v34);
				VAL v35 = pop_value();
				decref(v35);
				mw_mirth_match_ZPlusPattern_freezze();
				VAL v36 = pop_value();
				incref(v36);
				push_resource(r24);
				push_value(v17);
				push_value(v36);
				lpush(&lbl_pattern, v36);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 10, v);
					VAL* p = &VTUP(v)->cells[5];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				VAL v37 = (lpop(&lbl_pattern));
				incref(v37);
				push_value(v37);
				lpush(&lbl_pattern, v37);
				mw_mirth_match_Pattern_dom();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[6];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				mw_mirth_type_TZ_ZTo();
				VAL v38 = pop_value();
				VAL v39 = pop_value();
				VAL v40 = pop_value();
				push_value(v39);
				push_value(v38);
				push_value(v40);
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL v41 = (lpop(&lbl_pattern));
				VAL r42 = pop_resource();
				VAL v43 = pop_value();
				VAL v44 = pop_value();
				mw_mirth_type_ArrowType_unpack();
				VAL v45 = pop_value();
				VAL v46 = pop_value();
				VAL v47 = pop_value();
				incref(v44);
				incref(v46);
				uint64_t v48 = (0LL /* Nil */);
				push_value(v45);
				lpush(&lbl_home, v43);
				lpush(&lbl_tokenZ_start, v44);
				lpush(&lbl_tokenZ_end, v44);
				lpush(&lbl_dom, v46);
				lpush(&lbl_cod, v46);
				lpush(&lbl_ctx, v47);
				lpush(&lbl_atoms, MKU64(v48));
				mtw_mirth_arrow_Arrow_Arrow();
				VAL v49 = pop_value();
				lpush(&lbl_arrow, v49);
				mtw_mirth_elab_ZPlusAB_ZPlusAB();
				VAL v50 = pop_value();
				mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang();
				switch (get_top_resource_data_tag()) {
					case 0LL: { // +SPSYNTH
						mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				push_value(v50);
				mw_mirth_elab_abZ_unifyZ_typeZBang();
				mtp_mirth_elab_ZPlusAB_ZPlusAB();
				VAL v51 = (lpop(&lbl_arrow));
				push_resource(r42);
				lpush(&lbl_pattern, v41);
				lpush(&lbl_body, v51);
				mtw_mirth_match_Case_CASE();
				mw_mirth_match_ZPlusMatch_addZ_case();
				push_value(v14);
				mw_std_list_List_1_uncons();
				VAL v52 = pop_value();
				VAL v53 = pop_value();
				push_value(v52);
				push_value(v53);
			}
			VAL v54 = pop_value();
			decref(v54);
			VAL v55 = pop_value();
			decref(v55);
			mw_mirth_match_ZPlusMatch_freezze();
			push_resource(r8);
			mtw_mirth_arrow_Op_OpMatch();
			mw_mirth_elab_abZ_opZBang();
			mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_specializzer_ZPlusSPSynth_synthZ_lambdaZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SPSYNTH
			mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
			VAL v1 = pop_value();
			mw_mirth_elab_abZ_tokenZAt();
			incref(v1);
			mw_mirth_elab_abZ_ctxZAt();
			mw_mirth_elab_abZ_typeZAt();
			push_value(v1);
			mw_std_list_List_1_reverse();
			mw_std_list_List_1_uncons();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			while(1) {
				VAL v4 = pop_value();
				incref(v4);
				push_value(v4);
				push_value(v4);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v5 = pop_value();
				if (!VBOOL(v5)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v6 = pop_value();
				VAL v7 = pop_value();
				VAL v8 = pop_value();
				incref(v6);
				push_value(v6);
				mw_mirth_var_Ctx_new();
				push_value(v6);
				push_value(v8);
				mw_mirth_elab_abZ_tokenZAt();
				VAL r9 = pop_resource();
				mw_mirth_elab_elabZ_expandZ_tensorZBang();
				VAL v10 = pop_value();
				VAL v11 = pop_value();
				VAL v12 = pop_value();
				VAL v13 = pop_value();
				push_resource(r9);
				push_value(v12);
				push_value(v11);
				push_value(v13);
				mw_mirth_var_Var_type();
				VAL r14 = pop_resource();
				push_value(v10);
				mw_mirth_elab_elabZ_typeZ_unifyZBang();
				VAL v15 = pop_value();
				decref(v15);
				VAL v16 = pop_value();
				decref(v16);
				push_resource(r14);
				push_value(v7);
				mw_std_list_List_1_uncons();
				VAL v17 = pop_value();
				VAL v18 = pop_value();
				push_value(v17);
				push_value(v18);
			}
			VAL v19 = pop_value();
			decref(v19);
			VAL v20 = pop_value();
			decref(v20);
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			push_value(v21);
			push_value(v23);
			mw_mirth_elab_abZ_homeZAt();
			VAL r24 = pop_resource();
			VAL v25 = pop_value();
			VAL v26 = pop_value();
			incref(v26);
			VAL v27 = pop_value();
			incref(v27);
			VAL v28 = pop_value();
			uint64_t v29 = (0LL /* Nil */);
			lpush(&lbl_home, v25);
			lpush(&lbl_tokenZ_start, v26);
			lpush(&lbl_tokenZ_end, v26);
			lpush(&lbl_dom, v27);
			lpush(&lbl_cod, v27);
			lpush(&lbl_ctx, v28);
			lpush(&lbl_atoms, MKU64(v29));
			mtw_mirth_arrow_Arrow_Arrow();
			VAL v30 = pop_value();
			lpush(&lbl_arrow, v30);
			mtw_mirth_elab_ZPlusAB_ZPlusAB();
			mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 6, v);
				VAL* p = &VTUP(v)->cells[5];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_mirth_specializzer_ZPlusSPSynth_synthZ_arrowZBang();
			switch (get_top_resource_data_tag()) {
				case 0LL: { // +SPSYNTH
					mtp_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			mtp_mirth_elab_ZPlusAB_ZPlusAB();
			VAL v31 = (lpop(&lbl_arrow));
			push_resource(r24);
			lpush(&lbl_params, v1);
			lpush(&lbl_body, v31);
			mw_mirth_elab_abZ_ctxZAt();
			VAL v32 = pop_value();
			lpush(&lbl_outerZ_ctx, v32);
			mw_mirth_elab_abZ_typeZAt();
			VAL v33 = pop_value();
			lpush(&lbl_dom, v33);
			mw_mirth_elab_abZ_tokenZAt();
			VAL v34 = pop_value();
			lpush(&lbl_token, v34);
			mtw_mirth_arrow_Lambda_Lambda();
			mtw_mirth_arrow_Op_OpLambda();
			mw_mirth_elab_abZ_opZBang();
			mtw_mirth_specializzer_ZPlusSPSynth_ZPlusSPSYNTH();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_std_set_SETz_INITIALz_SIZZE (void) {
	int64_t v0 = (256LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
}
static void mw_std_set_ZPlusSet_new (void) {
	mw_std_set_SETz_INITIALz_SIZZE();
	mw_std_buffer_ZPlusBuffer_new();
	VAL r0 = pop_resource();
	lpush(&lbl_ZPlusbuffer, r0);
	mtw_std_set_ZPlusSet_ZPlusSet();
}
static void mw_std_set_ZPlusSet_rdrop (void) {
	mtp_std_set_ZPlusSet_ZPlusSet();
	VAL v0 = (lpop(&lbl_ZPlusbuffer));
	push_resource(v0);
	mw_std_buffer_ZPlusBuffer_rdrop();
}
static void mw_std_set_ZPlusSet_offsetZ_mask (void) {
	int64_t v0 = (8LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	incref(v1);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	push_value(v1);
	mp_primZ_intZ_mod();
	VAL v3 = pop_value();
	mp_primZ_intZ_div();
	VAL v4 = pop_value();
	incref(v4);
	int64_t v5 = (1LL);
	push_value(v4);
	push_value(v3);
	push_value(v4);
	push_i64(v5);
	mp_primZ_intZ_add();
	{
		push_resource(MKU64(0));
	}
	VAL r6 = pop_resource();
	mw_std_buffer_ZPlusBuffer_expandZBang();
	push_resource(r6);
	{
		(void)pop_resource();
	}
	VAL v7 = pop_value();
	int64_t v8 = (1LL);
	push_value(v7);
	push_i64(v8);
	mw_std_prim_Int_ZToNat();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	mp_primZ_intZ_shl();
	mw_std_prim_Int_ZToU8();
}
static void mw_std_set_ZPlusSet_memberZAsk (void) {
	mw_std_set_ZPlusSet_offsetZ_mask();
	{
		push_resource(MKU64(0));
	}
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	mw_std_buffer_ZPlusBuffer_ZAtU8();
	push_resource(r0);
	{
		(void)pop_resource();
	}
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	uint64_t v5 = (VU64(v4) & VU64(v3));
	int64_t v6 = (0LL);
	bool v7 = (((int64_t)(v5)) == v6);
	if (v7) {
		uint64_t v8 = (0LL /* False */);
		push_u64(v8);
	} else {
		uint64_t v9 = (1LL /* True */);
		push_u64(v9);
	}
}
static void mw_std_set_ZPlusSet_insertZBang (void) {
	mw_std_set_ZPlusSet_offsetZ_mask();
	{
		push_resource(MKU64(0));
	}
	VAL r0 = pop_resource();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v1);
	push_value(v2);
	mw_std_buffer_ZPlusBuffer_ZAtU8();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	uint64_t v5 = (VU64(v4) | VU64(v3));
	VAL v6 = pop_value();
	push_u64(v5);
	push_value(v6);
	mw_std_buffer_ZPlusBuffer_ZBangU8();
	push_resource(r0);
	{
		(void)pop_resource();
	}
}
static void mw_mirth_need_Need_ZToNat (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // NEED_WORD
			mtp_mirth_need_Need_NEEDz_WORD();
			mw_mirth_word_Word_index();
			int64_t v0 = (4LL);
			VAL v1 = pop_value();
			int64_t v2 = (VI64(v1) * v0);
			push_i64(v2);
			mw_std_prim_Int_ZToNat();
		} break;
		case 1LL: { // NEED_BLOCK
			mtp_mirth_need_Need_NEEDz_BLOCK();
			mw_mirth_arrow_Block_index();
			int64_t v3 = (4LL);
			VAL v4 = pop_value();
			int64_t v5 = (VI64(v4) * v3);
			int64_t v6 = (1LL);
			push_i64(v5);
			push_i64(v6);
			mp_primZ_intZ_add();
			mw_std_prim_Int_ZToNat();
		} break;
		case 2LL: { // NEED_TAGW
			mtp_mirth_need_Need_NEEDz_TAGW();
			mw_mirth_data_Tag_index();
			int64_t v7 = (4LL);
			VAL v8 = pop_value();
			int64_t v9 = (VI64(v8) * v7);
			int64_t v10 = (2LL);
			push_i64(v9);
			push_i64(v10);
			mp_primZ_intZ_add();
			mw_std_prim_Int_ZToNat();
		} break;
		case 3LL: { // NEED_TAGP
			mtp_mirth_need_Need_NEEDz_TAGP();
			mw_mirth_data_Tag_index();
			int64_t v11 = (4LL);
			VAL v12 = pop_value();
			int64_t v13 = (VI64(v12) * v11);
			int64_t v14 = (3LL);
			push_i64(v13);
			push_i64(v14);
			mp_primZ_intZ_add();
			mw_std_prim_Int_ZToNat();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_new (void) {
	uint64_t v0 = (0LL /* Nil */);
	lpush(&lbl_stack, MKU64(v0));
	mw_std_set_ZPlusSet_new();
	VAL r1 = pop_resource();
	lpush(&lbl_ZPlusset, r1);
	mtw_mirth_need_ZPlusNeeds_ZPlusNeeds();
}
static void mw_mirth_need_ZPlusNeeds_rdrop (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +Needs
			mtp_mirth_need_ZPlusNeeds_ZPlusNeeds();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_ZPlusset));
	push_resource(v0);
	mw_std_set_ZPlusSet_rdrop();
	VAL v1 = (lpop(&lbl_stack));
	decref(v1);
}
static void mw_mirth_need_Need_neededZAsk (void) {
	mw_mirth_need_Need_ZToNat();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_std_set_ZPlusSet_memberZAsk();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_word_Word_neededZAsk (void) {
	mtw_mirth_need_Need_NEEDz_WORD();
	mw_mirth_need_Need_neededZAsk();
}
static void mw_mirth_arrow_Block_neededZAsk (void) {
	mtw_mirth_need_Need_NEEDz_BLOCK();
	mw_mirth_need_Need_neededZAsk();
}
static void mw_mirth_data_Tag_wordZ_neededZAsk (void) {
	mtw_mirth_need_Need_NEEDz_TAGW();
	mw_mirth_need_Need_neededZAsk();
}
static void mw_mirth_data_Tag_patZ_neededZAsk (void) {
	mtw_mirth_need_Need_NEEDz_TAGP();
	mw_mirth_need_Need_neededZAsk();
}
static void mw_mirth_need_ZPlusNeeds_needZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_need_Need_neededZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		decref(v2);
	} else {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_need_Need_ZToNat();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r4 = pop_resource();
		mw_std_set_ZPlusSet_insertZBang();
		push_resource(r4);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[2];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r5 = pop_resource();
		mtw_std_list_List_1_Cons();
		push_resource(r5);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL t = *p; *p = u; decref(t);
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_needZ_wordZBang (void) {
	mtw_mirth_need_Need_NEEDz_WORD();
	mw_mirth_need_ZPlusNeeds_needZBang();
}
static void mw_mirth_need_ZPlusNeeds_needZ_blockZBang (void) {
	mtw_mirth_need_Need_NEEDz_BLOCK();
	mw_mirth_need_ZPlusNeeds_needZBang();
}
static void mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang (void) {
	mtw_mirth_need_Need_NEEDz_TAGW();
	mw_mirth_need_ZPlusNeeds_needZBang();
}
static void mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang (void) {
	mtw_mirth_need_Need_NEEDz_TAGP();
	mw_mirth_need_ZPlusNeeds_needZBang();
}
static void mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang (void) {
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang();
	mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang();
}
static void mw_mirth_need_ZPlusNeeds_determineZ_transitiveZ_needsZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r0 = pop_resource();
	mw_std_list_List_1_uncons();
	push_resource(r0);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL t = *p; *p = u; decref(t);
	}
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v2 = pop_value();
		if (!VBOOL(v2)) break;
		mw_std_maybe_Maybe_1_unwrap();
		mw_mirth_need_ZPlusNeeds_runZ_needZBang();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r3 = pop_resource();
		mw_std_list_List_1_uncons();
		push_resource(r3);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL t = *p; *p = u; decref(t);
		}
	}
	VAL v4 = pop_value();
	decref(v4);
}
static void mw_mirth_need_ZPlusNeeds_runZ_needZBang (void) {
	switch (get_top_data_tag()) {
		case 1LL: { // NEED_BLOCK
			mtp_mirth_need_Need_NEEDz_BLOCK();
			mw_mirth_need_ZPlusNeeds_runZ_blockZBang();
		} break;
		case 0LL: { // NEED_WORD
			mtp_mirth_need_Need_NEEDz_WORD();
			mw_mirth_need_ZPlusNeeds_runZ_wordZBang();
		} break;
		case 2LL: { // NEED_TAGW
			mtp_mirth_need_Need_NEEDz_TAGW();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		case 3LL: { // NEED_TAGP
			mtp_mirth_need_Need_NEEDz_TAGP();
			VAL v1 = pop_value();
			decref(v1);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_runZ_argsZBang (void) {
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_need_ZPlusNeeds_runZ_argZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_need_ZPlusNeeds_runZ_argZBang (void) {
	mw_mirth_need_ZPlusNeeds_runZ_blockZBang();
}
static void mw_mirth_need_ZPlusNeeds_runZ_blockZBang (void) {
	VAL r0 = pop_resource();
	mw_mirth_arrow_Block_arrow();
	push_resource(r0);
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang();
}
static void mw_mirth_need_ZPlusNeeds_runZ_wordZBang (void) {
	VAL r0 = pop_resource();
	mw_mirth_word_Word_arrow();
	push_resource(r0);
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang();
}
static void mw_mirth_need_ZPlusNeeds_runZ_arrowZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_need_ZPlusNeeds_runZ_atomZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_need_ZPlusNeeds_runZ_atomZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_need_ZPlusNeeds_runZ_opZBang();
}
static void mw_mirth_need_ZPlusNeeds_runZ_opZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // OpNone
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		case 7LL: { // OpInt
			mtp_mirth_arrow_Op_OpInt();
			VAL v1 = pop_value();
			decref(v1);
			VAL v2 = pop_value();
			decref(v2);
		} break;
		case 8LL: { // OpF64
			mtp_mirth_arrow_Op_OpF64();
			VAL v3 = pop_value();
			decref(v3);
			VAL v4 = pop_value();
			decref(v4);
		} break;
		case 9LL: { // OpStr
			mtp_mirth_arrow_Op_OpStr();
			VAL v5 = pop_value();
			decref(v5);
			VAL v6 = pop_value();
			decref(v6);
		} break;
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			VAL v7 = pop_value();
			incref(v7);
			push_value(v7);
			push_value(v7);
			mw_mirth_word_Word_preferZ_inlineZAsk();
			VAL v8 = pop_value();
			if (VBOOL(v8)) {
				mw_mirth_need_ZPlusNeeds_runZ_wordZBang();
			} else {
				mw_mirth_need_ZPlusNeeds_needZ_wordZBang();
			}
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
		} break;
		case 3LL: { // OpExternal
			mtp_mirth_arrow_Op_OpExternal();
			VAL v9 = pop_value();
			decref(v9);
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
		} break;
		case 4LL: { // OpBuffer
			mtp_mirth_arrow_Op_OpBuffer();
			VAL v10 = pop_value();
			decref(v10);
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
		} break;
		case 5LL: { // OpVariable
			mtp_mirth_arrow_Op_OpVariable();
			VAL v11 = pop_value();
			decref(v11);
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
		} break;
		case 6LL: { // OpField
			mtp_mirth_arrow_Op_OpField();
			VAL v12 = pop_value();
			decref(v12);
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
		} break;
		case 10LL: { // OpTag
			mtp_mirth_arrow_Op_OpTag();
			mw_mirth_need_ZPlusNeeds_needZ_tagZ_wordZBang();
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
		} break;
		case 1LL: { // OpPrim
			mtp_mirth_arrow_Op_OpPrim();
			mw_mirth_need_ZPlusNeeds_runZ_primZBang();
		} break;
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			decref(v14);
			push_value(v13);
			mw_mirth_need_ZPlusNeeds_runZ_matchZBang();
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			decref(v16);
			push_value(v15);
			mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang();
		} break;
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			VAL v17 = pop_value();
			decref(v17);
			VAL v18 = pop_value();
			decref(v18);
		} break;
		case 14LL: { // OpBlockPush
			mtp_mirth_arrow_Op_OpBlockPush();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			decref(v20);
			push_value(v19);
			mw_mirth_need_ZPlusNeeds_pushZ_blockZBang();
		} break;
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			decref(v22);
			push_value(v21);
			mw_mirth_need_ZPlusNeeds_runZ_blockZBang();
		} break;
		case 16LL: { // OpCoerce
			mtp_mirth_arrow_Op_OpCoerce();
			VAL v23 = pop_value();
			decref(v23);
			VAL v24 = pop_value();
			decref(v24);
		} break;
		case 17LL: { // OpLabelPush
			mtp_mirth_arrow_Op_OpLabelPush();
			VAL v25 = pop_value();
			decref(v25);
			VAL v26 = pop_value();
			decref(v26);
		} break;
		case 18LL: { // OpLabelPop
			mtp_mirth_arrow_Op_OpLabelPop();
			VAL v27 = pop_value();
			decref(v27);
			VAL v28 = pop_value();
			decref(v28);
		} break;
		case 19LL: { // OpLabelPushR
			mtp_mirth_arrow_Op_OpLabelPushR();
			VAL v29 = pop_value();
			decref(v29);
			VAL v30 = pop_value();
			decref(v30);
		} break;
		case 20LL: { // OpLabelPopR
			mtp_mirth_arrow_Op_OpLabelPopR();
			VAL v31 = pop_value();
			decref(v31);
			VAL v32 = pop_value();
			decref(v32);
		} break;
		case 21LL: { // OpDataGetTag
			mtp_mirth_arrow_Op_OpDataGetTag();
			VAL v33 = pop_value();
			decref(v33);
			VAL v34 = pop_value();
			decref(v34);
		} break;
		case 22LL: { // OpDataGetLabel
			mtp_mirth_arrow_Op_OpDataGetLabel();
			VAL v35 = pop_value();
			decref(v35);
			VAL v36 = pop_value();
			decref(v36);
			VAL v37 = pop_value();
			decref(v37);
		} break;
		case 23LL: { // OpDataSetLabel
			mtp_mirth_arrow_Op_OpDataSetLabel();
			VAL v38 = pop_value();
			decref(v38);
			VAL v39 = pop_value();
			decref(v39);
			VAL v40 = pop_value();
			decref(v40);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_runZ_primZBang (void) {
	switch (get_top_data_tag()) {
		case 4LL: { // PRIM_CORE_DIP
			(void)pop_u64();
			VAL v0 = pop_value();
			incref(v0);
			push_value(v0);
			push_value(v0);
			mw_std_list_List_1_ZDivL1();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v1 = pop_value();
					decref(v1);
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 13LL: { // PRIM_CORE_RDIP
			(void)pop_u64();
			VAL v2 = pop_value();
			incref(v2);
			push_value(v2);
			push_value(v2);
			mw_std_list_List_1_ZDivL1();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v3 = pop_value();
					decref(v3);
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 5LL: { // PRIM_CORE_IF
			(void)pop_u64();
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mw_std_list_List_1_ZDivL2();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v5 = pop_value();
					decref(v5);
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 6LL: { // PRIM_CORE_WHILE
			(void)pop_u64();
			VAL v6 = pop_value();
			incref(v6);
			push_value(v6);
			push_value(v6);
			mw_std_list_List_1_ZDivL2();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v7 = pop_value();
					decref(v7);
					mw_mirth_need_ZPlusNeeds_runZ_argsZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			VAL v8 = pop_value();
			decref(v8);
			mw_mirth_need_ZPlusNeeds_pushZ_argsZBang();
		} break;
	}
}
static void mw_mirth_need_ZPlusNeeds_runZ_matchZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_need_ZPlusNeeds_runZ_caseZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_need_ZPlusNeeds_runZ_caseZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_need_ZPlusNeeds_runZ_patternZBang();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang();
}
static void mw_mirth_need_ZPlusNeeds_runZ_lambdaZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_need_ZPlusNeeds_runZ_arrowZBang();
}
static void mw_mirth_need_ZPlusNeeds_runZ_patternZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[9];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_need_ZPlusNeeds_runZ_patatomZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_need_ZPlusNeeds_runZ_patatomZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // PatOpUnderscore
			(void)pop_u64();
		} break;
		case 1LL: { // PatOpTag
			mtp_mirth_match_PatternOp_PatOpTag();
			mw_mirth_need_ZPlusNeeds_needZ_tagZ_patZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_need_ZPlusNeeds_pushZ_argsZBang (void) {
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_need_ZPlusNeeds_pushZ_argZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_need_ZPlusNeeds_pushZ_argZBang (void) {
	mw_mirth_need_ZPlusNeeds_pushZ_blockZBang();
}
static void mw_mirth_need_ZPlusNeeds_pushZ_blockZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	VAL r1 = pop_resource();
	push_value(v0);
	push_value(v0);
	mw_mirth_arrow_Block_toZ_runZ_var();
	push_resource(r1);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v2 = pop_value();
			decref(v2);
			VAL v3 = pop_value();
			decref(v3);
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_need_ZPlusNeeds_needZ_blockZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99_put (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_std_output_ZPlusOutput_put();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[5];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_ZPlusC99_putZ_byte (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_std_output_ZPlusOutput_putZ_byte();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[5];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_ZPlusC99_line (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_std_output_ZPlusOutput_line();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[5];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_c99Z_startZBang (void) {
	VAL v0 = pop_value();
	int64_t v1 = (0LL);
	lpush(&lbl_options, v0);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	int64_t v3 = (0LL);
	lpush(&lbl_depth, v2);
	push_i64(v3);
	mw_std_prim_Int_ZToNat();
	VAL v4 = pop_value();
	lpush(&lbl_freshZ_counter, v4);
	mw_mirth_need_ZPlusNeeds_new();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v5);
	mw_mirth_need_ZPlusNeeds_determineZ_arrowZ_needsZBang();
	VAL r6 = pop_resource();
	VAL r7 = pop_resource();
	VAL v8 = (lpop(&lbl_options));
	incref(v8);
	lpush(&lbl_ZPlusneeds, r6);
	lpush(&lbl_ZPlusmirth, r7);
	push_value(v8);
	lpush(&lbl_options, v8);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_prim_ZPlusWorld_createZ_fileZBang();
	mw_std_file_ZPlusFileZAsk_unwrapZBang();
	mw_std_output_ZPlusOutput_startZBang();
	VAL r9 = pop_resource();
	lpush(&lbl_ZPlusoutput, r9);
	mtw_mirth_c99_ZPlusC99_ZPlusC99();
}
static void mw_mirth_c99_c99Z_endZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99
			mtp_mirth_c99_ZPlusC99_ZPlusC99();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_depth));
	VAL v1 = (lpop(&lbl_freshZ_counter));
	VAL v2 = (lpop(&lbl_options));
	decref(v2);
	decref(v1);
	decref(v0);
	VAL v3 = (lpop(&lbl_ZPlusneeds));
	push_resource(v3);
	mw_mirth_need_ZPlusNeeds_rdrop();
	VAL v4 = (lpop(&lbl_ZPlusoutput));
	push_resource(v4);
	mw_std_output_ZPlusOutput_endZBang();
	mw_std_file_ZPlusFile_closeZ_fileZBang();
	VAL v5 = (lpop(&lbl_ZPlusmirth));
	push_resource(v5);
}
static void mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang (void) {
	int64_t v0 = (0LL);
	push_i64(v0);
	mw_std_prim_Int_ZToNat();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_c99_ZPlusC99_freshZ_natZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	incref(v0);
	int64_t v1 = (1LL);
	push_value(v0);
	push_value(v0);
	push_i64(v1);
	mp_primZ_intZ_add();
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
}
static void mw_mirth_c99_ZPlusC99_freshZ_nameZBang (void) {
	mw_mirth_c99_ZPlusC99_freshZ_natZBang();
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	STRLIT("v", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mp_primZ_intZ_toZ_str();
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mtp_std_str_ZPlusStr_ZPlusStr();
}
static void mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang (void) {
	mw_mirth_c99_ZPlusC99_freshZ_natZBang();
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	STRLIT("r", 1);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mp_primZ_intZ_toZ_str();
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mtp_std_str_ZPlusStr_ZPlusStr();
}
static void mw_mirth_c99_runZ_outputZ_c99ZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	int64_t v0 = (0LL);
	VAL v1 = pop_value();
	bool v2 = (v0 < VI64(v1));
	if (v2) {
		VAL v3 = pop_value();
		decref(v3);
		VAL v4 = pop_value();
		decref(v4);
	} else {
		mw_mirth_c99_c99Z_startZBang();
		mw_mirth_c99_c99Z_headerZBang();
		mw_mirth_c99_c99Z_labelZ_defsZBang();
		mw_mirth_c99_c99Z_tagZ_defsZBang();
		mw_mirth_c99_c99Z_buffersZBang();
		mw_mirth_c99_c99Z_variablesZBang();
		mw_mirth_c99_c99Z_externalZ_blocksZBang();
		mw_mirth_c99_c99Z_wordZ_sigsZBang();
		mw_mirth_c99_c99Z_blockZ_sigsZBang();
		mw_mirth_c99_c99Z_fieldZ_sigsZBang();
		mw_mirth_c99_c99Z_mainZBang();
		mw_mirth_c99_c99Z_fieldZ_defsZBang();
		mw_mirth_c99_c99Z_wordZ_defsZBang();
		mw_mirth_c99_c99Z_blockZ_defsZBang();
		mw_mirth_c99_c99Z_endZBang();
	}
}
static void mw_mirth_data_Tag_wordZ_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Tag_ZTildewordZ_cname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mtw_", 4);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Tag_qname();
		VAL r5 = pop_resource();
		mw_mirth_name_QName_mangled();
		push_resource(r5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
}
static void mw_mirth_data_Tag_patZ_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Tag_ZTildepatZ_cname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mtp_", 4);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Tag_qname();
		VAL r5 = pop_resource();
		mw_mirth_name_QName_mangled();
		push_resource(r5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
}
static void mw_mirth_buffer_Buffer_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_buffer_Buffer_ZTildecname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mbuf_", 5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_buffer_Buffer_qname();
		VAL r5 = pop_resource();
		mw_mirth_name_QName_mangled();
		push_resource(r5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
}
static void mw_mirth_variable_Variable_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_variable_Variable_ZTildecname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mvar_", 5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_variable_Variable_qname();
		VAL r5 = pop_resource();
		mw_mirth_name_QName_mangled();
		push_resource(r5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	decref(v8);
	push_value(v7);
}
static void mw_mirth_table_Field_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_table_Field_ZTildecname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_table_Field_qnameZ_hard();
		mw_mirth_name_QName_mangled();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mfld_", 5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_external_External_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_external_External_ZTildecname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_external_External_qnameZ_hard();
		mw_mirth_name_QName_mangled();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mext_", 5);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_prim_Prim_cname (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_prim_Prim_ZTildecname();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		STRLIT("mp_", 3);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_prim_Prim_name();
		mw_mirth_name_Name_mangled();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		mtp_std_str_ZPlusStr_ZPlusStr();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_c99_ZPlusC99_sigZ_put (void) {
	STRLIT("static void ", 12);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" (void)", 7);
	mw_mirth_c99_ZPlusC99_put();
}
static void mw_mirth_c99_c99Z_headerZ_str (void) {
	STRLIT(
		"/* MIRTH HEADER */\n"
		"// #line 3 \"src/mirth.h\"\n"
		"\n"
		"#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n"
		"#define MIRTH_WINDOWS 1\n"
		"#elif defined(__linux__)\n"
		"#define MIRTH_LINUX 1\n"
		"#elif defined(__APPLE__)\n"
		"#define MIRTH_MACOS 1\n"
		"#else\n"
		"#error \"Platform not supported.\"\n"
		"#endif\n"
		"\n"
		"#if defined(__x86_64__) || defined(_M_X64)\n"
		"#define MIRTH_AMD64\n"
		"#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n"
		"#define MIRTH_I386\n"
		"#elif defined(__aarch64__) || defined(_M_ARM64)\n"
		"#define MIRTH_ARM64\n"
		"#else\n"
		"#error \"Architecture not supported.\"\n"
		"#endif\n"
		"\n"
		"#include <stdint.h>\n"
		"#include <stdbool.h>\n"
		"#include <stddef.h>\n"
		"#include <float.h>\n"
		"\n"
		"extern void* malloc(size_t);\n"
		"extern void* calloc(size_t, size_t);\n"
		"extern void* realloc(void*, size_t);\n"
		"extern void* memset(void*, int, size_t);\n"
		"extern void* memcpy(void*, const void*, size_t);\n"
		"extern int memcmp(const void*, const void*, size_t);\n"
		"extern int strcmp(const char*, const char*);\n"
		"extern size_t strlen(const char*);\n"
		"extern void free(void*);\n"
		"extern int read(int, void*, size_t);\n"
		"extern int write(int, const char*, size_t);\n"
		"extern int close(int);\n"
		"extern int open(const char*, int, ...);\n"
		"extern void exit(int);\n"
		"extern int sprintf (char * s, const char * format, ...);\n"
		"\n"
		"typedef uint16_t TAG;\n"
		"#define REFS_FLAG \t 0x8000\n"
		"#define TUP_FLAG \t 0x4000\n"
		"#define TUP_LEN_MASK 0x3FFF\n"
		"#define TUP_LEN_MAX  0x3FFF\n"
		"\n"
		"#define TAG_INT 1\n"
		"#define TAG_PTR 1\n"
		"#define TAG_STR (2 | REFS_FLAG)\n"
		"#define TAG_FNPTR 3\n"
		"#define TAG_F32 4\n"
		"#define TAG_F64 5\n"
		"#define TAG_TUP_NIL TUP_FLAG\n"
		"#define TAG_TUP_LEN(t) ((t) & TUP_LEN_MASK)\n"
		"#define TAG_TUP(n) (TUP_FLAG | REFS_FLAG | (n))\n"
		"\n"
		"typedef uint32_t REFS;\n"
		"typedef uint64_t USIZE;\n"
		"typedef void (*FNPTR)(void);\n"
		"\n"
		"typedef union DATA {\n"
		"\tUSIZE usize;\n"
		"\tuint64_t u64;\n"
		"\tuint32_t u32;\n"
		"\tuint16_t u16;\n"
		"\tuint8_t u8;\n"
		"\tint64_t i64;\n"
		"\tint32_t i32;\n"
		"\tint16_t i16;\n"
		"\tint8_t i8;\n"
		"\tfloat f32;\n"
		"\tdouble f64;\n"
		"\tvoid* ptr;\n"
		"\tFNPTR fnptr;\n"
		"\tREFS* refs;\n"
		"\tstruct TUP* tup;\n"
		"\tstruct STR* str;\n"
		"} DATA;\n"
		"\n"
		"typedef struct VAL {\n"
		"\tDATA data;\n"
		"\tTAG tag;\n"
		"} VAL;\n"
		"\n"
		"#define VALEQ(v1,v2) (((v1).tag == (v2).tag) && ((v1).data.u64 == (v2).data.u64))\n"
		"\n"
		"#define VREFS(v)  (*(v).data.refs)\n"
		"#define VVAL(v)   (v)\n"
		"#define VINT(v)   ((v).data.i64)\n"
		"#define VI64(v)   ((v).data.i64)\n"
		"#define VU64(v)   ((v).data.u64)\n"
		"#define VBOOL(v)  ((_Bool)((v).data.u64))\n"
		"#define VF32(v)   ((v).data.f32)\n"
		"#define VF64(v)   ((v).data.f64)\n"
		"#define VPTR(v)   ((v).data.ptr)\n"
		"#define VFNPTR(v) ((v).data.fnptr)\n"
		"#define VSTR(v)   ((v).data.str)\n"
		"#define VTUP(v)   ((v).data.tup)\n"
		"#define VTUPLEN(v) (TAG_TUP_LEN((v).tag))\n"
		"\n"
		"#define HAS_REFS(v) ((v).tag & REFS_FLAG)\n"
		"#define IS_VAL(v)   (1)\n"
		"#define IS_INT(v)   ((v).tag == TAG_INT)\n"
		"#define IS_I64(v)   ((v).tag == TAG_INT)\n"
		"#define IS_U64(v)   ((v).tag == TAG_INT)\n"
		"#define IS_BOOL(v)  ((v).tag == TAG_INT)\n"
		"#define IS_F32(v)   ((v).tag == TAG_F32)\n"
		"#define IS_F64(v)   ((v).tag == TAG_F64)\n"
		"#define IS_PTR(v)   ((v).tag == TAG_PTR)\n"
		"#define IS_FNPTR(v) ((v).tag == TAG_FNPTR)\n"
		"#define IS_STR(v)   ((v).tag == TAG_STR)\n"
		"#define IS_TUP(v)   ((v).tag & TUP_FLAG)\n"
		"#define IS_NIL(v)   (IS_TUP(v) && (VTUPLEN(v) == 0))\n"
		"\n"
		"#define MKVAL(x)   (x)\n"
		"#define MKINT(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKI64(x)   ((VAL){.tag=TAG_INT, .data={.i64=(x)}})\n"
		"#define MKU64(x)   ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKBOOL(x)  ((VAL){.tag=TAG_INT, .data={.u64=(x)}})\n"
		"#define MKF32(x)   ((VAL){.tag=TAG_F32, .data={.f32=(x)}})\n"
		"#define MKF64(x)   ((VAL){.tag=TAG_F64, .data={.f64=(x)}})\n"
		"#define MKFNPTR(x) ((VAL){.tag=TAG_FNPTR, .data={.fnptr=(x)}})\n"
		"#define MKPTR(x)   ((VAL){.tag=TAG_PTR, .data={.ptr=(x)}})\n"
		"#define MKSTR(x)   ((VAL){.tag=TAG_STR, .data={.str=(x)}})\n"
		"#define MKTUP(x,n) ((VAL){.tag=TAG_TUP(n), .data={.tup=(x)}})\n"
		"#define MKNIL_C\t         {.tag=TAG_TUP_NIL, .data={.tup=NULL}}\n"
		"#define MKNIL      ((VAL)MKNIL_C)\n"
		"\n"
		"#define STRLIT(x,n) \\\n"
		"\tdo { \\\n"
		"\t\tstatic VAL mval = {0}; \\\n"
		"\t\tif (!mval.tag) mval = mkstr(x,n); \\\n"
		"\t\tincref(mval); \\\n"
		"\t\tpush_value(mval); \\\n"
		"\t} while(0)\n"
		"\n"
		"typedef uint16_t TUPLEN;\n"
		"typedef struct TUP {\n"
		"\tREFS refs;\n"
		"\tTUPLEN cap;\n"
		"\tTUPLEN size;\n"
		"\tVAL cells[];\n"
		"} TUP;\n"
		"\n"
		"typedef struct STR {\n"
		"\tREFS refs;\n"
		"\tUSIZE cap;\n"
		"\tUSIZE size;\n"
		"\tchar data[];\n"
		"} STR;\n"
		"\n"
		"#define STACK_MAX 0x80000\n"
		"static USIZE stack_counter = STACK_MAX;\n"
		"static VAL stack [STACK_MAX] = {0};\n"
		"static USIZE rstack_counter = STACK_MAX;\n"
		"static VAL rstack [STACK_MAX] = {0};\n"
		"\n"
		"static int global_argc;\n"
		"static char** global_argv;\n"
		"\n"
		"static void push_value(VAL v);\n"
		"static void mp_primZ_debug(void);\n"
		"static void mp_primZ_rdebug(void);\n"
		"\n"
		"#if MIRTH_DEBUG\n"
		"\ttypedef struct LOC {\n"
		"\t\tFNPTR fnptr;\n"
		"\t\tconst char* word;\n"
		"\t\tconst char* path;\n"
		"\t\tUSIZE line, col;\n"
		"\t\tconst char* atom;\n"
		"\t} LOC;\n"
		"\tstatic USIZE fstack_counter = 0;\n"
		"\tstatic LOC fstack [STACK_MAX] = {\n"
		"\t\t{\n"
		"\t\t\t.fnptr=(void(*)(void))0,\n"
		"\t\t\t.word=\"<word>\",\n"
		"\t\t\t.path=\"<path>\",\n"
		"\t\t\t.line=0, .col=0,\n"
		"\t\t\t.atom=\"<atom>\"\n"
		"\t\t},\n"
		"\t};\n"
		"\n"
		"\t#define WORD_ENTER(_f,_w,_p,_l,_c) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tfstack[fstack_counter].fnptr = (_f); \\\n"
		"\t\t\tfstack[fstack_counter].word = (_w); \\\n"
		"\t\t\tfstack[fstack_counter].path = (_p); \\\n"
		"\t\t\tfstack[fstack_counter].line = (_l); \\\n"
		"\t\t\tfstack[fstack_counter].col = (_c); \\\n"
		"\t\t\tfstack[fstack_counter].atom = \"\"; \\\n"
		"\t\t\tfstack_counter++; \\\n"
		"\t\t} while(0)\n"
		"\n"
		"\t#define WORD_ATOM(_l,_c,_n) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tif (fstack_counter > 0) { \\\n"
		"\t\t\t\tfstack[fstack_counter-1].line = (_l); \\\n"
		"\t\t\t\tfstack[fstack_counter-1].col = (_c); \\\n"
		"\t\t\t\tfstack[fstack_counter-1].atom = (_n); \\\n"
		"\t\t\t} \\\n"
		"\t\t} while(0)\n"
		"\n"
		"\t#define WORD_EXIT(_f) \\\n"
		"\t\tdo { \\\n"
		"\t\t\tif ((fstack_counter == 0) || (fstack[fstack_counter-1].fnptr != (_f))) { \\\n"
		"\t\t\t\tTRACE(\"mismatched WORD_EXIT, expected \" #_f \"\\n\"); \\\n"
		"\t\t\t\texit(1); \\\n"
		"\t\t\t} \\\n"
		"\t\t\tfstack_counter--; \\\n"
		"\t\t} while(0)\n"
		"\t#define PRIM_ENTER(_f,_w) WORD_ENTER(_f,_w,__FILE__,__LINE__,1)\n"
		"\t#define PRIM_EXIT(_f) WORD_EXIT(_f)\n"
		"#else\n"
		"\t#define PRIM_ENTER(_f,_w)\n"
		"\t#define PRIM_EXIT(_f)\n"
		"#endif\n"
		"\n"
		"#define TRACE(x) write(2,x,strlen(x))\n"
		"#define _STR(x) #x\n"
		"#define STR(x) _STR(x)\n"
		"\n"
		"#define EXPECT(test,msg) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\tmp_primZ_debug(); \\\n"
		"\t\t\tmp_primZ_rdebug(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define EXPECT1(test,msg,v1) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\tpush_value(v1); \\\n"
		"\t\t\tmp_primZ_debug(); \\\n"
		"\t\t\tmp_primZ_rdebug(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define EXPECT2(test,msg,v1,v2) \\\n"
		"\tdo { \\\n"
		"\t\tif (!(test)) { \\\n"
		"\t\t\tTRACE(msg \"\\n\"); \\\n"
		"\t\t\tpush_value(v1); \\\n"
		"\t\t\tpush_value(v2); \\\n"
		"\t\t\tmp_primZ_debug(); \\\n"
		"\t\t\tmp_primZ_rdebug(); \\\n"
		"\t\t\texit(1); \\\n"
		"\t\t} \\\n"
		"\t} while(0)\n"
		"\n"
		"#define ASSERT(test) \\\n"
		"\tEXPECT(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\")\n"
		"#define ASSERT1(test,v) \\\n"
		"\tEXPECT1(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v)\n"
		"#define ASSERT2(test,v1,v2) \\\n"
		"\tEXPECT2(test, __FILE__ \":\" STR(__LINE__) \": error: assertion failed (\" #test \")\", v1, v2)\n"
		"\n"
		"#define incref(v) do { if (HAS_REFS(v)) VREFS(v)++; } while(0)\n"
		"#define decref(v) do { if (HAS_REFS(v)) if (!--VREFS(v)) free_value(v); } while(0)\n"
		"static void free_value(VAL v) {\n"
		"\tASSERT(HAS_REFS(v));\n"
		"\tASSERT(VREFS(v) == 0);\n"
		"\tASSERT1(IS_TUP(v)||IS_STR(v), v);\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tTUP* tup = VTUP(v);\n"
		"\t\tASSERT(tup);\n"
		"\t\tfor (TUPLEN i = 0; i < tup->size; i++) {\n"
		"\t\t\tdecref(tup->cells[i]);\n"
		"\t\t}\n"
		"\t\tfree(tup);\n"
		"\t} else if (IS_STR(v)) {\n"
		"\t\tSTR* str = VSTR(v);\n"
		"\t\tASSERT(str);\n"
		"\t\tfree(str);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void value_uncons(VAL val, VAL* tail, VAL* head) {\n"
		"\tif (IS_TUP(val)) {\n"
		"\t\tTUPLEN len = VTUPLEN(val);\n"
		"\t\tTUP* tup = VTUP(val);\n"
		"\t\tASSERT1((len > 0) && tup, val);\n"
		"\t\tVAL tailval = MKTUP(tup, len-1);\n"
		"\t\tVAL headval = tup->cells[len-1];\n"
		"\t\tif (len == 1) {\n"
		"\t\t\tincref(headval);\n"
		"\t\t\tdecref(val);\n"
		"\t\t\ttailval = MKNIL;\n"
		"\t\t} else {\n"
		"\t\t\tif (tup->refs == 1) {\n"
		"\t\t\t\tfor (TUPLEN i=len; i < tup->size; i++) { decref(tup->cells[i]); }\n"
		"\t\t\t\tmemset(tup->cells + (len-1), 0, sizeof(VAL)*(tup->size - (len-1)));\n"
		"\t\t\t\ttup->size = len-1;\n"
		"\t\t\t} else {\n"
		"\t\t\t\tincref(headval);\n"
		"\t\t\t}\n"
		"\t\t\tif (len == 2) {\n"
		"\t\t\t\tVAL ptval = tup->cells[0];\n"
		"\t\t\t\tif (!IS_TUP(ptval)) {\n"
		"\t\t\t\t\tincref(ptval);\n"
		"\t\t\t\t\tdecref(tailval);\n"
		"\t\t\t\t\ttailval = ptval;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t\t*tail = tailval;\n"
		"\t\t*head = headval;\n"
		"\t} else {\n"
		"\t\t*tail = MKNIL;\n"
		"\t\t*head = val;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static uint64_t value_u64 (VAL v) {\n"
		"\tASSERT1(IS_INT(v),v);\n"
		"\treturn VU64(v);\n"
		"}\n"
		"\n"
		"static int64_t value_i64 (VAL v) {\n"
		"\tASSERT1(IS_INT(v),v);\n"
		"\treturn VI64(v);\n"
		"}\n"
		"\n"
		"static float value_f32 (VAL v) {\n"
		"\tASSERT1(IS_F32(v), v);\n"
		"\treturn VF32(v);\n"
		"}\n"
		"\n"
		"static double value_f64 (VAL v) {\n"
		"\tASSERT1(IS_F64(v), v);\n"
		"\treturn VF64(v);\n"
		"}\n"
		"\n"
		"static void* value_ptr (VAL v) {\n"
		"\tASSERT1(IS_PTR(v),v);\n"
		"\treturn VPTR(v);\n"
		"}\n"
		"\n"
		"static FNPTR value_fnptr (VAL v) {\n"
		"\tASSERT1(IS_FNPTR(v),v);\n"
		"\treturn VFNPTR(v);\n"
		"}\n"
		"\n"
		"#define pop_u8() ((uint8_t)pop_u64())\n"
		"#define pop_u16() ((uint16_t)pop_u64())\n"
		"#define pop_u32() ((uint32_t)pop_u64())\n"
		"#define pop_u64() (value_u64(pop_value()))\n"
		"#define pop_i8() ((int8_t)pop_i64())\n"
		"#define pop_i16() ((int16_t)pop_i64())\n"
		"#define pop_i32() ((int32_t)pop_i64())\n"
		"#define pop_i64() (value_i64(pop_value()))\n"
		"#define pop_usize() (pop_u64())\n"
		"#define pop_f32() (value_f32(pop_value()))\n"
		"#define pop_f64() (value_f64(pop_value()))\n"
		"#define pop_bool() ((bool)pop_u64())\n"
		"#define pop_ptr() (value_ptr(pop_value()))\n"
		"#define pop_fnptr() (value_fnptr(pop_value()))\n"
		"\n"
		"#define push_u64(v) push_value(MKU64(v))\n"
		"#define push_i64(v) push_value(MKI64(v))\n"
		"#define push_usize(v) push_u64((uint64_t)(v))\n"
		"#define push_bool(b) push_u64((uint64_t)((bool)(b)))\n"
		"#define push_u8(b) push_u64((uint64_t)(b))\n"
		"#define push_u16(b) push_u64((uint64_t)(b))\n"
		"#define push_u32(b) push_u64((uint64_t)(b))\n"
		"#define push_i8(b) push_i64((int64_t)(b))\n"
		"#define push_i16(b) push_i64((int64_t)(b))\n"
		"#define push_i32(b) push_i64((int64_t)(b))\n"
		"#define push_f32(f) push_value(MKF32(f))\n"
		"#define push_f64(f) push_value(MKF64(f))\n"
		"#define push_ptr(p) push_value(MKPTR(p))\n"
		"#define push_fnptr(p) push_value(MKFNPTR(p))\n"
		"\n"
		"static void push_value(VAL x) {\n"
		"\tASSERT(stack_counter > 0);\n"
		"\tstack[--stack_counter] = x;\n"
		"}\n"
		"\n"
		"static VAL top_value(void) {\n"
		"\tASSERT(stack_counter < STACK_MAX);\n"
		"\treturn stack[stack_counter];\n"
		"}\n"
		"\n"
		"static VAL pop_value(void) {\n"
		"\tASSERT(stack_counter < STACK_MAX);\n"
		"\treturn stack[stack_counter++];\n"
		"}\n"
		"\n"
		"static void push_resource(VAL x) {\n"
		"\tASSERT(rstack_counter > 0);\n"
		"\trstack[--rstack_counter] = x;\n"
		"}\n"
		"\n"
		"static VAL top_resource(void) {\n"
		"\tASSERT(rstack_counter < STACK_MAX);\n"
		"\treturn rstack[rstack_counter];\n"
		"}\n"
		"\n"
		"static VAL pop_resource(void) {\n"
		"\tASSERT(rstack_counter < STACK_MAX);\n"
		"\treturn rstack[rstack_counter++];\n"
		"}\n"
		"\n"
		"// Create a TUP with at least min(cap_hint, TUP_LEN_MAX) capacity.\n"
		"static TUP* tup_new (TUPLEN cap_hint) {\n"
		"\tif (cap_hint < 3) cap_hint = 3;\n"
		"\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
		"\tTUP *new_tup = calloc(1, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
		"\tASSERT(new_tup);\n"
		"\tnew_tup->refs = 1;\n"
		"\tnew_tup->cap = cap_hint;\n"
		"\treturn new_tup;\n"
		"}\n"
		"\n"
		"// Create a TUP with at least min(max(old_tup->size, cap_hint), TUP_LEN_MAX) capacity.\n"
		"// Consume old_tup and copy its elements over to the new tuple.\n"
		"static TUP* tup_resize (TUP* old_tup, TUPLEN cap_hint) {\n"
		"\tASSERT(old_tup);\n"
		"\tif (cap_hint < old_tup->size) cap_hint = old_tup->size;\n"
		"\tif (old_tup->refs == 1) {\n"
		"\t\tif (cap_hint < 3) cap_hint = 3;\n"
		"\t\tif (cap_hint > TUP_LEN_MAX) cap_hint = TUP_LEN_MAX;\n"
		"\t\tTUPLEN old_cap = old_tup->cap;\n"
		"\t\tTUP *new_tup = realloc(old_tup, sizeof(TUP) + sizeof(VAL)*(USIZE)cap_hint);\n"
		"\t\tASSERT(new_tup);\n"
		"\t\tif (old_cap < cap_hint) {\n"
		"\t\t\tmemset(new_tup->cells + old_cap, 0, sizeof(VAL)*(cap_hint - old_cap));\n"
		"\t\t}\n"
		"\t\tnew_tup->cap = cap_hint;\n"
		"\t\treturn new_tup;\n"
		"\t} else {\n"
		"\t\tTUP* new_tup = tup_new(cap_hint);\n"
		"\t\tfor (TUPLEN i = 0; i < old_tup->size; i++) {\n"
		"\t\t\tVAL v = old_tup->cells[i];\n"
		"\t\t\tnew_tup->cells[i] = v;\n"
		"\t\t\tincref(v);\n"
		"\t\t}\n"
		"\t\tnew_tup->size = old_tup->size;\n"
		"\t\told_tup->refs--;\n"
		"\t\treturn new_tup;\n"
		"\t}\n"
		"}\n"
		"\n"
		"static VAL mkcons_hint (VAL tail, VAL head, TUPLEN cap_hint) {\n"
		"\tif (IS_TUP(tail) && HAS_REFS(tail)) {\n"
		"\t\tTUPLEN tail_len = VTUPLEN(tail);\n"
		"\t\tTUP *tail_tup = VTUP(tail);\n"
		"\t\tASSERT1(tail_tup, tail);\n"
		"\t\tASSERT1(tail_len <= tail_tup->size, tail);\n"
		"\t\tif (tail_len < tail_tup->size) {\n"
		"\t\t\tASSERT1(tail_tup->refs >= 1, tail);\n"
		"\t\t\tif (tail_tup->refs == 1) {\n"
		"\t\t\t\tdecref(tail_tup->cells[tail_len]);\n"
		"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
		"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t} else {\n"
		"\t\t\t\tVAL *cmp = &tail_tup->cells[tail_len];\n"
		"\t\t\t\tif (VALEQ(*cmp, head)) {\n"
		"\t\t\t\t\tdecref(head);\n"
		"\t\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t\t} else {\n"
		"\t\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
		"\t\t\t\t\tTUP* new_tup = tup_new(cap_hint);\n"
		"\t\t\t\t\tfor (TUPLEN i = 0; i < tail_len; i++) {\n"
		"\t\t\t\t\t\tVAL v = tail_tup->cells[i];\n"
		"\t\t\t\t\t\tnew_tup->cells[i] = v;\n"
		"\t\t\t\t\t\tincref(v);\n"
		"\t\t\t\t\t}\n"
		"\t\t\t\t\tnew_tup->cells[tail_len] = head;\n"
		"\t\t\t\t\tnew_tup->size = tail_len+1;\n"
		"\t\t\t\t\ttail_tup->refs--;\n"
		"\t\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t} else {\n"
		"\t\t\tASSERT1(tail_len < TUP_LEN_MAX, tail);\n"
		"\t\t\tASSERT1(tail_len <= tail_tup->cap, tail);\n"
		"\t\t\tif (tail_len < tail_tup->cap) {\n"
		"\t\t\t\ttail_tup->cells[tail_len] = head;\n"
		"\t\t\t\ttail_tup->size = tail_len+1;\n"
		"\t\t\t\treturn MKTUP(tail_tup, tail_len+1);\n"
		"\t\t\t} else {\n"
		"\t\t\t\tif (cap_hint < tail_len+1) cap_hint = 2*tail_len+1;\n"
		"\t\t\t\tTUP* new_tup = tup_resize(tail_tup, cap_hint);\n"
		"\t\t\t\tASSERT(tail_len < new_tup->cap);\n"
		"\t\t\t\tnew_tup->size = tail_len+1;\n"
		"\t\t\t\tnew_tup->cells[tail_len] = head;\n"
		"\t\t\t\treturn MKTUP(new_tup, tail_len+1);\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t} else if (IS_TUP(tail)) { // cons onto nil\n"
		"\t\tASSERT(IS_NIL(tail));\n"
		"\t\tif (IS_TUP(head)) {\n"
		"\t\t\tTUP* tup = tup_new(cap_hint);\n"
		"\t\t\ttup->size = 1;\n"
		"\t\t\ttup->cells[0] = head;\n"
		"\t\t\treturn MKTUP(tup,1);\n"
		"\t\t} else { // non-tup value pretends to be unary tuple\n"
		"\t\t\treturn head;\n"
		"\t\t}\n"
		"\t} else { // cons onto non-tup value pretending to be unary tuple\n"
		"\t\tTUP* tup = tup_new(cap_hint);\n"
		"\t\ttup->size = 2;\n"
		"\t\ttup->cells[0] = tail;\n"
		"\t\ttup->cells[1] = head;\n"
		"\t\treturn MKTUP(tup,2);\n"
		"\t}\n"
		"}\n"
		"static VAL mkcons(VAL tail, VAL head) {\n"
		"\tVAL v = mkcons_hint(tail,head,3);\n"
		"\treturn v;\n"
		"}\n"
		"\n"
		"static VAL lpop(VAL* stk) {\n"
		"\tVAL cons=*stk, lcar, lcdr; value_uncons(cons, &lcar, &lcdr);\n"
		"\t*stk=lcar; return lcdr;\n"
		"}\n"
		"static void lpush(VAL* stk, VAL cdr) { *stk = mkcons(*stk, cdr); }\n"
		"#define LPOP(v) push_value(lpop(&(v)))\n"
		"#define LPUSH(v) lpush(&(v),pop_value())\n"
		"#define LPOPR(v) push_resource(lpop(&(v)))\n"
		"#define LPUSHR(v) lpush(&(v),pop_resource())\n"
		"\n"
		"static STR* str_alloc (USIZE cap) {\n"
		"\tASSERT(cap <= SIZE_MAX - sizeof(STR) - 4);\n"
		"\tSTR* str = calloc(1, (size_t)(cap + sizeof(STR) + 4));\n"
		"\tEXPECT(str, \"failed to allocate string\");\n"
		"\tstr->refs = 1;\n"
		"\tstr->cap = cap;\n"
		"\treturn str;\n"
		"}\n"
		"\n"
		"static VAL mkstr (const char* data, USIZE size) {\n"
		"\tASSERT(data);\n"
		"\tASSERT(size <= SIZE_MAX - sizeof(STR) - 4);\n"
		"\tSTR* str = str_alloc(size);\n"
		"\tstr->size = size;\n"
		"\tmemcpy(str->data, data, (size_t)size);\n"
		"\treturn MKSTR(str);\n"
		"}\n"
		"\n"
		"static void do_uncons(void) {\n"
		"\tVAL val, tail, head;\n"
		"\tval = pop_value();\n"
		"\tvalue_uncons(val, &tail, &head);\n"
		"\tpush_value(tail);\n"
		"\tpush_value(head);\n"
		"}\n"
		"\n"
		"static USIZE get_data_tag(VAL v) {\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tASSERT(VTUPLEN(v) > 0);\n"
		"\t\treturn VU64(VTUP(v)->cells[0]);\n"
		"\t} else {\n"
		"\t\treturn VU64(v);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static USIZE get_top_data_tag(void) {\n"
		"\treturn get_data_tag(top_value());\n"
		"}\n"
		"\n"
		"static USIZE get_top_resource_data_tag(void) {\n"
		"\treturn get_data_tag(top_resource());\n"
		"}\n"
		"\n"
		"static int str_cmp_(STR* s1, STR* s2) {\n"
		"\tASSERT(s1 && s2);\n"
		"\tUSIZE n1 = s1->size;\n"
		"\tUSIZE n2 = s2->size;\n"
		"\tUSIZE n = (n1 < n2 ? n1 : n2);\n"
		"\tASSERT(n < SIZE_MAX);\n"
		"\tint r = memcmp(s1->data, s2->data, (size_t)n);\n"
		"\tif (r) return r;\n"
		"\tif (n1 < n2) return -1;\n"
		"\tif (n1 > n2) return 1;\n"
		"\treturn 0;\n"
		"}\n"
		"\n"
		"static void run_value(VAL v) {\n"
		"\tif (IS_TUP(v)) {\n"
		"\t\tVAL h = VTUP(v)->cells[0];\n"
		"\t\tASSERT(IS_FNPTR(h));\n"
		"\t\tpush_value(v);\n"
		"\t\tVFNPTR(h)();\n"
		"\t} else {\n"
		"\t\tASSERT(IS_FNPTR(v));\n"
		"\t\tVFNPTR(v)();\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void mp_primZ_id (void) {}\n"
		"static void mp_primZ_dup (void) {\n"
		"\tPRIM_ENTER(mp_primZ_dup,\"prim-dup\");\n"
		"\tVAL v = top_value();\n"
		"\tpush_value(v);\n"
		"\tincref(v);\n"
		"\tPRIM_EXIT(mp_primZ_dup);\n"
		"}\n"
		"static void mp_primZ_drop (void) {\n"
		"\tPRIM_ENTER(mp_primZ_drop,\"prim-drop\");\n"
		"\tVAL v = pop_value();\n"
		"\tdecref(v);\n"
		"\tPRIM_EXIT(mp_primZ_drop);\n"
		"}\n"
		"\n"
		"static void mp_primZ_swap (void) {\n"
		"\tPRIM_ENTER(mp_primZ_swap,\"prim-swap\");\n"
		"\tVAL a = pop_value();\n"
		"\tVAL b = pop_value();\n"
		"\tpush_value(a);\n"
		"\tpush_value(b);\n"
		"\tPRIM_EXIT(mp_primZ_swap);\n"
		"}\n"
		"\n"
		"static void mp_primZ_rswap (void) {\n"
		"\tPRIM_ENTER(mp_primZ_rswap,\"prim-rswap\");\n"
		"\tVAL a = pop_resource();\n"
		"\tVAL b = pop_resource();\n"
		"\tpush_resource(a);\n"
		"\tpush_resource(b);\n"
		"\tPRIM_EXIT(mp_primZ_rswap);\n"
		"}\n"
		"\n"
		"static void mp_primZ_intZ_add (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_add,\"prim-int-add\");\n"
		"\tint64_t b = pop_i64();\n"
		"\tint64_t a = pop_i64();\n"
		"\tif (b >= 0) {\n"
		"\t\tEXPECT(a <= INT64_MAX - b, \"integer overflow during addition (too positive)\");\n"
		"\t} else {\n"
		"\t\tEXPECT(a >= INT64_MIN - b, \"integer overflow during addition (too negative)\");\n"
		"\t}\n"
		"\tpush_i64(a + b);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_add);\n"
		"}\n"
		"static void mp_primZ_intZ_sub (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_sub,\"prim-int-sub\");\n"
		"\tint64_t b = pop_i64();\n"
		"\tint64_t a = pop_i64();\n"
		"\tif (b >= 0) {\n"
		"\t\tEXPECT(a >= INT64_MIN + b, \"integer overflow during subtraction (too negative)\");\n"
		"\t} else {\n"
		"\t\tEXPECT(a <= INT64_MAX + b, \"integer overflow during subtraction (too positive)\");\n"
		"\t}\n"
		"\tpush_i64(a - b);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_sub);\n"
		"}\n"
		"static void mp_primZ_intZ_mul (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_mul,\"prim-int-mul\");\n"
		"\tint64_t b = pop_i64();\n"
		"\tint64_t a = pop_i64();\n"
		"\t// overflow checks for multiplication\n"
		"\tpush_i64(a * b);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_mul);\n"
		"}\n"
		"static void mp_primZ_intZ_div (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_div,\"prim-int-div\");\n"
		"\tint64_t b = pop_i64();\n"
		"\tint64_t a = pop_i64();\n"
		"\tEXPECT(b != 0, \"divide by zero\");\n"
		"\tEXPECT(!((b == -1) && (a == INT64_MIN)), \"overflow during division\");\n"
		"\tint64_t r = a % b;\n"
		"\tint64_t q = a / b;\n"
		"\tif (((a < 0) ^ (b < 0)) && r) q--;\n"
		"\tpush_i64(q);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_div);\n"
		"}\n"
		"static void mp_primZ_intZ_mod (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_mod,\"prim-int-mod\");\n"
		"\tint64_t b = pop_i64();\n"
		"\tint64_t a = pop_i64();\n"
		"\tEXPECT(b != 0, \"divide by zero\");\n"
		"\tif (b == -1) { push_i64(0); return; }\n"
		"\tint64_t r = a % b;\n"
		"\tint64_t q = a / b;\n"
		"\tif (((a < 0) ^ (b < 0)) && r) r += b;\n"
		"\tpush_i64(r);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_mod);\n"
		"}\n"
		"\n"
		"static void mp_primZ_intZ_and (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_and,\"prim-int-and\");\n"
		"\tuint64_t b = pop_u64();\n"
		"\tuint64_t a = pop_u64();\n"
		"\tpush_u64(a & b);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_and);\n"
		"}\n"
		"static void mp_primZ_intZ_or (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_or,\"prim-int-or\");\n"
		"\tuint64_t b = pop_u64();\n"
		"\tuint64_t a = pop_u64();\n"
		"\tpush_u64(a | b);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_or);\n"
		"}\n"
		"static void mp_primZ_intZ_xor (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_xor,\"prim-int-xor\");\n"
		"\tuint64_t b = pop_u64();\n"
		"\tuint64_t a = pop_u64();\n"
		"\tpush_u64(a ^ b);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_xor);\n"
		"}\n"
		"static void mp_primZ_intZ_shl (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_shl,\"prim-int-shl\");\n"
		"\tuint64_t b = pop_u64();\n"
		"\tuint64_t a = pop_u64();\n"
		"\tpush_u64((b >= 64) ? 0 : (a << b));\n"
		"\tPRIM_EXIT(mp_primZ_intZ_shl);\n"
		"}\n"
		"static void mp_primZ_intZ_shr (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_shr,\"prim-int-shr\");\n"
		"\tuint64_t b = pop_u64();\n"
		"\tuint64_t a = pop_u64();\n"
		"\tpush_u64((b >= 64) ? 0 : (a >> b));\n"
		"\tPRIM_EXIT(mp_primZ_intZ_shr);\n"
		"}\n"
		"\n"
		"static void mp_primZ_intZ_eq (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_eq,\"prim-int-eq\");\n"
		"\tVAL b = pop_value();\n"
		"\tVAL a = pop_value();\n"
		"\tASSERT1(IS_INT(a), a);\n"
		"\tASSERT1(IS_INT(b), a);\n"
		"\tpush_bool(VINT(a) == VINT(b));\n"
		"\tPRIM_EXIT(mp_primZ_intZ_eq);\n"
		"}\n"
		"static void mp_primZ_intZ_lt (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_lt,\"prim-int-lt\");\n"
		"\tVAL b = pop_value();\n"
		"\tVAL a = pop_value();\n"
		"\tASSERT2(IS_INT(a) && IS_INT(b), a, b);\n"
		"\tpush_bool(VINT(a) < VINT(b));\n"
		"\tPRIM_EXIT(mp_primZ_intZ_lt);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_toZ_f64 (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_toZ_f64, \"prim-f32-to-f64\");\n"
		"\tfloat x = pop_f32();\n"
		"\tpush_f64((double)x);\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_toZ_f64);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_toZ_f32 (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_toZ_f32, \"prim-f64-to-f32\");\n"
		"\tdouble x = pop_f64();\n"
		"\tpush_f32((float)x);\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_toZ_f32);\n"
		"}\n"
		"\n"
		"static void mp_primZ_intZ_toZ_f32 (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_toZ_f32, \"prim-int-to-f32\");\n"
		"\tint64_t i = pop_i64();\n"
		"\tpush_f32((float)i);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_toZ_f32);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_toZ_int (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_toZ_int, \"prim-f32-to-int\");\n"
		"\tfloat d = pop_f32();\n"
		"\tpush_i64((int64_t)d);\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_toZ_int);\n"
		"}\n"
		"\n"
		"static void mp_primZ_intZ_toZ_f64 (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_toZ_f64, \"prim-int-to-f64\");\n"
		"\tint64_t i = pop_i64();\n"
		"\tpush_f64((double)i);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_toZ_f64);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_toZ_int (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_toZ_int, \"prim-f64-to-int\");\n"
		"\tdouble d = pop_f64();\n"
		"\tpush_i64((int64_t)d);\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_toZ_int);\n"
		"}\n"
		"\n"
		"static void mp_primZ_strZ_cmp (void) {\n"
		"\tPRIM_ENTER(mp_primZ_strZ_cmp,\"prim-str-cmp\");\n"
		"\tVAL b = pop_value();\n"
		"\tVAL a = pop_value();\n"
		"\tASSERT2(IS_STR(a) && IS_STR(b), a, b);\n"
		"\tint64_t cmp = str_cmp_(VSTR(a), VSTR(b));\n"
		"\tpush_i64(cmp);\n"
		"\tdecref(a); decref(b);\n"
		"\tPRIM_EXIT(mp_primZ_strZ_cmp);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_eq (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_eq,\"prim-f32-eq\");\n"
		"\tVAL b = pop_value();\n"
		"\tVAL a = pop_value();\n"
		"\tASSERT1(IS_F32(a), a);\n"
		"\tASSERT1(IS_F32(b), a);\n"
		"\tpush_bool(VF32(a) == VF32(b));\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_eq);\n"
		"}\n"
		"static void mp_primZ_f32Z_lt (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_lt,\"prim-f32-lt\");\n"
		"\tVAL b = pop_value();\n"
		"\tVAL a = pop_value();\n"
		"\tASSERT2(IS_F32(a) && IS_F32(b), a, b);\n"
		"\tpush_bool(VF32(a) < VF32(b));\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_lt);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_add (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_add,\"prim-f32-add\");\n"
		"\tdouble b = pop_f32();\n"
		"\tdouble a = pop_f32();\n"
		"\tpush_f32(a + b);\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_add);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_sub (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_sub,\"prim-f32-sub\");\n"
		"\tdouble b = pop_f32();\n"
		"\tdouble a = pop_f32();\n"
		"\tpush_f32(a - b);\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_sub);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_mul (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_mul,\"prim-f32-mul\");\n"
		"\tdouble b = pop_f32();\n"
		"\tdouble a = pop_f32();\n"
		"\tpush_f32(a * b);\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_mul);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_div (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_div,\"prim-f32-div\");\n"
		"\tdouble b = pop_f32();\n"
		"\tdouble a = pop_f32();\n"
		"\tpush_f32(a / b);\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_div);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f32Z_toZ_str (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f32Z_toZ_str, \"prim-f32-to-str\");\n"
		"\tdouble d = pop_f32();\n"
		"\tchar result[DBL_DIG+32] = {0};\n"
		"\tint len = sprintf(result,\"%.*g\", DBL_DIG,  d);\n"
		"\tpush_value(mkstr(result, len));\n"
		"\tPRIM_EXIT(mp_primZ_f32Z_toZ_str);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_eq (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_eq,\"prim-f64-eq\");\n"
		"\tVAL b = pop_value();\n"
		"\tVAL a = pop_value();\n"
		"\tASSERT1(IS_F64(a), a);\n"
		"\tASSERT1(IS_F64(b), a);\n"
		"\tpush_bool(VF64(a) == VF64(b));\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_eq);\n"
		"}\n"
		"static void mp_primZ_f64Z_lt (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_lt,\"prim-f64-lt\");\n"
		"\tVAL b = pop_value();\n"
		"\tVAL a = pop_value();\n"
		"\tASSERT2(IS_F64(a) && IS_F64(b), a, b);\n"
		"\tpush_bool(VF64(a) < VF64(b));\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_lt);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_add (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_add,\"prim-f64-add\");\n"
		"\tdouble b = pop_f64();\n"
		"\tdouble a = pop_f64();\n"
		"\tpush_f64(a + b);\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_add);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_sub (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_sub,\"prim-f64-sub\");\n"
		"\tdouble b = pop_f64();\n"
		"\tdouble a = pop_f64();\n"
		"\tpush_f64(a - b);\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_sub);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_mul (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_mul,\"prim-f64-mul\");\n"
		"\tdouble b = pop_f64();\n"
		"\tdouble a = pop_f64();\n"
		"\tpush_f64(a * b);\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_mul);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_div (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_div,\"prim-f64-div\");\n"
		"\tdouble b = pop_f64();\n"
		"\tdouble a = pop_f64();\n"
		"\tpush_f64(a / b);\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_div);\n"
		"}\n"
		"\n"
		"static void mp_primZ_f64Z_toZ_str (void) {\n"
		"\tPRIM_ENTER(mp_primZ_f64Z_toZ_str, \"prim-f64-to-str\");\n"
		"\tdouble d = pop_f64();\n"
		"\tchar result[DBL_DIG+32] = {0};\n"
		"\tint len = sprintf(result,\"%.*g\", DBL_DIG,  d);\n"
		"\tpush_value(mkstr(result, len));\n"
		"\tPRIM_EXIT(mp_primZ_f64Z_toZ_str);\n"
		"}\n"
		"\n"
		"static void mp_primZ_sysZ_argc (void) {\n"
		"\tPRIM_ENTER(mp_primZ_sysZ_argc,\"prim-sys-argc\");\n"
		"\tpush_i64(global_argc);\n"
		"\tPRIM_EXIT(mp_primZ_sysZ_argc);\n"
		"}\n"
		"static void mp_primZ_sysZ_argv (void) {\n"
		"\tPRIM_ENTER(mp_primZ_sysZ_argv,\"prim-sys-argv\");\n"
		"\tpush_ptr(global_argv);\n"
		"\tPRIM_EXIT(mp_primZ_sysZ_argv);\n"
		"}\n"
		"\n"
		"void int_repr(int64_t y, char** out_ptr, size_t *out_size) {\n"
		"\tstatic char c[32] = {0};\n"
		"\tmemset(c, 0, 32);\n"
		"\tchar* p = c+30;\n"
		"\tsize_t n = 0;\n"
		"\tuint64_t x;\n"
		"\tif (y < 0) {\n"
		"\t\tif (y == INT64_MIN) {\n"
		"\t\t\tx = 1+(uint64_t)INT64_MAX;\n"
		"\t\t} else {\n"
		"\t\t\tx = (uint64_t)-y;\n"
		"\t\t}\n"
		"\t} else {\n"
		"\t\tx = (uint64_t)y;\n"
		"\t}\n"
		"\tdo {\n"
		"\t\t*--p = '0' + (x % 10);\n"
		"\t\tx /= 10;\n"
		"\t\tn++;\n"
		"\t} while (x);\n"
		"\tif (y < 0) {\n"
		"\t\t*--p = '-';\n"
		"\t\tn++;\n"
		"\t}\n"
		"\t*out_ptr = p;\n"
		"\t*out_size = n;\n"
		"}\n"
		"\n"
		"void int_trace_(int64_t y, int fd) {\n"
		"\tchar* p; size_t n;\n"
		"\tint_repr(y, &p, &n);\n"
		"\twrite(fd, p, n);\n"
		"}\n"
		"\n"
		"void mp_primZ_intZ_toZ_str(void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_toZ_str,\"prim-int-to-str\");\n"
		"\tint64_t x = pop_i64();\n"
		"\tbool cache = (0 <= x) && (x <= 255);\n"
		"\tstatic VAL scache[256] = {0};\n"
		"\tif (cache && scache[x].tag) {\n"
		"\t\tincref(scache[x]);\n"
		"\t\tpush_value(scache[x]);\n"
		"\t} else {\n"
		"\t\tchar* p; size_t n;\n"
		"\t\tint_repr(x,&p,&n);\n"
		"\t\tVAL out = mkstr(p,n);\n"
		"\t\tpush_value(out);\n"
		"\t\tif (cache) {\n"
		"\t\t\tscache[x] = out;\n"
		"\t\t\tincref(out);\n"
		"\t\t}\n"
		"\t}\n"
		"\tPRIM_EXIT(mp_primZ_intZ_toZ_str);\n"
		"}\n"
		"\n"
		"void str_trace_(STR* str, int fd) {\n"
		"\tASSERT(str->size <= SIZE_MAX);\n"
		"\twrite(fd, \"\\\"\", 1);\n"
		"\tUSIZE i0 = 0;\n"
		"\tchar xb[4]={'\\\\','x'};\n"
		"\tUSIZE i;\n"
		"\tfor (i = 0; i < str->size; i++) {\n"
		"\t\tconst char* c = NULL; size_t n=0;\n"
		"\t\tuint8_t v=str->data[i];\n"
		"\t\tswitch(v) {\n"
		"\t\t\tcase '\\n': c=\"\\\\n\"; n=2; break;\n"
		"\t\t\tcase '\\r': c=\"\\\\r\"; n=2; break;\n"
		"\t\t\tcase '\\t': c=\"\\\\t\"; n=2; break;\n"
		"\t\t\tcase '\\\\': c=\"\\\\\\\\\"; n=2; break;\n"
		"\t\t\tcase '\\\"': c=\"\\\\\\\"\"; n=2; break;\n"
		"\t\t\tdefault:\n"
		"\t\t\t\tif (!((' ' <= v) && (v < 0x7F))) {\n"
		"\t\t\t\t\txb[2] = '0' + (v&15) + ('A'-'9'-1)*((v&15) > 9);\n"
		"\t\t\t\t\txb[3] = '0' + (v/16) + ('A'-'9'-1)*((v/16) > 9);\n"
		"\t\t\t\t\tc=xb; n=4;\n"
		"\t\t\t\t}\n"
		"\t\t}\n"
		"\t\tif ((n > 0) && (i0 < i)) {\n"
		"\t\t\twrite(fd, str->data+i0, (size_t)(i-i0));\n"
		"\t\t\ti0=i+1;\n"
		"\t\t}\n"
		"\t\twrite(fd, c, n);\n"
		"\t}\n"
		"\tif (i0 < i) write(fd, str->data+i0, (size_t)(i-i0));\n"
		"\twrite(fd, \"\\\"\", 1);\n"
		"}\n"
		"\n"
		"void value_trace_(VAL val, int fd) {\n"
		"\tif (IS_INT(val)) {\n"
		"\t\tint_trace_(VINT(val), fd);\n"
		"\t} else if (IS_STR(val)) {\n"
		"\t\tstr_trace_(VSTR(val), fd);\n"
		"\t} else if (IS_FNPTR(val)) {\n"
		"\t\twrite(fd, \"<fnptr>\", 7);\n"
		"\t} else if (IS_TUP(val)) {\n"
		"\t\tTUPLEN len = VTUPLEN(val);\n"
		"\t\tTUP* tup = VTUP(val);\n"
		"\t\tif (VTUPLEN(val) == 0) {\n"
		"\t\t\twrite(fd, \"[]\", 2);\n"
		"\t\t} else {\n"
		"\t\t\twrite(fd, \"[ \", 2);\n"
		"\t\t\tfor(TUPLEN i = 0; i < len; i++) {\n"
		"\t\t\t\tif (i > 0) write(fd, \" \", 1);\n"
		"\t\t\t\tvalue_trace_(tup->cells[i], fd);\n"
		"\t\t\t}\n"
		"\t\t\twrite(fd, \" ]\", 2);\n"
		"\t\t}\n"
		"\t} else {\n"
		"\t\tTRACE(\"value cannot be traced\");\n"
		"\t\texit(1);\n"
		"\t}\n"
		"}\n"
		"\n"
		"static void mp_primZ_debug (void) {\n"
		"\tTRACE(\"??\");\n"
		"\tfor (long i = STACK_MAX-1; i >= (long)stack_counter; i--) {\n"
		"\t\tTRACE(\" \");\n"
		"\t\tvalue_trace_(stack[i], 2);\n"
		"\t}\n"
		"\tTRACE(\"\\n\");\n"
		"}\n"
		"\n"
		"static void mp_primZ_rdebug (void) {\n"
		"\t#if MIRTH_DEBUG\n"
		"\t\tTRACE(\"call stack:\\n\");\n"
		"\t\tfor (USIZE i = fstack_counter; i --> 1;) {\n"
		"\t\t\tTRACE(\"    \");\n"
		"\t\t\tif (fstack[i-1].atom && *fstack[i-1].atom && strcmp(fstack[i-1].atom, fstack[i].word)) {\n"
		"\t\t\t\tTRACE(fstack[i-1].atom);\n"
		"\t\t\t\tTRACE(\" -> \");\n"
		"\t\t\t}\n"
		"\t\t\tTRACE(fstack[i].word);\n"
		"\t\t\tTRACE(\" at \");\n"
		"\t\t\tTRACE(fstack[i-1].path);\n"
		"\t\t\tTRACE(\":\");\n"
		"\t\t\tint_trace_((int64_t)fstack[i-1].line, 2);\n"
		"\t\t\tTRACE(\":\");\n"
		"\t\t\tint_trace_((int64_t)fstack[i-1].col, 2);\n"
		"\t\t\tTRACE(\"\\n\");\n"
		"\t\t}\n"
		"\t#endif\n"
		"}\n"
		"\n"
		"static void mp_primZ_panic(void) {\n"
		"\tif ((stack_counter > 0) && IS_STR(top_value())) {\n"
		"\t\tVAL v = pop_value();\n"
		"\t\tsize_t n = (VSTR(v)->size < 2048) ? (size_t)(VSTR(v)->size) : 2048;\n"
		"\t\twrite(2, VSTR(v)->data, n);\n"
		"\t\tTRACE(\"\\n\");\n"
		"\t} else {\n"
		"\t\tTRACE(\"panic!\\n\");\n"
		"\t}\n"
		"\tmp_primZ_debug();\n"
		"\tmp_primZ_rdebug();\n"
		"\texit(1);\n"
		"}\n"
		"\n"
		"static void mp_primZ_ptrZ_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_get,\"prim-ptr-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tvoid **p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_ptr(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u8Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u8Z_get,\"prim-u8-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint8_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_u8(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u8Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u16Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u16Z_get,\"prim-u16-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint16_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_u16(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u16Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u32Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u32Z_get,\"prim-u32-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint32_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_u32(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u32Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u64Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u64Z_get,\"prim-u64-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint64_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_u64(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u64Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i8Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i8Z_get,\"prim-i8-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint8_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_i8(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i8Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i16Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i16Z_get,\"prim-i16-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint16_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_i16(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i16Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i32Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i32Z_get,\"prim-i32-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint32_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_i32(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i32Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i64Z_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i64Z_get,\"prim-i64-get\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint64_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to load from null pointer\");\n"
		"\tpush_i64(*p);\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i64Z_get);\n"
		"}\n"
		"\n"
		"static void mp_primZ_intZ_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_intZ_set,\"prim-int-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint64_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_i64();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_intZ_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_ptrZ_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_set,\"prim-ptr-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tvoid **p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_ptr();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u8Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u8Z_set,\"prim-u8-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint8_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_u8();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u8Z_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u16Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u16Z_set,\"prim-u16-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint16_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_u16();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u16Z_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u32Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u32Z_set,\"prim-u32-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint32_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_u32();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u32Z_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_u64Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_u64Z_set,\"prim-u64-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tuint64_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_u64();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_u64Z_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i8Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i8Z_set,\"prim-i8-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint8_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_i8();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i8Z_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i16Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i16Z_set,\"prim-i16-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint16_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_i16();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i16Z_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i32Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i32Z_set,\"prim-i32-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint32_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_i32();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i32Z_set);\n"
		"}\n"
		"\n"
		"static void mp_primZ_i64Z_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_i64Z_set,\"prim-i64-set\");\n"
		"\tVAL vp = pop_value();\n"
		"\tint64_t *p = value_ptr(vp);\n"
		"\tEXPECT(p, \"tried to write to null pointer\");\n"
		"\t*p = pop_i64();\n"
		"\tdecref(vp);\n"
		"\tPRIM_EXIT(mp_primZ_i64Z_set);\n"
		"}\n"
		"\n"
		"\n"
		"#if defined(MIRTH_WINDOWS)\n"
		"#define mp_primZ_sysZ_os() push_u64(1)\n"
		"#elif defined(MIRTH_LINUX)\n"
		"#define mp_primZ_sysZ_os() push_u64(2)\n"
		"#elif defined(MIRTH_MACOS)\n"
		"#define mp_primZ_sysZ_os() push_u64(3)\n"
		"#else\n"
		"#define mp_primZ_sysZ_os() push_u64(0)\n"
		"#endif\n"
		"\n"
		"#if defined(MIRTH_I386)\n"
		"#define mp_primZ_sysZ_arch() push_u64(1)\n"
		"#elif defined(MIRTH_AMD64)\n"
		"#define mp_primZ_sysZ_arch() push_u64(2)\n"
		"#elif defined(MIRTH_ARM64)\n"
		"#define mp_primZ_sysZ_arch() push_u64(3)\n"
		"#else\n"
		"#define mp_primZ_sysZ_arch() push_u64(0)\n"
		"#endif\n"
		"\n"
		"static void mp_primZ_run (void) {\n"
		"\tPRIM_ENTER(mp_primZ_run,\"prim-run\");\n"
		"\tVAL f = pop_value();\n"
		"\trun_value(f);\n"
		"\tPRIM_EXIT(mp_primZ_run);\n"
		"}\n"
		"\n"
		"static void mp_primZ_ptrZ_nil (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_nil,\"prim-ptr-nil\");\n"
		"\tpush_ptr((void*)0);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_nil);\n"
		"}\n"
		"static void mp_primZ_ptrZ_eq (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_eq,\"prim-ptr-eq\");\n"
		"\tvoid* a = pop_ptr();\n"
		"\tvoid* b = pop_ptr();\n"
		"\tpush_bool(a == b);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_eq);\n"
		"}\n"
		"static void mp_primZ_ptrZ_add (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_add,\"prim-ptr-add\");\n"
		"\tVAL vptr = pop_value();\n"
		"\tUSIZE n = pop_usize();\n"
		"\tASSERT1(IS_PTR(vptr), vptr);\n"
		"\tEXPECT(VPTR(vptr), \"attempt to add to null pointer\");\n"
		"\tchar* ptr = (char*)VPTR(vptr);\n"
		"\tpush_ptr(ptr + n);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_add);\n"
		"}\n"
		"#define mp_primZ_ptrZ_sizze() push_u64((uint64_t)sizeof(void*))\n"
		"static void mp_primZ_ptrZ_alloc (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_alloc,\"prim-ptr-alloc\");\n"
		"\tUSIZE n = pop_usize();\n"
		"\tvoid* p = malloc((size_t)n);\n"
		"\tEXPECT(p, \"failed to allocate buffer\");\n"
		"\tpush_ptr(p);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_alloc);\n"
		"}\n"
		"static void mp_primZ_ptrZ_realloc (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_realloc,\"prim-ptr-realloc\");\n"
		"\tUSIZE n = pop_usize();\n"
		"\tvoid* p0 = pop_ptr();\n"
		"\tvoid* p1 = realloc(p0, (size_t)n);\n"
		"\tEXPECT(p1, \"failed to reallocate buffer\");\n"
		"\tpush_ptr(p1);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_realloc);\n"
		"}\n"
		"static void mp_primZ_ptrZ_free (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_free,\"prim-ptr-free\");\n"
		"\tvoid* p = pop_ptr();\n"
		"\tfree(p);\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_free);\n"
		"}\n"
		"\n"
		"static void mp_primZ_ptrZ_copy (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_copy,\"prim-ptr-copy\");\n"
		"\tVAL vdst = pop_value();\n"
		"\tint64_t ilen = pop_i64();\n"
		"\tVAL vsrc = pop_value();\n"
		"\tASSERT2(IS_PTR(vsrc) && IS_PTR(vdst), vsrc, vdst);\n"
		"\tvoid* src = value_ptr(vsrc);\n"
		"\tvoid* dst = value_ptr(vdst);\n"
		"\tif (src && dst && (ilen > 0)) {\n"
		"\t\tASSERT((USIZE)ilen <= SIZE_MAX);\n"
		"\t\tmemcpy(dst, src, (size_t)ilen);\n"
		"\t}\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_copy);\n"
		"}\n"
		"\n"
		"static void mp_primZ_ptrZ_fill (void) {\n"
		"\tPRIM_ENTER(mp_primZ_ptrZ_fill,\"prim-ptr-fill\");\n"
		"\tVAL vdst = pop_value();\n"
		"\tASSERT1(IS_PTR(vdst), vdst);\n"
		"\tint64_t ilen = pop_i64();\n"
		"\tuint64_t val = pop_u64();\n"
		"\tvoid* dst = value_ptr(vdst);\n"
		"\tif (dst && (ilen > 0)) {\n"
		"\t\tASSERT((USIZE)ilen <= SIZE_MAX);\n"
		"\t\tmemset(dst, (int)val, (size_t)ilen);\n"
		"\t}\n"
		"\tPRIM_EXIT(mp_primZ_ptrZ_fill);\n"
		"}\n"
		"\n"
		"static void mp_primZ_strZ_copy (void) {\n"
		"\tPRIM_ENTER(mp_primZ_strZ_copy,\"prim-str-copy\");\n"
		"\tUSIZE size = pop_usize();\n"
		"\tchar* ptr = (char*)pop_ptr();\n"
		"\tASSERT(size <= SIZE_MAX-sizeof(STR)-4);\n"
		"\tASSERT(ptr);\n"
		"\tpush_value(mkstr(ptr, size));\n"
		"\tPRIM_EXIT(mp_primZ_strZ_copy);\n"
		"}\n"
		"\n"
		"static void mp_primZ_strZ_cat (void) {\n"
		"\tPRIM_ENTER(mp_primZ_strZ_cat,\"prim-str-cat\");\n"
		"\tVAL v2 = pop_value();\n"
		"\tVAL v1 = pop_value();\n"
		"\tASSERT2(IS_STR(v1) && IS_STR(v2), v1, v2);\n"
		"\tSTR* s1 = VSTR(v1);\n"
		"\tSTR* s2 = VSTR(v2);\n"
		"\tUSIZE m = s1->cap;\n"
		"\tUSIZE n1 = s1->size;\n"
		"\tUSIZE n2 = s2->size;\n"
		"\tif ((s1->refs == 1) && (n1 + n2 + 4 <= m)) {\n"
		"\t\tASSERT(n2 <= SIZE_MAX);\n"
		"\t\tmemcpy(s1->data + n1, s2->data, (size_t)n2);\n"
		"\t\ts1->size += n2;\n"
		"\t\tASSERT(s1->size + 4 <= s1->cap);\n"
		"\t\tpush_value(v1);\n"
		"\t\tdecref(v2);\n"
		"\t} else {\n"
		"\t\tUSIZE m2 = n1 + n2 + 4;\n"
		"\t\tif ((s1->refs == 1) && (m2 < m*2)) m2 = m*2;\n"
		"\t\tSTR* str = str_alloc(m2);\n"
		"\t\tstr->size = n1+n2;\n"
		"\t\tASSERT(n1 <= SIZE_MAX);\n"
		"\t\tASSERT(n2 <= SIZE_MAX);\n"
		"\t\tmemcpy(str->data, s1->data, (size_t)n1);\n"
		"\t\tmemcpy(str->data+n1, s2->data, (size_t)n2);\n"
		"\t\tpush_value(MKSTR(str));\n"
		"\t\tdecref(v1);\n"
		"\t\tdecref(v2);\n"
		"\t}\n"
		"\tPRIM_EXIT(mp_primZ_strZ_cat);\n"
		"}\n"
		"\n"
		"static void mp_primZ_strZ_base (void) {\n"
		"\tPRIM_ENTER(mp_primZ_strZ_base,\"prim-str-base\");\n"
		"\tVAL vstr = pop_value();\n"
		"\tASSERT1(IS_STR(vstr) && VSTR(vstr), vstr);\n"
		"\tpush_ptr(VSTR(vstr)->data);\n"
		"\tdecref(vstr);\n"
		"\tPRIM_EXIT(mp_primZ_strZ_base);\n"
		"}\n"
		"\n"
		"static void mp_primZ_strZ_numZ_bytes (void) {\n"
		"\tPRIM_ENTER(mp_primZ_strZ_numZ_bytes,\"prim-str-num-bytes\");\n"
		"\tVAL v = pop_value();\n"
		"\tASSERT(IS_STR(v) && VSTR(v));\n"
		"\tpush_usize(VSTR(v)->size);\n"
		"\tdecref(v);\n"
		"\tPRIM_EXIT(mp_primZ_strZ_numZ_bytes);\n"
		"}\n"
		"\n"
		"static void mp_primZ_packZ_nil (void) {\n"
		"\tPRIM_ENTER(mp_primZ_packZ_nil,\"prim-pack-nil\");\n"
		"\tpush_value(MKNIL);\n"
		"\tPRIM_EXIT(mp_primZ_packZ_nil);\n"
		"}\n"
		"\n"
		"static void mp_primZ_packZ_cons (void) {\n"
		"\tPRIM_ENTER(mp_primZ_packZ_cons,\"prim-pack-cons\");\n"
		"\tVAL cdr = pop_value();\n"
		"\tVAL car = pop_value();\n"
		"\tpush_value(mkcons(car,cdr));\n"
		"\tPRIM_EXIT(mp_primZ_packZ_cons);\n"
		"}\n"
		"\n"
		"static void mp_primZ_packZ_uncons (void) {\n"
		"\tPRIM_ENTER(mp_primZ_packZ_uncons,\"prim-pack-uncons\");\n"
		"\tdo_uncons();\n"
		"\tPRIM_EXIT(mp_primZ_packZ_uncons);\n"
		"}\n"
		"\n"
		"static void mp_primZ_mutZ_get (void) {\n"
		"\tPRIM_ENTER(mp_primZ_mutZ_get,\"prim-mut-get\");\n"
		"\tVAL mut = pop_value();\n"
		"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
		"\tVAL v = *(VAL*)VPTR(mut);\n"
		"\tEXPECT(v.tag, \"tried to read uninitialized value\");\n"
		"\tpush_value(v);\n"
		"\tincref(v);\n"
		"\tPRIM_EXIT(mp_primZ_mutZ_get);\n"
		"}\n"
		"static void mp_primZ_mutZ_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_mutZ_set,\"prim-mut-set\");\n"
		"\tVAL mut = pop_value();\n"
		"\tVAL newval = pop_value();\n"
		"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
		"\tVAL oldval = *(VAL*)VPTR(mut);\n"
		"\t*(VAL*)VPTR(mut) = newval;\n"
		"\tif (oldval.tag) {\n"
		"\t\tdecref(oldval);\n"
		"\t}\n"
		"\tdecref(mut);\n"
		"\tPRIM_EXIT(mp_primZ_mutZ_set);\n"
		"}\n"
		"static void mp_primZ_mutZ_isZ_set (void) {\n"
		"\tPRIM_ENTER(mp_primZ_mutZ_isZ_set,\"prim-mut-is-set\");\n"
		"\tVAL mut = pop_value();\n"
		"\tASSERT1(IS_PTR(mut) && VPTR(mut), mut);\n"
		"\tVAL val = *(VAL*)VPTR(mut);\n"
		"\tpush_bool(val.tag);\n"
		"\tdecref(mut);\n"
		"\tPRIM_EXIT(mp_primZ_mutZ_isZ_set);\n"
		"}\n"
		"\n"
		"/* GENERATED C99 */\n",
		37470
	);
}
static void mw_mirth_c99_c99Z_headerZBang (void) {
	STRLIT("#define MIRTH_DEBUG ", 20);
	mw_mirth_c99_ZPlusC99_put();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		STRLIT("1", 1);
	} else {
		STRLIT("0", 1);
	}
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_c99Z_headerZ_str();
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_c99Z_buffersZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_buffer_Buffer_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_c99_c99Z_bufferZBang();
		int64_t v7 = (1LL);
		push_value(v6);
		push_i64(v7);
		mp_primZ_intZ_add();
	}
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_c99_c99Z_bufferZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_mirth_buffer_Buffer_cname();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(" {", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tstatic uint8_t b[", 18);
	mw_mirth_c99_ZPlusC99_put();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v2);
	mw_mirth_buffer_Buffer_sizze();
	mp_primZ_intZ_toZ_str();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT("] = {0};", 8);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tpush_ptr(&b);", 14);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	VAL v3 = pop_value();
	decref(v3);
}
static void mw_mirth_c99_c99Z_variablesZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_variable_Variable_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_c99_c99Z_variableZBang();
		int64_t v7 = (1LL);
		push_value(v6);
		push_i64(v7);
		mp_primZ_intZ_add();
	}
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_c99_c99Z_variableZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_variable_Variable_cname();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(" {", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tstatic VAL v = {0};", 20);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tpush_ptr(&v);", 14);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_c99Z_tagZ_defsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_data_Tag_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_c99_c99Z_tagZ_defZBang();
		int64_t v7 = (1LL);
		push_value(v6);
		push_i64(v7);
		mp_primZ_intZ_add();
	}
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_c99_c99Z_tagZ_defZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_tag, v0);
	mw_mirth_data_Tag_preferZ_inlineZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
	} else {
		VAL v2 = (lpop(&lbl_tag));
		incref(v2);
		push_value(v2);
		lpush(&lbl_tag, v2);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r3 = pop_resource();
		mw_mirth_data_Tag_wordZ_neededZAsk();
		push_resource(r3);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[4];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		VAL v4 = pop_value();
		if (VBOOL(v4)) {
			VAL v5 = (lpop(&lbl_tag));
			incref(v5);
			push_value(v5);
			lpush(&lbl_tag, v5);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r6 = pop_resource();
			mw_mirth_data_Tag_wordZ_cname();
			push_resource(r6);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_ZPlusC99_sigZ_put();
			STRLIT(" {", 2);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
			mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang();
			VAL v7 = (lpop(&lbl_tag));
			incref(v7);
			push_value(v7);
			lpush(&lbl_tag, v7);
			mw_mirth_data_Tag_isZ_transparentZAsk();
			VAL v8 = pop_value();
			if (VBOOL(v8)) {
			} else {
				VAL v9 = (lpop(&lbl_tag));
				incref(v9);
				push_value(v9);
				lpush(&lbl_tag, v9);
				mw_mirth_data_Tag_isZ_semiZ_transparentZAsk();
				VAL v10 = pop_value();
				if (VBOOL(v10)) {
					VAL v11 = (lpop(&lbl_tag));
					incref(v11);
					push_value(v11);
					lpush(&lbl_tag, v11);
					mw_mirth_data_Tag_outputsZ_resourceZAsk();
					VAL v12 = pop_value();
					if (VBOOL(v12)) {
						VAL v13 = (lpop(&lbl_tag));
						incref(v13);
						push_value(v13);
						lpush(&lbl_tag, v13);
						mw_mirth_data_Tag_numZ_typeZ_inputs();
						int64_t v14 = (0LL);
						VAL v15 = pop_value();
						bool v16 = (v14 < VI64(v15));
						if (v16) {
							STRLIT("\tpush_resource(pop_value());", 28);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
						} else {
							STRLIT("\tpush_resource(lpop(&lbl_", 25);
							mw_mirth_c99_ZPlusC99_put();
							VAL v17 = (lpop(&lbl_tag));
							incref(v17);
							push_value(v17);
							lpush(&lbl_tag, v17);
							mw_mirth_data_Tag_labelZ_inputs();
							mw_std_list_List_1_ZDivL1();
							mw_std_maybe_Maybe_1_unwrap();
							mw_mirth_label_Label_name();
							mw_mirth_name_Name_mangled();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("));", 3);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
						}
					} else {
						STRLIT("\tpush_value(lpop(&lbl_", 22);
						mw_mirth_c99_ZPlusC99_put();
						VAL v18 = (lpop(&lbl_tag));
						incref(v18);
						push_value(v18);
						lpush(&lbl_tag, v18);
						mw_mirth_data_Tag_labelZ_inputs();
						mw_std_list_List_1_ZDivL1();
						mw_std_maybe_Maybe_1_unwrap();
						mw_mirth_label_Label_name();
						mw_mirth_name_Name_mangled();
						mw_mirth_c99_ZPlusC99_put();
						STRLIT("));", 3);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
					}
				} else {
					VAL v19 = (lpop(&lbl_tag));
					incref(v19);
					push_value(v19);
					lpush(&lbl_tag, v19);
					mw_mirth_data_Tag_numZ_totalZ_inputs();
					int64_t v20 = (0LL);
					VAL v21 = pop_value();
					bool v22 = (VI64(v21) == v20);
					if (v22) {
						VAL v23 = (lpop(&lbl_tag));
						incref(v23);
						push_value(v23);
						lpush(&lbl_tag, v23);
						mw_mirth_data_Tag_outputsZ_resourceZAsk();
						VAL v24 = pop_value();
						if (VBOOL(v24)) {
							STRLIT("\tpush_resource(MKU64(", 21);
						} else {
							STRLIT("\tpush_value(MKU64(", 18);
						}
						mw_mirth_c99_ZPlusC99_put();
						VAL v25 = (lpop(&lbl_tag));
						incref(v25);
						push_value(v25);
						lpush(&lbl_tag, v25);
						mw_mirth_data_Tag_valueZ_show();
						mw_mirth_c99_ZPlusC99_put();
						STRLIT("LL));", 5);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
					} else {
						STRLIT("\tTUP* tup = tup_new(", 20);
						mw_mirth_c99_ZPlusC99_put();
						VAL v26 = (lpop(&lbl_tag));
						incref(v26);
						push_value(v26);
						lpush(&lbl_tag, v26);
						mw_mirth_data_Tag_numZ_totalZ_inputs();
						int64_t v27 = (1LL);
						push_i64(v27);
						mp_primZ_intZ_add();
						mp_primZ_intZ_toZ_str();
						mw_mirth_c99_ZPlusC99_put();
						STRLIT(");", 2);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						STRLIT("\ttup->size = ", 13);
						mw_mirth_c99_ZPlusC99_put();
						VAL v28 = (lpop(&lbl_tag));
						incref(v28);
						push_value(v28);
						lpush(&lbl_tag, v28);
						mw_mirth_data_Tag_numZ_totalZ_inputs();
						int64_t v29 = (1LL);
						push_i64(v29);
						mp_primZ_intZ_add();
						mp_primZ_intZ_toZ_str();
						mw_mirth_c99_ZPlusC99_put();
						STRLIT(";", 1);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						STRLIT("\ttup->cells[0] = MKU64(", 23);
						mw_mirth_c99_ZPlusC99_put();
						VAL v30 = (lpop(&lbl_tag));
						incref(v30);
						push_value(v30);
						lpush(&lbl_tag, v30);
						mw_mirth_data_Tag_valueZ_show();
						mw_mirth_c99_ZPlusC99_put();
						STRLIT("LL);", 4);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						VAL v31 = (lpop(&lbl_tag));
						incref(v31);
						push_value(v31);
						lpush(&lbl_tag, v31);
						mw_mirth_data_Tag_numZ_totalZ_inputs();
						VAL v32 = (lpop(&lbl_tag));
						incref(v32);
						push_value(v32);
						lpush(&lbl_tag, v32);
						mw_mirth_data_Tag_labelZ_inputs();
						mw_std_list_List_1_reverse();
						mw_std_list_List_1_uncons();
						VAL v33 = pop_value();
						VAL v34 = pop_value();
						push_value(v33);
						push_value(v34);
						while(1) {
							VAL v35 = pop_value();
							incref(v35);
							push_value(v35);
							push_value(v35);
							mw_std_maybe_Maybe_1_someZAsk();
							VAL v36 = pop_value();
							if (!VBOOL(v36)) break;
							mw_std_maybe_Maybe_1_unwrap();
							VAL v37 = pop_value();
							VAL v38 = pop_value();
							push_value(v37);
							STRLIT("\ttup->cells[", 12);
							mw_mirth_c99_ZPlusC99_put();
							VAL v39 = pop_value();
							VAL v40 = pop_value();
							incref(v40);
							push_value(v40);
							push_value(v39);
							push_value(v40);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("] = lpop(&lbl_", 14);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_label_Label_name();
							mw_mirth_name_Name_mangled();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT(");", 2);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
							int64_t v41 = (1LL);
							push_i64(v41);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
							push_value(v38);
							mw_std_list_List_1_uncons();
							VAL v42 = pop_value();
							VAL v43 = pop_value();
							push_value(v42);
							push_value(v43);
						}
						VAL v44 = pop_value();
						decref(v44);
						VAL v45 = pop_value();
						decref(v45);
						VAL v46 = (lpop(&lbl_tag));
						incref(v46);
						push_value(v46);
						lpush(&lbl_tag, v46);
						mw_mirth_data_Tag_numZ_resourceZ_inputs();
						while(1) {
							VAL v47 = pop_value();
							incref(v47);
							int64_t v48 = (0LL);
							bool v49 = (v48 < VI64(v47));
							push_value(v47);
							if (!v49) break;
							VAL v50 = pop_value();
							STRLIT("\ttup->cells[", 12);
							mw_mirth_c99_ZPlusC99_put();
							VAL v51 = pop_value();
							incref(v51);
							push_value(v51);
							push_value(v51);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("] = pop_resource();", 19);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
							int64_t v52 = (1LL);
							push_i64(v52);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
							int64_t v53 = (1LL);
							push_value(v50);
							push_i64(v53);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
						}
						VAL v54 = pop_value();
						decref(v54);
						VAL v55 = (lpop(&lbl_tag));
						incref(v55);
						push_value(v55);
						lpush(&lbl_tag, v55);
						mw_mirth_data_Tag_numZ_typeZ_inputs();
						while(1) {
							VAL v56 = pop_value();
							incref(v56);
							int64_t v57 = (0LL);
							bool v58 = (v57 < VI64(v56));
							push_value(v56);
							if (!v58) break;
							VAL v59 = pop_value();
							STRLIT("\ttup->cells[", 12);
							mw_mirth_c99_ZPlusC99_put();
							VAL v60 = pop_value();
							incref(v60);
							push_value(v60);
							push_value(v60);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("] = pop_value();", 16);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
							int64_t v61 = (1LL);
							push_i64(v61);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
							int64_t v62 = (1LL);
							push_value(v59);
							push_i64(v62);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
						}
						VAL v63 = pop_value();
						decref(v63);
						VAL v64 = pop_value();
						decref(v64);
						VAL v65 = (lpop(&lbl_tag));
						incref(v65);
						push_value(v65);
						lpush(&lbl_tag, v65);
						mw_mirth_data_Tag_outputsZ_resourceZAsk();
						VAL v66 = pop_value();
						if (VBOOL(v66)) {
							STRLIT("\tpush_resource(MKTUP(tup, ", 26);
						} else {
							STRLIT("\tpush_value(MKTUP(tup, ", 23);
						}
						mw_mirth_c99_ZPlusC99_put();
						VAL v67 = (lpop(&lbl_tag));
						incref(v67);
						push_value(v67);
						lpush(&lbl_tag, v67);
						mw_mirth_data_Tag_numZ_totalZ_inputs();
						int64_t v68 = (1LL);
						push_i64(v68);
						mp_primZ_intZ_add();
						mp_primZ_intZ_toZ_str();
						mw_mirth_c99_ZPlusC99_put();
						STRLIT("));", 3);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
					}
				}
			}
			STRLIT("}", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
		} else {
		}
		VAL v69 = (lpop(&lbl_tag));
		incref(v69);
		push_value(v69);
		lpush(&lbl_tag, v69);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r70 = pop_resource();
		mw_mirth_data_Tag_patZ_neededZAsk();
		push_resource(r70);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[4];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		VAL v71 = pop_value();
		if (VBOOL(v71)) {
			VAL v72 = (lpop(&lbl_tag));
			incref(v72);
			push_value(v72);
			lpush(&lbl_tag, v72);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r73 = pop_resource();
			mw_mirth_data_Tag_patZ_cname();
			push_resource(r73);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_ZPlusC99_sigZ_put();
			STRLIT(" {", 2);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
			mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang();
			VAL v74 = (lpop(&lbl_tag));
			incref(v74);
			push_value(v74);
			lpush(&lbl_tag, v74);
			mw_mirth_data_Tag_isZ_transparentZAsk();
			VAL v75 = pop_value();
			if (VBOOL(v75)) {
			} else {
				VAL v76 = (lpop(&lbl_tag));
				incref(v76);
				push_value(v76);
				lpush(&lbl_tag, v76);
				mw_mirth_data_Tag_outputsZ_resourceZAsk();
				VAL v77 = pop_value();
				if (VBOOL(v77)) {
					STRLIT("\tVAL val = pop_resource();", 26);
				} else {
					STRLIT("\tVAL val = pop_value();", 23);
				}
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				VAL v78 = (lpop(&lbl_tag));
				incref(v78);
				push_value(v78);
				lpush(&lbl_tag, v78);
				mw_mirth_data_Tag_isZ_semiZ_transparentZAsk();
				VAL v79 = pop_value();
				if (VBOOL(v79)) {
					VAL v80 = (lpop(&lbl_tag));
					incref(v80);
					push_value(v80);
					lpush(&lbl_tag, v80);
					mw_mirth_data_Tag_numZ_typeZ_inputs();
					int64_t v81 = (0LL);
					VAL v82 = pop_value();
					bool v83 = (v81 < VI64(v82));
					if (v83) {
						STRLIT("\tpush_value(val);", 17);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
					} else {
						STRLIT("\tlpush(&lbl_", 12);
						mw_mirth_c99_ZPlusC99_put();
						VAL v84 = (lpop(&lbl_tag));
						incref(v84);
						push_value(v84);
						lpush(&lbl_tag, v84);
						mw_mirth_data_Tag_labelZ_inputs();
						mw_std_list_List_1_ZDivL1();
						mw_std_maybe_Maybe_1_unwrap();
						mw_mirth_label_Label_name();
						mw_mirth_name_Name_mangled();
						mw_mirth_c99_ZPlusC99_put();
						STRLIT(", val);", 7);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
					}
				} else {
					VAL v85 = (lpop(&lbl_tag));
					incref(v85);
					push_value(v85);
					lpush(&lbl_tag, v85);
					mw_mirth_data_Tag_numZ_totalZ_inputs();
					int64_t v86 = (0LL);
					VAL v87 = pop_value();
					bool v88 = (VI64(v87) == v86);
					if (v88) {
						STRLIT("\t(void)val;", 11);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
					} else {
						STRLIT("\tASSERT1(IS_TUP(val),val);", 26);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						STRLIT("\tTUP* tup = VTUP(val);", 22);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						int64_t v89 = (1LL);
						VAL v90 = (lpop(&lbl_tag));
						incref(v90);
						push_i64(v89);
						push_value(v90);
						lpush(&lbl_tag, v90);
						mw_mirth_data_Tag_numZ_typeZ_inputs();
						while(1) {
							VAL v91 = pop_value();
							incref(v91);
							int64_t v92 = (0LL);
							bool v93 = (v92 < VI64(v91));
							push_value(v91);
							if (!v93) break;
							VAL v94 = pop_value();
							STRLIT("\tpush_value(tup->cells[", 23);
							mw_mirth_c99_ZPlusC99_put();
							VAL v95 = pop_value();
							incref(v95);
							push_value(v95);
							push_value(v95);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("]);", 3);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
							int64_t v96 = (1LL);
							push_i64(v96);
							mp_primZ_intZ_add();
							int64_t v97 = (1LL);
							push_value(v94);
							push_i64(v97);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
						}
						VAL v98 = pop_value();
						decref(v98);
						VAL v99 = (lpop(&lbl_tag));
						incref(v99);
						push_value(v99);
						lpush(&lbl_tag, v99);
						mw_mirth_data_Tag_numZ_resourceZ_inputs();
						while(1) {
							VAL v100 = pop_value();
							incref(v100);
							int64_t v101 = (0LL);
							bool v102 = (v101 < VI64(v100));
							push_value(v100);
							if (!v102) break;
							VAL v103 = pop_value();
							STRLIT("\tpush_resource(tup->cells[", 26);
							mw_mirth_c99_ZPlusC99_put();
							VAL v104 = pop_value();
							incref(v104);
							push_value(v104);
							push_value(v104);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("]);", 3);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
							int64_t v105 = (1LL);
							push_i64(v105);
							mp_primZ_intZ_add();
							int64_t v106 = (1LL);
							push_value(v103);
							push_i64(v106);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
						}
						VAL v107 = pop_value();
						decref(v107);
						VAL v108 = (lpop(&lbl_tag));
						incref(v108);
						push_value(v108);
						lpush(&lbl_tag, v108);
						mw_mirth_data_Tag_labelZ_inputs();
						mw_std_list_List_1_uncons();
						VAL v109 = pop_value();
						VAL v110 = pop_value();
						push_value(v109);
						push_value(v110);
						while(1) {
							VAL v111 = pop_value();
							incref(v111);
							push_value(v111);
							push_value(v111);
							mw_std_maybe_Maybe_1_someZAsk();
							VAL v112 = pop_value();
							if (!VBOOL(v112)) break;
							mw_std_maybe_Maybe_1_unwrap();
							VAL v113 = pop_value();
							VAL v114 = pop_value();
							push_value(v113);
							STRLIT("\tlpush(&lbl_", 12);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_label_Label_name();
							mw_mirth_name_Name_mangled();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT(", tup->cells[", 13);
							mw_mirth_c99_ZPlusC99_put();
							VAL v115 = pop_value();
							incref(v115);
							push_value(v115);
							push_value(v115);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("]);", 3);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
							int64_t v116 = (1LL);
							push_i64(v116);
							mp_primZ_intZ_add();
							push_value(v114);
							mw_std_list_List_1_uncons();
							VAL v117 = pop_value();
							VAL v118 = pop_value();
							push_value(v117);
							push_value(v118);
						}
						VAL v119 = pop_value();
						decref(v119);
						VAL v120 = pop_value();
						decref(v120);
						VAL v121 = pop_value();
						decref(v121);
						STRLIT("\tif (tup->refs > 1) {", 21);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						int64_t v122 = (1LL);
						VAL v123 = (lpop(&lbl_tag));
						incref(v123);
						push_i64(v122);
						push_value(v123);
						lpush(&lbl_tag, v123);
						mw_mirth_data_Tag_numZ_totalZ_inputs();
						while(1) {
							VAL v124 = pop_value();
							incref(v124);
							int64_t v125 = (0LL);
							bool v126 = (v125 < VI64(v124));
							push_value(v124);
							if (!v126) break;
							VAL v127 = pop_value();
							STRLIT("\t\tincref(tup->cells[", 20);
							mw_mirth_c99_ZPlusC99_put();
							VAL v128 = pop_value();
							incref(v128);
							push_value(v128);
							push_value(v128);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("]);", 3);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
							int64_t v129 = (1LL);
							push_i64(v129);
							mp_primZ_intZ_add();
							int64_t v130 = (1LL);
							push_value(v127);
							push_i64(v130);
							mp_primZ_intZ_sub();
							mw_std_prim_Int_ZToNat();
						}
						VAL v131 = pop_value();
						decref(v131);
						VAL v132 = pop_value();
						decref(v132);
						STRLIT("\t\tdecref(val);", 14);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						STRLIT("\t} else {", 9);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						STRLIT("\t\tfree(tup);", 12);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
						STRLIT("\t}", 2);
						mw_mirth_c99_ZPlusC99_put();
						mw_mirth_c99_ZPlusC99_line();
					}
				}
			}
			STRLIT("}", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
		} else {
		}
	}
	VAL v133 = (lpop(&lbl_tag));
	decref(v133);
}
static void mw_mirth_c99_c99Z_tagZ_labelZ_index (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v0);
	push_value(v1);
	mw_mirth_data_Tag_numZ_totalZ_inputs();
	int64_t v2 = (1LL);
	push_i64(v2);
	mp_primZ_intZ_add();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v4);
	push_value(v3);
	push_value(v5);
	mw_mirth_data_Tag_labelZ_inputs();
	mw_std_list_List_1_reverse();
	uint64_t v6 = (0LL /* None */);
	VAL v7 = pop_value();
	push_u64(v6);
	push_value(v7);
	mw_std_list_List_1_uncons();
	VAL v8 = pop_value();
	VAL v9 = pop_value();
	push_value(v8);
	push_value(v9);
	while(1) {
		VAL v10 = pop_value();
		incref(v10);
		push_value(v10);
		push_value(v10);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v11 = pop_value();
		if (!VBOOL(v11)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		incref(v12);
		int64_t v15 = (1LL);
		push_i64(v15);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		incref(v17);
		push_value(v17);
		push_value(v16);
		push_value(v17);
		push_value(v12);
		mw_mirth_label_Label_ZEqualZEqual();
		VAL v18 = pop_value();
		push_value(v12);
		if (VBOOL(v18)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v19 = pop_value();
			decref(v19);
			uint64_t v20 = (0LL /* None */);
			push_u64(v20);
		}
		VAL v21 = pop_value();
		push_value(v14);
		push_value(v13);
		push_value(v21);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				decref(v23);
				VAL v24 = pop_value();
				decref(v24);
				uint64_t v25 = (0LL /* Nil */);
				push_value(v22);
				push_u64(v25);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		push_value(v26);
		push_value(v27);
	}
	VAL v28 = pop_value();
	decref(v28);
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	decref(v30);
	VAL v31 = pop_value();
	VAL v32 = pop_value();
	decref(v32);
	VAL v33 = pop_value();
	decref(v33);
	push_value(v31);
}
static void mw_mirth_c99_c99Z_tagZ_getZ_labelZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("{", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r0 = pop_resource();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_add();
	push_resource(r0);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v2);
	push_value(v3);
	mw_mirth_data_Tag_isZ_semiZ_transparentZAsk();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		incref(v6);
		incref(v5);
		push_value(v6);
		push_value(v5);
		push_value(v5);
		push_value(v6);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r7 = pop_resource();
		mw_mirth_data_Tag_projectZ_inputZ_label();
		push_resource(r7);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_std_maybe_Maybe_1_unwrap();
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				VAL v8 = pop_value();
				decref(v8);
				VAL v9 = pop_value();
				VAL v10 = pop_value();
				incref(v10);
				push_value(v10);
				push_value(v9);
				push_value(v10);
				mw_mirth_data_Tag_outputsZ_resourceZAsk();
				VAL v11 = pop_value();
				if (VBOOL(v11)) {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL v = top_resource();", 23);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("incref(v);", 10);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("push_value(v);", 14);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				} else {
				}
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				VAL v12 = pop_value();
				decref(v12);
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("push_resource(MKU64(0));", 24);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	} else {
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		incref(v14);
		push_value(v14);
		push_value(v13);
		push_value(v14);
		mw_mirth_data_Tag_outputsZ_resourceZAsk();
		VAL v15 = pop_value();
		if (VBOOL(v15)) {
			mw_mirth_c99_ZPlusC99_indent();
			STRLIT("VAL v = pop_resource();", 23);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
		} else {
			mw_mirth_c99_ZPlusC99_indent();
			STRLIT("VAL v = pop_value();", 20);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
		}
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("ASSERT1(IS_TUP(v), v);", 22);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("ASSERT1(VTUPLEN(v) == ", 22);
		mw_mirth_c99_ZPlusC99_put();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		incref(v17);
		push_value(v17);
		push_value(v16);
		push_value(v17);
		mw_mirth_data_Tag_numZ_totalZ_inputs();
		int64_t v18 = (1LL);
		push_i64(v18);
		mp_primZ_intZ_add();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", v);", 5);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("VAL* p = &VTUP(v)->cells[", 25);
		mw_mirth_c99_ZPlusC99_put();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		incref(v20);
		incref(v19);
		push_value(v20);
		push_value(v19);
		push_value(v20);
		push_value(v19);
		mw_mirth_c99_c99Z_tagZ_labelZ_index();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT("];", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("VAL u = *p;", 11);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		incref(v22);
		incref(v21);
		push_value(v22);
		push_value(v21);
		push_value(v21);
		push_value(v22);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r23 = pop_resource();
		mw_mirth_data_Tag_projectZ_inputZ_label();
		push_resource(r23);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_std_maybe_Maybe_1_unwrap();
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				VAL v24 = pop_value();
				decref(v24);
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("incref(u);", 10);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				incref(v26);
				push_value(v26);
				push_value(v25);
				push_value(v26);
				mw_mirth_data_Tag_outputsZ_resourceZAsk();
				VAL v27 = pop_value();
				if (VBOOL(v27)) {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("push_resource(v);", 17);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				} else {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("decref(v);", 10);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				}
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("push_value(u);", 14);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				VAL v28 = pop_value();
				decref(v28);
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("ASSERT1(VREFS(v) == 1, v);", 26);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("*p = (VAL){0};", 14);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("push_resource(u);", 17);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("push_resource(v);", 17);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	decref(v30);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r31 = pop_resource();
	int64_t v32 = (1LL);
	push_i64(v32);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
	push_resource(r31);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
}
static void mw_mirth_c99_c99Z_tagZ_setZ_labelZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	lpush(&lbl_lbl, v0);
	lpush(&lbl_tag, v1);
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("{", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r2 = pop_resource();
	int64_t v3 = (1LL);
	push_i64(v3);
	mp_primZ_intZ_add();
	push_resource(r2);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v4 = (lpop(&lbl_lbl));
	incref(v4);
	VAL v5 = (lpop(&lbl_tag));
	incref(v5);
	push_value(v4);
	lpush(&lbl_lbl, v4);
	push_value(v5);
	lpush(&lbl_tag, v5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r6 = pop_resource();
	mw_mirth_data_Tag_projectZ_inputZ_label();
	push_resource(r6);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_std_maybe_Maybe_1_unwrap();
	switch (get_top_data_tag()) {
		case 0LL: { // Left
			mtp_std_either_Either_2_Left();
			VAL v7 = pop_value();
			decref(v7);
			VAL v8 = (lpop(&lbl_tag));
			incref(v8);
			push_value(v8);
			lpush(&lbl_tag, v8);
			mw_mirth_data_Tag_isZ_semiZ_transparentZAsk();
			VAL v9 = pop_value();
			if (VBOOL(v9)) {
				VAL v10 = (lpop(&lbl_tag));
				incref(v10);
				push_value(v10);
				lpush(&lbl_tag, v10);
				mw_mirth_data_Tag_outputsZ_resourceZAsk();
				VAL v11 = pop_value();
				if (VBOOL(v11)) {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL v = pop_resource();", 23);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("push_resource(pop_value());", 27);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("decref(v);", 10);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				} else {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL v = pop_value();", 20);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("decref(v);", 10);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				}
			} else {
				VAL v12 = (lpop(&lbl_tag));
				incref(v12);
				push_value(v12);
				lpush(&lbl_tag, v12);
				mw_mirth_data_Tag_outputsZ_resourceZAsk();
				VAL v13 = pop_value();
				if (VBOOL(v13)) {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL v = top_resource();", 23);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				} else {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL v = pop_value();", 20);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				}
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("VAL u = pop_value();", 20);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("ASSERT1(IS_TUP(v), v);", 22);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("ASSERT1(VTUPLEN(v) == ", 22);
				mw_mirth_c99_ZPlusC99_put();
				VAL v14 = (lpop(&lbl_tag));
				incref(v14);
				push_value(v14);
				lpush(&lbl_tag, v14);
				mw_mirth_data_Tag_numZ_totalZ_inputs();
				int64_t v15 = (1LL);
				push_i64(v15);
				mp_primZ_intZ_add();
				mp_primZ_intZ_toZ_str();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT(", v);", 5);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				VAL v16 = (lpop(&lbl_tag));
				incref(v16);
				push_value(v16);
				lpush(&lbl_tag, v16);
				mw_mirth_data_Tag_outputsZ_resourceZAsk();
				VAL v17 = pop_value();
				if (VBOOL(v17)) {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL* p = &VTUP(v)->cells[", 25);
					mw_mirth_c99_ZPlusC99_put();
					VAL v18 = (lpop(&lbl_tag));
					incref(v18);
					VAL v19 = (lpop(&lbl_lbl));
					incref(v19);
					push_value(v18);
					lpush(&lbl_tag, v18);
					push_value(v19);
					lpush(&lbl_lbl, v19);
					mw_mirth_c99_c99Z_tagZ_labelZ_index();
					mp_primZ_intZ_toZ_str();
					mw_mirth_c99_ZPlusC99_put();
					STRLIT("];", 2);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL t = *p; *p = u; decref(t);", 30);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				} else {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("if (VTUP(v)->refs == 1) {", 25);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r20 = pop_resource();
					int64_t v21 = (1LL);
					push_i64(v21);
					mp_primZ_intZ_add();
					push_resource(r20);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL* p = &VTUP(v)->cells[", 25);
					mw_mirth_c99_ZPlusC99_put();
					VAL v22 = (lpop(&lbl_tag));
					incref(v22);
					VAL v23 = (lpop(&lbl_lbl));
					incref(v23);
					push_value(v22);
					lpush(&lbl_tag, v22);
					push_value(v23);
					lpush(&lbl_lbl, v23);
					mw_mirth_c99_c99Z_tagZ_labelZ_index();
					mp_primZ_intZ_toZ_str();
					mw_mirth_c99_ZPlusC99_put();
					STRLIT("];", 2);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("VAL t = *p; *p = u; decref(t);", 30);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("push_value(v);", 14);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r24 = pop_resource();
					int64_t v25 = (1LL);
					push_i64(v25);
					mp_primZ_intZ_sub();
					mw_std_prim_Int_ZToNat();
					push_resource(r24);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("} else {", 8);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r26 = pop_resource();
					int64_t v27 = (1LL);
					push_i64(v27);
					mp_primZ_intZ_add();
					push_resource(r26);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("TUP *tup = tup_new(", 19);
					mw_mirth_c99_ZPlusC99_put();
					VAL v28 = (lpop(&lbl_tag));
					incref(v28);
					push_value(v28);
					lpush(&lbl_tag, v28);
					mw_mirth_data_Tag_numZ_totalZ_inputs();
					int64_t v29 = (1LL);
					push_i64(v29);
					mp_primZ_intZ_add();
					mp_primZ_intZ_toZ_str();
					mw_mirth_c99_ZPlusC99_put();
					STRLIT(");", 2);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("tup->size = ", 12);
					mw_mirth_c99_ZPlusC99_put();
					VAL v30 = (lpop(&lbl_tag));
					incref(v30);
					push_value(v30);
					lpush(&lbl_tag, v30);
					mw_mirth_data_Tag_numZ_totalZ_inputs();
					int64_t v31 = (1LL);
					push_i64(v31);
					mp_primZ_intZ_add();
					mp_primZ_intZ_toZ_str();
					mw_mirth_c99_ZPlusC99_put();
					STRLIT(";", 1);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					int64_t v32 = (0LL);
					push_i64(v32);
					mw_std_prim_Int_ZToNat();
					while(1) {
						VAL v33 = pop_value();
						incref(v33);
						VAL v34 = (lpop(&lbl_tag));
						incref(v34);
						push_value(v33);
						push_value(v33);
						push_value(v34);
						lpush(&lbl_tag, v34);
						mw_mirth_data_Tag_numZ_totalZ_inputs();
						VAL v35 = pop_value();
						VAL v36 = pop_value();
						bool v37 = (VI64(v35) < VI64(v36));
						if (v37) {
							uint64_t v38 = (0LL /* False */);
							push_u64(v38);
						} else {
							uint64_t v39 = (1LL /* True */);
							push_u64(v39);
						}
						VAL v40 = pop_value();
						if (!VBOOL(v40)) break;
						VAL v41 = pop_value();
						incref(v41);
						VAL v42 = (lpop(&lbl_tag));
						incref(v42);
						VAL v43 = (lpop(&lbl_lbl));
						incref(v43);
						push_value(v41);
						push_value(v41);
						push_value(v42);
						lpush(&lbl_tag, v42);
						push_value(v43);
						lpush(&lbl_lbl, v43);
						mw_mirth_c99_c99Z_tagZ_labelZ_index();
						VAL v44 = pop_value();
						VAL v45 = pop_value();
						bool v46 = (VI64(v45) == VI64(v44));
						if (v46) {
							mw_mirth_c99_ZPlusC99_indent();
							STRLIT("tup->cells[", 11);
							mw_mirth_c99_ZPlusC99_put();
							VAL v47 = pop_value();
							incref(v47);
							push_value(v47);
							push_value(v47);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("] = u;", 6);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
						} else {
							mw_mirth_c99_ZPlusC99_indent();
							STRLIT("tup->cells[", 11);
							mw_mirth_c99_ZPlusC99_put();
							VAL v48 = pop_value();
							incref(v48);
							push_value(v48);
							push_value(v48);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("] = VTUP(v)->cells[", 19);
							mw_mirth_c99_ZPlusC99_put();
							VAL v49 = pop_value();
							incref(v49);
							push_value(v49);
							push_value(v49);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("]; incref(tup->cells[", 21);
							mw_mirth_c99_ZPlusC99_put();
							VAL v50 = pop_value();
							incref(v50);
							push_value(v50);
							push_value(v50);
							mp_primZ_intZ_toZ_str();
							mw_mirth_c99_ZPlusC99_put();
							STRLIT("]);", 3);
							mw_mirth_c99_ZPlusC99_put();
							mw_mirth_c99_ZPlusC99_line();
						}
						int64_t v51 = (1LL);
						push_i64(v51);
						mp_primZ_intZ_add();
					}
					VAL v52 = pop_value();
					decref(v52);
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("decref(v);", 10);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("push_value(MKTUP(tup,", 21);
					mw_mirth_c99_ZPlusC99_put();
					VAL v53 = (lpop(&lbl_tag));
					incref(v53);
					push_value(v53);
					lpush(&lbl_tag, v53);
					mw_mirth_data_Tag_numZ_totalZ_inputs();
					int64_t v54 = (1LL);
					push_i64(v54);
					mp_primZ_intZ_add();
					mp_primZ_intZ_toZ_str();
					mw_mirth_c99_ZPlusC99_put();
					STRLIT("));", 3);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r55 = pop_resource();
					int64_t v56 = (1LL);
					push_i64(v56);
					mp_primZ_intZ_sub();
					mw_std_prim_Int_ZToNat();
					push_resource(r55);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("}", 1);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				}
			}
		} break;
		case 1LL: { // Right
			mtp_std_either_Either_2_Right();
			VAL v57 = pop_value();
			decref(v57);
			VAL v58 = (lpop(&lbl_tag));
			incref(v58);
			push_value(v58);
			lpush(&lbl_tag, v58);
			mw_mirth_data_Tag_isZ_semiZ_transparentZAsk();
			VAL v59 = pop_value();
			if (VBOOL(v59)) {
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("(void)pop_resource();", 21);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
			} else {
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("VAL v = pop_resource();", 23);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("VAL u = pop_resource();", 23);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("ASSERT1(IS_TUP(v), v);", 22);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("ASSERT1(VTUPLEN(v) == ", 22);
				mw_mirth_c99_ZPlusC99_put();
				VAL v60 = (lpop(&lbl_tag));
				incref(v60);
				push_value(v60);
				lpush(&lbl_tag, v60);
				mw_mirth_data_Tag_numZ_totalZ_inputs();
				int64_t v61 = (1LL);
				push_i64(v61);
				mp_primZ_intZ_add();
				mp_primZ_intZ_toZ_str();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT(", v);", 5);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("ASSERT1(VREFS(v) == 1, v);", 26);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("VAL* p = &VTUP(v)->cells[", 25);
				mw_mirth_c99_ZPlusC99_put();
				VAL v62 = (lpop(&lbl_tag));
				incref(v62);
				VAL v63 = (lpop(&lbl_lbl));
				incref(v63);
				push_value(v62);
				lpush(&lbl_tag, v62);
				push_value(v63);
				lpush(&lbl_lbl, v63);
				mw_mirth_c99_c99Z_tagZ_labelZ_index();
				mp_primZ_intZ_toZ_str();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT("];", 2);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("ASSERT1(p->tag == 0, v);", 24);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("*p = u;", 7);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("push_resource(v);", 17);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r64 = pop_resource();
	int64_t v65 = (1LL);
	push_i64(v65);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
	push_resource(r64);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
	VAL v66 = (lpop(&lbl_lbl));
	VAL v67 = (lpop(&lbl_tag));
	decref(v67);
	decref(v66);
}
static void mw_mirth_c99_c99Z_externalZ_blocksZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_external_ExternalBlock_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_c99_c99Z_externalZ_blockZBang();
		int64_t v7 = (1LL);
		push_value(v6);
		push_i64(v7);
		mp_primZ_intZ_add();
	}
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_c99_c99Z_externalZ_blockZBang (void) {
	mw_mirth_external_ExternalBlock_parts();
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		switch (get_top_data_tag()) {
			case 0LL: { // EBPCode
				mtp_mirth_external_ExternalBlockPart_EBPCode();
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
			} break;
			case 1LL: { // EBPDef
				mtp_mirth_external_ExternalBlockPart_EBPDef();
				mw_mirth_c99_c99Z_externalZ_defZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_c99_c99Z_externalZ_defZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_ext, v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_mirth_external_External_ctype();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	lpush(&lbl_cty, v2);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v3 = (0LL /* None */);
	VAL v4 = pop_value();
	push_u64(v3);
	push_value(v4);
	mw_std_list_List_1_uncons();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	while(1) {
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		push_value(v7);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v8 = pop_value();
		if (!VBOOL(v8)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		incref(v9);
		incref(v9);
		push_value(v9);
		mw_mirth_type_CTypeStackPart_labelZAsk();
		mw_std_maybe_Maybe_1_noneZAsk();
		VAL v12 = pop_value();
		push_value(v9);
		if (VBOOL(v12)) {
			mw_mirth_type_CTypeStackPart_ctype();
			mw_mirth_type_CType_phantomZAsk();
			VAL v13 = pop_value();
			if (VBOOL(v13)) {
				uint64_t v14 = (0LL /* False */);
				push_u64(v14);
			} else {
				uint64_t v15 = (1LL /* True */);
				push_u64(v15);
			}
		} else {
			VAL v16 = pop_value();
			decref(v16);
			uint64_t v17 = (0LL /* False */);
			push_u64(v17);
		}
		VAL v18 = pop_value();
		push_value(v9);
		if (VBOOL(v18)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v19 = pop_value();
			decref(v19);
			uint64_t v20 = (0LL /* None */);
			push_u64(v20);
		}
		VAL v21 = pop_value();
		push_value(v11);
		push_value(v10);
		push_value(v21);
		switch (get_top_data_tag()) {
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				decref(v23);
				VAL v24 = pop_value();
				decref(v24);
				uint64_t v25 = (0LL /* Nil */);
				push_value(v22);
				push_u64(v25);
			} break;
		}
		mw_std_list_List_1_uncons();
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		push_value(v26);
		push_value(v27);
	}
	VAL v28 = pop_value();
	decref(v28);
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	incref(v30);
	push_value(v30);
	lpush(&lbl_outty, v30);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_type_CTypeStackPart_ctype();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v31 = (5LL /* Phantom */);
			push_u64(v31);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_type_CType_cname();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL v32 = (lpop(&lbl_ext));
	incref(v32);
	push_value(v32);
	lpush(&lbl_ext, v32);
	mw_mirth_external_External_symbol();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" (", 2);
	mw_mirth_c99_ZPlusC99_put();
	VAL v33 = (lpop(&lbl_cty));
	incref(v33);
	push_value(v33);
	lpush(&lbl_cty, v33);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v34 = (0LL /* Nil */);
	push_u64(v34);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v35 = pop_value();
	VAL v36 = pop_value();
	push_value(v35);
	push_value(v36);
	while(1) {
		VAL v37 = pop_value();
		incref(v37);
		push_value(v37);
		push_value(v37);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v38 = pop_value();
		if (!VBOOL(v38)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v39 = pop_value();
		VAL v40 = pop_value();
		VAL r41 = pop_resource();
		incref(v39);
		push_value(v39);
		mw_mirth_type_CTypeStackPart_ctype();
		mw_mirth_type_CType_phantomZAsk();
		VAL v42 = pop_value();
		if (VBOOL(v42)) {
			uint64_t v43 = (0LL /* False */);
			push_u64(v43);
		} else {
			uint64_t v44 = (1LL /* True */);
			push_u64(v44);
		}
		VAL v45 = pop_value();
		push_value(v39);
		if (VBOOL(v45)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v46 = pop_value();
			decref(v46);
			uint64_t v47 = (0LL /* None */);
			push_u64(v47);
		}
		push_resource(r41);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v40);
		mw_std_list_List_1_uncons();
		VAL v48 = pop_value();
		VAL v49 = pop_value();
		push_value(v48);
		push_value(v49);
	}
	VAL v50 = pop_value();
	decref(v50);
	VAL v51 = pop_value();
	decref(v51);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	switch (get_top_data_tag()) {
		case 0LL: { // Nil
			(void)pop_u64();
			STRLIT("void", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		default: {
			mw_std_list_List_1_uncons();
			VAL v52 = pop_value();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					mw_mirth_type_CTypeStackPart_ctype();
					mw_mirth_type_CType_cname();
					mw_mirth_c99_ZPlusC99_put();
				} break;
				case 0LL: { // None
					(void)pop_u64();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			push_value(v52);
			mw_std_list_List_1_uncons();
			VAL v53 = pop_value();
			VAL v54 = pop_value();
			push_value(v53);
			push_value(v54);
			while(1) {
				VAL v55 = pop_value();
				incref(v55);
				push_value(v55);
				push_value(v55);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v56 = pop_value();
				if (!VBOOL(v56)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v57 = pop_value();
				VAL v58 = pop_value();
				STRLIT(", ", 2);
				mw_mirth_c99_ZPlusC99_put();
				push_value(v57);
				mw_mirth_type_CTypeStackPart_ctype();
				mw_mirth_type_CType_cname();
				mw_mirth_c99_ZPlusC99_put();
				push_value(v58);
				mw_std_list_List_1_uncons();
				VAL v59 = pop_value();
				VAL v60 = pop_value();
				push_value(v59);
				push_value(v60);
			}
			VAL v61 = pop_value();
			decref(v61);
			VAL v62 = pop_value();
			decref(v62);
		} break;
	}
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	VAL v63 = (lpop(&lbl_ext));
	incref(v63);
	push_value(v63);
	lpush(&lbl_ext, v63);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r64 = pop_resource();
	mw_mirth_external_External_cname();
	push_resource(r64);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(" {", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang();
	VAL v65 = (lpop(&lbl_cty));
	incref(v65);
	push_value(v65);
	lpush(&lbl_cty, v65);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v66 = pop_value();
	incref(v66);
	push_value(v66);
	push_value(v66);
	mw_std_list_List_1_len();
	VAL v67 = pop_value();
	lpush(&lbl_argZ_index, v67);
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v68 = pop_value();
	VAL v69 = pop_value();
	push_value(v68);
	push_value(v69);
	while(1) {
		VAL v70 = pop_value();
		incref(v70);
		push_value(v70);
		push_value(v70);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v71 = pop_value();
		if (!VBOOL(v71)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v72 = pop_value();
		VAL v73 = pop_value();
		incref(v72);
		push_value(v72);
		push_value(v72);
		mw_mirth_type_CTypeStackPart_ctype();
		mw_mirth_type_CType_phantomZAsk();
		VAL v74 = pop_value();
		if (VBOOL(v74)) {
		} else {
			STRLIT("\t", 1);
			mw_mirth_c99_ZPlusC99_put();
			VAL v75 = pop_value();
			incref(v75);
			push_value(v75);
			push_value(v75);
			mw_mirth_type_CTypeStackPart_ctype();
			mw_mirth_type_CType_cname();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(" ", 1);
			mw_mirth_c99_ZPlusC99_put();
			VAL v76 = pop_value();
			incref(v76);
			push_value(v76);
			push_value(v76);
			mw_mirth_type_CTypeStackPart_c99Z_argZ_name();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(" = ", 3);
			mw_mirth_c99_ZPlusC99_put();
		}
		mw_mirth_type_CTypeStackPart_c99Z_pop();
		STRLIT(";", 1);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		VAL v77 = (lpop(&lbl_argZ_index));
		int64_t v78 = (1LL);
		push_value(v77);
		push_i64(v78);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		VAL v79 = pop_value();
		lpush(&lbl_argZ_index, v79);
		push_value(v73);
		mw_std_list_List_1_uncons();
		VAL v80 = pop_value();
		VAL v81 = pop_value();
		push_value(v80);
		push_value(v81);
	}
	VAL v82 = pop_value();
	decref(v82);
	VAL v83 = pop_value();
	decref(v83);
	STRLIT("\t", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL v84 = (lpop(&lbl_outty));
	incref(v84);
	push_value(v84);
	lpush(&lbl_outty, v84);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_type_CTypeStackPart_ctype();
			mw_mirth_type_CType_cname();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(" Y = ", 5);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v85 = (lpop(&lbl_ext));
	incref(v85);
	push_value(v85);
	lpush(&lbl_ext, v85);
	mw_mirth_external_External_symbol();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT("(", 1);
	mw_mirth_c99_ZPlusC99_put();
	int64_t v86 = (1LL);
	push_i64(v86);
	mw_std_prim_Int_ZToNat();
	VAL v87 = (lpop(&lbl_argZ_index));
	decref(v87);
	VAL v88 = pop_value();
	VAL v89 = (lpop(&lbl_cty));
	incref(v89);
	lpush(&lbl_argZ_index, v88);
	push_value(v89);
	lpush(&lbl_cty, v89);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	uint64_t v90 = (0LL /* Nil */);
	push_u64(v90);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v91 = pop_value();
	VAL v92 = pop_value();
	push_value(v91);
	push_value(v92);
	while(1) {
		VAL v93 = pop_value();
		incref(v93);
		push_value(v93);
		push_value(v93);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v94 = pop_value();
		if (!VBOOL(v94)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v95 = pop_value();
		VAL v96 = pop_value();
		VAL r97 = pop_resource();
		incref(v95);
		push_value(v95);
		push_value(v95);
		mw_mirth_type_CTypeStackPart_ctype();
		mw_mirth_type_CType_phantomZAsk();
		VAL v98 = pop_value();
		if (VBOOL(v98)) {
			VAL v99 = pop_value();
			decref(v99);
			uint64_t v100 = (0LL /* None */);
			push_u64(v100);
		} else {
			mw_mirth_type_CTypeStackPart_c99Z_argZ_name();
			mtw_std_maybe_Maybe_1_Some();
		}
		VAL v101 = (lpop(&lbl_argZ_index));
		int64_t v102 = (1LL);
		push_value(v101);
		push_i64(v102);
		mp_primZ_intZ_add();
		VAL v103 = pop_value();
		lpush(&lbl_argZ_index, v103);
		push_resource(r97);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v96);
		mw_std_list_List_1_uncons();
		VAL v104 = pop_value();
		VAL v105 = pop_value();
		push_value(v104);
		push_value(v105);
	}
	VAL v106 = pop_value();
	decref(v106);
	VAL v107 = pop_value();
	decref(v107);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v108 = pop_value();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 0LL: { // None
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	push_value(v108);
	mw_std_list_List_1_uncons();
	VAL v109 = pop_value();
	VAL v110 = pop_value();
	push_value(v109);
	push_value(v110);
	while(1) {
		VAL v111 = pop_value();
		incref(v111);
		push_value(v111);
		push_value(v111);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v112 = pop_value();
		if (!VBOOL(v112)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v113 = pop_value();
		VAL v114 = pop_value();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		push_value(v113);
		mw_mirth_c99_ZPlusC99_put();
		push_value(v114);
		mw_std_list_List_1_uncons();
		VAL v115 = pop_value();
		VAL v116 = pop_value();
		push_value(v115);
		push_value(v116);
	}
	VAL v117 = pop_value();
	decref(v117);
	VAL v118 = pop_value();
	decref(v118);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	VAL v119 = (lpop(&lbl_cty));
	incref(v119);
	push_value(v119);
	lpush(&lbl_cty, v119);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v120 = pop_value();
	VAL v121 = pop_value();
	push_value(v120);
	push_value(v121);
	while(1) {
		VAL v122 = pop_value();
		incref(v122);
		push_value(v122);
		push_value(v122);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v123 = pop_value();
		if (!VBOOL(v123)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v124 = pop_value();
		VAL v125 = pop_value();
		push_value(v124);
		STRLIT("\t", 1);
		mw_mirth_c99_ZPlusC99_put();
		VAL v126 = pop_value();
		incref(v126);
		push_value(v126);
		mw_mirth_type_CTypeStackPart_labelZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mw_mirth_label_Label_name();
				mw_mirth_name_Name_mangled();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("Y", 1);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v126);
		mw_mirth_type_CTypeStackPart_c99Z_push();
		mw_mirth_c99_ZPlusC99_line();
		push_value(v125);
		mw_std_list_List_1_uncons();
		VAL v127 = pop_value();
		VAL v128 = pop_value();
		push_value(v127);
		push_value(v128);
	}
	VAL v129 = pop_value();
	decref(v129);
	VAL v130 = pop_value();
	decref(v130);
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	VAL v131 = (lpop(&lbl_argZ_index));
	decref(v131);
	VAL v132 = (lpop(&lbl_ext));
	VAL v133 = (lpop(&lbl_cty));
	VAL v134 = (lpop(&lbl_outty));
	decref(v134);
	decref(v133);
	decref(v132);
}
static void mw_mirth_type_CType_c99Z_popZ_value (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // IntLike
			mtp_mirth_type_CType_IntLike();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")pop_i64()", 10);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 1LL: { // F32Like
			mtp_mirth_type_CType_F32Like();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")pop_f32()", 10);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 2LL: { // F64Like
			mtp_mirth_type_CType_F64Like();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")pop_f64()", 10);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 3LL: { // PtrLike
			mtp_mirth_type_CType_PtrLike();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")pop_ptr()", 10);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 4LL: { // FnPtr
			mtp_mirth_type_CType_FnPtr();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")pop_fnptr()", 12);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 5LL: { // Phantom
			(void)pop_u64();
			STRLIT("(void)pop_value()", 17);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CType_c99Z_popZ_resource (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // IntLike
			mtp_mirth_type_CType_IntLike();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_i64(pop_resource())", 26);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 1LL: { // F32Like
			mtp_mirth_type_CType_F32Like();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_f32(pop_resource())", 26);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 2LL: { // F64Like
			mtp_mirth_type_CType_F64Like();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_f64(pop_resource())", 26);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 3LL: { // PtrLike
			mtp_mirth_type_CType_PtrLike();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_ptr(pop_resource())", 26);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 4LL: { // FnPtr
			mtp_mirth_type_CType_FnPtr();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_fnptr(pop_resource())", 28);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 5LL: { // Phantom
			(void)pop_u64();
			STRLIT("(void)pop_resource()", 20);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CType_c99Z_popZ_label (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // IntLike
			mtp_mirth_type_CType_IntLike();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_i64(lpop(&lbl_", 21);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("))", 2);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 1LL: { // F32Like
			mtp_mirth_type_CType_F32Like();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_f32(lpop(&lbl_", 21);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("))", 2);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 2LL: { // F64Like
			mtp_mirth_type_CType_F64Like();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_f64(lpop(&lbl_", 21);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("))", 2);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 3LL: { // PtrLike
			mtp_mirth_type_CType_PtrLike();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_ptr(lpop(&lbl_", 21);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("))", 2);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 4LL: { // FnPtr
			mtp_mirth_type_CType_FnPtr();
			STRLIT("(", 1);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")value_fnptr(lpop(&lbl_", 23);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("))", 2);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 5LL: { // Phantom
			(void)pop_u64();
			STRLIT("(void)lpop(&lbl_", 16);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")", 1);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CType_c99Z_pushZ_value (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // IntLike
			mtp_mirth_type_CType_IntLike();
			VAL v0 = pop_value();
			decref(v0);
			STRLIT("push_i64((int64_t)(", 19);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("));", 3);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 1LL: { // F32Like
			mtp_mirth_type_CType_F32Like();
			VAL v1 = pop_value();
			decref(v1);
			STRLIT("push_f32((float)(", 17);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("));", 3);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 2LL: { // F64Like
			mtp_mirth_type_CType_F64Like();
			VAL v2 = pop_value();
			decref(v2);
			STRLIT("push_f64((double)(", 18);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("));", 3);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 3LL: { // PtrLike
			mtp_mirth_type_CType_PtrLike();
			VAL v3 = pop_value();
			decref(v3);
			STRLIT("push_ptr((void*)(", 17);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("));", 3);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 4LL: { // FnPtr
			mtp_mirth_type_CType_FnPtr();
			VAL v4 = pop_value();
			decref(v4);
			STRLIT("push_fnptr((FNPTR)(", 19);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("));", 3);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 5LL: { // Phantom
			(void)pop_u64();
			VAL v5 = pop_value();
			decref(v5);
			STRLIT("push_i64(0);", 12);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CType_c99Z_pushZ_resource (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // IntLike
			mtp_mirth_type_CType_IntLike();
			VAL v0 = pop_value();
			decref(v0);
			STRLIT("push_resource(MKI64((int64_t)(", 30);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 1LL: { // F32Like
			mtp_mirth_type_CType_F32Like();
			VAL v1 = pop_value();
			decref(v1);
			STRLIT("push_resource(MKF32((float)(", 28);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 2LL: { // F64Like
			mtp_mirth_type_CType_F64Like();
			VAL v2 = pop_value();
			decref(v2);
			STRLIT("push_resource(MKF64((double)(", 29);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 3LL: { // PtrLike
			mtp_mirth_type_CType_PtrLike();
			VAL v3 = pop_value();
			decref(v3);
			STRLIT("push_resource(MKPTR((void*)(", 28);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 4LL: { // FnPtr
			mtp_mirth_type_CType_FnPtr();
			VAL v4 = pop_value();
			decref(v4);
			STRLIT("push_resource(MKFNPTR((FNPTR)(", 30);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 5LL: { // Phantom
			(void)pop_u64();
			VAL v5 = pop_value();
			decref(v5);
			STRLIT("push_resource(MKI64(0));", 24);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CType_c99Z_pushZ_label (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // IntLike
			mtp_mirth_type_CType_IntLike();
			VAL v0 = pop_value();
			decref(v0);
			STRLIT("lpush(&lbl_", 11);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(", ", 2);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("MKI64((int64_t)(", 16);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 1LL: { // F32Like
			mtp_mirth_type_CType_F32Like();
			VAL v1 = pop_value();
			decref(v1);
			STRLIT("lpush(&lbl_", 11);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(", ", 2);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("MKF32((float)(", 14);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 2LL: { // F64Like
			mtp_mirth_type_CType_F64Like();
			VAL v2 = pop_value();
			decref(v2);
			STRLIT("lpush(&lbl_", 11);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(", ", 2);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("MKF64((double)(", 15);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 3LL: { // PtrLike
			mtp_mirth_type_CType_PtrLike();
			VAL v3 = pop_value();
			decref(v3);
			STRLIT("lpush(&lbl_", 11);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(", ", 2);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("MKPTR((void*)(", 14);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 4LL: { // FnPtr
			mtp_mirth_type_CType_FnPtr();
			VAL v4 = pop_value();
			decref(v4);
			STRLIT("lpush(&lbl_", 11);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(", ", 2);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("MKFNPTR((FNPTR)(", 16);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")));", 4);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		case 5LL: { // Phantom
			(void)pop_u64();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			decref(v6);
			push_value(v5);
			STRLIT("lpush(&lbl_", 11);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(", ", 2);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("MKI64((int64_t)(0)));", 21);
			mw_mirth_c99_ZPlusC99_put();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CTypeStackPart_c99Z_argZ_name (void) {
	mw_mirth_type_CTypeStackPart_labelZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			mw_mirth_label_Label_name();
			mw_mirth_name_Name_mangled();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("X", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			VAL v0 = (lpop(&lbl_argZ_index));
			incref(v0);
			push_value(v0);
			lpush(&lbl_argZ_index, v0);
			mp_primZ_intZ_toZ_str();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CTypeStackPart_c99Z_pop (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // CTSPCons
			mtp_mirth_type_CTypeStackPart_CTSPCons();
			mw_mirth_type_CType_c99Z_popZ_value();
		} break;
		case 2LL: { // CTSPWith
			mtp_mirth_type_CTypeStackPart_CTSPWith();
			mw_mirth_type_CType_c99Z_popZ_resource();
		} break;
		case 1LL: { // CTSPConsLabel
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			mw_mirth_type_CType_c99Z_popZ_label();
		} break;
		case 3LL: { // CTSPWithLabel
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			mw_mirth_type_CType_c99Z_popZ_label();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_type_CTypeStackPart_c99Z_push (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // CTSPCons
			mtp_mirth_type_CTypeStackPart_CTSPCons();
			mw_mirth_type_CType_c99Z_pushZ_value();
		} break;
		case 2LL: { // CTSPWith
			mtp_mirth_type_CTypeStackPart_CTSPWith();
			mw_mirth_type_CType_c99Z_pushZ_resource();
		} break;
		case 1LL: { // CTSPConsLabel
			mtp_mirth_type_CTypeStackPart_CTSPConsLabel();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			push_value(v0);
			push_value(v1);
			mw_mirth_type_CType_c99Z_pushZ_label();
		} break;
		case 3LL: { // CTSPWithLabel
			mtp_mirth_type_CTypeStackPart_CTSPWithLabel();
			VAL v2 = pop_value();
			VAL v3 = pop_value();
			push_value(v2);
			push_value(v3);
			mw_mirth_type_CType_c99Z_pushZ_label();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99_indent (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	while(1) {
		VAL v0 = pop_value();
		incref(v0);
		int64_t v1 = (0LL);
		bool v2 = (v1 < VI64(v0));
		push_value(v0);
		if (!v2) break;
		VAL v3 = pop_value();
		STRLIT("\t", 1);
		mw_mirth_c99_ZPlusC99_put();
		int64_t v4 = (1LL);
		push_value(v3);
		push_i64(v4);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
	}
	VAL v5 = pop_value();
	decref(v5);
}
static void mw_mirth_c99_c99Z_callZBang (void) {
	VAL v0 = pop_value();
	mw_mirth_c99_c99Z_argsZ_pushZBang();
	push_value(v0);
	mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_mirth_c99_ZPlusC99_indent();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT("();", 3);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_c99Z_arrowZBang (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[7];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_c99_c99Z_atomZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_c99_c99Z_atomZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk();
	} else {
		uint64_t v3 = (0LL /* False */);
		push_u64(v3);
	}
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r5 = pop_resource();
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("WORD_ATOM(", 10);
		mw_mirth_c99_ZPlusC99_put();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 9, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_token_Token_row();
		mw_mirth_location_Row_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		push_value(v7);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 9, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_token_Token_col();
		mw_mirth_location_Col_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 9, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_token_Token_nameZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mw_mirth_name_Name_ZToStr();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				STRLIT("", 0);
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_c99_ZPlusC99_putZ_cstr();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		push_resource(r5);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[1];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
	} else {
	}
	VAL v9 = pop_value();
	incref(v9);
	push_value(v9);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	push_value(v9);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_c99_c99Z_argsZ_opZBang();
}
static void mw_mirth_arrow_Atom_showZ_inZ_stackZ_traceZAsk (void) {
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // OpNone
			(void)pop_u64();
			uint64_t v0 = (0LL /* False */);
			push_u64(v0);
		} break;
		case 7LL: { // OpInt
			mtp_mirth_arrow_Op_OpInt();
			VAL v1 = pop_value();
			decref(v1);
			uint64_t v2 = (0LL /* False */);
			push_u64(v2);
		} break;
		case 8LL: { // OpF64
			mtp_mirth_arrow_Op_OpF64();
			VAL v3 = pop_value();
			decref(v3);
			uint64_t v4 = (0LL /* False */);
			push_u64(v4);
		} break;
		case 9LL: { // OpStr
			mtp_mirth_arrow_Op_OpStr();
			VAL v5 = pop_value();
			decref(v5);
			uint64_t v6 = (0LL /* False */);
			push_u64(v6);
		} break;
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			mw_mirth_word_Word_preferZ_inlineZAsk();
			VAL v7 = pop_value();
			if (VBOOL(v7)) {
				uint64_t v8 = (0LL /* False */);
				push_u64(v8);
			} else {
				uint64_t v9 = (1LL /* True */);
				push_u64(v9);
			}
		} break;
		case 3LL: { // OpExternal
			mtp_mirth_arrow_Op_OpExternal();
			VAL v10 = pop_value();
			decref(v10);
			uint64_t v11 = (1LL /* True */);
			push_u64(v11);
		} break;
		case 4LL: { // OpBuffer
			mtp_mirth_arrow_Op_OpBuffer();
			VAL v12 = pop_value();
			decref(v12);
			uint64_t v13 = (0LL /* False */);
			push_u64(v13);
		} break;
		case 5LL: { // OpVariable
			mtp_mirth_arrow_Op_OpVariable();
			VAL v14 = pop_value();
			decref(v14);
			uint64_t v15 = (0LL /* False */);
			push_u64(v15);
		} break;
		case 6LL: { // OpField
			mtp_mirth_arrow_Op_OpField();
			VAL v16 = pop_value();
			decref(v16);
			uint64_t v17 = (0LL /* False */);
			push_u64(v17);
		} break;
		case 10LL: { // OpTag
			mtp_mirth_arrow_Op_OpTag();
			mw_mirth_data_Tag_preferZ_inlineZAsk();
			VAL v18 = pop_value();
			if (VBOOL(v18)) {
				uint64_t v19 = (0LL /* False */);
				push_u64(v19);
			} else {
				uint64_t v20 = (1LL /* True */);
				push_u64(v20);
			}
		} break;
		case 1LL: { // OpPrim
			mtp_mirth_arrow_Op_OpPrim();
			VAL v21 = pop_value();
			decref(v21);
			uint64_t v22 = (1LL /* True */);
			push_u64(v22);
		} break;
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			VAL v23 = pop_value();
			decref(v23);
			uint64_t v24 = (0LL /* False */);
			push_u64(v24);
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			VAL v25 = pop_value();
			decref(v25);
			uint64_t v26 = (0LL /* False */);
			push_u64(v26);
		} break;
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			VAL v27 = pop_value();
			decref(v27);
			uint64_t v28 = (0LL /* False */);
			push_u64(v28);
		} break;
		case 14LL: { // OpBlockPush
			mtp_mirth_arrow_Op_OpBlockPush();
			VAL v29 = pop_value();
			decref(v29);
			uint64_t v30 = (0LL /* False */);
			push_u64(v30);
		} break;
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			VAL v31 = pop_value();
			decref(v31);
			uint64_t v32 = (0LL /* False */);
			push_u64(v32);
		} break;
		case 16LL: { // OpCoerce
			mtp_mirth_arrow_Op_OpCoerce();
			VAL v33 = pop_value();
			decref(v33);
			uint64_t v34 = (0LL /* False */);
			push_u64(v34);
		} break;
		case 17LL: { // OpLabelPush
			mtp_mirth_arrow_Op_OpLabelPush();
			VAL v35 = pop_value();
			decref(v35);
			uint64_t v36 = (0LL /* False */);
			push_u64(v36);
		} break;
		case 18LL: { // OpLabelPop
			mtp_mirth_arrow_Op_OpLabelPop();
			VAL v37 = pop_value();
			decref(v37);
			uint64_t v38 = (0LL /* False */);
			push_u64(v38);
		} break;
		case 19LL: { // OpLabelPushR
			mtp_mirth_arrow_Op_OpLabelPushR();
			VAL v39 = pop_value();
			decref(v39);
			uint64_t v40 = (0LL /* False */);
			push_u64(v40);
		} break;
		case 20LL: { // OpLabelPopR
			mtp_mirth_arrow_Op_OpLabelPopR();
			VAL v41 = pop_value();
			decref(v41);
			uint64_t v42 = (0LL /* False */);
			push_u64(v42);
		} break;
		case 21LL: { // OpDataGetTag
			mtp_mirth_arrow_Op_OpDataGetTag();
			VAL v43 = pop_value();
			decref(v43);
			uint64_t v44 = (0LL /* False */);
			push_u64(v44);
		} break;
		case 22LL: { // OpDataGetLabel
			mtp_mirth_arrow_Op_OpDataGetLabel();
			VAL v45 = pop_value();
			decref(v45);
			VAL v46 = pop_value();
			decref(v46);
			uint64_t v47 = (0LL /* False */);
			push_u64(v47);
		} break;
		case 23LL: { // OpDataSetLabel
			mtp_mirth_arrow_Op_OpDataSetLabel();
			VAL v48 = pop_value();
			decref(v48);
			VAL v49 = pop_value();
			decref(v49);
			uint64_t v50 = (0LL /* False */);
			push_u64(v50);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_c99Z_argsZ_opZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // OpNone
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		case 7LL: { // OpInt
			mtp_mirth_arrow_Op_OpInt();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_c99_c99Z_intZBang();
		} break;
		case 8LL: { // OpF64
			mtp_mirth_arrow_Op_OpF64();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			decref(v4);
			push_value(v3);
			mw_mirth_c99_c99Z_f64ZBang();
		} break;
		case 9LL: { // OpStr
			mtp_mirth_arrow_Op_OpStr();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			decref(v6);
			push_value(v5);
			mw_mirth_c99_c99Z_strZBang();
		} break;
		case 2LL: { // OpWord
			mtp_mirth_arrow_Op_OpWord();
			mw_mirth_c99_c99Z_wordZBang();
		} break;
		case 3LL: { // OpExternal
			mtp_mirth_arrow_Op_OpExternal();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r7 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r8 = pop_resource();
			mw_mirth_external_External_cname();
			push_resource(r8);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			push_resource(r7);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_c99Z_callZBang();
		} break;
		case 4LL: { // OpBuffer
			mtp_mirth_arrow_Op_OpBuffer();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r9 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r10 = pop_resource();
			mw_mirth_buffer_Buffer_cname();
			push_resource(r10);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			push_resource(r9);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_c99Z_callZBang();
		} break;
		case 5LL: { // OpVariable
			mtp_mirth_arrow_Op_OpVariable();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r11 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r12 = pop_resource();
			mw_mirth_variable_Variable_cname();
			push_resource(r12);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			push_resource(r11);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_c99Z_callZBang();
		} break;
		case 6LL: { // OpField
			mtp_mirth_arrow_Op_OpField();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r13 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r14 = pop_resource();
			mw_mirth_table_Field_cname();
			push_resource(r14);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			push_resource(r13);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_c99Z_callZBang();
		} break;
		case 10LL: { // OpTag
			mtp_mirth_arrow_Op_OpTag();
			mw_mirth_c99_c99Z_tagZ_wordZBang();
		} break;
		case 1LL: { // OpPrim
			mtp_mirth_arrow_Op_OpPrim();
			mw_mirth_c99_c99Z_primZBang();
		} break;
		case 11LL: { // OpMatch
			mtp_mirth_arrow_Op_OpMatch();
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			decref(v16);
			push_value(v15);
			mw_mirth_c99_c99Z_matchZBang();
		} break;
		case 12LL: { // OpLambda
			mtp_mirth_arrow_Op_OpLambda();
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			decref(v18);
			push_value(v17);
			mw_mirth_c99_c99Z_lambdaZBang();
		} break;
		case 13LL: { // OpVar
			mtp_mirth_arrow_Op_OpVar();
			VAL v19 = pop_value();
			VAL v20 = pop_value();
			decref(v20);
			push_value(v19);
			mw_mirth_c99_c99Z_varZBang();
		} break;
		case 14LL: { // OpBlockPush
			mtp_mirth_arrow_Op_OpBlockPush();
			VAL v21 = pop_value();
			VAL v22 = pop_value();
			decref(v22);
			push_value(v21);
			mw_mirth_c99_c99Z_blockZ_pushZBang();
		} break;
		case 15LL: { // OpBlockRun
			mtp_mirth_arrow_Op_OpBlockRun();
			VAL v23 = pop_value();
			VAL v24 = pop_value();
			decref(v24);
			push_value(v23);
			mw_mirth_c99_c99Z_blockZ_runZBang();
		} break;
		case 16LL: { // OpCoerce
			mtp_mirth_arrow_Op_OpCoerce();
			VAL v25 = pop_value();
			decref(v25);
			VAL v26 = pop_value();
			decref(v26);
		} break;
		case 17LL: { // OpLabelPush
			mtp_mirth_arrow_Op_OpLabelPush();
			VAL v27 = pop_value();
			VAL v28 = pop_value();
			decref(v28);
			push_value(v27);
			mw_mirth_c99_c99Z_labelZ_pushZBang();
		} break;
		case 18LL: { // OpLabelPop
			mtp_mirth_arrow_Op_OpLabelPop();
			VAL v29 = pop_value();
			VAL v30 = pop_value();
			decref(v30);
			push_value(v29);
			mw_mirth_c99_c99Z_labelZ_popZBang();
		} break;
		case 19LL: { // OpLabelPushR
			mtp_mirth_arrow_Op_OpLabelPushR();
			VAL v31 = pop_value();
			VAL v32 = pop_value();
			decref(v32);
			push_value(v31);
			mw_mirth_c99_c99Z_labelZ_pushZ_rZBang();
		} break;
		case 20LL: { // OpLabelPopR
			mtp_mirth_arrow_Op_OpLabelPopR();
			VAL v33 = pop_value();
			VAL v34 = pop_value();
			decref(v34);
			push_value(v33);
			mw_mirth_c99_c99Z_labelZ_popZ_rZBang();
		} break;
		case 21LL: { // OpDataGetTag
			mtp_mirth_arrow_Op_OpDataGetTag();
			mw_mirth_c99_c99Z_getZ_dataZ_tagZBang();
		} break;
		case 22LL: { // OpDataGetLabel
			mtp_mirth_arrow_Op_OpDataGetLabel();
			mw_mirth_c99_c99Z_tagZ_getZ_labelZBang();
			VAL v35 = pop_value();
			decref(v35);
		} break;
		case 23LL: { // OpDataSetLabel
			mtp_mirth_arrow_Op_OpDataSetLabel();
			mw_mirth_c99_c99Z_tagZ_setZ_labelZBang();
			VAL v36 = pop_value();
			decref(v36);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_c99Z_getZ_dataZ_tagZBang (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	decref(v1);
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Data_isZ_enumZAsk();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		uint64_t v3 = (1LL /* True */);
		push_u64(v3);
	} else {
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Data_isZ_unitZAsk();
	}
	VAL v5 = pop_value();
	if (VBOOL(v5)) {
	} else {
		mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("{", 1);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r6 = pop_resource();
		int64_t v7 = (1LL);
		push_i64(v7);
		mp_primZ_intZ_add();
		push_resource(r6);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("VAL val = pop_value();", 22);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		mw_mirth_data_Data_isZ_semiZ_transparentZAsk();
		VAL v9 = pop_value();
		if (VBOOL(v9)) {
			mw_mirth_c99_ZPlusC99_indent();
			STRLIT("push_u64(", 9);
			mw_mirth_c99_ZPlusC99_put();
			VAL v10 = pop_value();
			incref(v10);
			push_value(v10);
			push_value(v10);
			mw_mirth_data_Data_tags();
			mw_std_list_List_1_ZDivL1();
			mw_std_maybe_Maybe_1_unwrap();
			mw_mirth_data_Tag_value();
			mp_primZ_intZ_toZ_str();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT("LL);", 4);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
		} else {
			mw_mirth_c99_ZPlusC99_indent();
			STRLIT("USIZE tag = get_data_tag(val);", 30);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
			mw_mirth_c99_ZPlusC99_indent();
			STRLIT("push_u64(tag);", 14);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
		}
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("decref(val);", 12);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r11 = pop_resource();
		int64_t v12 = (1LL);
		push_i64(v12);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		push_resource(r11);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("}", 1);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		mw_mirth_c99_ZPlusC99_startZ_branchZBang();
	}
	VAL v13 = pop_value();
	decref(v13);
}
static void mw_mirth_c99_c99Z_wordZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_word_Word_preferZ_inlineZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		mw_mirth_c99_c99Z_argsZ_pushZBang();
		push_value(v2);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r3 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r4 = pop_resource();
		mw_mirth_word_Word_arrow();
		push_resource(r4);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		push_resource(r3);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[1];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_c99Z_arrowZBang();
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r5 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r6 = pop_resource();
		mw_mirth_word_Word_cname();
		push_resource(r6);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		push_resource(r5);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[1];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_c99Z_callZBang();
	}
}
static void mw_mirth_data_Tag_valueZ_show (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mfld_mirth_data_Tag_ZTildevalueZ_show();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mp_primZ_mutZ_isZ_set();
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mp_primZ_mutZ_get();
	} else {
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_data_Tag_value();
		mp_primZ_intZ_toZ_str();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		push_value(v3);
		mp_primZ_mutZ_set();
	}
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	decref(v7);
	push_value(v6);
}
static void mw_mirth_c99_c99Z_tagZ_wordZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_preferZ_inlineZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_data_Tag_data();
		mw_mirth_data_Data_isZ_transparentZAsk();
		VAL v3 = pop_value();
		if (VBOOL(v3)) {
		} else {
			VAL v4 = pop_value();
			incref(v4);
			push_value(v4);
			push_value(v4);
			mw_mirth_data_Tag_outputsZ_resourceZAsk();
			VAL v5 = pop_value();
			if (VBOOL(v5)) {
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					ASSERT1(VREFS(v) == 1, v);
					*p = (VAL){0};
					push_resource(u);
					push_resource(v);
				}
				VAL r6 = pop_resource();
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
				VAL v7 = pop_value();
				VAL r8 = pop_resource();
				lpush(&lbl_localZ_resourceZ_name, v7);
				mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource();
				push_resource(r8);
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("VAL ", 4);
				mw_mirth_c99_ZPlusC99_put();
				VAL r9 = pop_resource();
				{
					VAL v = top_resource();
					incref(v);
					push_value(v);
				}
				push_resource(r9);
				mw_mirth_c99_ZPlusC99_put();
				STRLIT(" = (", 4);
				mw_mirth_c99_ZPlusC99_put();
				VAL r10 = pop_resource();
				VAL r11 = pop_resource();
				push_resource(r10);
				STRLIT("MKU64(", 6);
				mw_mirth_c99_ZPlusC99_put();
				VAL v12 = pop_value();
				incref(v12);
				push_value(v12);
				push_value(v12);
				mw_mirth_data_Tag_valueZ_show();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT("LL /* ", 6);
				mw_mirth_c99_ZPlusC99_put();
				VAL v13 = pop_value();
				incref(v13);
				push_value(v13);
				push_value(v13);
				mw_mirth_data_Tag_name();
				mw_mirth_name_Name_ZToStr();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT(" */)", 4);
				mw_mirth_c99_ZPlusC99_put();
				VAL r14 = pop_resource();
				push_resource(r11);
				push_resource(r14);
				STRLIT(");", 2);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				push_resource(r6);
				{
					VAL v = pop_resource();
					VAL u = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					ASSERT1(VREFS(v) == 1, v);
					VAL* p = &VTUP(v)->cells[1];
					ASSERT1(p->tag == 0, v);
					*p = u;
					push_resource(v);
				}
				VAL r15 = pop_resource();
				VAL r16 = pop_resource();
				push_resource(r15);
				push_resource(r16);
				mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang();
			} else {
				uint64_t v17 = (2LL /* C99RT_U64 */);
				push_u64(v17);
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					ASSERT1(VREFS(v) == 1, v);
					*p = (VAL){0};
					push_resource(u);
					push_resource(v);
				}
				VAL r18 = pop_resource();
				VAL v19 = pop_value();
				lpush(&lbl_localZ_repr, v19);
				mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
				VAL v20 = pop_value();
				VAL r21 = pop_resource();
				lpush(&lbl_localZ_name, v20);
				mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
				push_resource(r21);
				mw_mirth_c99_ZPlusC99_indent();
				VAL r22 = pop_resource();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				push_resource(r22);
				mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT(" ", 1);
				mw_mirth_c99_ZPlusC99_put();
				VAL r23 = pop_resource();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				push_resource(r23);
				mw_mirth_c99_ZPlusC99_put();
				STRLIT(" = (", 4);
				mw_mirth_c99_ZPlusC99_put();
				VAL r24 = pop_resource();
				VAL r25 = pop_resource();
				VAL v26 = pop_value();
				incref(v26);
				push_resource(r24);
				push_value(v26);
				push_value(v26);
				mw_mirth_data_Tag_valueZ_show();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT("LL /* ", 6);
				mw_mirth_c99_ZPlusC99_put();
				VAL v27 = pop_value();
				incref(v27);
				push_value(v27);
				push_value(v27);
				mw_mirth_data_Tag_name();
				mw_mirth_name_Name_ZToStr();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT(" */", 3);
				mw_mirth_c99_ZPlusC99_put();
				VAL r28 = pop_resource();
				push_resource(r25);
				push_resource(r28);
				STRLIT(");", 2);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				push_resource(r18);
				{
					VAL v = pop_resource();
					VAL u = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					ASSERT1(VREFS(v) == 1, v);
					VAL* p = &VTUP(v)->cells[1];
					ASSERT1(p->tag == 0, v);
					*p = u;
					push_resource(v);
				}
				VAL r29 = pop_resource();
				VAL r30 = pop_resource();
				push_resource(r29);
				push_resource(r30);
				mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
			}
		}
		VAL v31 = pop_value();
		decref(v31);
		VAL v32 = pop_value();
		decref(v32);
	} else {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r33 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r34 = pop_resource();
		mw_mirth_data_Tag_wordZ_cname();
		push_resource(r34);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		push_resource(r33);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[1];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_c99Z_callZBang();
	}
}
static void mw_mirth_c99_c99Z_reverseZ_tagZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_preferZ_inlineZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_data_Tag_data();
		mw_mirth_data_Data_isZ_transparentZAsk();
		VAL v3 = pop_value();
		if (VBOOL(v3)) {
		} else {
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r4 = pop_resource();
			mw_mirth_c99_ZPlusC99_indent();
			VAL v5 = pop_value();
			incref(v5);
			push_value(v5);
			push_value(v5);
			mw_mirth_data_Tag_outputsZ_resourceZAsk();
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				STRLIT("(void)pop_resource();", 21);
			} else {
				STRLIT("(void)pop_u64();", 16);
			}
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
			push_resource(r4);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
		}
		VAL v7 = pop_value();
		decref(v7);
	} else {
		VAL v8 = pop_value();
		uint64_t v9 = (0LL /* Nil */);
		push_u64(v9);
		push_value(v8);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r10 = pop_resource();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r11 = pop_resource();
		mw_mirth_data_Tag_patZ_cname();
		push_resource(r11);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		push_resource(r10);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[1];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_c99Z_callZBang();
	}
}
static void mw_mirth_c99_c99Z_labelZ_defsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_label_Label_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_c99_c99Z_labelZ_defZBang();
		int64_t v7 = (1LL);
		push_value(v6);
		push_i64(v7);
		mp_primZ_intZ_add();
	}
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_c99_c99Z_labelZ_defZBang (void) {
	STRLIT("static VAL lbl_", 15);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_label_Label_name();
	mw_mirth_name_Name_mangled();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = MKNIL_C;", 11);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_pushZ_localZ_labelZ_directZBang (void) {
	mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("lpush(&lbl_", 11);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_label_Label_name();
	mw_mirth_name_Name_mangled();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(", ", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_pushZ_localZ_labelZBang (void) {
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	push_resource(r0);
	push_resource(r1);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	VAL r4 = pop_resource();
	push_resource(r3);
	push_resource(r4);
	mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
	push_resource(r2);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang (void) {
	mw_mirth_c99_ZPlusC99LocalResource_consume();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("lpush(&lbl_", 11);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_label_Label_name();
	mw_mirth_name_Name_mangled();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(", ", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang (void) {
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	push_resource(r0);
	push_resource(r1);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	VAL r4 = pop_resource();
	push_resource(r3);
	push_resource(r4);
	mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
	push_resource(r2);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_popZ_localZ_labelZ_directZBang (void) {
	uint64_t v0 = (0LL /* C99RT_VAL */);
	lpush(&lbl_localZ_repr, MKU64(v0));
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v1 = pop_value();
	VAL r2 = pop_resource();
	lpush(&lbl_localZ_name, v1);
	mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
	push_resource(r2);
	mw_mirth_c99_ZPlusC99_indent();
	VAL r3 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r3);
	mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL r4 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r4);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = (", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r5 = pop_resource();
	VAL r6 = pop_resource();
	push_resource(r5);
	STRLIT("lpop(&lbl_", 10);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_label_Label_name();
	mw_mirth_name_Name_mangled();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(")", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL r7 = pop_resource();
	push_resource(r6);
	push_resource(r7);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	VAL r8 = pop_resource();
	VAL r9 = pop_resource();
	push_resource(r8);
	push_resource(r9);
}
static void mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang (void) {
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v0 = pop_value();
	VAL r1 = pop_resource();
	lpush(&lbl_localZ_resourceZ_name, v0);
	mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource();
	push_resource(r1);
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("VAL ", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r2 = pop_resource();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	push_resource(r2);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = (", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r3 = pop_resource();
	VAL r4 = pop_resource();
	push_resource(r3);
	STRLIT("lpop(&lbl_", 10);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_label_Label_name();
	mw_mirth_name_Name_mangled();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(")", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL r5 = pop_resource();
	push_resource(r4);
	push_resource(r5);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	VAL r6 = pop_resource();
	VAL r7 = pop_resource();
	push_resource(r6);
	push_resource(r7);
}
static void mw_mirth_c99_c99Z_labelZ_pushZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
	mw_mirth_c99_pushZ_localZ_labelZBang();
}
static void mw_mirth_c99_c99Z_labelZ_pushZ_rZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZBang();
	mw_mirth_c99_pushZ_localZ_resourceZ_labelZBang();
}
static void mw_mirth_c99_c99Z_labelZ_popZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZBang();
	mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
}
static void mw_mirth_c99_c99Z_labelZ_popZ_rZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZBang();
	mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang();
}
static void mw_mirth_c99_c99Z_intZBang (void) {
	uint64_t v0 = (1LL /* C99RT_I64 */);
	push_u64(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	lpush(&lbl_localZ_repr, v2);
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v3 = pop_value();
	VAL r4 = pop_resource();
	lpush(&lbl_localZ_name, v3);
	mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
	push_resource(r4);
	mw_mirth_c99_ZPlusC99_indent();
	VAL r5 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r5);
	mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL r6 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r6);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = (", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r7 = pop_resource();
	VAL r8 = pop_resource();
	push_resource(r7);
	mp_primZ_intZ_toZ_str();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT("LL", 2);
	mw_mirth_c99_ZPlusC99_put();
	VAL r9 = pop_resource();
	push_resource(r8);
	push_resource(r9);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r10 = pop_resource();
	VAL r11 = pop_resource();
	push_resource(r10);
	push_resource(r11);
	mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
}
static void mw_mirth_c99_c99Z_f64ZBang (void) {
	uint64_t v0 = (4LL /* C99RT_F64 */);
	push_u64(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	lpush(&lbl_localZ_repr, v2);
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v3 = pop_value();
	VAL r4 = pop_resource();
	lpush(&lbl_localZ_name, v3);
	mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
	push_resource(r4);
	mw_mirth_c99_ZPlusC99_indent();
	VAL r5 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r5);
	mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL r6 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r6);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = (", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r7 = pop_resource();
	VAL r8 = pop_resource();
	push_resource(r7);
	mp_primZ_f64Z_toZ_str();
	mw_mirth_c99_ZPlusC99_put();
	VAL r9 = pop_resource();
	push_resource(r8);
	push_resource(r9);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r10 = pop_resource();
	VAL r11 = pop_resource();
	push_resource(r10);
	push_resource(r11);
	mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
}
static void mw_mirth_c99_c99Z_strZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	int64_t v1 = (4090LL);
	push_i64(v1);
	mw_std_prim_Int_ZToNat();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	bool v4 = (VI64(v2) < VI64(v3));
	if (v4) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("STRLIT(", 7);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r5 = pop_resource();
		int64_t v6 = (1LL);
		push_i64(v6);
		mp_primZ_intZ_add();
		push_resource(r5);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_c99_ZPlusC99_indent();
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		push_value(v7);
		mw_mirth_c99_ZPlusC99_putZ_cstrZ_long();
		STRLIT(",", 1);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		mw_mirth_c99_ZPlusC99_indent();
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		mp_primZ_strZ_numZ_bytes();
		mw_std_prim_Int_ZToNat();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r9 = pop_resource();
		int64_t v10 = (1LL);
		push_i64(v10);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		push_resource(r9);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
	} else {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("STRLIT(", 7);
		mw_mirth_c99_ZPlusC99_put();
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		push_value(v11);
		mw_mirth_c99_ZPlusC99_putZ_cstr();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v12 = pop_value();
		incref(v12);
		push_value(v12);
		push_value(v12);
		mp_primZ_strZ_numZ_bytes();
		mw_std_prim_Int_ZToNat();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
	}
	VAL v13 = pop_value();
	decref(v13);
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
}
static void mw_mirth_c99_ZPlusC99_putZ_cstrZ_long (void) {
	uint64_t v0 = (0LL /* False */);
	uint64_t v1 = (34LL /* BQUOTE */);
	lpush(&lbl_avoidZ_hexdigit, MKU64(v0));
	push_u64(v1);
	mw_mirth_c99_ZPlusC99_putZ_byte();
	uint64_t v2 = (0LL /* BNUL */);
	VAL v3 = pop_value();
	incref(v3);
	incref(v3);
	push_u64(v2);
	push_value(v3);
	mp_primZ_strZ_base();
	push_value(v3);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	while(1) {
		VAL v4 = pop_value();
		incref(v4);
		int64_t v5 = (0LL);
		bool v6 = (v5 < VI64(v4));
		push_value(v4);
		if (!v6) break;
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		incref(v8);
		VAL v9 = (MKU64(0LL /* +Unsafe */));
		push_value(v8);
		push_resource(v9);
		mw_std_prim_Ptr_ZAtByte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		uint64_t v12 = (10LL /* BLF */);
		push_value(v10);
		push_value(v11);
		push_u64(v12);
		mw_std_byte_Byte_ZEqualZEqual();
		VAL v13 = pop_value();
		if (VBOOL(v13)) {
			uint64_t v14 = (34LL /* BQUOTE */);
			push_u64(v14);
			mw_mirth_c99_ZPlusC99_putZ_byte();
			mw_mirth_c99_ZPlusC99_line();
			mw_mirth_c99_ZPlusC99_indent();
			uint64_t v15 = (34LL /* BQUOTE */);
			push_u64(v15);
			mw_mirth_c99_ZPlusC99_putZ_byte();
		} else {
		}
		VAL v16 = pop_value();
		incref(v16);
		push_value(v16);
		push_value(v16);
		mw_mirth_c99_c99Z_stringZ_byteZBang();
		int64_t v17 = (1LL);
		VAL v18 = (MKU64(0LL /* +Unsafe */));
		push_i64(v17);
		push_resource(v18);
		push_value(v8);
		mp_primZ_ptrZ_add();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		int64_t v19 = (1LL);
		push_value(v7);
		push_i64(v19);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
	}
	VAL v20 = pop_value();
	decref(v20);
	VAL v21 = pop_value();
	decref(v21);
	decref(v3);
	uint64_t v22 = (34LL /* BQUOTE */);
	push_u64(v22);
	mw_mirth_c99_ZPlusC99_putZ_byte();
	VAL v23 = (lpop(&lbl_avoidZ_hexdigit));
	decref(v23);
	VAL v24 = pop_value();
	decref(v24);
}
static void mw_mirth_c99_ZPlusC99_putZ_cstr (void) {
	uint64_t v0 = (0LL /* False */);
	uint64_t v1 = (34LL /* BQUOTE */);
	lpush(&lbl_avoidZ_hexdigit, MKU64(v0));
	push_u64(v1);
	mw_mirth_c99_ZPlusC99_putZ_byte();
	VAL v2 = pop_value();
	incref(v2);
	incref(v2);
	push_value(v2);
	mp_primZ_strZ_base();
	push_value(v2);
	mp_primZ_strZ_numZ_bytes();
	mw_std_prim_Int_ZToNat();
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		int64_t v4 = (0LL);
		bool v5 = (v4 < VI64(v3));
		push_value(v3);
		if (!v5) break;
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		incref(v7);
		VAL v8 = (MKU64(0LL /* +Unsafe */));
		push_value(v7);
		push_resource(v8);
		mw_std_prim_Ptr_ZAtByte();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_c99_c99Z_stringZ_byteZBang();
		int64_t v9 = (1LL);
		VAL v10 = (MKU64(0LL /* +Unsafe */));
		push_i64(v9);
		push_resource(v10);
		push_value(v7);
		mp_primZ_ptrZ_add();
		switch (get_top_resource_data_tag()) {
			case 0LL: { // +Unsafe
				(void)pop_resource();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		int64_t v11 = (1LL);
		push_value(v6);
		push_i64(v11);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
	}
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	decref(v13);
	decref(v2);
	uint64_t v14 = (34LL /* BQUOTE */);
	push_u64(v14);
	mw_mirth_c99_ZPlusC99_putZ_byte();
	VAL v15 = (lpop(&lbl_avoidZ_hexdigit));
	decref(v15);
}
static void mw_mirth_c99_c99Z_stringZ_byteZBang (void) {
	switch (get_top_data_tag()) {
		case 92LL: { // B'\'
			(void)pop_u64();
			STRLIT("\\\\", 2);
			mw_mirth_c99_ZPlusC99_put();
			uint64_t v0 = (0LL /* False */);
			VAL v1 = (lpop(&lbl_avoidZ_hexdigit));
			decref(v1);
			lpush(&lbl_avoidZ_hexdigit, MKU64(v0));
		} break;
		case 34LL: { // BQUOTE
			(void)pop_u64();
			STRLIT("\\\"", 2);
			mw_mirth_c99_ZPlusC99_put();
			uint64_t v2 = (0LL /* False */);
			VAL v3 = (lpop(&lbl_avoidZ_hexdigit));
			decref(v3);
			lpush(&lbl_avoidZ_hexdigit, MKU64(v2));
		} break;
		case 9LL: { // BHT
			(void)pop_u64();
			STRLIT("\\t", 2);
			mw_mirth_c99_ZPlusC99_put();
			uint64_t v4 = (0LL /* False */);
			VAL v5 = (lpop(&lbl_avoidZ_hexdigit));
			decref(v5);
			lpush(&lbl_avoidZ_hexdigit, MKU64(v4));
		} break;
		case 10LL: { // BLF
			(void)pop_u64();
			STRLIT("\\n", 2);
			mw_mirth_c99_ZPlusC99_put();
			uint64_t v6 = (0LL /* False */);
			VAL v7 = (lpop(&lbl_avoidZ_hexdigit));
			decref(v7);
			lpush(&lbl_avoidZ_hexdigit, MKU64(v6));
		} break;
		case 13LL: { // BCR
			(void)pop_u64();
			STRLIT("\\r", 2);
			mw_mirth_c99_ZPlusC99_put();
			uint64_t v8 = (0LL /* False */);
			VAL v9 = (lpop(&lbl_avoidZ_hexdigit));
			decref(v9);
			lpush(&lbl_avoidZ_hexdigit, MKU64(v8));
		} break;
		default: {
			VAL v10 = pop_value();
			incref(v10);
			uint64_t v11 = (32LL /* BSPACE */);
			uint64_t v12 = (126LL /* B'~' */);
			push_value(v10);
			push_value(v10);
			push_u64(v11);
			push_u64(v12);
			mw_std_byte_Byte_inZ_range();
			VAL v13 = pop_value();
			if (VBOOL(v13)) {
				VAL v14 = pop_value();
				incref(v14);
				push_value(v14);
				push_value(v14);
				mw_std_byte_Byte_isZ_hexdigit();
				VAL v15 = (lpop(&lbl_avoidZ_hexdigit));
				incref(v15);
				lpush(&lbl_avoidZ_hexdigit, v15);
				if (VBOOL(v15)) {
				} else {
					VAL v16 = pop_value();
					decref(v16);
					uint64_t v17 = (0LL /* False */);
					push_u64(v17);
				}
				VAL v18 = pop_value();
				if (VBOOL(v18)) {
					uint64_t v19 = (0LL /* False */);
					push_u64(v19);
				} else {
					uint64_t v20 = (1LL /* True */);
					push_u64(v20);
				}
			} else {
				uint64_t v21 = (0LL /* False */);
				push_u64(v21);
			}
			VAL v22 = pop_value();
			if (VBOOL(v22)) {
				mw_mirth_c99_ZPlusC99_putZ_byte();
				uint64_t v23 = (0LL /* False */);
				VAL v24 = (lpop(&lbl_avoidZ_hexdigit));
				decref(v24);
				lpush(&lbl_avoidZ_hexdigit, MKU64(v23));
			} else {
				STRLIT("\\x", 2);
				mw_mirth_c99_ZPlusC99_put();
				mw_std_byte_Byte_toZ_hexdigits();
				VAL v25 = pop_value();
				mw_mirth_c99_ZPlusC99_putZ_byte();
				push_value(v25);
				mw_mirth_c99_ZPlusC99_putZ_byte();
				uint64_t v26 = (1LL /* True */);
				VAL v27 = (lpop(&lbl_avoidZ_hexdigit));
				decref(v27);
				lpush(&lbl_avoidZ_hexdigit, MKU64(v26));
			}
		} break;
	}
}
static void mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("VAL", 3);
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			STRLIT("int64_t", 7);
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			STRLIT("uint64_t", 8);
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
			STRLIT("float", 5);
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
			STRLIT("double", 6);
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			STRLIT("bool", 4);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_C99ReprType_mkZ_macro (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("MKVAL", 5);
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			STRLIT("MKI64", 5);
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			STRLIT("MKU64", 5);
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
			STRLIT("MKF32", 5);
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
			STRLIT("MKF64", 5);
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			STRLIT("MKBOOL", 6);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_C99ReprType_popZ_macro (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("pop_value", 9);
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			STRLIT("pop_i64", 7);
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			STRLIT("pop_u64", 7);
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
			STRLIT("pop_f32", 7);
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
			STRLIT("pop_f64", 7);
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			STRLIT("pop_bool", 8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_C99ReprType_pushZ_macro (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("push_value", 10);
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			STRLIT("push_i64", 8);
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			STRLIT("push_u64", 8);
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
			STRLIT("push_f32", 8);
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
			STRLIT("push_f64", 8);
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			STRLIT("push_bool", 9);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang (void) {
	VAL v0 = pop_value();
	lpush(&lbl_localZ_repr, v0);
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v1 = pop_value();
	lpush(&lbl_localZ_name, v1);
	mw_mirth_c99_ZPlusC99_indent();
	VAL v2 = (lpop(&lbl_localZ_repr));
	incref(v2);
	push_value(v2);
	lpush(&lbl_localZ_repr, v2);
	mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL v3 = (lpop(&lbl_localZ_name));
	incref(v3);
	push_value(v3);
	lpush(&lbl_localZ_name, v3);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = ", 3);
	mw_mirth_c99_ZPlusC99_put();
	VAL v4 = (lpop(&lbl_localZ_repr));
	incref(v4);
	push_value(v4);
	lpush(&lbl_localZ_repr, v4);
	mw_mirth_c99_C99ReprType_popZ_macro();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT("();", 3);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
}
static void mw_mirth_c99_ZPlusC99_popZ_localZ_directZBang (void) {
	uint64_t v0 = (0LL /* C99RT_VAL */);
	push_u64(v0);
	mw_mirth_c99_C99ReprType_popZ_toZ_localZ_directZBang();
}
static void mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_c99_ZPlusC99_indent();
	VAL v0 = (lpop(&lbl_localZ_repr));
	push_value(v0);
	mw_mirth_c99_C99ReprType_pushZ_macro();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT("(", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL v1 = (lpop(&lbl_localZ_name));
	push_value(v1);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_ZPlusC99Local_consume (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_localZ_repr));
	decref(v0);
	VAL v1 = (lpop(&lbl_localZ_name));
	push_value(v1);
}
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_localZ_repr));
	push_value(v0);
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			VAL v1 = (lpop(&lbl_localZ_name));
			push_value(v1);
		} break;
		default: {
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			mw_mirth_c99_C99ReprType_mkZ_macro();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("(", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			VAL v2 = (lpop(&lbl_localZ_name));
			push_value(v2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(")", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
	}
}
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_I64 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_localZ_name));
	VAL v1 = (lpop(&lbl_localZ_repr));
	push_value(v0);
	push_value(v1);
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("VI64(", 5);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(")", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("((int64_t)(", 11);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("))", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("((int64_t)(", 11);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("))", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		default: {
			STRLIT("attempted to consume non-I64 as I64", 35);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_U64 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_localZ_name));
	VAL v1 = (lpop(&lbl_localZ_repr));
	push_value(v0);
	push_value(v1);
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("VU64(", 5);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(")", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("((uint64_t)(", 12);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("))", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("((uint64_t)(", 12);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("))", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		default: {
			STRLIT("attempted to consume non-U64 as U64", 35);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_BOOL (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_localZ_name));
	VAL v1 = (lpop(&lbl_localZ_repr));
	push_value(v0);
	push_value(v1);
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("VBOOL(", 6);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(")", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("((_Bool)(", 9);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("))", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("((_Bool)(", 9);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT("))", 2);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		default: {
			STRLIT("attempted to consume non-U64 as U64", 35);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_F32 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_localZ_name));
	VAL v1 = (lpop(&lbl_localZ_repr));
	push_value(v0);
	push_value(v1);
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("VF32(", 5);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(")", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
		} break;
		default: {
			STRLIT("attempted to consume non-F32 as F32", 35);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_F64 (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Local
			mtp_mirth_c99_ZPlusC99Local_ZPlusC99Local();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_localZ_name));
	VAL v1 = (lpop(&lbl_localZ_repr));
	push_value(v0);
	push_value(v1);
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			STRLIT("VF64(", 5);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_std_str_ZPlusStr_pushZ_strZBang();
			STRLIT(")", 1);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mtp_std_str_ZPlusStr_ZPlusStr();
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
		} break;
		default: {
			STRLIT("attempted to consume non-F64 as F64", 35);
			mp_primZ_panic();
		} break;
	}
}
static void mw_mirth_c99_ZPlusC99Local_consumeZ_as (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL();
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_I64();
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_U64();
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_BOOL();
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_F32();
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_F64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99Local_dropZ_localZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			VAL r0 = pop_resource();
			lpush(&lbl_ZPlusx, r0);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r1 = pop_resource();
			mw_mirth_c99_ZPlusC99_indent();
			STRLIT("decref(", 7);
			mw_mirth_c99_ZPlusC99_put();
			VAL v2 = (lpop(&lbl_ZPlusx));
			push_resource(v2);
			mw_mirth_c99_ZPlusC99Local_consume();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(");", 2);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
			push_resource(r1);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consume();
			VAL v3 = pop_value();
			decref(v3);
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consume();
			VAL v4 = pop_value();
			decref(v4);
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consume();
			VAL v5 = pop_value();
			decref(v5);
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consume();
			VAL v6 = pop_value();
			decref(v6);
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Local_consume();
			VAL v7 = pop_value();
			decref(v7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99Local_dupZ_localZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r0 = pop_resource();
	lpush(&lbl_ZPlusx, r0);
	switch (get_top_data_tag()) {
		case 0LL: { // C99RT_VAL
			(void)pop_u64();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r1 = pop_resource();
			mw_mirth_c99_ZPlusC99_indent();
			STRLIT("incref(", 7);
			mw_mirth_c99_ZPlusC99_put();
			VAL v2 = (lpop(&lbl_ZPlusx));
			push_resource(v2);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL r3 = pop_resource();
			lpush(&lbl_ZPlusx, r3);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(");", 2);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
			push_resource(r1);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
		} break;
		case 1LL: { // C99RT_I64
			(void)pop_u64();
		} break;
		case 2LL: { // C99RT_U64
			(void)pop_u64();
		} break;
		case 3LL: { // C99RT_F32
			(void)pop_u64();
		} break;
		case 4LL: { // C99RT_F64
			(void)pop_u64();
		} break;
		case 5LL: { // C99RT_BOOL
			(void)pop_u64();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v4 = (lpop(&lbl_ZPlusx));
	push_resource(v4);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v5 = pop_value();
	lpush(&lbl_localZ_repr, v5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v6 = pop_value();
	lpush(&lbl_localZ_name, v6);
	mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
}
static void mw_mirth_c99_ZPlusC99LocalResource_consume (void) {
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource();
	VAL v0 = (lpop(&lbl_localZ_resourceZ_name));
	push_value(v0);
}
static void mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang (void) {
	mw_mirth_c99_ZPlusC99_freshZ_resourceZ_nameZBang();
	VAL v0 = pop_value();
	lpush(&lbl_localZ_resourceZ_name, v0);
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("VAL ", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL v1 = (lpop(&lbl_localZ_resourceZ_name));
	incref(v1);
	push_value(v1);
	lpush(&lbl_localZ_resourceZ_name, v1);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = pop_resource();", 18);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource();
}
static void mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang (void) {
	mtp_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("push_resource(", 14);
	mw_mirth_c99_ZPlusC99_put();
	VAL v0 = (lpop(&lbl_localZ_resourceZ_name));
	push_value(v0);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SCNil
			(void)pop_resource();
			VAL v0 = (MKU64(0LL /* +C99LocalNone */));
			VAL v1 = (MKU64(0LL /* +SCNil */));
			push_resource(v0);
			push_resource(v1);
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
			mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome();
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			push_resource(r2);
			push_resource(r3);
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
			VAL r4 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk();
			push_resource(r4);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
			VAL r5 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk();
			push_resource(r5);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
			VAL r6 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk();
			push_resource(r6);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SCNil
			(void)pop_resource();
			VAL v0 = (MKU64(0LL /* +C99LocalResourceNone */));
			VAL v1 = (MKU64(0LL /* +SCNil */));
			push_resource(v0);
			push_resource(v1);
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
			mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome();
			VAL r2 = pop_resource();
			VAL r3 = pop_resource();
			push_resource(r2);
			push_resource(r3);
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
			VAL r4 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk();
			push_resource(r4);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
			VAL r5 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk();
			push_resource(r5);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
			VAL r6 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk();
			push_resource(r6);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SCNil
			(void)pop_resource();
			VAL v0 = (MKU64(0LL /* +C99LocalNone */));
			VAL v1 = (MKU64(0LL /* +SCNil */));
			push_resource(v0);
			push_resource(v1);
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
			VAL r2 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk();
			push_resource(r2);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk();
			push_resource(r3);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
			VAL v4 = pop_value();
			VAL r5 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk();
			push_resource(r5);
			push_value(v4);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			incref(v7);
			incref(v6);
			push_value(v7);
			push_value(v6);
			push_value(v7);
			push_value(v6);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v8 = pop_value();
			if (VBOOL(v8)) {
				VAL v9 = pop_value();
				decref(v9);
				mtw_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome();
				VAL r10 = pop_resource();
				VAL r11 = pop_resource();
				push_resource(r10);
				push_resource(r11);
			} else {
				VAL v12 = pop_value();
				VAL r13 = pop_resource();
				mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk();
				push_resource(r13);
				push_value(v12);
				mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SCNil
			(void)pop_resource();
			VAL v0 = (MKU64(0LL /* +C99LocalResourceNone */));
			VAL v1 = (MKU64(0LL /* +SCNil */));
			push_resource(v0);
			push_resource(v1);
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
			VAL r2 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk();
			push_resource(r2);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk();
			push_resource(r3);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
			VAL v4 = pop_value();
			VAL r5 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk();
			push_resource(r5);
			push_value(v4);
			mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
			VAL v6 = pop_value();
			VAL v7 = pop_value();
			incref(v7);
			incref(v6);
			push_value(v7);
			push_value(v6);
			push_value(v7);
			push_value(v6);
			mw_mirth_label_Label_ZEqualZEqual();
			VAL v8 = pop_value();
			if (VBOOL(v8)) {
				VAL v9 = pop_value();
				decref(v9);
				mtw_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome();
				VAL r10 = pop_resource();
				VAL r11 = pop_resource();
				push_resource(r10);
				push_resource(r11);
			} else {
				VAL v12 = pop_value();
				VAL r13 = pop_resource();
				mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk();
				push_resource(r13);
				push_value(v12);
				mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
			}
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +SCNil
			(void)pop_resource();
		} break;
		case 1LL: { // +SCCons
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
			VAL r0 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang();
			push_resource(r0);
			mw_mirth_c99_ZPlusC99Local_pushZ_localZ_directZBang();
		} break;
		case 2LL: { // +SCWith
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
			VAL r1 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang();
			push_resource(r1);
			mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZ_directZBang();
		} break;
		case 3LL: { // +SCConsLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCConsLabel();
			VAL r2 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang();
			push_resource(r2);
			mw_mirth_c99_pushZ_localZ_labelZ_directZBang();
		} break;
		case 4LL: { // +SCWithLabel
			mtp_mirth_c99_ZPlusC99StackCache_ZPlusSCWithLabel();
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang();
			push_resource(r3);
			mw_mirth_c99_pushZ_localZ_resourceZ_labelZ_directZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99_startZ_branchZBang (void) {
	VAL r0 = pop_resource();
	VAL v1 = (MKU64(0LL /* +SCNil */));
	lpush(&lbl_ZPluscore, r0);
	lpush(&lbl_ZPlusstack, v1);
	mtw_mirth_c99_ZPlusC99Branch_ZPlusC99Branch();
}
static void mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang (void) {
	switch (get_top_resource_data_tag()) {
		case 0LL: { // +C99Branch
			mtp_mirth_c99_ZPlusC99Branch_ZPlusC99Branch();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_ZPluscore));
	VAL v1 = (lpop(&lbl_ZPlusstack));
	push_resource(v0);
	push_resource(v1);
	mw_mirth_c99_ZPlusC99StackCache_flushZ_allZBang();
}
static void mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZAsk();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	push_resource(r1);
	push_resource(r2);
	switch (get_top_resource_data_tag()) {
		case 1LL: { // +C99LocalSome
			mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome();
		} break;
		case 0LL: { // +C99LocalNone
			(void)pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99_popZ_localZ_directZBang();
			VAL r4 = pop_resource();
			VAL r5 = pop_resource();
			push_resource(r4);
			push_resource(r5);
			push_resource(r3);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			VAL r6 = pop_resource();
			VAL r7 = pop_resource();
			push_resource(r6);
			push_resource(r7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_labelZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_labelZAsk();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	push_resource(r1);
	push_resource(r2);
	switch (get_top_resource_data_tag()) {
		case 1LL: { // +C99LocalSome
			mtp_mirth_c99_ZPlusC99LocalZAsk_ZPlusC99LocalSome();
			VAL v3 = pop_value();
			decref(v3);
		} break;
		case 0LL: { // +C99LocalNone
			(void)pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r4 = pop_resource();
			mw_mirth_c99_popZ_localZ_labelZ_directZBang();
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			push_resource(r5);
			push_resource(r6);
			push_resource(r4);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			push_resource(r7);
			push_resource(r8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZAsk();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	push_resource(r1);
	push_resource(r2);
	switch (get_top_resource_data_tag()) {
		case 1LL: { // +C99LocalResourceSome
			mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome();
		} break;
		case 0LL: { // +C99LocalResourceNone
			(void)pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99_popZ_localZ_resourceZ_directZBang();
			VAL r4 = pop_resource();
			VAL r5 = pop_resource();
			push_resource(r4);
			push_resource(r5);
			push_resource(r3);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			VAL r6 = pop_resource();
			VAL r7 = pop_resource();
			push_resource(r6);
			push_resource(r7);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZ_labelZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_c99_ZPlusC99StackCache_popZ_localZ_resourceZ_labelZAsk();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r1 = pop_resource();
	VAL r2 = pop_resource();
	push_resource(r1);
	push_resource(r2);
	switch (get_top_resource_data_tag()) {
		case 1LL: { // +C99LocalResourceSome
			mtp_mirth_c99_ZPlusC99LocalResourceZAsk_ZPlusC99LocalResourceSome();
			VAL v3 = pop_value();
			decref(v3);
		} break;
		case 0LL: { // +C99LocalResourceNone
			(void)pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r4 = pop_resource();
			mw_mirth_c99_popZ_localZ_resourceZ_labelZ_directZBang();
			VAL r5 = pop_resource();
			VAL r6 = pop_resource();
			push_resource(r5);
			push_resource(r6);
			push_resource(r4);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			VAL r7 = pop_resource();
			VAL r8 = pop_resource();
			push_resource(r7);
			push_resource(r8);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_ZPlusC99Local_pushZ_localZBang (void) {
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	push_resource(r0);
	push_resource(r1);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	VAL r4 = pop_resource();
	push_resource(r3);
	push_resource(r4);
	mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCCons();
	push_resource(r2);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang (void) {
	VAL r0 = pop_resource();
	VAL r1 = pop_resource();
	push_resource(r0);
	push_resource(r1);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r2 = pop_resource();
	VAL r3 = pop_resource();
	VAL r4 = pop_resource();
	push_resource(r3);
	push_resource(r4);
	mtw_mirth_c99_ZPlusC99StackCache_ZPlusSCWith();
	push_resource(r2);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[2];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_C99BinOp_Mk (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	lpush(&lbl_outZ_type, v0);
	lpush(&lbl_arg2Z_type, v1);
	lpush(&lbl_arg1Z_type, v2);
	lpush(&lbl_precedence, v3);
	lpush(&lbl_operator, v4);
	mtw_mirth_c99_C99BinOp_C99BinOp();
}
static void mw_mirth_c99_c99Z_primZ_binopZAsk (void) {
	switch (get_top_data_tag()) {
		case 18LL: { // PRIM_INT_MUL
			(void)pop_u64();
			STRLIT("*", 1);
			int64_t v0 = (3LL);
			uint64_t v1 = (1LL /* C99RT_I64 */);
			uint64_t v2 = (1LL /* C99RT_I64 */);
			uint64_t v3 = (1LL /* C99RT_I64 */);
			push_i64(v0);
			push_u64(v1);
			push_u64(v2);
			push_u64(v3);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 15LL: { // PRIM_INT_LT
			(void)pop_u64();
			STRLIT("<", 1);
			int64_t v4 = (6LL);
			uint64_t v5 = (1LL /* C99RT_I64 */);
			uint64_t v6 = (1LL /* C99RT_I64 */);
			uint64_t v7 = (5LL /* C99RT_BOOL */);
			push_i64(v4);
			push_u64(v5);
			push_u64(v6);
			push_u64(v7);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 14LL: { // PRIM_INT_EQ
			(void)pop_u64();
			STRLIT("==", 2);
			int64_t v8 = (7LL);
			uint64_t v9 = (1LL /* C99RT_I64 */);
			uint64_t v10 = (1LL /* C99RT_I64 */);
			uint64_t v11 = (5LL /* C99RT_BOOL */);
			push_i64(v8);
			push_u64(v9);
			push_u64(v10);
			push_u64(v11);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 21LL: { // PRIM_INT_AND
			(void)pop_u64();
			STRLIT("&", 1);
			int64_t v12 = (8LL);
			uint64_t v13 = (2LL /* C99RT_U64 */);
			uint64_t v14 = (2LL /* C99RT_U64 */);
			uint64_t v15 = (2LL /* C99RT_U64 */);
			push_i64(v12);
			push_u64(v13);
			push_u64(v14);
			push_u64(v15);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 23LL: { // PRIM_INT_XOR
			(void)pop_u64();
			STRLIT("^", 1);
			int64_t v16 = (9LL);
			uint64_t v17 = (2LL /* C99RT_U64 */);
			uint64_t v18 = (2LL /* C99RT_U64 */);
			uint64_t v19 = (2LL /* C99RT_U64 */);
			push_i64(v16);
			push_u64(v17);
			push_u64(v18);
			push_u64(v19);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 22LL: { // PRIM_INT_OR
			(void)pop_u64();
			STRLIT("|", 1);
			int64_t v20 = (10LL);
			uint64_t v21 = (2LL /* C99RT_U64 */);
			uint64_t v22 = (2LL /* C99RT_U64 */);
			uint64_t v23 = (2LL /* C99RT_U64 */);
			push_i64(v20);
			push_u64(v21);
			push_u64(v22);
			push_u64(v23);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 31LL: { // PRIM_F32_ADD
			(void)pop_u64();
			STRLIT("+", 1);
			int64_t v24 = (4LL);
			uint64_t v25 = (3LL /* C99RT_F32 */);
			uint64_t v26 = (3LL /* C99RT_F32 */);
			uint64_t v27 = (3LL /* C99RT_F32 */);
			push_i64(v24);
			push_u64(v25);
			push_u64(v26);
			push_u64(v27);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 32LL: { // PRIM_F32_SUB
			(void)pop_u64();
			STRLIT("-", 1);
			int64_t v28 = (4LL);
			uint64_t v29 = (3LL /* C99RT_F32 */);
			uint64_t v30 = (3LL /* C99RT_F32 */);
			uint64_t v31 = (3LL /* C99RT_F32 */);
			push_i64(v28);
			push_u64(v29);
			push_u64(v30);
			push_u64(v31);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 33LL: { // PRIM_F32_MUL
			(void)pop_u64();
			STRLIT("*", 1);
			int64_t v32 = (3LL);
			uint64_t v33 = (3LL /* C99RT_F32 */);
			uint64_t v34 = (3LL /* C99RT_F32 */);
			uint64_t v35 = (3LL /* C99RT_F32 */);
			push_i64(v32);
			push_u64(v33);
			push_u64(v34);
			push_u64(v35);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 34LL: { // PRIM_F32_DIV
			(void)pop_u64();
			STRLIT("/", 1);
			int64_t v36 = (3LL);
			uint64_t v37 = (3LL /* C99RT_F32 */);
			uint64_t v38 = (3LL /* C99RT_F32 */);
			uint64_t v39 = (3LL /* C99RT_F32 */);
			push_i64(v36);
			push_u64(v37);
			push_u64(v38);
			push_u64(v39);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 30LL: { // PRIM_F32_LT
			(void)pop_u64();
			STRLIT("<", 1);
			int64_t v40 = (6LL);
			uint64_t v41 = (3LL /* C99RT_F32 */);
			uint64_t v42 = (3LL /* C99RT_F32 */);
			uint64_t v43 = (5LL /* C99RT_BOOL */);
			push_i64(v40);
			push_u64(v41);
			push_u64(v42);
			push_u64(v43);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 29LL: { // PRIM_F32_EQ
			(void)pop_u64();
			STRLIT("==", 2);
			int64_t v44 = (7LL);
			uint64_t v45 = (3LL /* C99RT_F32 */);
			uint64_t v46 = (3LL /* C99RT_F32 */);
			uint64_t v47 = (5LL /* C99RT_BOOL */);
			push_i64(v44);
			push_u64(v45);
			push_u64(v46);
			push_u64(v47);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 40LL: { // PRIM_F64_ADD
			(void)pop_u64();
			STRLIT("+", 1);
			int64_t v48 = (4LL);
			uint64_t v49 = (4LL /* C99RT_F64 */);
			uint64_t v50 = (4LL /* C99RT_F64 */);
			uint64_t v51 = (4LL /* C99RT_F64 */);
			push_i64(v48);
			push_u64(v49);
			push_u64(v50);
			push_u64(v51);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 41LL: { // PRIM_F64_SUB
			(void)pop_u64();
			STRLIT("-", 1);
			int64_t v52 = (4LL);
			uint64_t v53 = (4LL /* C99RT_F64 */);
			uint64_t v54 = (4LL /* C99RT_F64 */);
			uint64_t v55 = (4LL /* C99RT_F64 */);
			push_i64(v52);
			push_u64(v53);
			push_u64(v54);
			push_u64(v55);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 42LL: { // PRIM_F64_MUL
			(void)pop_u64();
			STRLIT("*", 1);
			int64_t v56 = (3LL);
			uint64_t v57 = (4LL /* C99RT_F64 */);
			uint64_t v58 = (4LL /* C99RT_F64 */);
			uint64_t v59 = (4LL /* C99RT_F64 */);
			push_i64(v56);
			push_u64(v57);
			push_u64(v58);
			push_u64(v59);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 43LL: { // PRIM_F64_DIV
			(void)pop_u64();
			STRLIT("/", 1);
			int64_t v60 = (3LL);
			uint64_t v61 = (4LL /* C99RT_F64 */);
			uint64_t v62 = (4LL /* C99RT_F64 */);
			uint64_t v63 = (4LL /* C99RT_F64 */);
			push_i64(v60);
			push_u64(v61);
			push_u64(v62);
			push_u64(v63);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 39LL: { // PRIM_F64_LT
			(void)pop_u64();
			STRLIT("<", 1);
			int64_t v64 = (6LL);
			uint64_t v65 = (4LL /* C99RT_F64 */);
			uint64_t v66 = (4LL /* C99RT_F64 */);
			uint64_t v67 = (5LL /* C99RT_BOOL */);
			push_i64(v64);
			push_u64(v65);
			push_u64(v66);
			push_u64(v67);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 38LL: { // PRIM_F64_EQ
			(void)pop_u64();
			STRLIT("==", 2);
			int64_t v68 = (7LL);
			uint64_t v69 = (4LL /* C99RT_F64 */);
			uint64_t v70 = (4LL /* C99RT_F64 */);
			uint64_t v71 = (5LL /* C99RT_BOOL */);
			push_i64(v68);
			push_u64(v69);
			push_u64(v70);
			push_u64(v71);
			mw_mirth_c99_C99BinOp_Mk();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		default: {
			VAL v72 = pop_value();
			decref(v72);
			uint64_t v73 = (0LL /* None */);
			push_u64(v73);
		} break;
	}
}
static void mw_mirth_c99_c99Z_primZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // PRIM_CORE_ID
			(void)pop_u64();
			VAL v0 = pop_value();
			decref(v0);
		} break;
		case 2LL: { // PRIM_CORE_DROP
			(void)pop_u64();
			VAL v1 = pop_value();
			decref(v1);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
			mw_mirth_c99_ZPlusC99Local_dropZ_localZBang();
		} break;
		case 1LL: { // PRIM_CORE_DUP
			(void)pop_u64();
			VAL v2 = pop_value();
			decref(v2);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
			mw_mirth_c99_ZPlusC99Local_dupZ_localZBang();
			VAL r3 = pop_resource();
			mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
			push_resource(r3);
			mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
		} break;
		case 3LL: { // PRIM_CORE_SWAP
			(void)pop_u64();
			VAL v4 = pop_value();
			decref(v4);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
			VAL r5 = pop_resource();
			lpush(&lbl_ZPlusb, r5);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
			VAL r6 = pop_resource();
			VAL v7 = (lpop(&lbl_ZPlusb));
			lpush(&lbl_ZPlusa, r6);
			push_resource(v7);
			mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
			VAL v8 = (lpop(&lbl_ZPlusa));
			push_resource(v8);
			mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
		} break;
		case 12LL: { // PRIM_CORE_RSWAP
			(void)pop_u64();
			VAL v9 = pop_value();
			decref(v9);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZBang();
			VAL r10 = pop_resource();
			lpush(&lbl_ZPlusb, r10);
			mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZBang();
			VAL r11 = pop_resource();
			VAL v12 = (lpop(&lbl_ZPlusb));
			lpush(&lbl_ZPlusa, r11);
			push_resource(v12);
			mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang();
			VAL v13 = (lpop(&lbl_ZPlusa));
			push_resource(v13);
			mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang();
		} break;
		case 4LL: { // PRIM_CORE_DIP
			(void)pop_u64();
			VAL v14 = pop_value();
			incref(v14);
			push_value(v14);
			push_value(v14);
			mw_std_list_List_1_ZDivL1();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v15 = pop_value();
					VAL v16 = pop_value();
					decref(v16);
					push_value(v15);
					mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
					VAL r17 = pop_resource();
					lpush(&lbl_ZPlusdipped, r17);
					mw_mirth_c99_c99Z_argZ_runZBang();
					VAL v18 = (lpop(&lbl_ZPlusdipped));
					push_resource(v18);
					mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v19 = (4LL /* PRIM_CORE_DIP */);
					push_u64(v19);
					mw_mirth_c99_c99Z_primZ_defaultZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 13LL: { // PRIM_CORE_RDIP
			(void)pop_u64();
			VAL v20 = pop_value();
			incref(v20);
			push_value(v20);
			push_value(v20);
			mw_std_list_List_1_ZDivL1();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v21 = pop_value();
					VAL v22 = pop_value();
					decref(v22);
					push_value(v21);
					mw_mirth_c99_ZPlusC99Branch_popZ_localZ_resourceZBang();
					VAL r23 = pop_resource();
					lpush(&lbl_ZPlusdipped, r23);
					mw_mirth_c99_c99Z_argZ_runZBang();
					VAL v24 = (lpop(&lbl_ZPlusdipped));
					push_resource(v24);
					mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v25 = (13LL /* PRIM_CORE_RDIP */);
					push_u64(v25);
					mw_mirth_c99_c99Z_primZ_defaultZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 5LL: { // PRIM_CORE_IF
			(void)pop_u64();
			VAL v26 = pop_value();
			incref(v26);
			push_value(v26);
			push_value(v26);
			mw_std_list_List_1_ZDivL2();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v27 = pop_value();
					VAL v28 = pop_value();
					decref(v28);
					push_value(v27);
					mp_primZ_packZ_uncons();
					VAL v29 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v30 = pop_value();
					VAL v31 = pop_value();
					decref(v31);
					push_value(v30);
					push_value(v29);
					mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
					VAL r32 = pop_resource();
					lpush(&lbl_ZPluscond, r32);
					mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("if (", 4);
					mw_mirth_c99_ZPlusC99_put();
					VAL v33 = (lpop(&lbl_ZPluscond));
					push_resource(v33);
					mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_BOOL();
					mw_mirth_c99_ZPlusC99_put();
					STRLIT(") {", 3);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r34 = pop_resource();
					int64_t v35 = (1LL);
					push_i64(v35);
					mp_primZ_intZ_add();
					push_resource(r34);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_startZ_branchZBang();
					VAL v36 = pop_value();
					VAL v37 = pop_value();
					push_value(v36);
					push_value(v37);
					mw_mirth_c99_c99Z_argZ_runZBang();
					mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r38 = pop_resource();
					int64_t v39 = (1LL);
					push_i64(v39);
					mp_primZ_intZ_sub();
					mw_std_prim_Int_ZToNat();
					push_resource(r38);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("} else {", 8);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r40 = pop_resource();
					int64_t v41 = (1LL);
					push_i64(v41);
					mp_primZ_intZ_add();
					push_resource(r40);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_startZ_branchZBang();
					mw_mirth_c99_c99Z_argZ_runZBang();
					mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r42 = pop_resource();
					int64_t v43 = (1LL);
					push_i64(v43);
					mp_primZ_intZ_sub();
					mw_std_prim_Int_ZToNat();
					push_resource(r42);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("}", 1);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_startZ_branchZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v44 = (5LL /* PRIM_CORE_IF */);
					push_u64(v44);
					mw_mirth_c99_c99Z_primZ_defaultZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		case 6LL: { // PRIM_CORE_WHILE
			(void)pop_u64();
			VAL v45 = pop_value();
			incref(v45);
			push_value(v45);
			push_value(v45);
			mw_std_list_List_1_ZDivL2();
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v46 = pop_value();
					VAL v47 = pop_value();
					decref(v47);
					push_value(v46);
					mp_primZ_packZ_uncons();
					VAL v48 = pop_value();
					mp_primZ_packZ_uncons();
					VAL v49 = pop_value();
					VAL v50 = pop_value();
					decref(v50);
					push_value(v49);
					push_value(v48);
					mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("while(1) {", 10);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r51 = pop_resource();
					int64_t v52 = (1LL);
					push_i64(v52);
					mp_primZ_intZ_add();
					push_resource(r51);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_startZ_branchZBang();
					VAL v53 = pop_value();
					VAL v54 = pop_value();
					push_value(v53);
					push_value(v54);
					mw_mirth_c99_c99Z_argZ_runZBang();
					mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
					VAL r55 = pop_resource();
					lpush(&lbl_ZPluscond, r55);
					mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("if (!", 5);
					mw_mirth_c99_ZPlusC99_put();
					VAL v56 = (lpop(&lbl_ZPluscond));
					push_resource(v56);
					mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_BOOL();
					mw_mirth_c99_ZPlusC99_put();
					STRLIT(") break;", 8);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_startZ_branchZBang();
					mw_mirth_c99_c99Z_argZ_runZBang();
					mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r57 = pop_resource();
					int64_t v58 = (1LL);
					push_i64(v58);
					mp_primZ_intZ_sub();
					mw_std_prim_Int_ZToNat();
					push_resource(r57);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("}", 1);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_startZ_branchZBang();
				} break;
				case 0LL: { // None
					(void)pop_u64();
					uint64_t v59 = (6LL /* PRIM_CORE_WHILE */);
					push_u64(v59);
					mw_mirth_c99_c99Z_primZ_defaultZBang();
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
		} break;
		default: {
			VAL v60 = pop_value();
			VAL v61 = pop_value();
			incref(v61);
			push_value(v61);
			push_value(v60);
			push_value(v61);
			mw_std_list_List_1_emptyZAsk();
			VAL v62 = pop_value();
			if (VBOOL(v62)) {
				VAL v63 = pop_value();
				incref(v63);
				push_value(v63);
				push_value(v63);
				mw_mirth_c99_c99Z_primZ_binopZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
						VAL v64 = pop_value();
						VAL v65 = pop_value();
						decref(v65);
						VAL v66 = pop_value();
						decref(v66);
						push_value(v64);
						mw_mirth_c99_c99Z_binopZBang();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						mw_mirth_c99_c99Z_primZ_defaultZBang();
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
			} else {
				mw_mirth_c99_c99Z_primZ_defaultZBang();
			}
		} break;
	}
}
static void mw_mirth_c99_c99Z_binopZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // C99BinOp
			mtp_mirth_c99_C99BinOp_C99BinOp();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
	VAL r0 = pop_resource();
	lpush(&lbl_ZPlusarg2, r0);
	mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
	VAL r1 = pop_resource();
	VAL v2 = (lpop(&lbl_outZ_type));
	lpush(&lbl_ZPlusarg1, r1);
	push_value(v2);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r3 = pop_resource();
	VAL v4 = pop_value();
	lpush(&lbl_localZ_repr, v4);
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v5 = pop_value();
	VAL r6 = pop_resource();
	lpush(&lbl_localZ_name, v5);
	mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
	push_resource(r6);
	mw_mirth_c99_ZPlusC99_indent();
	VAL r7 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r7);
	mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL r8 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r8);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = (", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r9 = pop_resource();
	VAL r10 = pop_resource();
	VAL v11 = (lpop(&lbl_ZPlusarg1));
	VAL v12 = (lpop(&lbl_arg1Z_type));
	push_resource(r9);
	push_resource(v11);
	push_value(v12);
	mw_mirth_c99_ZPlusC99Local_consumeZ_as();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL v13 = (lpop(&lbl_operator));
	push_value(v13);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL v14 = (lpop(&lbl_ZPlusarg2));
	VAL v15 = (lpop(&lbl_arg2Z_type));
	push_resource(v14);
	push_value(v15);
	mw_mirth_c99_ZPlusC99Local_consumeZ_as();
	mw_mirth_c99_ZPlusC99_put();
	VAL r16 = pop_resource();
	push_resource(r10);
	push_resource(r16);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r3);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r17 = pop_resource();
	VAL r18 = pop_resource();
	push_resource(r17);
	push_resource(r18);
	mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
	VAL v19 = (lpop(&lbl_precedence));
	decref(v19);
}
static void mw_mirth_c99_c99Z_primZ_defaultZBang (void) {
	mw_mirth_prim_Prim_cname();
	mw_mirth_c99_c99Z_callZBang();
}
static void mw_mirth_c99_c99Z_argsZ_pushZBang (void) {
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	while(1) {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v3 = pop_value();
		if (!VBOOL(v3)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v4 = pop_value();
		VAL v5 = pop_value();
		push_value(v4);
		mw_mirth_c99_c99Z_argZ_pushZBang();
		push_value(v5);
		mw_std_list_List_1_uncons();
		VAL v6 = pop_value();
		VAL v7 = pop_value();
		push_value(v6);
		push_value(v7);
	}
	VAL v8 = pop_value();
	decref(v8);
	VAL v9 = pop_value();
	decref(v9);
}
static void mw_mirth_c99_c99Z_argZ_pushZBang (void) {
	mw_mirth_c99_c99Z_blockZ_pushZBang();
}
static void mw_mirth_c99_c99Z_argZ_runZBang (void) {
	mw_mirth_c99_c99Z_blockZ_runZBang();
}
static void mw_mirth_c99_c99Z_blockZ_runZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_mirth_arrow_Block_arrow();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_c99Z_arrowZBang();
}
static void mw_mirth_c99_ZPlusC99_varZ_put (void) {
	STRLIT("var_", 4);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_var_Var_name();
	mw_mirth_name_Name_mangled();
	mw_mirth_c99_ZPlusC99_put();
}
static void mw_mirth_c99_c99Z_packZ_closureZ_varsZBang (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		incref(v5);
		push_value(v5);
		mw_mirth_var_Var_isZ_physicalZAsk();
		VAL v8 = pop_value();
		push_value(v5);
		if (VBOOL(v8)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		}
		push_resource(r7);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	push_value(v15);
	push_value(v16);
	while(1) {
		VAL v17 = pop_value();
		incref(v17);
		push_value(v17);
		push_value(v17);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v18 = pop_value();
		if (!VBOOL(v18)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		mw_mirth_c99_c99Z_varZ_pushZBang();
		uint64_t v21 = (0LL /* Nil */);
		uint64_t v22 = (48LL /* PRIM_PACK_CONS */);
		push_u64(v21);
		push_u64(v22);
		mw_mirth_c99_c99Z_primZBang();
		push_value(v20);
		mw_std_list_List_1_uncons();
		VAL v23 = pop_value();
		VAL v24 = pop_value();
		push_value(v23);
		push_value(v24);
	}
	VAL v25 = pop_value();
	decref(v25);
	VAL v26 = pop_value();
	decref(v26);
}
static void mw_mirth_c99_c99Z_popZ_toZ_varZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_popZ_localZBang();
	mw_mirth_c99_ZPlusC99Local_consumeZ_asZ_VAL();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r2 = pop_resource();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("VAL ", 4);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_varZ_put();
	STRLIT(" = ", 3);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(";", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r2);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
}
static void mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		incref(v5);
		push_value(v5);
		mw_mirth_var_Var_isZ_physicalZAsk();
		VAL v8 = pop_value();
		push_value(v5);
		if (VBOOL(v8)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		}
		push_resource(r7);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v15 = pop_value();
	incref(v15);
	push_value(v15);
	push_value(v15);
	mw_std_list_List_1_emptyZAsk();
	VAL v16 = pop_value();
	if (VBOOL(v16)) {
		VAL v17 = pop_value();
		decref(v17);
	} else {
		mw_std_list_List_1_reverse();
		mw_std_list_List_1_uncons();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		push_value(v19);
		while(1) {
			VAL v20 = pop_value();
			incref(v20);
			push_value(v20);
			push_value(v20);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v21 = pop_value();
			if (!VBOOL(v21)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			uint64_t v24 = (0LL /* Nil */);
			uint64_t v25 = (49LL /* PRIM_PACK_UNCONS */);
			push_value(v22);
			push_u64(v24);
			push_u64(v25);
			mw_mirth_c99_c99Z_primZBang();
			mw_mirth_c99_c99Z_popZ_toZ_varZBang();
			push_value(v23);
			mw_std_list_List_1_uncons();
			VAL v26 = pop_value();
			VAL v27 = pop_value();
			push_value(v26);
			push_value(v27);
		}
		VAL v28 = pop_value();
		decref(v28);
		VAL v29 = pop_value();
		decref(v29);
		uint64_t v30 = (0LL /* Nil */);
		uint64_t v31 = (2LL /* PRIM_CORE_DROP */);
		push_u64(v30);
		push_u64(v31);
		mw_mirth_c99_c99Z_primZBang();
	}
}
static void mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang (void) {
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	push_value(v1);
	push_value(v2);
	while(1) {
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v4 = pop_value();
		if (!VBOOL(v4)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		VAL r7 = pop_resource();
		incref(v5);
		push_value(v5);
		mw_mirth_var_Var_isZ_physicalZAsk();
		VAL v8 = pop_value();
		push_value(v5);
		if (VBOOL(v8)) {
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v9 = pop_value();
			decref(v9);
			uint64_t v10 = (0LL /* None */);
			push_u64(v10);
		}
		push_resource(r7);
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
			} break;
			case 0LL: { // None
				(void)pop_u64();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v6);
		mw_std_list_List_1_uncons();
		VAL v11 = pop_value();
		VAL v12 = pop_value();
		push_value(v11);
		push_value(v12);
	}
	VAL v13 = pop_value();
	decref(v13);
	VAL v14 = pop_value();
	decref(v14);
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v15 = pop_value();
	VAL v16 = pop_value();
	push_value(v15);
	push_value(v16);
	while(1) {
		VAL v17 = pop_value();
		incref(v17);
		push_value(v17);
		push_value(v17);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v18 = pop_value();
		if (!VBOOL(v18)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v19 = pop_value();
		VAL v20 = pop_value();
		push_value(v19);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r21 = pop_resource();
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("decref(", 7);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_varZ_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		push_resource(r21);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[1];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		push_value(v20);
		mw_std_list_List_1_uncons();
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		push_value(v22);
		push_value(v23);
	}
	VAL v24 = pop_value();
	decref(v24);
	VAL v25 = pop_value();
	decref(v25);
}
static void mw_mirth_c99_c99Z_blockZ_pushZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r2 = pop_resource();
	mw_mirth_arrow_Block_toZ_runZ_var();
	push_resource(r2);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v3 = pop_value();
			VAL v4 = pop_value();
			decref(v4);
			push_value(v3);
			mw_mirth_c99_c99Z_varZ_pushZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang();
			uint64_t v5 = (0LL /* C99RT_VAL */);
			push_u64(v5);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r6 = pop_resource();
			VAL v7 = pop_value();
			lpush(&lbl_localZ_repr, v7);
			mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
			VAL v8 = pop_value();
			VAL r9 = pop_resource();
			lpush(&lbl_localZ_name, v8);
			mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
			push_resource(r9);
			mw_mirth_c99_ZPlusC99_indent();
			VAL r10 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			push_resource(r10);
			mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(" ", 1);
			mw_mirth_c99_ZPlusC99_put();
			VAL r11 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			push_resource(r11);
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(" = (", 4);
			mw_mirth_c99_ZPlusC99_put();
			VAL r12 = pop_resource();
			VAL r13 = pop_resource();
			push_resource(r12);
			STRLIT("MKFNPTR(&", 9);
			mw_mirth_c99_ZPlusC99_put();
			VAL v14 = pop_value();
			incref(v14);
			push_value(v14);
			push_value(v14);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r15 = pop_resource();
			mw_mirth_arrow_Block_cname();
			push_resource(r15);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_ZPlusC99_put();
			STRLIT(")", 1);
			mw_mirth_c99_ZPlusC99_put();
			VAL r16 = pop_resource();
			push_resource(r13);
			push_resource(r16);
			STRLIT(");", 2);
			mw_mirth_c99_ZPlusC99_put();
			mw_mirth_c99_ZPlusC99_line();
			push_resource(r6);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			VAL r17 = pop_resource();
			VAL r18 = pop_resource();
			push_resource(r17);
			push_resource(r18);
			mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
			VAL v19 = pop_value();
			incref(v19);
			push_value(v19);
			push_value(v19);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r20 = pop_resource();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[6];
				VAL u = *p;
				ASSERT1(VREFS(v) == 1, v);
				*p = (VAL){0};
				push_resource(u);
				push_resource(v);
			}
			VAL r21 = pop_resource();
			mw_mirth_arrow_Block_freeZ_vars();
			push_resource(r21);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[6];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			push_resource(r20);
			{
				VAL v = pop_resource();
				VAL u = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				ASSERT1(VREFS(v) == 1, v);
				VAL* p = &VTUP(v)->cells[1];
				ASSERT1(p->tag == 0, v);
				*p = u;
				push_resource(v);
			}
			mw_mirth_c99_c99Z_packZ_closureZ_varsZBang();
			VAL v22 = pop_value();
			decref(v22);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_c99_c99Z_varZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_var_Var_autoZ_runZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_c99_c99Z_varZ_runZBang();
	} else {
		mw_mirth_c99_c99Z_varZ_pushZBang();
	}
}
static void mw_mirth_c99_c99Z_varZ_runZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("incref(", 7);
	mw_mirth_c99_ZPlusC99_put();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mw_mirth_c99_ZPlusC99_varZ_put();
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r2 = pop_resource();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("run_value(", 10);
	mw_mirth_c99_ZPlusC99_put();
	VAL v3 = pop_value();
	incref(v3);
	push_value(v3);
	push_value(v3);
	mw_mirth_c99_ZPlusC99_varZ_put();
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r2);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL v4 = pop_value();
	decref(v4);
}
static void mw_mirth_c99_c99Z_varZ_pushZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_flushZ_cacheZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("incref(", 7);
	mw_mirth_c99_ZPlusC99_put();
	VAL v1 = pop_value();
	incref(v1);
	push_value(v1);
	push_value(v1);
	mw_mirth_c99_ZPlusC99_varZ_put();
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	uint64_t v2 = (0LL /* C99RT_VAL */);
	push_u64(v2);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r3 = pop_resource();
	VAL v4 = pop_value();
	lpush(&lbl_localZ_repr, v4);
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v5 = pop_value();
	VAL r6 = pop_resource();
	lpush(&lbl_localZ_name, v5);
	mtw_mirth_c99_ZPlusC99Local_ZPlusC99Local();
	push_resource(r6);
	mw_mirth_c99_ZPlusC99_indent();
	VAL r7 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r7);
	mw_mirth_c99_C99ReprType_underlyingZ_c99Z_type();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" ", 1);
	mw_mirth_c99_ZPlusC99_put();
	VAL r8 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	push_resource(r8);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = (", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r9 = pop_resource();
	VAL r10 = pop_resource();
	VAL v11 = pop_value();
	incref(v11);
	push_resource(r9);
	push_value(v11);
	push_value(v11);
	mw_mirth_c99_ZPlusC99_varZ_put();
	VAL r12 = pop_resource();
	push_resource(r10);
	push_resource(r12);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r3);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r13 = pop_resource();
	VAL r14 = pop_resource();
	push_resource(r13);
	push_resource(r14);
	mw_mirth_c99_ZPlusC99Local_pushZ_localZBang();
	VAL v15 = pop_value();
	decref(v15);
}
static void mw_mirth_c99_c99Z_lambdaZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("{", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r0 = pop_resource();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_add();
	push_resource(r0);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	push_value(v2);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	push_value(v3);
	push_value(v4);
	while(1) {
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v6 = pop_value();
		if (!VBOOL(v6)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		mw_mirth_c99_c99Z_popZ_toZ_varZBang();
		push_value(v8);
		mw_std_list_List_1_uncons();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v10);
	}
	VAL v11 = pop_value();
	decref(v11);
	VAL v12 = pop_value();
	decref(v12);
	VAL v13 = pop_value();
	incref(v13);
	push_value(v13);
	push_value(v13);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_c99_c99Z_arrowZBang();
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 6, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v14 = pop_value();
	VAL v15 = pop_value();
	push_value(v14);
	push_value(v15);
	while(1) {
		VAL v16 = pop_value();
		incref(v16);
		push_value(v16);
		push_value(v16);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v17 = pop_value();
		if (!VBOOL(v17)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v18 = pop_value();
		VAL v19 = pop_value();
		push_value(v18);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r20 = pop_resource();
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("decref(", 7);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_varZ_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		push_resource(r20);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[1];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		push_value(v19);
		mw_std_list_List_1_uncons();
		VAL v21 = pop_value();
		VAL v22 = pop_value();
		push_value(v21);
		push_value(v22);
	}
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	decref(v24);
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r25 = pop_resource();
	int64_t v26 = (1LL);
	push_i64(v26);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
	push_resource(r25);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
}
static void mw_mirth_c99_c99Z_matchZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_match_Match_isZ_transparentZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[7];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_std_list_List_1_first();
		mw_std_maybe_Maybe_1_unwrap();
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_c99_c99Z_arrowZBang();
	} else {
		VAL v2 = pop_value();
		incref(v2);
		push_value(v2);
		push_value(v2);
		mw_mirth_match_Match_semiZ_transparentZ_tagZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				VAL v3 = pop_value();
				uint64_t v4 = (0LL /* Nil */);
				push_u64(v4);
				push_value(v3);
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					ASSERT1(VREFS(v) == 1, v);
					*p = (VAL){0};
					push_resource(u);
					push_resource(v);
				}
				VAL r5 = pop_resource();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[6];
					VAL u = *p;
					ASSERT1(VREFS(v) == 1, v);
					*p = (VAL){0};
					push_resource(u);
					push_resource(v);
				}
				VAL r6 = pop_resource();
				mw_mirth_data_Tag_patZ_cname();
				push_resource(r6);
				{
					VAL v = pop_resource();
					VAL u = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					ASSERT1(VREFS(v) == 1, v);
					VAL* p = &VTUP(v)->cells[6];
					ASSERT1(p->tag == 0, v);
					*p = u;
					push_resource(v);
				}
				push_resource(r5);
				{
					VAL v = pop_resource();
					VAL u = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					ASSERT1(VREFS(v) == 1, v);
					VAL* p = &VTUP(v)->cells[1];
					ASSERT1(p->tag == 0, v);
					*p = u;
					push_resource(v);
				}
				mw_mirth_c99_c99Z_callZBang();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[7];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_std_list_List_1_first();
				mw_std_maybe_Maybe_1_unwrap();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_c99_c99Z_arrowZBang();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
				VAL v7 = pop_value();
				incref(v7);
				push_value(v7);
				push_value(v7);
				mw_mirth_match_Match_scrutineeZ_dataZAsk();
				switch (get_top_data_tag()) {
					case 1LL: { // Some
						mtp_std_maybe_Maybe_1_Some();
					} break;
					case 0LL: { // None
						(void)pop_u64();
						{
							VAL v = pop_value();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 8, v);
							VAL* p = &VTUP(v)->cells[2];
							VAL u = *p;
							incref(u);
							decref(v);
							push_value(u);
						}
						STRLIT("non-uniform match, not supported at present", 43);
						{
							VAL v = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 7, v);
							VAL* p = &VTUP(v)->cells[6];
							VAL u = *p;
							ASSERT1(VREFS(v) == 1, v);
							*p = (VAL){0};
							push_resource(u);
							push_resource(v);
						}
						VAL r8 = pop_resource();
						mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
						push_resource(r8);
						{
							VAL v = pop_resource();
							VAL u = pop_resource();
							ASSERT1(IS_TUP(v), v);
							ASSERT1(VTUPLEN(v) == 7, v);
							ASSERT1(VREFS(v) == 1, v);
							VAL* p = &VTUP(v)->cells[6];
							ASSERT1(p->tag == 0, v);
							*p = u;
							push_resource(v);
						}
					} break;
					default: {
						push_value(mkstr("unexpected fallthrough in match\n", 32));
						mp_primZ_panic();
					}
				}
				mw_mirth_data_Data_isZ_resourceZAsk();
				VAL v9 = pop_value();
				if (VBOOL(v9)) {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("switch (get_top_resource_data_tag()) {", 38);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				} else {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("switch (get_top_data_tag()) {", 29);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				}
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r10 = pop_resource();
				int64_t v11 = (1LL);
				push_i64(v11);
				mp_primZ_intZ_add();
				push_resource(r10);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
				VAL v12 = pop_value();
				incref(v12);
				push_value(v12);
				push_value(v12);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 8, v);
					VAL* p = &VTUP(v)->cells[7];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_std_list_List_1_uncons();
				VAL v13 = pop_value();
				VAL v14 = pop_value();
				push_value(v13);
				push_value(v14);
				while(1) {
					VAL v15 = pop_value();
					incref(v15);
					push_value(v15);
					push_value(v15);
					mw_std_maybe_Maybe_1_someZAsk();
					VAL v16 = pop_value();
					if (!VBOOL(v16)) break;
					mw_std_maybe_Maybe_1_unwrap();
					VAL v17 = pop_value();
					VAL v18 = pop_value();
					push_value(v17);
					mw_mirth_c99_c99Z_caseZBang();
					push_value(v18);
					mw_std_list_List_1_uncons();
					VAL v19 = pop_value();
					VAL v20 = pop_value();
					push_value(v19);
					push_value(v20);
				}
				VAL v21 = pop_value();
				decref(v21);
				VAL v22 = pop_value();
				decref(v22);
				mw_mirth_match_Match_hasZ_defaultZ_caseZAsk();
				VAL v23 = pop_value();
				if (VBOOL(v23)) {
				} else {
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("default: {", 10);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r24 = pop_resource();
					int64_t v25 = (1LL);
					push_i64(v25);
					mp_primZ_intZ_add();
					push_resource(r24);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("push_value(mkstr(\"unexpected fallthrough in match\\n\", 32));", 59);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
					mw_mirth_c99_ZPlusC99_startZ_branchZBang();
					uint64_t v26 = (0LL /* Nil */);
					uint64_t v27 = (8LL /* PRIM_CORE_PANIC */);
					push_u64(v26);
					push_u64(v27);
					mw_mirth_c99_c99Z_primZBang();
					mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r28 = pop_resource();
					int64_t v29 = (1LL);
					push_i64(v29);
					mp_primZ_intZ_sub();
					mw_std_prim_Int_ZToNat();
					push_resource(r28);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
					mw_mirth_c99_ZPlusC99_indent();
					STRLIT("}", 1);
					mw_mirth_c99_ZPlusC99_put();
					mw_mirth_c99_ZPlusC99_line();
				}
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r30 = pop_resource();
				int64_t v31 = (1LL);
				push_i64(v31);
				mp_primZ_intZ_sub();
				mw_std_prim_Int_ZToNat();
				push_resource(r30);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("}", 1);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				mw_mirth_c99_ZPlusC99_startZ_branchZBang();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
}
static void mw_mirth_c99_c99Z_caseZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	mw_mirth_match_Pattern_isZ_defaultZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("default: {", 10);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r2 = pop_resource();
		int64_t v3 = (1LL);
		push_i64(v3);
		mp_primZ_intZ_add();
		push_resource(r2);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_c99_ZPlusC99_startZ_branchZBang();
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_c99_c99Z_arrowZBang();
		mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r4 = pop_resource();
		int64_t v5 = (1LL);
		push_i64(v5);
		mp_primZ_intZ_sub();
		mw_std_prim_Int_ZToNat();
		push_resource(r4);
		{
			VAL v = top_resource();
			VAL u = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL t = *p; *p = u; decref(t);
		}
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("} break;", 8);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
	} else {
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 3, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_match_Pattern_singleZ_tagZAsk();
		switch (get_top_data_tag()) {
			case 1LL: { // Some
				mtp_std_maybe_Maybe_1_Some();
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("case ", 5);
				mw_mirth_c99_ZPlusC99_put();
				VAL v7 = pop_value();
				incref(v7);
				push_value(v7);
				push_value(v7);
				mw_mirth_data_Tag_valueZ_show();
				mw_mirth_c99_ZPlusC99_put();
				STRLIT("LL: { // ", 9);
				mw_mirth_c99_ZPlusC99_put();
				VAL v8 = pop_value();
				incref(v8);
				push_value(v8);
				push_value(v8);
				mw_mirth_data_Tag_name();
				mw_mirth_name_Name_ZToStr();
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r9 = pop_resource();
				int64_t v10 = (1LL);
				push_i64(v10);
				mp_primZ_intZ_add();
				push_resource(r9);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
				mw_mirth_c99_ZPlusC99_startZ_branchZBang();
				mw_mirth_c99_c99Z_reverseZ_tagZBang();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				mw_mirth_c99_c99Z_arrowZBang();
				mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r11 = pop_resource();
				int64_t v12 = (1LL);
				push_i64(v12);
				mp_primZ_intZ_sub();
				mw_std_prim_Int_ZToNat();
				push_resource(r11);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
				mw_mirth_c99_ZPlusC99_indent();
				STRLIT("} break;", 8);
				mw_mirth_c99_ZPlusC99_put();
				mw_mirth_c99_ZPlusC99_line();
			} break;
			case 0LL: { // None
				(void)pop_u64();
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 10, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				STRLIT("c99 target -- don't know how to compile this pattern", 52);
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[6];
					VAL u = *p;
					ASSERT1(VREFS(v) == 1, v);
					*p = (VAL){0};
					push_resource(u);
					push_resource(v);
				}
				VAL r13 = pop_resource();
				mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
				push_resource(r13);
				{
					VAL v = pop_resource();
					VAL u = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					ASSERT1(VREFS(v) == 1, v);
					VAL* p = &VTUP(v)->cells[6];
					ASSERT1(p->tag == 0, v);
					*p = u;
					push_resource(v);
				}
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
	}
}
static void mw_mirth_c99_c99Z_wordZ_sigsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_word_Word_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		incref(v6);
		push_value(v6);
		push_value(v6);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r7 = pop_resource();
		mw_mirth_word_Word_neededZAsk();
		push_resource(r7);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[4];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			mw_mirth_c99_c99Z_wordZ_sigZBang();
		} else {
			VAL v9 = pop_value();
			decref(v9);
		}
		int64_t v10 = (1LL);
		push_value(v6);
		push_i64(v10);
		mp_primZ_intZ_add();
	}
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_mirth_c99_c99Z_wordZ_sigZBang (void) {
	mw_mirth_c99_ZPlusC99_indent();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_word_Word_cname();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(";", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_c99Z_blockZ_sigsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_arrow_Block_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		incref(v6);
		push_value(v6);
		push_value(v6);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r7 = pop_resource();
		mw_mirth_arrow_Block_neededZAsk();
		push_resource(r7);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[4];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			mw_mirth_c99_c99Z_blockZ_sigZBang();
		} else {
			VAL v9 = pop_value();
			decref(v9);
		}
		int64_t v10 = (1LL);
		push_value(v6);
		push_i64(v10);
		mp_primZ_intZ_add();
	}
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_mirth_c99_c99Z_blockZ_sigZBang (void) {
	mw_mirth_c99_ZPlusC99_indent();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_arrow_Block_cname();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(";", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_c99Z_fieldZ_sigsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_table_Field_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_c99_c99Z_fieldZ_sigZBang();
		int64_t v7 = (1LL);
		push_value(v6);
		push_i64(v7);
		mp_primZ_intZ_add();
	}
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_c99_c99Z_fieldZ_sigZBang (void) {
	mw_mirth_c99_ZPlusC99_indent();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r0 = pop_resource();
	mw_mirth_table_Field_cname();
	push_resource(r0);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(";", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_c99Z_blockZ_enterZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("WORD_ENTER(", 11);
		mw_mirth_c99_ZPlusC99_put();
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r2 = pop_resource();
		mw_mirth_arrow_Block_cname();
		push_resource(r2);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_arrow_Block_home();
		switch (get_top_data_tag()) {
			case 0LL: { // HomeMain
				mtp_mirth_arrow_Home_HomeMain();
				VAL v4 = pop_value();
				decref(v4);
				STRLIT("block", 5);
			} break;
			case 1LL: { // HomeWord
				mtp_mirth_arrow_Home_HomeWord();
				mw_mirth_word_Word_name();
				mw_mirth_name_Name_ZToStr();
				STRLIT(" block", 6);
				mp_primZ_strZ_cat();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		mw_mirth_c99_ZPlusC99_putZ_cstr();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_mirth_arrow_Block_token();
		mw_mirth_token_Token_module();
		mw_mirth_module_Module_sourceZ_path();
		mw_mirth_c99_ZPlusC99_putZ_cstr();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_mirth_arrow_Block_token();
		mw_mirth_token_Token_row();
		mw_mirth_location_Row_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		push_value(v7);
		mw_mirth_arrow_Block_token();
		mw_mirth_token_Token_col();
		mw_mirth_location_Col_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		VAL v8 = pop_value();
		decref(v8);
	} else {
		VAL v9 = pop_value();
		decref(v9);
	}
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
}
static void mw_mirth_c99_c99Z_blockZ_exitZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("WORD_EXIT(", 10);
		mw_mirth_c99_ZPlusC99_put();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r1 = pop_resource();
		mw_mirth_arrow_Block_cname();
		push_resource(r1);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
	} else {
		VAL v2 = pop_value();
		decref(v2);
	}
}
static void mw_mirth_c99_c99Z_blockZ_defsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_arrow_Block_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		incref(v6);
		push_value(v6);
		push_value(v6);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r7 = pop_resource();
		mw_mirth_arrow_Block_neededZAsk();
		push_resource(r7);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[4];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			mw_mirth_c99_c99Z_blockZ_defZBang();
		} else {
			VAL v9 = pop_value();
			decref(v9);
		}
		int64_t v10 = (1LL);
		push_value(v6);
		push_i64(v10);
		mp_primZ_intZ_add();
	}
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_mirth_c99_c99Z_blockZ_defZBang (void) {
	mw_mirth_c99_ZPlusC99_indent();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_mirth_arrow_Block_cname();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(" {", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r2 = pop_resource();
	int64_t v3 = (1LL);
	push_i64(v3);
	mp_primZ_intZ_add();
	push_resource(r2);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mw_mirth_c99_c99Z_blockZ_enterZBang();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r6 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r7 = pop_resource();
	mw_mirth_arrow_Block_arrow();
	push_resource(r7);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	push_resource(r6);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL v8 = pop_value();
	incref(v8);
	push_value(v8);
	push_value(v8);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r9 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r10 = pop_resource();
	mw_mirth_arrow_Arrow_freeZ_vars();
	push_resource(r10);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	push_resource(r9);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_c99Z_unpackZ_closureZ_varsZBang();
	VAL v11 = pop_value();
	incref(v11);
	push_value(v11);
	push_value(v11);
	mw_mirth_c99_c99Z_arrowZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r12 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r13 = pop_resource();
	mw_mirth_arrow_Arrow_freeZ_vars();
	push_resource(r13);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	push_resource(r12);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_c99Z_decrefZ_closureZ_varsZBang();
	mw_mirth_c99_c99Z_blockZ_exitZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r14 = pop_resource();
	int64_t v15 = (1LL);
	push_i64(v15);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
	push_resource(r14);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_c99_c99Z_wordZ_enterZBang (void) {
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("WORD_ENTER(", 11);
		mw_mirth_c99_ZPlusC99_put();
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r2 = pop_resource();
		mw_mirth_word_Word_cname();
		push_resource(r2);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		mw_mirth_word_Word_name();
		mw_mirth_name_Name_ZToStr();
		mw_mirth_c99_ZPlusC99_putZ_cstr();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		mw_mirth_word_Word_body();
		mw_mirth_token_Token_module();
		mw_mirth_module_Module_sourceZ_path();
		mw_mirth_c99_ZPlusC99_putZ_cstr();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		mw_mirth_word_Word_body();
		mw_mirth_token_Token_row();
		mw_mirth_location_Row_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		push_value(v6);
		mw_mirth_word_Word_body();
		mw_mirth_token_Token_col();
		mw_mirth_location_Col_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
		VAL v7 = pop_value();
		decref(v7);
	} else {
		VAL v8 = pop_value();
		decref(v8);
	}
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
}
static void mw_mirth_c99_c99Z_wordZ_exitZBang (void) {
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v0 = pop_value();
	if (VBOOL(v0)) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("WORD_EXIT(", 10);
		mw_mirth_c99_ZPlusC99_put();
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[6];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r1 = pop_resource();
		mw_mirth_word_Word_cname();
		push_resource(r1);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[6];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
	} else {
		VAL v2 = pop_value();
		decref(v2);
	}
}
static void mw_mirth_c99_c99Z_wordZ_defsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_word_Word_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		incref(v6);
		push_value(v6);
		push_value(v6);
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			VAL* p = &VTUP(v)->cells[4];
			VAL u = *p;
			ASSERT1(VREFS(v) == 1, v);
			*p = (VAL){0};
			push_resource(u);
			push_resource(v);
		}
		VAL r7 = pop_resource();
		mw_mirth_word_Word_neededZAsk();
		push_resource(r7);
		{
			VAL v = pop_resource();
			VAL u = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 7, v);
			ASSERT1(VREFS(v) == 1, v);
			VAL* p = &VTUP(v)->cells[4];
			ASSERT1(p->tag == 0, v);
			*p = u;
			push_resource(v);
		}
		VAL v8 = pop_value();
		if (VBOOL(v8)) {
			mw_mirth_c99_c99Z_wordZ_defZBang();
		} else {
			VAL v9 = pop_value();
			decref(v9);
		}
		int64_t v10 = (1LL);
		push_value(v6);
		push_i64(v10);
		mp_primZ_intZ_add();
	}
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_mirth_c99_c99Z_wordZ_defZBang (void) {
	mw_mirth_c99_ZPlusC99_indent();
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_mirth_word_Word_cname();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(" {", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r2 = pop_resource();
	int64_t v3 = (1LL);
	push_i64(v3);
	mp_primZ_intZ_add();
	push_resource(r2);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v4 = pop_value();
	incref(v4);
	push_value(v4);
	push_value(v4);
	mw_mirth_c99_c99Z_wordZ_enterZBang();
	VAL v5 = pop_value();
	incref(v5);
	push_value(v5);
	push_value(v5);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r6 = pop_resource();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r7 = pop_resource();
	mw_mirth_word_Word_arrow();
	push_resource(r7);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	push_resource(r6);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_c99Z_arrowZBang();
	VAL v8 = pop_value();
	incref(v8);
	push_value(v8);
	push_value(v8);
	mw_mirth_c99_c99Z_wordZ_exitZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r9 = pop_resource();
	int64_t v10 = (1LL);
	push_i64(v10);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
	push_resource(r9);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	VAL v11 = pop_value();
	decref(v11);
}
static void mw_mirth_c99_c99Z_fieldZ_defsZBang (void) {
	int64_t v0 = (1LL);
	push_i64(v0);
	while(1) {
		VAL v1 = pop_value();
		incref(v1);
		push_value(v1);
		push_value(v1);
		mbuf_mirth_table_Field_NUM();
		mp_primZ_u64Z_get();
		int64_t v2 = (1LL);
		push_i64(v2);
		mp_primZ_intZ_add();
		VAL v3 = pop_value();
		VAL v4 = pop_value();
		bool v5 = (VI64(v4) < VI64(v3));
		if (!v5) break;
		VAL v6 = pop_value();
		incref(v6);
		push_value(v6);
		mw_mirth_c99_c99Z_fieldZ_defZBang();
		int64_t v7 = (1LL);
		push_value(v6);
		push_i64(v7);
		mp_primZ_intZ_add();
	}
	VAL v8 = pop_value();
	decref(v8);
}
static void mw_mirth_c99_c99Z_fieldZ_defZBang (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r1 = pop_resource();
	mw_mirth_table_Field_cname();
	push_resource(r1);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[6];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	mw_mirth_c99_ZPlusC99_sigZ_put();
	STRLIT(" {", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang();
	STRLIT("\tsize_t i = (size_t)pop_u64();", 30);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tstatic struct VAL * p = 0;", 27);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tsize_t m = ", 12);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_elab_TABLEz_MAXz_COUNT();
	mp_primZ_intZ_toZ_str();
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(";", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tif (! p) { p = calloc(m, sizeof *p); }", 39);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tEXPECT(i<m, \"table grew too big\");", 35);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("\tpush_ptr(p+i);", 15);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_line();
	VAL v2 = pop_value();
	decref(v2);
}
static void mw_mirth_c99_c99Z_mainZBang (void) {
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("int main (int argc, char** argv) {", 34);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_resetZ_freshZ_counterZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r0 = pop_resource();
	int64_t v1 = (1LL);
	push_i64(v1);
	mp_primZ_intZ_add();
	push_resource(r0);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("global_argc = argc;", 19);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("global_argv = argv;", 19);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v2 = pop_value();
	if (VBOOL(v2)) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("WORD_ENTER(", 11);
		mw_mirth_c99_ZPlusC99_put();
		STRLIT("(void(*)(void))0, ", 18);
		mw_mirth_c99_ZPlusC99_put();
		STRLIT("\"<main>\", ", 10);
		mw_mirth_c99_ZPlusC99_put();
		VAL v3 = pop_value();
		incref(v3);
		push_value(v3);
		push_value(v3);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_token_Token_module();
		mw_mirth_module_Module_sourceZ_path();
		mw_mirth_c99_ZPlusC99_putZ_cstr();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v4 = pop_value();
		incref(v4);
		push_value(v4);
		push_value(v4);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_token_Token_row();
		mw_mirth_location_Row_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(", ", 2);
		mw_mirth_c99_ZPlusC99_put();
		VAL v5 = pop_value();
		incref(v5);
		push_value(v5);
		push_value(v5);
		{
			VAL v = pop_value();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 8, v);
			VAL* p = &VTUP(v)->cells[2];
			VAL u = *p;
			incref(u);
			decref(v);
			push_value(u);
		}
		mw_mirth_token_Token_col();
		mw_mirth_location_Col_ZToInt();
		mp_primZ_intZ_toZ_str();
		mw_mirth_c99_ZPlusC99_put();
		STRLIT(");", 2);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
	} else {
	}
	mw_mirth_c99_ZPlusC99_startZ_branchZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		ASSERT1(VREFS(v) == 1, v);
		*p = (VAL){0};
		push_resource(u);
		push_resource(v);
	}
	VAL r6 = pop_resource();
	mw_mirth_c99_ZPlusC99_freshZ_nameZBang();
	VAL v7 = pop_value();
	VAL r8 = pop_resource();
	lpush(&lbl_localZ_resourceZ_name, v7);
	mtw_mirth_c99_ZPlusC99LocalResource_ZPlusC99LocalResource();
	push_resource(r8);
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("VAL ", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r9 = pop_resource();
	{
		VAL v = top_resource();
		incref(v);
		push_value(v);
	}
	push_resource(r9);
	mw_mirth_c99_ZPlusC99_put();
	STRLIT(" = (", 4);
	mw_mirth_c99_ZPlusC99_put();
	VAL r10 = pop_resource();
	VAL r11 = pop_resource();
	push_resource(r10);
	STRLIT("MKU64(0) /* The World! */", 25);
	mw_mirth_c99_ZPlusC99_put();
	VAL r12 = pop_resource();
	push_resource(r11);
	push_resource(r12);
	STRLIT(");", 2);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	push_resource(r6);
	{
		VAL v = pop_resource();
		VAL u = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		ASSERT1(VREFS(v) == 1, v);
		VAL* p = &VTUP(v)->cells[1];
		ASSERT1(p->tag == 0, v);
		*p = u;
		push_resource(v);
	}
	VAL r13 = pop_resource();
	VAL r14 = pop_resource();
	push_resource(r13);
	push_resource(r14);
	mw_mirth_c99_ZPlusC99LocalResource_pushZ_localZ_resourceZBang();
	mw_mirth_c99_c99Z_arrowZBang();
	mw_mirth_c99_ZPlusC99Branch_endZ_branchZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 3, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v15 = pop_value();
	if (VBOOL(v15)) {
		mw_mirth_c99_ZPlusC99_indent();
		STRLIT("WORD_EXIT((void(*)(void))0);", 28);
		mw_mirth_c99_ZPlusC99_put();
		mw_mirth_c99_ZPlusC99_line();
	} else {
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("return 0;", 9);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r16 = pop_resource();
	int64_t v17 = (1LL);
	push_i64(v17);
	mp_primZ_intZ_sub();
	mw_std_prim_Int_ZToNat();
	push_resource(r16);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[2];
		VAL t = *p; *p = u; decref(t);
	}
	mw_mirth_c99_ZPlusC99_indent();
	STRLIT("}", 1);
	mw_mirth_c99_ZPlusC99_put();
	mw_mirth_c99_ZPlusC99_line();
}
static void mw_mirth_main_Arguments_default (void) {
	uint64_t v0 = (0LL /* False */);
	lpush(&lbl_emitZ_debugZ_info, MKU64(v0));
	STRLIT("mirth.mth", 9);
	VAL v1 = pop_value();
	uint64_t v2 = (0LL /* None */);
	lpush(&lbl_inputZ_file, v1);
	lpush(&lbl_outputZ_file, MKU64(v2));
	STRLIT("main", 4);
	mtw_std_maybe_Maybe_1_Some();
	VAL v3 = pop_value();
	uint64_t v4 = (0LL /* Nil */);
	uint64_t v5 = (0LL /* Nil */);
	lpush(&lbl_entryZ_point, v3);
	lpush(&lbl_packages, MKU64(v4));
	lpush(&lbl_packageZ_searchZ_paths, MKU64(v5));
	mtw_mirth_main_Arguments_Arguments();
}
static void mw_mirth_main_compileZBang (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Arguments
			mtp_mirth_main_Arguments_Arguments();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v0 = (lpop(&lbl_packageZ_searchZ_paths));
	push_value(v0);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r1 = pop_resource();
	VAL v2 = pop_value();
	decref(v2);
	push_resource(r1);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL t = *p; *p = u; decref(t);
	}
	VAL r3 = pop_resource();
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	STRLIT("Compiling ", 10);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	VAL v4 = (lpop(&lbl_inputZ_file));
	incref(v4);
	push_value(v4);
	lpush(&lbl_inputZ_file, v4);
	mw_std_path_Path_pathZThen();
	mtp_std_str_ZPlusStr_ZPlusStr();
	STRLIT("\n", 1);
	mp_primZ_strZ_cat();
	mw_std_prim_ZPlusWorld_traceZ_();
	VAL v5 = (lpop(&lbl_packages));
	push_resource(r3);
	push_value(v5);
	mw_std_list_List_1_uncons();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	push_value(v6);
	push_value(v7);
	while(1) {
		VAL v8 = pop_value();
		incref(v8);
		push_value(v8);
		push_value(v8);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v9 = pop_value();
		if (!VBOOL(v9)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		push_value(v10);
		mp_primZ_packZ_uncons();
		VAL v12 = pop_value();
		mp_primZ_packZ_uncons();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		decref(v14);
		push_value(v12);
		push_value(v13);
		mw_std_prim_Str_ZToName();
		mw_mirth_package_Package_newZ_orZ_pathZBang();
		VAL v15 = pop_value();
		decref(v15);
		push_value(v11);
		mw_std_list_List_1_uncons();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		push_value(v16);
		push_value(v17);
	}
	VAL v18 = pop_value();
	decref(v18);
	VAL v19 = pop_value();
	decref(v19);
	VAL v20 = (lpop(&lbl_inputZ_file));
	push_value(v20);
	mw_mirth_lexer_runZ_lexerZBang();
	VAL r21 = pop_resource();
	STRLIT("", 0);
	mtw_std_str_ZPlusStr_ZPlusStr();
	STRLIT("Building.", 9);
	mw_std_str_ZPlusStr_pushZ_strZBang();
	mtp_std_str_ZPlusStr_ZPlusStr();
	STRLIT("\n", 1);
	mp_primZ_strZ_cat();
	mw_std_prim_ZPlusWorld_traceZ_();
	push_resource(r21);
	mw_mirth_elab_elabZ_moduleZBang();
	mw_mirth_elab_typecheckZ_everythingZBang();
	VAL v22 = (lpop(&lbl_entryZ_point));
	push_value(v22);
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v23 = pop_value();
			VAL v24 = pop_value();
			incref(v24);
			push_value(v24);
			push_value(v24);
			mtw_mirth_name_Namespace_NAMESPACEz_MODULE();
			push_value(v23);
			mw_std_prim_Str_ZToName();
			mw_mirth_name_QNAME0();
			mw_mirth_elab_elabZ_entryZ_point();
			mtw_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			uint64_t v25 = (0LL /* None */);
			push_u64(v25);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v26 = pop_value();
	VAL v27 = pop_value();
	decref(v27);
	push_value(v26);
	mw_mirth_mirth_ZPlusMirth_traceZ_diagnosticsZBang();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 9, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	int64_t v28 = (0LL);
	VAL v29 = pop_value();
	bool v30 = (v28 < VI64(v29));
	if (v30) {
		{
			VAL v = pop_resource();
			ASSERT1(IS_TUP(v), v);
			ASSERT1(VTUPLEN(v) == 9, v);
			VAL* p = &VTUP(v)->cells[1];
			VAL u = *p;
			incref(u);
			push_resource(v);
			push_value(u);
		}
		VAL r31 = pop_resource();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		uint64_t v32 = (31LL /* FGRed */);
		push_u64(v32);
		mw_std_terminal_Sgr_emitZThen();
		mp_primZ_intZ_toZ_str();
		mw_std_str_ZPlusStr_pushZ_strZBang();
		STRLIT(" errors.", 8);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		uint64_t v33 = (0LL /* Reset */);
		push_u64(v33);
		mw_std_terminal_Sgr_emitZThen();
		mtp_std_str_ZPlusStr_ZPlusStr();
		STRLIT("\n", 1);
		mp_primZ_strZ_cat();
		mw_std_prim_ZPlusWorld_traceZ_();
		int64_t v34 = (1LL);
		push_resource(r31);
		push_i64(v34);
		mext_std_posix_externalZ_posixZ_exit();
	} else {
		VAL r35 = pop_resource();
		STRLIT("", 0);
		mtw_std_str_ZPlusStr_ZPlusStr();
		uint64_t v36 = (32LL /* FGGreen */);
		push_u64(v36);
		mw_std_terminal_Sgr_emitZThen();
		STRLIT("No errors.", 10);
		mw_std_str_ZPlusStr_pushZ_strZBang();
		uint64_t v37 = (0LL /* Reset */);
		push_u64(v37);
		mw_std_terminal_Sgr_emitZThen();
		mtp_std_str_ZPlusStr_ZPlusStr();
		STRLIT("\n", 1);
		mp_primZ_strZ_cat();
		mw_std_prim_ZPlusWorld_traceZ_();
		push_resource(r35);
	}
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			STRLIT("Specializer.", 12);
			VAL r38 = pop_resource();
			STRLIT("\n", 1);
			mp_primZ_strZ_cat();
			mw_std_prim_ZPlusWorld_traceZ_();
			push_resource(r38);
			mw_mirth_specializzer_runZ_specializzerZBang();
			STRLIT("Codegen.", 8);
			VAL r39 = pop_resource();
			STRLIT("\n", 1);
			mp_primZ_strZ_cat();
			mw_std_prim_ZPlusWorld_traceZ_();
			VAL v40 = (lpop(&lbl_outputZ_file));
			push_resource(r39);
			push_value(v40);
			mw_std_maybe_Maybe_1_unwrap();
			VAL v41 = pop_value();
			lpush(&lbl_outputZ_path, v41);
			mtw_mirth_c99_C99z_Options_C99z_Options();
			mw_mirth_c99_runZ_outputZ_c99ZBang();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Skipping Codegen.", 17);
			VAL r42 = pop_resource();
			STRLIT("\n", 1);
			mp_primZ_strZ_cat();
			mw_std_prim_ZPlusWorld_traceZ_();
			VAL v43 = (lpop(&lbl_emitZ_debugZ_info));
			decref(v43);
			VAL v44 = (lpop(&lbl_outputZ_file));
			decref(v44);
			push_resource(r42);
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mw_mirth_main_parseZ_packageZ_def (void) {
	VAL v0 = pop_value();
	uint64_t v1 = (58LL /* BCOLON */);
	push_u64(v1);
	push_value(v0);
	mw_std_prim_Str_splitZ_byte();
	mw_std_list_List_1_ZDivL2();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			STRLIT("Invalid package path definition", 31);
			mp_primZ_panic();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mp_primZ_packZ_uncons();
	VAL v2 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	decref(v4);
	mp_primZ_packZ_nil();
	push_value(v3);
	mp_primZ_packZ_cons();
	push_value(v2);
	mp_primZ_packZ_cons();
}
static void mw_mirth_main_compilerZ_parseZ_args (void) {
	switch (get_top_data_tag()) {
		case 0LL: { // Short
			mtp_argZ_parser_types_ArgpOptionType_Short();
			VAL v0 = pop_value();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			push_value(v1);
			push_value(v2);
			push_value(v0);
			switch (get_top_data_tag()) {
				case 111LL: { // B'o'
					(void)pop_u64();
					VAL v3 = pop_value();
					incref(v3);
					push_value(v3);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					VAL v4 = pop_value();
					decref(v4);
					mw_std_maybe_Maybe_1_unwrap();
					mtw_std_maybe_Maybe_1_Some();
					push_value(v3);
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[2];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(7);
							tup->size = 7;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = u;
							tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
							tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
							tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
							tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
							decref(v);
							push_value(MKTUP(tup,7));
						}
					}
				} break;
				case 101LL: { // B'e'
					(void)pop_u64();
					VAL v5 = pop_value();
					incref(v5);
					push_value(v5);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[3];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					VAL v6 = pop_value();
					decref(v6);
					mw_std_maybe_Maybe_1_unwrap();
					mtw_std_maybe_Maybe_1_Some();
					push_value(v5);
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[3];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(7);
							tup->size = 7;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
							tup->cells[3] = u;
							tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
							tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
							tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
							decref(v);
							push_value(MKTUP(tup,7));
						}
					}
				} break;
				case 99LL: { // B'c'
					(void)pop_u64();
					VAL v7 = pop_value();
					incref(v7);
					push_value(v7);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[3];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					VAL v8 = pop_value();
					decref(v8);
					VAL v9 = pop_value();
					decref(v9);
					uint64_t v10 = (0LL /* None */);
					push_u64(v10);
					push_value(v7);
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[3];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(7);
							tup->size = 7;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
							tup->cells[3] = u;
							tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
							tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
							tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
							decref(v);
							push_value(MKTUP(tup,7));
						}
					}
				} break;
				case 112LL: { // B'p'
					(void)pop_u64();
					VAL v11 = pop_value();
					mw_std_maybe_Maybe_1_unwrap();
					mw_mirth_main_parseZ_packageZ_def();
					incref(v11);
					push_value(v11);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[4];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mtw_std_list_List_1_Cons();
					push_value(v11);
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[4];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(7);
							tup->size = 7;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
							tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
							tup->cells[4] = u;
							tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
							tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
							decref(v);
							push_value(MKTUP(tup,7));
						}
					}
				} break;
				case 80LL: { // B'P'
					(void)pop_u64();
					VAL v12 = pop_value();
					mw_std_maybe_Maybe_1_unwrap();
					incref(v12);
					push_value(v12);
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[5];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					mtw_std_list_List_1_Cons();
					push_value(v12);
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[5];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(7);
							tup->size = 7;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
							tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
							tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
							tup->cells[5] = u;
							tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
							decref(v);
							push_value(MKTUP(tup,7));
						}
					}
				} break;
				default: {
					VAL v13 = pop_value();
					decref(v13);
					VAL v14 = pop_value();
					VAL v15 = pop_value();
					decref(v15);
					uint64_t v16 = (4LL /* UnknownArg */);
					push_value(v14);
					push_u64(v16);
					mtw_std_maybe_Maybe_1_Some();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					VAL r17 = pop_resource();
					{
						VAL v = pop_value();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						if (VTUP(v)->refs == 1) {
							VAL* p = &VTUP(v)->cells[6];
							VAL t = *p; *p = u; decref(t);
							push_value(v);
						} else {
							TUP *tup = tup_new(7);
							tup->size = 7;
							tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
							tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
							tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
							tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
							tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
							tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
							tup->cells[6] = u;
							decref(v);
							push_value(MKTUP(tup,7));
						}
					}
					push_resource(r17);
					{
						VAL v = top_resource();
						VAL u = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL t = *p; *p = u; decref(t);
					}
				} break;
			}
		} break;
		case 2LL: { // Positional
			(void)pop_u64();
			VAL v18 = pop_value();
			VAL v19 = pop_value();
			push_value(v18);
			push_value(v19);
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			int64_t v20 = (0LL);
			VAL v21 = pop_value();
			bool v22 = (VI64(v21) == v20);
			if (v22) {
				VAL v23 = pop_value();
				incref(v23);
				push_value(v23);
				{
					VAL v = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					VAL* p = &VTUP(v)->cells[1];
					VAL u = *p;
					incref(u);
					decref(v);
					push_value(u);
				}
				VAL v24 = pop_value();
				decref(v24);
				mw_std_maybe_Maybe_1_unwrap();
				push_value(v23);
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[1];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(7);
						tup->size = 7;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = u;
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
						decref(v);
						push_value(MKTUP(tup,7));
					}
				}
			} else {
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				decref(v26);
				uint64_t v27 = (2LL /* TooManyArgs */);
				push_value(v25);
				push_u64(v27);
				mtw_std_maybe_Maybe_1_Some();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r28 = pop_resource();
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[6];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(7);
						tup->size = 7;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = u;
						decref(v);
						push_value(MKTUP(tup,7));
					}
				}
				push_resource(r28);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
			}
		} break;
		case 1LL: { // LongOnly
			mtp_argZ_parser_types_ArgpOptionType_LongOnly();
			VAL v29 = pop_value();
			incref(v29);
			push_value(v29);
			push_value(v29);
			STRLIT("debug", 5);
			mp_primZ_strZ_cmp();
			int64_t v30 = (0LL);
			VAL v31 = pop_value();
			incref(v31);
			bool v32 = (VI64(v31) == v30);
			push_value(v31);
			push_i64(v30);
			if (v32) {
				VAL v33 = pop_value();
				decref(v33);
				VAL v34 = pop_value();
				decref(v34);
				uint64_t v35 = (1LL /* EQ */);
				push_u64(v35);
			} else {
				VAL v36 = pop_value();
				VAL v37 = pop_value();
				bool v38 = (VI64(v37) < VI64(v36));
				if (v38) {
					uint64_t v39 = (0LL /* LT */);
					push_u64(v39);
				} else {
					uint64_t v40 = (2LL /* GT */);
					push_u64(v40);
				}
			}
			switch (get_top_data_tag()) {
				case 0LL: { // LT
					(void)pop_u64();
					uint64_t v41 = (0LL /* False */);
					push_u64(v41);
				} break;
				case 1LL: { // EQ
					(void)pop_u64();
					uint64_t v42 = (1LL /* True */);
					push_u64(v42);
				} break;
				case 2LL: { // GT
					(void)pop_u64();
					uint64_t v43 = (0LL /* False */);
					push_u64(v43);
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			VAL v44 = pop_value();
			if (VBOOL(v44)) {
				VAL v45 = pop_value();
				decref(v45);
				VAL v46 = pop_value();
				decref(v46);
				uint64_t v47 = (1LL /* True */);
				VAL v48 = pop_value();
				push_u64(v47);
				push_value(v48);
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[6];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(7);
						tup->size = 7;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = u;
						decref(v);
						push_value(MKTUP(tup,7));
					}
				}
			} else {
				VAL v49 = pop_value();
				decref(v49);
				VAL v50 = pop_value();
				decref(v50);
				uint64_t v51 = (4LL /* UnknownArg */);
				push_u64(v51);
				mtw_std_maybe_Maybe_1_Some();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r52 = pop_resource();
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[6];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(7);
						tup->size = 7;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = u;
						decref(v);
						push_value(MKTUP(tup,7));
					}
				}
				push_resource(r52);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
			}
		} break;
		case 3LL: { // End
			(void)pop_u64();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[4];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			int64_t v53 = (1LL);
			VAL v54 = pop_value();
			bool v55 = (VI64(v54) < v53);
			if (v55) {
				uint64_t v56 = (3LL /* TooFewArgs */);
				push_u64(v56);
				mtw_std_maybe_Maybe_1_Some();
				{
					VAL v = pop_resource();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL u = *p;
					incref(u);
					push_resource(v);
					push_value(u);
				}
				VAL r57 = pop_resource();
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[6];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(7);
						tup->size = 7;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
						tup->cells[6] = u;
						decref(v);
						push_value(MKTUP(tup,7));
					}
				}
				push_resource(r57);
				{
					VAL v = top_resource();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 3, v);
					VAL* p = &VTUP(v)->cells[2];
					VAL t = *p; *p = u; decref(t);
				}
			} else {
			}
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			switch (get_top_data_tag()) {
				case 1LL: { // Some
					mtp_std_maybe_Maybe_1_Some();
					VAL v58 = pop_value();
					decref(v58);
				} break;
				case 0LL: { // None
					(void)pop_u64();
					{
						VAL v = pop_resource();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 3, v);
						VAL* p = &VTUP(v)->cells[2];
						VAL u = *p;
						incref(u);
						push_resource(v);
						push_value(u);
					}
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[1];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					{
						VAL v = pop_value();
						ASSERT1(IS_TUP(v), v);
						ASSERT1(VTUPLEN(v) == 7, v);
						VAL* p = &VTUP(v)->cells[3];
						VAL u = *p;
						incref(u);
						decref(v);
						push_value(u);
					}
					switch (get_top_data_tag()) {
						case 1LL: { // Some
							mtp_std_maybe_Maybe_1_Some();
							VAL v59 = pop_value();
							decref(v59);
							STRLIT("output-file", 11);
							mtw_argZ_parser_types_ArgumentParsingError_MissingArg();
							mtw_std_maybe_Maybe_1_Some();
							{
								VAL v = pop_resource();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 3, v);
								VAL* p = &VTUP(v)->cells[2];
								VAL u = *p;
								incref(u);
								push_resource(v);
								push_value(u);
							}
							VAL r60 = pop_resource();
							{
								VAL v = pop_value();
								VAL u = pop_value();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 7, v);
								if (VTUP(v)->refs == 1) {
									VAL* p = &VTUP(v)->cells[6];
									VAL t = *p; *p = u; decref(t);
									push_value(v);
								} else {
									TUP *tup = tup_new(7);
									tup->size = 7;
									tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
									tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
									tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
									tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
									tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
									tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
									tup->cells[6] = u;
									decref(v);
									push_value(MKTUP(tup,7));
								}
							}
							push_resource(r60);
							{
								VAL v = top_resource();
								VAL u = pop_value();
								ASSERT1(IS_TUP(v), v);
								ASSERT1(VTUPLEN(v) == 3, v);
								VAL* p = &VTUP(v)->cells[2];
								VAL t = *p; *p = u; decref(t);
							}
						} break;
						case 0LL: { // None
							(void)pop_u64();
						} break;
						default: {
							push_value(mkstr("unexpected fallthrough in match\n", 32));
							mp_primZ_panic();
						}
					}
				} break;
				default: {
					push_value(mkstr("unexpected fallthrough in match\n", 32));
					mp_primZ_panic();
				}
			}
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				VAL* p = &VTUP(v)->cells[5];
				VAL u = *p;
				incref(u);
				decref(v);
				push_value(u);
			}
			mw_std_list_List_1_emptyZAsk();
			VAL v61 = pop_value();
			if (VBOOL(v61)) {
				VAL v62 = pop_value();
				uint64_t v63 = (0LL /* Nil */);
				push_u64(v63);
				mw_std_list_List_1_reverse();
				mtw_std_list_ZPlusList_1_ZPlusList();
				STRLIT("lib", 3);
				mtp_std_list_ZPlusList_1_ZPlusList();
				mtw_std_list_List_1_Cons();
				mtw_std_list_ZPlusList_1_ZPlusList();
				mtp_std_list_ZPlusList_1_ZPlusList();
				mw_std_list_List_1_reverse();
				VAL v64 = pop_value();
				VAL v65 = pop_value();
				push_value(v64);
				push_value(v65);
				{
					VAL v = pop_value();
					VAL u = pop_value();
					ASSERT1(IS_TUP(v), v);
					ASSERT1(VTUPLEN(v) == 7, v);
					if (VTUP(v)->refs == 1) {
						VAL* p = &VTUP(v)->cells[5];
						VAL t = *p; *p = u; decref(t);
						push_value(v);
					} else {
						TUP *tup = tup_new(7);
						tup->size = 7;
						tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
						tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
						tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
						tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
						tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
						tup->cells[5] = u;
						tup->cells[6] = VTUP(v)->cells[6]; incref(tup->cells[6]);
						decref(v);
						push_value(MKTUP(tup,7));
					}
				}
				push_value(v62);
			} else {
			}
			VAL v66 = pop_value();
			decref(v66);
		} break;
		default: {
			VAL v67 = pop_value();
			decref(v67);
			VAL v68 = pop_value();
			decref(v68);
			uint64_t v69 = (4LL /* UnknownArg */);
			push_u64(v69);
			mtw_std_maybe_Maybe_1_Some();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			{
				VAL v = pop_value();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 7, v);
				if (VTUP(v)->refs == 1) {
					VAL* p = &VTUP(v)->cells[6];
					VAL t = *p; *p = u; decref(t);
					push_value(v);
				} else {
					TUP *tup = tup_new(7);
					tup->size = 7;
					tup->cells[0] = VTUP(v)->cells[0]; incref(tup->cells[0]);
					tup->cells[1] = VTUP(v)->cells[1]; incref(tup->cells[1]);
					tup->cells[2] = VTUP(v)->cells[2]; incref(tup->cells[2]);
					tup->cells[3] = VTUP(v)->cells[3]; incref(tup->cells[3]);
					tup->cells[4] = VTUP(v)->cells[4]; incref(tup->cells[4]);
					tup->cells[5] = VTUP(v)->cells[5]; incref(tup->cells[5]);
					tup->cells[6] = u;
					decref(v);
					push_value(MKTUP(tup,7));
				}
			}
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 3, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL t = *p; *p = u; decref(t);
			}
		} break;
	}
}
static void mw_mirth_main_main (void) {
	mw_mirth_mirth_ZPlusMirth_InitZBang();
	mw_mirth_main_Arguments_default();
	uint64_t v0 = (0LL /* Nil */);
	push_u64(v0);
	mw_std_list_List_1_reverse();
	mtw_std_list_ZPlusList_1_ZPlusList();
	STRLIT("output-file", 11);
	mtw_std_maybe_Maybe_1_Some();
	VAL v1 = pop_value();
	uint64_t v2 = (111LL /* B'o' */);
	lpush(&lbl_name, v1);
	push_u64(v2);
	mtw_argZ_parser_types_ArgpOptionType_Short();
	VAL v3 = pop_value();
	lpush(&lbl_flagZ_type, v3);
	STRLIT("OUTPUT_FILE", 11);
	mtw_std_maybe_Maybe_1_Some();
	VAL v4 = pop_value();
	lpush(&lbl_argZ_doc, v4);
	STRLIT("Test argument", 13);
	mtw_std_maybe_Maybe_1_Some();
	VAL v5 = pop_value();
	uint64_t v6 = (0LL /* None */);
	lpush(&lbl_doc, v5);
	lpush(&lbl_group, MKU64(v6));
	mtw_argZ_parser_types_ArgpOption_ArgpOption();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusList_1_ZPlusList();
	STRLIT("compile-only", 12);
	mtw_std_maybe_Maybe_1_Some();
	VAL v7 = pop_value();
	uint64_t v8 = (99LL /* B'c' */);
	lpush(&lbl_name, v7);
	push_u64(v8);
	mtw_argZ_parser_types_ArgpOptionType_Short();
	VAL v9 = pop_value();
	uint64_t v10 = (0LL /* None */);
	lpush(&lbl_flagZ_type, v9);
	lpush(&lbl_argZ_doc, MKU64(v10));
	STRLIT("Compile code without running codegen step", 41);
	mtw_std_maybe_Maybe_1_Some();
	VAL v11 = pop_value();
	uint64_t v12 = (0LL /* None */);
	lpush(&lbl_doc, v11);
	lpush(&lbl_group, MKU64(v12));
	mtw_argZ_parser_types_ArgpOption_ArgpOption();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusList_1_ZPlusList();
	STRLIT("entry-point", 11);
	mtw_std_maybe_Maybe_1_Some();
	VAL v13 = pop_value();
	uint64_t v14 = (101LL /* B'e' */);
	lpush(&lbl_name, v13);
	push_u64(v14);
	mtw_argZ_parser_types_ArgpOptionType_Short();
	VAL v15 = pop_value();
	lpush(&lbl_flagZ_type, v15);
	STRLIT("ENTRY_POINT", 11);
	mtw_std_maybe_Maybe_1_Some();
	VAL v16 = pop_value();
	lpush(&lbl_argZ_doc, v16);
	STRLIT("Custom entry point word for compilation", 39);
	mtw_std_maybe_Maybe_1_Some();
	VAL v17 = pop_value();
	uint64_t v18 = (0LL /* None */);
	lpush(&lbl_doc, v17);
	lpush(&lbl_group, MKU64(v18));
	mtw_argZ_parser_types_ArgpOption_ArgpOption();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusList_1_ZPlusList();
	STRLIT("package", 7);
	mtw_std_maybe_Maybe_1_Some();
	VAL v19 = pop_value();
	uint64_t v20 = (112LL /* B'p' */);
	lpush(&lbl_name, v19);
	push_u64(v20);
	mtw_argZ_parser_types_ArgpOptionType_Short();
	VAL v21 = pop_value();
	lpush(&lbl_flagZ_type, v21);
	STRLIT("(PACKAGE:PATH)*", 15);
	mtw_std_maybe_Maybe_1_Some();
	VAL v22 = pop_value();
	lpush(&lbl_argZ_doc, v22);
	STRLIT("Package locations", 17);
	mtw_std_maybe_Maybe_1_Some();
	VAL v23 = pop_value();
	uint64_t v24 = (0LL /* None */);
	lpush(&lbl_doc, v23);
	lpush(&lbl_group, MKU64(v24));
	mtw_argZ_parser_types_ArgpOption_ArgpOption();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusList_1_ZPlusList();
	STRLIT("package-search-path", 19);
	mtw_std_maybe_Maybe_1_Some();
	VAL v25 = pop_value();
	uint64_t v26 = (80LL /* B'P' */);
	lpush(&lbl_name, v25);
	push_u64(v26);
	mtw_argZ_parser_types_ArgpOptionType_Short();
	VAL v27 = pop_value();
	lpush(&lbl_flagZ_type, v27);
	STRLIT("SEARCH_PATH*", 12);
	mtw_std_maybe_Maybe_1_Some();
	VAL v28 = pop_value();
	lpush(&lbl_argZ_doc, v28);
	STRLIT("Package search paths", 20);
	mtw_std_maybe_Maybe_1_Some();
	VAL v29 = pop_value();
	uint64_t v30 = (0LL /* None */);
	lpush(&lbl_doc, v29);
	lpush(&lbl_group, MKU64(v30));
	mtw_argZ_parser_types_ArgpOption_ArgpOption();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusList_1_ZPlusList();
	STRLIT("debug", 5);
	mtw_std_maybe_Maybe_1_Some();
	VAL v31 = pop_value();
	lpush(&lbl_name, v31);
	STRLIT("debug", 5);
	mtw_argZ_parser_types_ArgpOptionType_LongOnly();
	VAL v32 = pop_value();
	uint64_t v33 = (0LL /* None */);
	lpush(&lbl_flagZ_type, v32);
	lpush(&lbl_argZ_doc, MKU64(v33));
	STRLIT("Emit debugging information during codegen", 41);
	mtw_std_maybe_Maybe_1_Some();
	VAL v34 = pop_value();
	uint64_t v35 = (0LL /* None */);
	lpush(&lbl_doc, v34);
	lpush(&lbl_group, MKU64(v35));
	mtw_argZ_parser_types_ArgpOption_ArgpOption();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mtw_std_list_List_1_Cons();
	mtw_std_list_ZPlusList_1_ZPlusList();
	mtp_std_list_ZPlusList_1_ZPlusList();
	mw_std_list_List_1_reverse();
	VAL v36 = pop_value();
	lpush(&lbl_options, v36);
	VAL v37 = (MKFNPTR(&mb_mirth_main_main_1));
	push_value(v37);
	mtw_std_maybe_Maybe_1_Some();
	VAL v38 = pop_value();
	lpush(&lbl_parser, v38);
	STRLIT("input-file", 10);
	mtw_std_maybe_Maybe_1_Some();
	VAL v39 = pop_value();
	lpush(&lbl_argsZ_doc, v39);
	STRLIT("Mirth Compiler", 14);
	VAL v40 = pop_value();
	lpush(&lbl_doc, v40);
	mtw_argZ_parser_types_ArgumentParser_1_ArgumentParser();
	mw_argZ_parser_parse_parseZ_args();
	switch (get_top_data_tag()) {
		case 1LL: { // Right
			mtp_std_either_Either_2_Right();
		} break;
		case 0LL: { // Left
			mtp_std_either_Either_2_Left();
			VAL r41 = pop_resource();
			STRLIT("", 0);
			mtw_std_str_ZPlusStr_ZPlusStr();
			mp_primZ_packZ_uncons();
			VAL v42 = pop_value();
			mp_primZ_packZ_uncons();
			VAL v43 = pop_value();
			VAL v44 = pop_value();
			decref(v44);
			push_value(v43);
			push_value(v42);
			mw_std_str_ZPlusStr_pushZ_strZBang();
			mw_argZ_parser_types_ArgumentParsingError_emitZThen();
			mtp_std_str_ZPlusStr_ZPlusStr();
			STRLIT("\n", 1);
			mp_primZ_strZ_cat();
			mw_std_prim_ZPlusWorld_traceZ_();
			int64_t v45 = (1LL);
			push_resource(r41);
			push_i64(v45);
			mext_std_posix_externalZ_posixZ_exit();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	mw_mirth_main_compileZBang();
	mw_mirth_mirth_ZPlusMirth_rdrop();
}
static void mb_mirth_main_main_1 (void) {
	mw_mirth_main_compilerZ_parseZ_args();
}
static void mb_std_list_List_1_for_1_0 (void) {
	mw_std_list_List_1_uncons();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
}
static void mb_std_list_List_1_for_1_1 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_f = v0;
	VAL v1 = pop_value();
	decref(v1);
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	push_value(v2);
	incref(var_f);
	run_value(var_f);
	decref(var_f);
	push_value(v3);
}
static void mb_std_prim_Str_ZToName_2 (void) {
	mw_mirth_name_Name_mangleZ_computeZBang();
}
static void mb_mirth_mirth_PropLabel_prop2_1_1 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_f = v0;
	VAL v1 = pop_value();
	decref(v1);
	mp_primZ_packZ_uncons();
	VAL v2 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	decref(v4);
	push_value(v3);
	push_value(v2);
	incref(var_f);
	run_value(var_f);
	decref(var_f);
}
static void mb_mirth_mirth_PropLabel_prop3_1_1 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_f = v0;
	VAL v1 = pop_value();
	decref(v1);
	mp_primZ_packZ_uncons();
	VAL v2 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v3 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v4 = pop_value();
	VAL v5 = pop_value();
	decref(v5);
	push_value(v4);
	push_value(v3);
	push_value(v2);
	incref(var_f);
	run_value(var_f);
	decref(var_f);
}
static void mb_mirth_mirth_PropLabel_prop0_1_1 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_f = v0;
	VAL v1 = pop_value();
	decref(v1);
	VAL v2 = pop_value();
	decref(v2);
	incref(var_f);
	run_value(var_f);
	decref(var_f);
}
static void mb_mirth_elab_abZ_buildZ_homZBang_1_1 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_f = v0;
	VAL v1 = pop_value();
	decref(v1);
	incref(var_f);
	run_value(var_f);
	mw_mirth_elab_abZ_unifyZ_typeZBang();
	decref(var_f);
}
static void mb_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1_2 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_f = v0;
	VAL v1 = pop_value();
	decref(v1);
	VAL v2 = pop_value();
	incref(v2);
	push_value(v2);
	mw_mirth_elab_guessZ_initialZ_ctxZ_type();
	incref(v2);
	push_value(v2);
	mw_mirth_word_Word_body();
	push_value(v2);
	mtw_mirth_arrow_Home_HomeWord();
	incref(var_f);
	VAL v3 = (var_f);
	push_value(v3);
	{
		VAL v4 = pop_value();
		VAL var_f = v4;
		VAL v5 = pop_value();
		VAL v6 = pop_value();
		mw_mirth_type_ArrowType_unpack();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		push_value(v7);
		push_value(v9);
		push_value(v8);
		push_value(v6);
		push_value(v5);
		VAL v10 = (MKFNPTR(&mb_mirth_elab_abZ_buildZ_homZBang_1_1));
		push_value(v10);
		incref(var_f);
		VAL v11 = (var_f);
		push_value(v11);
		mp_primZ_packZ_cons();
		{
			VAL v12 = pop_value();
			VAL var_f = v12;
			VAL v13 = pop_value();
			VAL v14 = pop_value();
			incref(v14);
			VAL v15 = pop_value();
			incref(v15);
			VAL v16 = pop_value();
			uint64_t v17 = (0LL /* Nil */);
			lpush(&lbl_home, v13);
			lpush(&lbl_tokenZ_start, v14);
			lpush(&lbl_tokenZ_end, v14);
			lpush(&lbl_dom, v15);
			lpush(&lbl_cod, v15);
			lpush(&lbl_ctx, v16);
			lpush(&lbl_atoms, MKU64(v17));
			mtw_mirth_arrow_Arrow_Arrow();
			VAL v18 = pop_value();
			lpush(&lbl_arrow, v18);
			mtw_mirth_elab_ZPlusAB_ZPlusAB();
			incref(var_f);
			run_value(var_f);
			mtp_mirth_elab_ZPlusAB_ZPlusAB();
			VAL v19 = (lpop(&lbl_arrow));
			decref(var_f);
			push_value(v19);
		}
		decref(var_f);
	}
	decref(var_f);
}
static void mb_mirth_elab_dataZ_getZ_labelZ_type_0 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_tag = v0;
	VAL v1 = pop_value();
	decref(v1);
	incref(var_tag);
	VAL v2 = (var_tag);
	push_value(v2);
	mw_mirth_data_Tag_outputZ_type();
	mw_mirth_type_TZMulZPlus();
	decref(var_tag);
}
static void mb_mirth_elab_elabZ_blockZ_atZBang_1 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_arrow_Block_ctx();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	push_value(v1);
	push_value(v2);
	push_value(v2);
	mw_mirth_arrow_Block_dom();
	VAL v3 = pop_value();
	VAL v4 = pop_value();
	incref(v4);
	push_value(v3);
	push_value(v4);
	push_value(v4);
	mw_mirth_arrow_Block_cod();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	incref(v6);
	push_value(v5);
	push_value(v6);
	push_value(v6);
	mw_mirth_arrow_Block_token();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v8);
	mw_mirth_arrow_Block_home();
	mw_mirth_elab_elabZ_arrowZ_homZBang();
}
static void mb_mirth_elab_elabZ_aliasZBang_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	incref(v1);
	lpush(&lbl_alias, v0);
	lpush(&lbl_target, v1);
	lpush(&lbl_token, v1);
	STRLIT("target", 6);
	VAL v2 = pop_value();
	uint64_t v3 = (0LL /* False */);
	uint64_t v4 = (0LL /* False */);
	lpush(&lbl_sort, v2);
	lpush(&lbl_reportZ_ambiguousZ_asZ_warning, MKU64(v3));
	lpush(&lbl_ignoreZ_lastZ_name, MKU64(v4));
	mw_mirth_elab_resolveZ_defZ_beginZBang();
	VAL v5 = (lpop(&lbl_alias));
	push_value(v5);
	mw_mirth_alias_Alias_arity();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	uint64_t v6 = (0LL /* Nil */);
	uint64_t v7 = (0LL /* Nil */);
	VAL v8 = pop_value();
	push_u64(v6);
	push_u64(v7);
	push_value(v8);
	mw_std_list_List_1_uncons();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	while(1) {
		VAL v11 = pop_value();
		incref(v11);
		push_value(v11);
		push_value(v11);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v12 = pop_value();
		if (!VBOOL(v12)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		VAL v17 = pop_value();
		incref(v17);
		incref(v13);
		VAL r18 = pop_resource();
		push_value(v17);
		push_value(v13);
		push_value(v17);
		push_value(v13);
		mw_mirth_def_Def_arity();
		push_resource(r18);
		mw_mirth_elab_arityZ_compatibleZAsk();
		VAL v19 = pop_value();
		if (VBOOL(v19)) {
			mtw_std_either_Either_2_Right();
		} else {
			mtw_mirth_elab_RejectedDef_RDz_WRONGz_ARITY();
			mtw_std_either_Either_2_Left();
		}
		VAL v20 = pop_value();
		push_value(v16);
		push_value(v15);
		push_value(v20);
		switch (get_top_data_tag()) {
			case 0LL: { // Left
				mtp_std_either_Either_2_Left();
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				push_value(v21);
				push_value(v23);
				mtw_std_list_List_1_Cons();
				push_value(v22);
			} break;
			case 1LL: { // Right
				mtp_std_either_Either_2_Right();
				VAL v24 = pop_value();
				VAL v25 = pop_value();
				push_value(v24);
				push_value(v25);
				mtw_std_list_List_1_Cons();
			} break;
			default: {
				push_value(mkstr("unexpected fallthrough in match\n", 32));
				mp_primZ_panic();
			}
		}
		push_value(v14);
		mw_std_list_List_1_uncons();
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		push_value(v26);
		push_value(v27);
	}
	VAL v28 = pop_value();
	decref(v28);
	VAL v29 = pop_value();
	decref(v29);
	VAL v30 = pop_value();
	mw_std_list_List_1_reverse();
	push_value(v30);
	mw_std_list_List_1_reverse();
	VAL v31 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL r32 = pop_resource();
	mw_std_list_List_1_cat();
	push_resource(r32);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL t = *p; *p = u; decref(t);
	}
	push_value(v31);
	{
		VAL v = top_resource();
		VAL u = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 7, v);
		VAL* p = &VTUP(v)->cells[3];
		VAL t = *p; *p = u; decref(t);
	}
	VAL v33 = pop_value();
	decref(v33);
	mw_mirth_elab_ZPlusResolveDef_filterZ_qualifiers();
	uint64_t v34 = (0LL /* Nil */);
	push_u64(v34);
	mw_mirth_elab_ZPlusResolveDef_filterZ_roots();
	mw_mirth_elab_resolveZ_defZ_endZBang();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_mirth_ZPlusMirth_panicZ_diagnosticsZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	switch (get_top_data_tag()) {
		case 0LL: { // DefAlias
			mtp_mirth_def_Def_DefAlias();
			mfld_mirth_alias_Alias_ZTildetarget();
			VAL v35 = (MKFNPTR(&mb_mirth_elab_elabZ_aliasZBang_6));
			push_value(v35);
			mw_mirth_mirth_Prop_1_forceZ_orZBang_1();
		} break;
		default: {
		} break;
	}
	VAL v36 = (lpop(&lbl_target));
	decref(v36);
}
static void mb_mirth_elab_elabZ_aliasZBang_6 (void) {
	VAL v0 = (lpop(&lbl_target));
	incref(v0);
	push_value(v0);
	lpush(&lbl_target, v0);
	STRLIT("Alias points to itself, circular aliases are not allowed.", 57);
	mw_mirth_mirth_ZPlusMirth_emitZ_fatalZ_errorZBang();
}
static void mb_mirth_elab_elabZ_defZBang_0 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_word_Word_sigZAsk();
	switch (get_top_data_tag()) {
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			VAL v1 = pop_value();
			VAL v2 = pop_value();
			decref(v2);
			push_value(v1);
			mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang();
			mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang();
			VAL v3 = pop_value();
			{
				VAL v = pop_resource();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[1];
				VAL u = *p;
				incref(u);
				push_resource(v);
				push_value(u);
			}
			VAL v4 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v4);
			mp_primZ_packZ_cons();
			push_value(v3);
			mp_primZ_packZ_cons();
			mw_mirth_elab_ZPlusTypeElab_rdrop();
		} break;
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_word_Word_arrow();
			mw_mirth_arrow_Arrow_ctxZ_type();
			VAL v5 = pop_value();
			VAL v6 = pop_value();
			mp_primZ_packZ_nil();
			push_value(v6);
			mp_primZ_packZ_cons();
			push_value(v5);
			mp_primZ_packZ_cons();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
}
static void mb_mirth_elab_elabZ_defZBang_2 (void) {
	mw_mirth_elab_elabZ_defZ_paramsZBang();
}
static void mb_mirth_elab_elabZ_defZBang_3 (void) {
	VAL v0 = pop_value();
	incref(v0);
	incref(v0);
	push_value(v0);
	push_value(v0);
	push_value(v0);
	VAL v1 = (MKFNPTR(&mb_mirth_elab_elabZ_defZBang_4));
	push_value(v1);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	VAL v2 = pop_value();
	incref(v2);
	VAL v3 = pop_value();
	push_value(v2);
	push_value(v3);
	push_value(v2);
	mw_mirth_elab_checkZ_inlineZ_recursionZ_arrowZBang();
}
static void mb_mirth_elab_elabZ_defZBang_4 (void) {
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	VAL r2 = pop_resource();
	push_value(v0);
	push_value(v1);
	mw_mirth_word_Word_params();
	VAL v3 = pop_value();
	incref(v3);
	push_resource(r2);
	push_value(v3);
	push_value(v3);
	mw_std_list_List_1_emptyZAsk();
	VAL v4 = pop_value();
	if (VBOOL(v4)) {
		VAL v5 = pop_value();
		decref(v5);
		mw_mirth_elab_elabZ_defZ_bodyZBang();
	} else {
		VAL v6 = pop_value();
		mw_mirth_elab_abZ_tokenZAt();
		incref(v6);
		mw_mirth_elab_abZ_ctxZAt();
		mw_mirth_elab_abZ_typeZAt();
		push_value(v6);
		mw_std_list_List_1_reverse();
		mw_std_list_List_1_uncons();
		VAL v7 = pop_value();
		VAL v8 = pop_value();
		push_value(v7);
		push_value(v8);
		while(1) {
			VAL v9 = pop_value();
			incref(v9);
			push_value(v9);
			push_value(v9);
			mw_std_maybe_Maybe_1_someZAsk();
			VAL v10 = pop_value();
			if (!VBOOL(v10)) break;
			mw_std_maybe_Maybe_1_unwrap();
			VAL v11 = pop_value();
			VAL v12 = pop_value();
			VAL v13 = pop_value();
			incref(v11);
			push_value(v11);
			mw_mirth_var_Ctx_new();
			push_value(v11);
			push_value(v13);
			mw_mirth_elab_abZ_tokenZAt();
			VAL r14 = pop_resource();
			mw_mirth_elab_elabZ_expandZ_tensorZBang();
			VAL v15 = pop_value();
			VAL v16 = pop_value();
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			push_resource(r14);
			push_value(v17);
			push_value(v16);
			push_value(v18);
			mw_mirth_var_Var_type();
			VAL r19 = pop_resource();
			push_value(v15);
			mw_mirth_elab_elabZ_typeZ_unifyZBang();
			VAL v20 = pop_value();
			decref(v20);
			VAL v21 = pop_value();
			decref(v21);
			push_resource(r19);
			push_value(v12);
			mw_std_list_List_1_uncons();
			VAL v22 = pop_value();
			VAL v23 = pop_value();
			push_value(v22);
			push_value(v23);
		}
		VAL v24 = pop_value();
		decref(v24);
		VAL v25 = pop_value();
		decref(v25);
		VAL v26 = pop_value();
		VAL v27 = pop_value();
		VAL v28 = pop_value();
		push_value(v27);
		push_value(v26);
		push_value(v28);
		mw_mirth_elab_abZ_homeZAt();
		VAL r29 = pop_resource();
		VAL v30 = pop_value();
		VAL v31 = pop_value();
		incref(v31);
		VAL v32 = pop_value();
		incref(v32);
		VAL v33 = pop_value();
		uint64_t v34 = (0LL /* Nil */);
		lpush(&lbl_home, v30);
		lpush(&lbl_tokenZ_start, v31);
		lpush(&lbl_tokenZ_end, v31);
		lpush(&lbl_dom, v32);
		lpush(&lbl_cod, v32);
		lpush(&lbl_ctx, v33);
		lpush(&lbl_atoms, MKU64(v34));
		mtw_mirth_arrow_Arrow_Arrow();
		VAL v35 = pop_value();
		lpush(&lbl_arrow, v35);
		mtw_mirth_elab_ZPlusAB_ZPlusAB();
		mw_mirth_elab_elabZ_defZ_bodyZBang();
		mtp_mirth_elab_ZPlusAB_ZPlusAB();
		VAL v36 = (lpop(&lbl_arrow));
		push_resource(r29);
		lpush(&lbl_params, v6);
		lpush(&lbl_body, v36);
		mw_mirth_elab_abZ_ctxZAt();
		VAL v37 = pop_value();
		lpush(&lbl_outerZ_ctx, v37);
		mw_mirth_elab_abZ_typeZAt();
		VAL v38 = pop_value();
		lpush(&lbl_dom, v38);
		mw_mirth_elab_abZ_tokenZAt();
		VAL v39 = pop_value();
		lpush(&lbl_token, v39);
		mtw_mirth_arrow_Lambda_Lambda();
		mtw_mirth_arrow_Op_OpLambda();
		mw_mirth_elab_abZ_opZBang();
	}
}
static void mb_mirth_elab_elabZ_defZ_typeZBang_2 (void) {
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang();
}
static void mb_mirth_elab_elabZ_variableZBang_1 (void) {
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang();
}
static void mb_mirth_elab_elabZ_fieldZBang_2 (void) {
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang();
}
static void mb_mirth_elab_elabZ_fieldZBang_3 (void) {
	mw_mirth_elab_elabZ_simpleZ_typeZ_argZBang();
}
static void mb_mirth_elab_elabZ_dataZ_headerZBang_2 (void) {
	mw_mirth_elab_elabZ_dataZ_paramsZBang();
}
static void mb_mirth_elab_elabZ_dataZ_tagZBang_1 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	push_value(v0);
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_headZAsk();
	mw_std_maybe_Maybe_1_unwrap();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	incref(v2);
	lpush(&lbl_token, v1);
	push_value(v2);
	push_value(v2);
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_params();
	mw_std_list_List_1_ZToCtx();
	VAL v3 = pop_value();
	uint64_t v4 = (1LL /* True */);
	uint64_t v5 = (0LL /* False */);
	lpush(&lbl_ctx, v3);
	lpush(&lbl_allowZ_implicitZ_typeZ_vars, MKU64(v4));
	lpush(&lbl_allowZ_typeZ_holes, MKU64(v5));
	mtw_mirth_elab_ZPlusTypeElab_ZPlusTypeElab();
	mw_mirth_type_T0();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	incref(v7);
	push_value(v7);
	push_value(v6);
	push_value(v7);
	mw_mirth_data_Tag_data();
	VAL r8 = pop_resource();
	mw_mirth_data_Data_fullZ_type();
	push_resource(r8);
	mw_mirth_type_TZMulZPlus();
	VAL v9 = pop_value();
	VAL v10 = pop_value();
	push_value(v9);
	push_value(v10);
	mw_mirth_data_Tag_sigZAsk();
	switch (get_top_data_tag()) {
		case 0LL: { // None
			(void)pop_u64();
			mw_mirth_type_T0();
		} break;
		case 1LL: { // Some
			mtp_std_maybe_Maybe_1_Some();
			{
				VAL v = top_resource();
				VAL u = pop_value();
				ASSERT1(IS_TUP(v), v);
				ASSERT1(VTUPLEN(v) == 5, v);
				VAL* p = &VTUP(v)->cells[2];
				VAL t = *p; *p = u; decref(t);
			}
			mw_mirth_type_T0();
			mw_mirth_elab_ZPlusTypeElab_elabZ_stackZ_typeZ_partsZBang();
		} break;
		default: {
			push_value(mkstr("unexpected fallthrough in match\n", 32));
			mp_primZ_panic();
		}
	}
	VAL v11 = pop_value();
	VAL v12 = pop_value();
	push_value(v11);
	push_value(v12);
	mw_mirth_type_TZ_ZTo();
	VAL v13 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v14 = pop_value();
	mp_primZ_packZ_nil();
	push_value(v14);
	mp_primZ_packZ_cons();
	push_value(v13);
	mp_primZ_packZ_cons();
	mw_mirth_elab_ZPlusTypeElab_rdrop();
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_5 (void) {
	mw_mirth_data_Tag_ctxZ_type();
	mw_mirth_type_ArrowType_unpack();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	push_value(v0);
	push_value(v1);
	mw_mirth_type_TZ_ZTo();
	VAL v2 = pop_value();
	VAL v3 = pop_value();
	mp_primZ_packZ_nil();
	push_value(v3);
	mp_primZ_packZ_cons();
	push_value(v2);
	mp_primZ_packZ_cons();
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_6 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_tag, v0);
	mw_mirth_data_Tag_untag();
	mw_std_maybe_Maybe_1_unwrap();
	VAL v1 = (MKFNPTR(&mb_mirth_elab_elabZ_dataZ_doneZBang_7));
	push_value(v1);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	VAL v2 = (lpop(&lbl_tag));
	decref(v2);
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_7 (void) {
	VAL v0 = (lpop(&lbl_tag));
	incref(v0);
	VAL r1 = pop_resource();
	push_value(v0);
	lpush(&lbl_tag, v0);
	mw_mirth_data_Tag_type();
	push_resource(r1);
	mw_mirth_type_ArrowType_dom();
	VAL v2 = pop_value();
	VAL v3 = (lpop(&lbl_tag));
	incref(v3);
	lpush(&lbl_cod, v2);
	push_value(v3);
	lpush(&lbl_tag, v3);
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_headZAsk();
	mw_std_maybe_Maybe_1_unwrap();
	VAL v4 = pop_value();
	lpush(&lbl_body, v4);
	mw_mirth_elab_abZ_ctxZAt();
	VAL v5 = pop_value();
	lpush(&lbl_ctx, v5);
	mw_mirth_elab_abZ_typeZAt();
	VAL v6 = pop_value();
	lpush(&lbl_dom, v6);
	mw_mirth_elab_abZ_tokenZAt();
	VAL v7 = pop_value();
	lpush(&lbl_token, v7);
	mw_mirth_elab_abZ_homeZAt();
	VAL v8 = pop_value();
	uint64_t v9 = (0LL /* Nil */);
	VAL r10 = pop_resource();
	lpush(&lbl_home, v8);
	lpush(&lbl_cases, MKU64(v9));
	mtw_mirth_match_ZPlusMatch_ZPlusMatch();
	VAL v11 = (lpop(&lbl_tag));
	incref(v11);
	push_value(v11);
	lpush(&lbl_tag, v11);
	mw_mirth_data_Tag_data();
	mw_mirth_data_Data_headZAsk();
	mw_std_maybe_Maybe_1_unwrap();
	VAL v12 = pop_value();
	incref(v12);
	push_value(v12);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v13 = pop_value();
	VAL v14 = pop_value();
	incref(v14);
	lpush(&lbl_home, v13);
	lpush(&lbl_tokenZ_start, v14);
	lpush(&lbl_tokenZ_end, v14);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[4];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v15 = pop_value();
	incref(v15);
	uint64_t v16 = (0LL /* Nil */);
	lpush(&lbl_outerZ_ctx, v15);
	lpush(&lbl_innerZ_ctx, v15);
	lpush(&lbl_saved, MKU64(v16));
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v17 = pop_value();
	incref(v17);
	uint64_t v18 = (0LL /* Nil */);
	lpush(&lbl_mid, v17);
	lpush(&lbl_cod, v17);
	lpush(&lbl_atoms, MKU64(v18));
	mtw_mirth_match_Pattern_Pattern();
	VAL r19 = pop_resource();
	mw_mirth_match_Pattern_thaw();
	VAL v20 = (lpop(&lbl_tag));
	incref(v20);
	push_value(v20);
	lpush(&lbl_tag, v20);
	mw_mirth_match_ZPlusPattern_tagZBang();
	mw_mirth_match_ZPlusPattern_freezze();
	VAL v21 = pop_value();
	incref(v21);
	push_resource(r19);
	push_value(v12);
	push_value(v21);
	lpush(&lbl_pattern, v21);
	{
		VAL v = pop_value();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 10, v);
		VAL* p = &VTUP(v)->cells[5];
		VAL u = *p;
		incref(u);
		decref(v);
		push_value(u);
	}
	VAL v22 = (lpop(&lbl_pattern));
	incref(v22);
	push_value(v22);
	lpush(&lbl_pattern, v22);
	mw_mirth_match_Pattern_dom();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[6];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	mw_mirth_type_TZ_ZTo();
	VAL v23 = pop_value();
	VAL v24 = pop_value();
	VAL v25 = pop_value();
	push_value(v24);
	push_value(v23);
	push_value(v25);
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 8, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v26 = (lpop(&lbl_pattern));
	VAL r27 = pop_resource();
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	mw_mirth_type_ArrowType_unpack();
	VAL v30 = pop_value();
	VAL v31 = pop_value();
	VAL v32 = pop_value();
	incref(v29);
	incref(v31);
	uint64_t v33 = (0LL /* Nil */);
	push_value(v30);
	lpush(&lbl_home, v28);
	lpush(&lbl_tokenZ_start, v29);
	lpush(&lbl_tokenZ_end, v29);
	lpush(&lbl_dom, v31);
	lpush(&lbl_cod, v31);
	lpush(&lbl_ctx, v32);
	lpush(&lbl_atoms, MKU64(v33));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v34 = pop_value();
	lpush(&lbl_arrow, v34);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v35 = pop_value();
	push_value(v35);
	mw_mirth_elab_abZ_unifyZ_typeZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v36 = (lpop(&lbl_arrow));
	push_resource(r27);
	lpush(&lbl_pattern, v26);
	lpush(&lbl_body, v36);
	mtw_mirth_match_Case_CASE();
	mw_mirth_match_ZPlusMatch_addZ_case();
	mw_mirth_match_ZPlusMatch_freezze();
	push_resource(r10);
	mtw_mirth_arrow_Op_OpMatch();
	mw_mirth_elab_abZ_opZBang();
}
static void mb_mirth_elab_elabZ_dataZ_doneZBang_12 (void) {
	VAL v0 = pop_value();
	incref(v0);
	push_value(v0);
	lpush(&lbl_dat, v0);
	mw_mirth_data_Data_isZ_unitZAsk();
	VAL v1 = pop_value();
	if (VBOOL(v1)) {
		uint64_t v2 = (5LL /* Phantom */);
		push_u64(v2);
		mtw_std_maybe_Maybe_1_Some();
	} else {
		VAL v3 = (lpop(&lbl_dat));
		incref(v3);
		push_value(v3);
		lpush(&lbl_dat, v3);
		mw_mirth_data_Data_isZ_enumZAsk();
		VAL v4 = pop_value();
		if (VBOOL(v4)) {
			STRLIT("int", 3);
			mtw_mirth_type_CType_IntLike();
			mtw_std_maybe_Maybe_1_Some();
		} else {
			VAL v5 = (lpop(&lbl_dat));
			incref(v5);
			push_value(v5);
			lpush(&lbl_dat, v5);
			mw_mirth_data_Data_isZ_semiZ_transparentZAsk();
			VAL v6 = pop_value();
			if (VBOOL(v6)) {
				VAL v7 = (lpop(&lbl_dat));
				incref(v7);
				push_value(v7);
				lpush(&lbl_dat, v7);
				mw_mirth_data_Data_tags();
				mw_std_list_List_1_ZDivL1();
				mw_std_maybe_Maybe_1_unwrap();
				mw_mirth_data_Tag_type();
				mw_mirth_type_ArrowType_dom();
				switch (get_top_data_tag()) {
					case 5LL: { // STCons
						mtp_mirth_type_StackType_STCons();
						VAL v8 = pop_value();
						VAL v9 = pop_value();
						decref(v9);
						push_value(v8);
						mw_mirth_type_Type_ctypeZAsk();
					} break;
					case 6LL: { // STConsLabel
						mtp_mirth_type_StackType_STConsLabel();
						VAL v10 = pop_value();
						decref(v10);
						VAL v11 = pop_value();
						VAL v12 = pop_value();
						decref(v12);
						push_value(v11);
						mw_mirth_type_Type_ctypeZAsk();
					} break;
					case 7LL: { // STWith
						mtp_mirth_type_StackType_STWith();
						VAL v13 = pop_value();
						VAL v14 = pop_value();
						decref(v14);
						push_value(v13);
						mw_mirth_type_Resource_ctypeZAsk();
					} break;
					case 8LL: { // STWithLabel
						mtp_mirth_type_StackType_STWithLabel();
						VAL v15 = pop_value();
						decref(v15);
						VAL v16 = pop_value();
						VAL v17 = pop_value();
						decref(v17);
						push_value(v16);
						mw_mirth_type_Resource_ctypeZAsk();
					} break;
					default: {
						STRLIT("unexpected tag inputs for transparent data", 42);
						mp_primZ_panic();
					} break;
				}
			} else {
				uint64_t v18 = (0LL /* None */);
				push_u64(v18);
			}
		}
	}
	VAL v19 = (lpop(&lbl_dat));
	decref(v19);
}
static void mb_mirth_elab_elabZ_defZ_head_3 (void) {
	mw_mirth_elab_elabZ_defZ_qnameZ_undefined();
}
static void mb_mirth_elab_createZ_projectorsZBang_0 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_tag = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_dat = v1;
	VAL v2 = pop_value();
	decref(v2);
	{
		VAL v3 = pop_value();
		VAL var_lbl = v3;
		incref(var_dat);
		VAL v4 = (var_dat);
		push_value(v4);
		incref(var_lbl);
		VAL v5 = (var_lbl);
		push_value(v5);
		mw_mirth_label_Label_name();
		int64_t v6 = (0LL);
		push_i64(v6);
		mw_mirth_data_dataZ_qname();
		mw_mirth_name_QName_undefinedZ_softZAsk();
		VAL v7 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_1));
		push_value(v7);
		incref(var_dat);
		VAL v8 = (var_dat);
		push_value(v8);
		mp_primZ_packZ_cons();
		incref(var_lbl);
		VAL v9 = (var_lbl);
		push_value(v9);
		mp_primZ_packZ_cons();
		incref(var_tag);
		VAL v10 = (var_tag);
		push_value(v10);
		mp_primZ_packZ_cons();
		{
			VAL v11 = pop_value();
			VAL var_f = v11;
			VAL v12 = pop_value();
			if (VBOOL(v12)) {
				incref(var_f);
				run_value(var_f);
			} else {
			}
			decref(var_f);
		}
		decref(var_lbl);
	}
	decref(var_tag);
	decref(var_dat);
}
static void mb_mirth_elab_createZ_projectorsZBang_1 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_tag = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_lbl = v1;
	mp_primZ_packZ_uncons();
	VAL v2 = pop_value();
	VAL var_dat = v2;
	VAL v3 = pop_value();
	decref(v3);
	incref(var_dat);
	VAL v4 = (var_dat);
	push_value(v4);
	incref(var_lbl);
	VAL v5 = (var_lbl);
	push_value(v5);
	mw_mirth_label_Label_ZToStr();
	int64_t v6 = (0LL);
	push_i64(v6);
	mw_mirth_elab_dataZ_wordZ_newZBang();
	incref(var_dat);
	VAL v7 = (var_dat);
	push_value(v7);
	incref(var_lbl);
	VAL v8 = (var_lbl);
	push_value(v8);
	mw_mirth_label_Label_ZToStr();
	STRLIT("!", 1);
	mp_primZ_strZ_cat();
	int64_t v9 = (0LL);
	push_i64(v9);
	mw_mirth_elab_dataZ_wordZ_newZBang();
	incref(var_dat);
	VAL v10 = (var_dat);
	push_value(v10);
	incref(var_lbl);
	VAL v11 = (var_lbl);
	push_value(v11);
	mw_mirth_label_Label_ZToStr();
	int64_t v12 = (1LL);
	push_i64(v12);
	mw_mirth_elab_dataZ_wordZ_newZBang();
	{
		VAL v13 = pop_value();
		VAL var_lblz_lens = v13;
		VAL v14 = pop_value();
		VAL var_lblz_set = v14;
		VAL v15 = pop_value();
		VAL var_lblz_get = v15;
		incref(var_lblz_get);
		VAL v16 = (var_lblz_get);
		push_value(v16);
		mw_mirth_word_Word_makeZ_inlineZBang();
		incref(var_lblz_get);
		VAL v17 = (var_lblz_get);
		push_value(v17);
		mtw_mirth_mirth_PropLabel_WordType();
		VAL v18 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_2));
		push_value(v18);
		incref(var_tag);
		VAL v19 = (var_tag);
		push_value(v19);
		mp_primZ_packZ_cons();
		incref(var_lbl);
		VAL v20 = (var_lbl);
		push_value(v20);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop0_1();
		incref(var_lblz_get);
		VAL v21 = (var_lblz_get);
		push_value(v21);
		mfld_mirth_word_Word_ZTildectxZ_type();
		mp_primZ_mutZ_set();
		incref(var_lblz_get);
		VAL v22 = (var_lblz_get);
		incref(v22);
		push_value(v22);
		push_value(v22);
		mtw_mirth_mirth_PropLabel_WordArrow();
		VAL v23 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_3));
		push_value(v23);
		incref(var_tag);
		VAL v24 = (var_tag);
		push_value(v24);
		mp_primZ_packZ_cons();
		incref(var_lbl);
		VAL v25 = (var_lbl);
		push_value(v25);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop_1();
		incref(var_lblz_get);
		VAL v26 = (var_lblz_get);
		push_value(v26);
		mfld_mirth_word_Word_ZTildearrow();
		mp_primZ_mutZ_set();
		incref(var_lblz_set);
		VAL v27 = (var_lblz_set);
		push_value(v27);
		mw_mirth_word_Word_makeZ_inlineZBang();
		incref(var_lblz_set);
		VAL v28 = (var_lblz_set);
		push_value(v28);
		mtw_mirth_mirth_PropLabel_WordType();
		VAL v29 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_5));
		push_value(v29);
		incref(var_tag);
		VAL v30 = (var_tag);
		push_value(v30);
		mp_primZ_packZ_cons();
		incref(var_lbl);
		VAL v31 = (var_lbl);
		push_value(v31);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop0_1();
		incref(var_lblz_set);
		VAL v32 = (var_lblz_set);
		push_value(v32);
		mfld_mirth_word_Word_ZTildectxZ_type();
		mp_primZ_mutZ_set();
		incref(var_lblz_set);
		VAL v33 = (var_lblz_set);
		incref(v33);
		push_value(v33);
		push_value(v33);
		mtw_mirth_mirth_PropLabel_WordArrow();
		VAL v34 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_6));
		push_value(v34);
		incref(var_tag);
		VAL v35 = (var_tag);
		push_value(v35);
		mp_primZ_packZ_cons();
		incref(var_lbl);
		VAL v36 = (var_lbl);
		push_value(v36);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop_1();
		incref(var_lblz_set);
		VAL v37 = (var_lblz_set);
		push_value(v37);
		mfld_mirth_word_Word_ZTildearrow();
		mp_primZ_mutZ_set();
		incref(var_lblz_lens);
		VAL v38 = (var_lblz_lens);
		push_value(v38);
		mw_mirth_word_Word_makeZ_inlineZBang();
		incref(var_lblz_lens);
		VAL v39 = (var_lblz_lens);
		push_value(v39);
		mtw_mirth_mirth_PropLabel_WordType();
		VAL v40 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_8));
		push_value(v40);
		incref(var_lbl);
		VAL v41 = (var_lbl);
		push_value(v41);
		mp_primZ_packZ_cons();
		incref(var_tag);
		VAL v42 = (var_tag);
		push_value(v42);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop0_1();
		incref(var_lblz_lens);
		VAL v43 = (var_lblz_lens);
		push_value(v43);
		mfld_mirth_word_Word_ZTildectxZ_type();
		mp_primZ_mutZ_set();
		incref(var_lblz_lens);
		VAL v44 = (var_lblz_lens);
		incref(v44);
		push_value(v44);
		push_value(v44);
		mtw_mirth_mirth_PropLabel_WordParams();
		VAL v45 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_9));
		push_value(v45);
		mw_mirth_mirth_PropLabel_prop_1();
		incref(var_lblz_lens);
		VAL v46 = (var_lblz_lens);
		push_value(v46);
		mfld_mirth_word_Word_ZTildeparams();
		mp_primZ_mutZ_set();
		incref(var_lblz_lens);
		VAL v47 = (var_lblz_lens);
		incref(v47);
		push_value(v47);
		push_value(v47);
		mtw_mirth_mirth_PropLabel_WordArrow();
		VAL v48 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_10));
		push_value(v48);
		incref(var_lblz_lens);
		VAL v49 = (var_lblz_lens);
		push_value(v49);
		mp_primZ_packZ_cons();
		incref(var_dat);
		VAL v50 = (var_dat);
		push_value(v50);
		mp_primZ_packZ_cons();
		incref(var_lblz_get);
		VAL v51 = (var_lblz_get);
		push_value(v51);
		mp_primZ_packZ_cons();
		incref(var_lblz_set);
		VAL v52 = (var_lblz_set);
		push_value(v52);
		mp_primZ_packZ_cons();
		mw_mirth_mirth_PropLabel_prop_1();
		incref(var_lblz_lens);
		VAL v53 = (var_lblz_lens);
		push_value(v53);
		mfld_mirth_word_Word_ZTildearrow();
		mp_primZ_mutZ_set();
		decref(var_lblz_lens);
		decref(var_lblz_set);
		decref(var_lblz_get);
	}
	decref(var_tag);
	decref(var_lbl);
	decref(var_dat);
}
static void mb_mirth_elab_createZ_projectorsZBang_2 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lbl = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_tag = v1;
	VAL v2 = pop_value();
	decref(v2);
	incref(var_tag);
	VAL v3 = (var_tag);
	push_value(v3);
	mw_mirth_data_Tag_ctx();
	incref(var_tag);
	VAL v4 = (var_tag);
	push_value(v4);
	incref(var_lbl);
	VAL v5 = (var_lbl);
	push_value(v5);
	mw_mirth_elab_dataZ_getZ_labelZ_type();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	mp_primZ_packZ_nil();
	push_value(v7);
	mp_primZ_packZ_cons();
	push_value(v6);
	mp_primZ_packZ_cons();
	decref(var_lbl);
	decref(var_tag);
}
static void mb_mirth_elab_createZ_projectorsZBang_3 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lbl = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_tag = v1;
	VAL v2 = pop_value();
	decref(v2);
	VAL v3 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_4));
	push_value(v3);
	incref(var_tag);
	VAL v4 = (var_tag);
	push_value(v4);
	mp_primZ_packZ_cons();
	incref(var_lbl);
	VAL v5 = (var_lbl);
	push_value(v5);
	mp_primZ_packZ_cons();
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	decref(var_lbl);
	decref(var_tag);
}
static void mb_mirth_elab_createZ_projectorsZBang_4 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lbl = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_tag = v1;
	VAL v2 = pop_value();
	decref(v2);
	incref(var_tag);
	VAL v3 = (var_tag);
	push_value(v3);
	incref(var_lbl);
	VAL v4 = (var_lbl);
	push_value(v4);
	mtw_mirth_arrow_Op_OpDataGetLabel();
	mw_mirth_elab_abZ_opZBang();
	decref(var_lbl);
	decref(var_tag);
}
static void mb_mirth_elab_createZ_projectorsZBang_5 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lbl = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_tag = v1;
	VAL v2 = pop_value();
	decref(v2);
	incref(var_tag);
	VAL v3 = (var_tag);
	push_value(v3);
	mw_mirth_data_Tag_ctx();
	incref(var_tag);
	VAL v4 = (var_tag);
	push_value(v4);
	incref(var_lbl);
	VAL v5 = (var_lbl);
	push_value(v5);
	mw_mirth_elab_dataZ_setZ_labelZ_type();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	mp_primZ_packZ_nil();
	push_value(v7);
	mp_primZ_packZ_cons();
	push_value(v6);
	mp_primZ_packZ_cons();
	decref(var_lbl);
	decref(var_tag);
}
static void mb_mirth_elab_createZ_projectorsZBang_6 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lbl = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_tag = v1;
	VAL v2 = pop_value();
	decref(v2);
	VAL v3 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_7));
	push_value(v3);
	incref(var_tag);
	VAL v4 = (var_tag);
	push_value(v4);
	mp_primZ_packZ_cons();
	incref(var_lbl);
	VAL v5 = (var_lbl);
	push_value(v5);
	mp_primZ_packZ_cons();
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	decref(var_lbl);
	decref(var_tag);
}
static void mb_mirth_elab_createZ_projectorsZBang_7 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lbl = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_tag = v1;
	VAL v2 = pop_value();
	decref(v2);
	incref(var_tag);
	VAL v3 = (var_tag);
	push_value(v3);
	incref(var_lbl);
	VAL v4 = (var_lbl);
	push_value(v4);
	mtw_mirth_arrow_Op_OpDataSetLabel();
	mw_mirth_elab_abZ_opZBang();
	decref(var_lbl);
	decref(var_tag);
}
static void mb_mirth_elab_createZ_projectorsZBang_8 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_tag = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_lbl = v1;
	VAL v2 = pop_value();
	decref(v2);
	mw_mirth_type_TYPEz_STACK();
	STRLIT("*x", 2);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	mw_mirth_type_TYPEz_STACK();
	STRLIT("*y", 2);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZBang();
	incref(var_lbl);
	VAL v3 = (var_lbl);
	push_value(v3);
	incref(var_tag);
	VAL v4 = (var_tag);
	push_value(v4);
	mw_mirth_data_Tag_projectZ_inputZ_label();
	mw_std_maybe_Maybe_1_unwrap();
	incref(var_tag);
	VAL v5 = (var_tag);
	push_value(v5);
	mw_mirth_data_Tag_outputZ_type();
	{
		VAL v6 = pop_value();
		VAL var_datty = v6;
		VAL v7 = pop_value();
		VAL var_lblty = v7;
		VAL v8 = pop_value();
		VAL var_sy = v8;
		VAL v9 = pop_value();
		VAL var_sx = v9;
		incref(var_tag);
		VAL v10 = (var_tag);
		push_value(v10);
		mw_mirth_data_Tag_ctx();
		incref(var_sx);
		VAL v11 = (var_sx);
		push_value(v11);
		incref(var_sy);
		VAL v12 = (var_sy);
		uint64_t v13 = (0LL /* Nil */);
		push_value(v12);
		push_u64(v13);
		mtw_std_list_List_1_Cons();
		mtw_std_list_List_1_Cons();
		mw_std_list_List_1_cat();
		incref(var_sx);
		VAL v14 = (var_sx);
		push_value(v14);
		mtw_mirth_type_StackType_STVar();
		incref(var_datty);
		VAL v15 = (var_datty);
		push_value(v15);
		mw_mirth_type_TZMulZPlus();
		incref(var_sx);
		VAL v16 = (var_sx);
		push_value(v16);
		mtw_mirth_type_StackType_STVar();
		incref(var_lblty);
		VAL v17 = (var_lblty);
		push_value(v17);
		mw_mirth_type_TZMulZPlus();
		incref(var_sy);
		VAL v18 = (var_sy);
		push_value(v18);
		mtw_mirth_type_StackType_STVar();
		incref(var_lblty);
		VAL v19 = (var_lblty);
		push_value(v19);
		mw_mirth_type_TZMulZPlus();
		mw_mirth_type_TZ_ZTo();
		mtw_mirth_type_Type_TMorphism();
		mw_mirth_type_TZMul();
		incref(var_sy);
		VAL v20 = (var_sy);
		push_value(v20);
		mtw_mirth_type_StackType_STVar();
		incref(var_datty);
		VAL v21 = (var_datty);
		push_value(v21);
		mw_mirth_type_TZMulZPlus();
		mw_mirth_type_TZ_ZTo();
		VAL v22 = pop_value();
		VAL v23 = pop_value();
		mp_primZ_packZ_nil();
		push_value(v23);
		mp_primZ_packZ_cons();
		push_value(v22);
		mp_primZ_packZ_cons();
		decref(var_datty);
		decref(var_lblty);
		decref(var_sy);
		decref(var_sx);
	}
	decref(var_tag);
	decref(var_lbl);
}
static void mb_mirth_elab_createZ_projectorsZBang_9 (void) {
	mw_mirth_word_Word_type();
	mw_mirth_type_ArrowType_dom();
	mw_mirth_type_StackType_forceZ_consZAskZBang();
	mw_std_maybe_Maybe_1_unwrap();
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL v2 = pop_value();
	decref(v2);
	decref(v1);
	push_value(v0);
	STRLIT("f", 1);
	mw_std_prim_Str_ZToName();
	mw_mirth_var_Var_newZ_autoZ_runZBang();
	uint64_t v3 = (0LL /* Nil */);
	push_u64(v3);
	mtw_std_list_List_1_Cons();
}
static void mb_mirth_elab_createZ_projectorsZBang_10 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lblz_set = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_lblz_get = v1;
	mp_primZ_packZ_uncons();
	VAL v2 = pop_value();
	VAL var_dat = v2;
	mp_primZ_packZ_uncons();
	VAL v3 = pop_value();
	VAL var_lblz_lens = v3;
	VAL v4 = pop_value();
	decref(v4);
	VAL v5 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_11));
	push_value(v5);
	incref(var_lblz_lens);
	VAL v6 = (var_lblz_lens);
	push_value(v6);
	mp_primZ_packZ_cons();
	incref(var_dat);
	VAL v7 = (var_dat);
	push_value(v7);
	mp_primZ_packZ_cons();
	incref(var_lblz_get);
	VAL v8 = (var_lblz_get);
	push_value(v8);
	mp_primZ_packZ_cons();
	incref(var_lblz_set);
	VAL v9 = (var_lblz_set);
	push_value(v9);
	mp_primZ_packZ_cons();
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
	decref(var_lblz_set);
	decref(var_lblz_get);
	decref(var_dat);
	decref(var_lblz_lens);
}
static void mb_mirth_elab_createZ_projectorsZBang_11 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lblz_set = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_lblz_get = v1;
	mp_primZ_packZ_uncons();
	VAL v2 = pop_value();
	VAL var_dat = v2;
	mp_primZ_packZ_uncons();
	VAL v3 = pop_value();
	VAL var_lblz_lens = v3;
	VAL v4 = pop_value();
	decref(v4);
	incref(var_lblz_lens);
	VAL v5 = (var_lblz_lens);
	VAL r6 = pop_resource();
	push_value(v5);
	mw_mirth_word_Word_params();
	VAL v7 = pop_value();
	incref(v7);
	push_resource(r6);
	push_value(v7);
	push_value(v7);
	VAL v8 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_13));
	push_value(v8);
	incref(var_dat);
	VAL v9 = (var_dat);
	push_value(v9);
	mp_primZ_packZ_cons();
	incref(var_lblz_get);
	VAL v10 = (var_lblz_get);
	push_value(v10);
	mp_primZ_packZ_cons();
	incref(var_lblz_set);
	VAL v11 = (var_lblz_set);
	push_value(v11);
	mp_primZ_packZ_cons();
	{
		VAL v12 = pop_value();
		VAL var_f = v12;
		VAL v13 = pop_value();
		mw_mirth_elab_abZ_tokenZAt();
		push_value(v13);
		incref(var_f);
		VAL v14 = (var_f);
		push_value(v14);
		{
			VAL v15 = pop_value();
			VAL var_f = v15;
			VAL v16 = pop_value();
			incref(v16);
			mw_mirth_elab_abZ_ctxZAt();
			mw_mirth_elab_abZ_typeZAt();
			push_value(v16);
			mw_std_list_List_1_reverse();
			mw_std_list_List_1_uncons();
			VAL v17 = pop_value();
			VAL v18 = pop_value();
			push_value(v17);
			push_value(v18);
			while(1) {
				VAL v19 = pop_value();
				incref(v19);
				push_value(v19);
				push_value(v19);
				mw_std_maybe_Maybe_1_someZAsk();
				VAL v20 = pop_value();
				if (!VBOOL(v20)) break;
				mw_std_maybe_Maybe_1_unwrap();
				VAL v21 = pop_value();
				VAL v22 = pop_value();
				VAL v23 = pop_value();
				incref(v21);
				push_value(v21);
				mw_mirth_var_Ctx_new();
				push_value(v21);
				push_value(v23);
				mw_mirth_elab_abZ_tokenZAt();
				VAL r24 = pop_resource();
				mw_mirth_elab_elabZ_expandZ_tensorZBang();
				VAL v25 = pop_value();
				VAL v26 = pop_value();
				VAL v27 = pop_value();
				VAL v28 = pop_value();
				push_resource(r24);
				push_value(v27);
				push_value(v26);
				push_value(v28);
				mw_mirth_var_Var_type();
				VAL r29 = pop_resource();
				push_value(v25);
				mw_mirth_elab_elabZ_typeZ_unifyZBang();
				VAL v30 = pop_value();
				decref(v30);
				VAL v31 = pop_value();
				decref(v31);
				push_resource(r29);
				push_value(v22);
				mw_std_list_List_1_uncons();
				VAL v32 = pop_value();
				VAL v33 = pop_value();
				push_value(v32);
				push_value(v33);
			}
			VAL v34 = pop_value();
			decref(v34);
			VAL v35 = pop_value();
			decref(v35);
			VAL v36 = pop_value();
			VAL v37 = pop_value();
			VAL v38 = pop_value();
			push_value(v37);
			push_value(v36);
			push_value(v38);
			mw_mirth_elab_abZ_homeZAt();
			VAL r39 = pop_resource();
			incref(var_f);
			VAL v40 = (var_f);
			push_value(v40);
			{
				VAL v41 = pop_value();
				VAL var_f = v41;
				VAL v42 = pop_value();
				VAL v43 = pop_value();
				incref(v43);
				VAL v44 = pop_value();
				incref(v44);
				VAL v45 = pop_value();
				uint64_t v46 = (0LL /* Nil */);
				lpush(&lbl_home, v42);
				lpush(&lbl_tokenZ_start, v43);
				lpush(&lbl_tokenZ_end, v43);
				lpush(&lbl_dom, v44);
				lpush(&lbl_cod, v44);
				lpush(&lbl_ctx, v45);
				lpush(&lbl_atoms, MKU64(v46));
				mtw_mirth_arrow_Arrow_Arrow();
				VAL v47 = pop_value();
				lpush(&lbl_arrow, v47);
				mtw_mirth_elab_ZPlusAB_ZPlusAB();
				incref(var_f);
				run_value(var_f);
				mtp_mirth_elab_ZPlusAB_ZPlusAB();
				VAL v48 = (lpop(&lbl_arrow));
				decref(var_f);
				push_value(v48);
			}
			VAL v49 = pop_value();
			push_resource(r39);
			lpush(&lbl_params, v16);
			lpush(&lbl_body, v49);
			mw_mirth_elab_abZ_ctxZAt();
			VAL v50 = pop_value();
			lpush(&lbl_outerZ_ctx, v50);
			mw_mirth_elab_abZ_typeZAt();
			VAL v51 = pop_value();
			lpush(&lbl_dom, v51);
			mw_mirth_elab_abZ_tokenZAt();
			VAL v52 = pop_value();
			lpush(&lbl_token, v52);
			mtw_mirth_arrow_Lambda_Lambda();
			mtw_mirth_arrow_Op_OpLambda();
			mw_mirth_elab_abZ_opZBang();
			decref(var_f);
		}
		decref(var_f);
	}
	decref(var_lblz_set);
	decref(var_lblz_get);
	decref(var_dat);
	decref(var_lblz_lens);
}
static void mb_mirth_elab_createZ_projectorsZBang_13 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lblz_set = v0;
	mp_primZ_packZ_uncons();
	VAL v1 = pop_value();
	VAL var_lblz_get = v1;
	mp_primZ_packZ_uncons();
	VAL v2 = pop_value();
	VAL var_dat = v2;
	VAL v3 = pop_value();
	decref(v3);
	mw_std_list_List_1_ZDivL1();
	mw_std_maybe_Maybe_1_unwrap();
	VAL v4 = pop_value();
	lpush(&lbl_f, v4);
	incref(var_dat);
	VAL v5 = (var_dat);
	push_value(v5);
	mw_mirth_data_Data_isZ_resourceZAsk();
	VAL v6 = pop_value();
	if (VBOOL(v6)) {
		incref(var_lblz_get);
		VAL v7 = (var_lblz_get);
		push_value(v7);
		mw_mirth_elab_abZ_wordZBang();
		mw_mirth_elab_abZ_tokenZAt();
		mw_mirth_elab_abZ_ctxZAt();
		mw_mirth_type_MetaVar_newZBang();
		mtw_mirth_type_StackType_STMeta();
		VAL v8 = pop_value();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		push_value(v9);
		push_value(v8);
		push_value(v10);
		mw_mirth_elab_abZ_homeZAt();
		VAL r11 = pop_resource();
		VAL v12 = pop_value();
		VAL v13 = pop_value();
		incref(v13);
		VAL v14 = pop_value();
		incref(v14);
		VAL v15 = pop_value();
		uint64_t v16 = (0LL /* Nil */);
		lpush(&lbl_home, v12);
		lpush(&lbl_tokenZ_start, v13);
		lpush(&lbl_tokenZ_end, v13);
		lpush(&lbl_dom, v14);
		lpush(&lbl_cod, v14);
		lpush(&lbl_ctx, v15);
		lpush(&lbl_atoms, MKU64(v16));
		mtw_mirth_arrow_Arrow_Arrow();
		VAL v17 = pop_value();
		lpush(&lbl_arrow, v17);
		mtw_mirth_elab_ZPlusAB_ZPlusAB();
		VAL v18 = (lpop(&lbl_f));
		push_value(v18);
		mw_mirth_elab_abZ_varZBang();
		mtp_mirth_elab_ZPlusAB_ZPlusAB();
		VAL v19 = (lpop(&lbl_arrow));
		push_value(v19);
		mw_mirth_arrow_Block_newZBang();
		push_resource(r11);
		mtw_mirth_arrow_Op_OpBlockPush();
		mw_mirth_elab_abZ_opZBang();
		uint64_t v20 = (13LL /* PRIM_CORE_RDIP */);
		push_u64(v20);
		mw_mirth_elab_abZ_primZBang();
		incref(var_lblz_set);
		VAL v21 = (var_lblz_set);
		push_value(v21);
		mw_mirth_elab_abZ_wordZBang();
	} else {
		uint64_t v22 = (1LL /* PRIM_CORE_DUP */);
		push_u64(v22);
		mw_mirth_elab_abZ_primZBang();
		VAL v23 = (MKFNPTR(&mb_mirth_elab_createZ_projectorsZBang_17));
		push_value(v23);
		incref(var_lblz_get);
		VAL v24 = (var_lblz_get);
		push_value(v24);
		mp_primZ_packZ_cons();
		{
			VAL v25 = pop_value();
			VAL var_f = v25;
			incref(var_f);
			VAL v26 = (var_f);
			push_value(v26);
			{
				VAL v27 = pop_value();
				VAL var_f = v27;
				mw_mirth_elab_abZ_tokenZAt();
				incref(var_f);
				VAL v28 = (var_f);
				push_value(v28);
				{
					VAL v29 = pop_value();
					VAL var_f = v29;
					mw_mirth_elab_abZ_ctxZAt();
					mw_mirth_type_MetaVar_newZBang();
					mtw_mirth_type_StackType_STMeta();
					VAL v30 = pop_value();
					VAL v31 = pop_value();
					VAL v32 = pop_value();
					push_value(v31);
					push_value(v30);
					push_value(v32);
					mw_mirth_elab_abZ_homeZAt();
					VAL r33 = pop_resource();
					incref(var_f);
					VAL v34 = (var_f);
					push_value(v34);
					{
						VAL v35 = pop_value();
						VAL var_f = v35;
						VAL v36 = pop_value();
						VAL v37 = pop_value();
						incref(v37);
						VAL v38 = pop_value();
						incref(v38);
						VAL v39 = pop_value();
						uint64_t v40 = (0LL /* Nil */);
						lpush(&lbl_home, v36);
						lpush(&lbl_tokenZ_start, v37);
						lpush(&lbl_tokenZ_end, v37);
						lpush(&lbl_dom, v38);
						lpush(&lbl_cod, v38);
						lpush(&lbl_ctx, v39);
						lpush(&lbl_atoms, MKU64(v40));
						mtw_mirth_arrow_Arrow_Arrow();
						VAL v41 = pop_value();
						lpush(&lbl_arrow, v41);
						mtw_mirth_elab_ZPlusAB_ZPlusAB();
						incref(var_f);
						run_value(var_f);
						mtp_mirth_elab_ZPlusAB_ZPlusAB();
						VAL v42 = (lpop(&lbl_arrow));
						decref(var_f);
						push_value(v42);
					}
					mw_mirth_arrow_Block_newZBang();
					push_resource(r33);
					mtw_mirth_arrow_Op_OpBlockPush();
					mw_mirth_elab_abZ_opZBang();
					decref(var_f);
				}
				decref(var_f);
			}
			uint64_t v43 = (4LL /* PRIM_CORE_DIP */);
			push_u64(v43);
			mw_mirth_elab_abZ_primZBang();
			decref(var_f);
		}
		incref(var_lblz_set);
		VAL v44 = (var_lblz_set);
		push_value(v44);
		mw_mirth_elab_abZ_wordZBang();
	}
	decref(var_lblz_set);
	decref(var_lblz_get);
	decref(var_dat);
}
static void mb_mirth_elab_createZ_projectorsZBang_17 (void) {
	mp_primZ_packZ_uncons();
	VAL v0 = pop_value();
	VAL var_lblz_get = v0;
	VAL v1 = pop_value();
	decref(v1);
	incref(var_lblz_get);
	VAL v2 = (var_lblz_get);
	push_value(v2);
	mw_mirth_elab_abZ_wordZBang();
	VAL v3 = (lpop(&lbl_f));
	push_value(v3);
	mw_mirth_elab_abZ_varZBang();
	decref(var_lblz_get);
}
static void mb_mirth_elab_elabZ_externalZ_defZBang_2 (void) {
	mw_mirth_external_External_sig();
	mw_mirth_elab_ZPlusTypeElab_typeZ_sigZ_startZBang();
	mw_mirth_elab_ZPlusTypeElab_elabZ_typeZ_sigZBang();
	VAL v0 = pop_value();
	{
		VAL v = pop_resource();
		ASSERT1(IS_TUP(v), v);
		ASSERT1(VTUPLEN(v) == 5, v);
		VAL* p = &VTUP(v)->cells[1];
		VAL u = *p;
		incref(u);
		push_resource(v);
		push_value(u);
	}
	VAL v1 = pop_value();
	mp_primZ_packZ_nil();
	push_value(v1);
	mp_primZ_packZ_cons();
	push_value(v0);
	mp_primZ_packZ_cons();
	mw_mirth_elab_ZPlusTypeElab_rdrop();
}
static void mb_mirth_elab_elabZ_externalZ_defZBang_4 (void) {
	mw_mirth_elab_elabZ_defZ_externalZ_ctype();
}
static void mb_mirth_specializzer_specializzeZ_wordZBang_1 (void) {
	mw_mirth_word_Word_ctxZ_type();
	mw_mirth_specializzer_specializzeZ_ctxZ_type();
	VAL v0 = pop_value();
	VAL v1 = pop_value();
	mp_primZ_packZ_nil();
	push_value(v1);
	mp_primZ_packZ_cons();
	push_value(v0);
	mp_primZ_packZ_cons();
}
static void mb_mirth_specializzer_specializzeZ_wordZBang_2 (void) {
	VAL v0 = (MKFNPTR(&mb_mirth_specializzer_specializzeZ_wordZBang_3));
	push_value(v0);
	mw_mirth_elab_abZ_buildZ_wordZ_arrowZBang_1();
}
static void mb_mirth_specializzer_specializzeZ_wordZBang_3 (void) {
	VAL v0 = pop_value();
	mw_mirth_specializzer_synthZ_specializzedZ_wordZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_embedZ_strZBangZDot58ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_contents));
	push_value(v1);
	mw_mirth_elab_abZ_strZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot57ZRParen_0 (void) {
	VAL v0 = pop_value();
	uint64_t v1 = (0LL /* CoerceUnsafe */);
	push_u64(v1);
	mw_mirth_elab_abZ_coerceZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDotelabZ_dataZ_doneZBangZDot24ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_dat));
	incref(v1);
	push_value(v1);
	lpush(&lbl_dat, v1);
	mtw_mirth_arrow_Op_OpDataGetTag();
	mw_mirth_elab_abZ_opZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot373ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	VAL v2 = (lpop(&lbl_tbl));
	incref(v2);
	push_value(v2);
	lpush(&lbl_tbl, v2);
	mw_mirth_table_Table_numZ_buffer();
	mw_mirth_elab_abZ_bufferZBang();
	uint64_t v3 = (76LL /* PRIM_U64_GET */);
	push_u64(v3);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v4 = (0LL /* CoerceUnsafe */);
	push_u64(v4);
	mw_mirth_elab_abZ_coerceZBang();
	int64_t v5 = (1LL);
	push_i64(v5);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v6 = (16LL /* PRIM_INT_ADD */);
	push_u64(v6);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v7 = (1LL /* PRIM_CORE_DUP */);
	push_u64(v7);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v8 = (0LL /* CoerceUnsafe */);
	push_u64(v8);
	mw_mirth_elab_abZ_coerceZBang();
	VAL v9 = (lpop(&lbl_tbl));
	incref(v9);
	push_value(v9);
	lpush(&lbl_tbl, v9);
	mw_mirth_table_Table_numZ_buffer();
	mw_mirth_elab_abZ_bufferZBang();
	uint64_t v10 = (77LL /* PRIM_U64_SET */);
	push_u64(v10);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v11 = (0LL /* CoerceUnsafe */);
	push_u64(v11);
	mw_mirth_elab_abZ_coerceZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot303ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	VAL v2 = (lpop(&lbl_vx));
	incref(v2);
	uint64_t v3 = (0LL /* Nil */);
	push_value(v2);
	lpush(&lbl_vx, v2);
	push_u64(v3);
	mtw_std_list_List_1_Cons();
	VAL v4 = pop_value();
	mw_mirth_elab_abZ_tokenZAt();
	incref(v4);
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_elab_abZ_typeZAt();
	push_value(v4);
	mw_std_list_List_1_reverse();
	mw_std_list_List_1_uncons();
	VAL v5 = pop_value();
	VAL v6 = pop_value();
	push_value(v5);
	push_value(v6);
	while(1) {
		VAL v7 = pop_value();
		incref(v7);
		push_value(v7);
		push_value(v7);
		mw_std_maybe_Maybe_1_someZAsk();
		VAL v8 = pop_value();
		if (!VBOOL(v8)) break;
		mw_std_maybe_Maybe_1_unwrap();
		VAL v9 = pop_value();
		VAL v10 = pop_value();
		VAL v11 = pop_value();
		incref(v9);
		push_value(v9);
		mw_mirth_var_Ctx_new();
		push_value(v9);
		push_value(v11);
		mw_mirth_elab_abZ_tokenZAt();
		VAL r12 = pop_resource();
		mw_mirth_elab_elabZ_expandZ_tensorZBang();
		VAL v13 = pop_value();
		VAL v14 = pop_value();
		VAL v15 = pop_value();
		VAL v16 = pop_value();
		push_resource(r12);
		push_value(v15);
		push_value(v14);
		push_value(v16);
		mw_mirth_var_Var_type();
		VAL r17 = pop_resource();
		push_value(v13);
		mw_mirth_elab_elabZ_typeZ_unifyZBang();
		VAL v18 = pop_value();
		decref(v18);
		VAL v19 = pop_value();
		decref(v19);
		push_resource(r17);
		push_value(v10);
		mw_std_list_List_1_uncons();
		VAL v20 = pop_value();
		VAL v21 = pop_value();
		push_value(v20);
		push_value(v21);
	}
	VAL v22 = pop_value();
	decref(v22);
	VAL v23 = pop_value();
	decref(v23);
	VAL v24 = pop_value();
	VAL v25 = pop_value();
	VAL v26 = pop_value();
	push_value(v25);
	push_value(v24);
	push_value(v26);
	mw_mirth_elab_abZ_homeZAt();
	VAL r27 = pop_resource();
	VAL v28 = pop_value();
	VAL v29 = pop_value();
	incref(v29);
	VAL v30 = pop_value();
	incref(v30);
	VAL v31 = pop_value();
	uint64_t v32 = (0LL /* Nil */);
	lpush(&lbl_home, v28);
	lpush(&lbl_tokenZ_start, v29);
	lpush(&lbl_tokenZ_end, v29);
	lpush(&lbl_dom, v30);
	lpush(&lbl_cod, v30);
	lpush(&lbl_ctx, v31);
	lpush(&lbl_atoms, MKU64(v32));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v33 = pop_value();
	lpush(&lbl_arrow, v33);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	int64_t v34 = (1LL);
	push_i64(v34);
	mw_mirth_elab_abZ_intZBang();
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v35 = pop_value();
	VAL v36 = pop_value();
	VAL v37 = pop_value();
	push_value(v36);
	push_value(v35);
	push_value(v37);
	mw_mirth_elab_abZ_homeZAt();
	VAL r38 = pop_resource();
	VAL v39 = pop_value();
	VAL v40 = pop_value();
	incref(v40);
	VAL v41 = pop_value();
	incref(v41);
	VAL v42 = pop_value();
	uint64_t v43 = (0LL /* Nil */);
	lpush(&lbl_home, v39);
	lpush(&lbl_tokenZ_start, v40);
	lpush(&lbl_tokenZ_end, v40);
	lpush(&lbl_dom, v41);
	lpush(&lbl_cod, v41);
	lpush(&lbl_ctx, v42);
	lpush(&lbl_atoms, MKU64(v43));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v44 = pop_value();
	lpush(&lbl_arrow, v44);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	uint64_t v45 = (1LL /* PRIM_CORE_DUP */);
	push_u64(v45);
	mw_mirth_elab_abZ_primZBang();
	VAL v46 = (lpop(&lbl_tbl));
	incref(v46);
	push_value(v46);
	lpush(&lbl_tbl, v46);
	mw_mirth_table_Table_numZ_buffer();
	mw_mirth_elab_abZ_bufferZBang();
	uint64_t v47 = (76LL /* PRIM_U64_GET */);
	push_u64(v47);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v48 = (0LL /* CoerceUnsafe */);
	push_u64(v48);
	mw_mirth_elab_abZ_coerceZBang();
	int64_t v49 = (1LL);
	push_i64(v49);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v50 = (16LL /* PRIM_INT_ADD */);
	push_u64(v50);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v51 = (15LL /* PRIM_INT_LT */);
	push_u64(v51);
	mw_mirth_elab_abZ_primZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v52 = (lpop(&lbl_arrow));
	push_value(v52);
	mw_mirth_arrow_Block_newZBang();
	push_resource(r38);
	mtw_mirth_arrow_Op_OpBlockPush();
	mw_mirth_elab_abZ_opZBang();
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v53 = pop_value();
	VAL v54 = pop_value();
	VAL v55 = pop_value();
	push_value(v54);
	push_value(v53);
	push_value(v55);
	mw_mirth_elab_abZ_homeZAt();
	VAL r56 = pop_resource();
	VAL v57 = pop_value();
	VAL v58 = pop_value();
	incref(v58);
	VAL v59 = pop_value();
	incref(v59);
	VAL v60 = pop_value();
	uint64_t v61 = (0LL /* Nil */);
	lpush(&lbl_home, v57);
	lpush(&lbl_tokenZ_start, v58);
	lpush(&lbl_tokenZ_end, v58);
	lpush(&lbl_dom, v59);
	lpush(&lbl_cod, v59);
	lpush(&lbl_ctx, v60);
	lpush(&lbl_atoms, MKU64(v61));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v62 = pop_value();
	lpush(&lbl_arrow, v62);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	uint64_t v63 = (1LL /* PRIM_CORE_DUP */);
	push_u64(v63);
	mw_mirth_elab_abZ_primZBang();
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v64 = pop_value();
	VAL v65 = pop_value();
	VAL v66 = pop_value();
	push_value(v65);
	push_value(v64);
	push_value(v66);
	mw_mirth_elab_abZ_homeZAt();
	VAL r67 = pop_resource();
	VAL v68 = pop_value();
	VAL v69 = pop_value();
	incref(v69);
	VAL v70 = pop_value();
	incref(v70);
	VAL v71 = pop_value();
	uint64_t v72 = (0LL /* Nil */);
	lpush(&lbl_home, v68);
	lpush(&lbl_tokenZ_start, v69);
	lpush(&lbl_tokenZ_end, v69);
	lpush(&lbl_dom, v70);
	lpush(&lbl_cod, v70);
	lpush(&lbl_ctx, v71);
	lpush(&lbl_atoms, MKU64(v72));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v73 = pop_value();
	lpush(&lbl_arrow, v73);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	uint64_t v74 = (0LL /* CoerceUnsafe */);
	push_u64(v74);
	mw_mirth_elab_abZ_coerceZBang();
	VAL v75 = (lpop(&lbl_vx));
	incref(v75);
	push_value(v75);
	lpush(&lbl_vx, v75);
	mw_mirth_elab_abZ_varZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v76 = (lpop(&lbl_arrow));
	push_value(v76);
	mw_mirth_arrow_Block_newZBang();
	push_resource(r67);
	mtw_mirth_arrow_Op_OpBlockPush();
	mw_mirth_elab_abZ_opZBang();
	uint64_t v77 = (4LL /* PRIM_CORE_DIP */);
	push_u64(v77);
	mw_mirth_elab_abZ_primZBang();
	int64_t v78 = (1LL);
	push_i64(v78);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v79 = (16LL /* PRIM_INT_ADD */);
	push_u64(v79);
	mw_mirth_elab_abZ_primZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v80 = (lpop(&lbl_arrow));
	push_value(v80);
	mw_mirth_arrow_Block_newZBang();
	push_resource(r56);
	mtw_mirth_arrow_Op_OpBlockPush();
	mw_mirth_elab_abZ_opZBang();
	uint64_t v81 = (6LL /* PRIM_CORE_WHILE */);
	push_u64(v81);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v82 = (2LL /* PRIM_CORE_DROP */);
	push_u64(v82);
	mw_mirth_elab_abZ_primZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v83 = (lpop(&lbl_arrow));
	push_resource(r27);
	lpush(&lbl_params, v4);
	lpush(&lbl_body, v83);
	mw_mirth_elab_abZ_ctxZAt();
	VAL v84 = pop_value();
	lpush(&lbl_outerZ_ctx, v84);
	mw_mirth_elab_abZ_typeZAt();
	VAL v85 = pop_value();
	lpush(&lbl_dom, v85);
	mw_mirth_elab_abZ_tokenZAt();
	VAL v86 = pop_value();
	lpush(&lbl_token, v86);
	mtw_mirth_arrow_Lambda_Lambda();
	mtw_mirth_arrow_Op_OpLambda();
	mw_mirth_elab_abZ_opZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot221ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	uint64_t v2 = (0LL /* CoerceUnsafe */);
	push_u64(v2);
	mw_mirth_elab_abZ_coerceZBang();
	uint64_t v3 = (1LL /* PRIM_CORE_DUP */);
	push_u64(v3);
	mw_mirth_elab_abZ_primZBang();
	int64_t v4 = (0LL);
	push_i64(v4);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v5 = (14LL /* PRIM_INT_EQ */);
	push_u64(v5);
	mw_mirth_elab_abZ_primZBang();
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v6 = pop_value();
	VAL v7 = pop_value();
	VAL v8 = pop_value();
	push_value(v7);
	push_value(v6);
	push_value(v8);
	mw_mirth_elab_abZ_homeZAt();
	VAL r9 = pop_resource();
	VAL v10 = pop_value();
	VAL v11 = pop_value();
	incref(v11);
	VAL v12 = pop_value();
	incref(v12);
	VAL v13 = pop_value();
	uint64_t v14 = (0LL /* Nil */);
	lpush(&lbl_home, v10);
	lpush(&lbl_tokenZ_start, v11);
	lpush(&lbl_tokenZ_end, v11);
	lpush(&lbl_dom, v12);
	lpush(&lbl_cod, v12);
	lpush(&lbl_ctx, v13);
	lpush(&lbl_atoms, MKU64(v14));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v15 = pop_value();
	lpush(&lbl_arrow, v15);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v16 = (lpop(&lbl_arrow));
	push_value(v16);
	mw_mirth_arrow_Block_newZBang();
	push_resource(r9);
	mtw_mirth_arrow_Op_OpBlockPush();
	mw_mirth_elab_abZ_opZBang();
	mw_mirth_elab_abZ_tokenZAt();
	mw_mirth_elab_abZ_ctxZAt();
	mw_mirth_type_MetaVar_newZBang();
	mtw_mirth_type_StackType_STMeta();
	VAL v17 = pop_value();
	VAL v18 = pop_value();
	VAL v19 = pop_value();
	push_value(v18);
	push_value(v17);
	push_value(v19);
	mw_mirth_elab_abZ_homeZAt();
	VAL r20 = pop_resource();
	VAL v21 = pop_value();
	VAL v22 = pop_value();
	incref(v22);
	VAL v23 = pop_value();
	incref(v23);
	VAL v24 = pop_value();
	uint64_t v25 = (0LL /* Nil */);
	lpush(&lbl_home, v21);
	lpush(&lbl_tokenZ_start, v22);
	lpush(&lbl_tokenZ_end, v22);
	lpush(&lbl_dom, v23);
	lpush(&lbl_cod, v23);
	lpush(&lbl_ctx, v24);
	lpush(&lbl_atoms, MKU64(v25));
	mtw_mirth_arrow_Arrow_Arrow();
	VAL v26 = pop_value();
	lpush(&lbl_arrow, v26);
	mtw_mirth_elab_ZPlusAB_ZPlusAB();
	int64_t v27 = (1LL);
	push_i64(v27);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v28 = (17LL /* PRIM_INT_SUB */);
	push_u64(v28);
	mw_mirth_elab_abZ_primZBang();
	mtp_mirth_elab_ZPlusAB_ZPlusAB();
	VAL v29 = (lpop(&lbl_arrow));
	push_value(v29);
	mw_mirth_arrow_Block_newZBang();
	push_resource(r20);
	mtw_mirth_arrow_Op_OpBlockPush();
	mw_mirth_elab_abZ_opZBang();
	uint64_t v30 = (5LL /* PRIM_CORE_IF */);
	push_u64(v30);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v31 = (0LL /* CoerceUnsafe */);
	push_u64(v31);
	mw_mirth_elab_abZ_coerceZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot174ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	uint64_t v2 = (0LL /* CoerceUnsafe */);
	push_u64(v2);
	mw_mirth_elab_abZ_coerceZBang();
	int64_t v3 = (1LL);
	push_i64(v3);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v4 = (16LL /* PRIM_INT_ADD */);
	push_u64(v4);
	mw_mirth_elab_abZ_primZBang();
	VAL v5 = (lpop(&lbl_tbl));
	incref(v5);
	push_value(v5);
	lpush(&lbl_tbl, v5);
	mw_mirth_table_Table_numZ_buffer();
	mw_mirth_elab_abZ_bufferZBang();
	uint64_t v6 = (76LL /* PRIM_U64_GET */);
	push_u64(v6);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v7 = (0LL /* CoerceUnsafe */);
	push_u64(v7);
	mw_mirth_elab_abZ_coerceZBang();
	int64_t v8 = (1LL);
	push_i64(v8);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v9 = (16LL /* PRIM_INT_ADD */);
	push_u64(v9);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v10 = (20LL /* PRIM_INT_MOD */);
	push_u64(v10);
	mw_mirth_elab_abZ_primZBang();
	uint64_t v11 = (0LL /* CoerceUnsafe */);
	push_u64(v11);
	mw_mirth_elab_abZ_coerceZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot146ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	uint64_t v2 = (0LL /* CoerceUnsafe */);
	push_u64(v2);
	mw_mirth_elab_abZ_coerceZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot116ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	uint64_t v2 = (0LL /* CoerceUnsafe */);
	push_u64(v2);
	mw_mirth_elab_abZ_coerceZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot73ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	int64_t v2 = (0LL);
	push_i64(v2);
	mw_mirth_elab_abZ_intZBang();
	uint64_t v3 = (0LL /* CoerceUnsafe */);
	push_u64(v3);
	mw_mirth_elab_abZ_coerceZBang();
	push_value(v0);
}
static void mb_mirth_elab_abZ_buildZ_wordZBang_1_ZLParenmirthZDotelabZDottableZ_newZBangZDot44ZRParen_0 (void) {
	VAL v0 = pop_value();
	VAL v1 = (lpop(&lbl_tbl));
	incref(v1);
	push_value(v1);
	lpush(&lbl_tbl, v1);
	mw_mirth_table_Table_head();
	mw_mirth_elab_abZ_tokenZBang();
	mw_mirth_elab_TABLEz_MAXz_COUNT();
	mw_mirth_elab_abZ_intZBang();
	push_value(v0);
}
