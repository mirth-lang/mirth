

###########
# Prelude #
###########

def(trip, a -- a a a, dup dup)
def(rotr, a b c -- c a b, swap dip(swap))
def(rotl, a b c -- b c a, dip(swap) swap)
def(over, a b -- a b a, dip(dup) swap)
def(tuck, a b -- b a b, dup dip(swap))
def(nip, a b -- b, dip(drop))
def(dup2, a b -- a b a b, over over)
def(drop2, a b --, drop drop)
def(swap2, a b c d -- c d a b, dip(rotr) rotr)

def(>, Int Int -- Bool, swap <)
def(>=, Int Int -- Bool, swap <=)

def(0=, Int -- Bool, 0 =)
def(0<, Int -- Bool, 0 <)
def(0>, Int -- Bool, 0 >)
def(0<=, Int -- Bool, 0 <=)
def(0>=, Int -- Bool, 0 >=)

def(1=, Int -- Bool, 1 =)
def(1<, Int -- Bool, 1 <)
def(1>, Int -- Bool, 1 >)
def(1<=, Int -- Bool, 1 <=)
def(1>=, Int -- Bool, 1 >=)
def(1+, Int -- Int, 1 +)
def(1-, Int -- Int, 1 -)

def(2*, Int -- Int, 2 *)
def(2/, Int -- Int, 2 /)
def(2%, Int -- Int, 2 %)
def(2+, Int -- Int, 2 +)
def(2-, Int -- Int, 2 -)

def(|u8|, 1)
def(|u16|, 2)
def(|u32|, 4)
def(|u64|, 8)
def(|i8|, 1)
def(|i16|, 2)
def(|i32|, 4)
def(|i64|, 8)

def(not, Bool -- Bool, 0 =)
def(and, Bool Bool -- Bool, swap if(id, drop 0))
def(or, Bool Bool -- Bool, swap if(drop 1, id))

# Assertions

def(!!, Bool --, if(id, "Assertion failed" panic!))
def(!!=, Int Int --, = !!)
def(!!0, Int --, 0 !!=)
def(!!1, Int --, 1 !!=)
def(!!00, Int Int --, !!0 !!0)
def(!!01, Int Int --, !!1 !!0)
def(!!10, Int Int --, !!0 !!1)
def(!!11, Int Int --, !!1 !!1)
def(!!000, Int Int --, !!0 !!0 !!0)
def(!!001, Int Int --, !!1 !!0 !!0)
def(!!010, Int Int --, !!0 !!1 !!0)
def(!!011, Int Int --, !!1 !!1 !!0)
def(!!100, Int Int --, !!0 !!0 !!1)
def(!!101, Int Int --, !!1 !!0 !!1)
def(!!110, Int Int --, !!0 !!1 !!1)
def(!!111, Int Int --, !!1 !!1 !!1)


def(str-head?, Str -- Str Int, dup str-head)
def(str-tail?, Str -- Str Str, dup str-tail)
def(str-null, Str -- Bool, str-head 0=)
def(str-null?, Str -- Str Bool, dup str-null)
def(str-not-null, Str -- Bool, str-null not)
def(str-not-null?, Str -- Str Bool, dup str-not-null)
def(str-length?, Str -- Str Int, dup str-length)
def(str-length, Str -- Int,
    dip(0) str-not-null? while(
        drop str-tail dip(1+)
        str-not-null?
    ) drop)

def(STR_BUF_SIZE, 4096)
|u64| def-static-buffer(STR_BUF_LEN)
STR_BUF_SIZE def-static-buffer(STR_BUF)
def(str-buf-length?, 0 u64@(STR_BUF_LEN))
def(str-buf-length!, dup 0 u64!(STR_BUF_LEN) dip(0) str-buf-u8!)
def(str-buf-u8@, u8@(STR_BUF))
def(str-buf-u8!, u8!(STR_BUF))
def(str-buf-full?, str-buf-length? 1+ STR_BUF_SIZE >=)
def(str-buf-clear!, 0 str-buf-length!)
def(str-buf-push!,
    str-buf-full? if(
        "str-buf-push! but STR_BUF is already full" panic!,
        str-buf-length? str-buf-u8!
        str-buf-length? 1+ str-buf-length!
    ))
def(str-buf-write!, 0 str-buf-length? syscall-write!(STR_BUF))
def(str-buf-print!, file-out? str-buf-write!)
def(str-buf-trace!, file-err? str-buf-write!)

def(str-buf-read!, File -- +IO,
    str-buf-clear!
    0 STR_BUF_SIZE 1- syscall-read!(STR_BUF)
    dup 0 < if(
        "str-buf-read! failed" panic!,
        str-buf-length!
    )
)
def(str-buf-input!, -- +IO, file-in? str-buf-read!)

# Clear STR_BUF and copy prefix of string over to it.
# Returns remaining string.
def(str-buf-copy!, Str -- Str,
    str-buf-clear!
    str-head?
    while(
        str-buf-push!
        str-tail
        str-buf-full? if(0, str-head?)
    ))

# Set the STR_BUF to a given string. If the string is
# too large (> STR_BUF_SIZE - 1) it gets truncated.
def(str-buf!, Str --, str-buf-copy! drop)

# Tests

def(run-tests, --, test-if test-drop test-dup test-swap test-dip
    test-trip test-rotr test-rotl test= test< test<= test> test>=
    test+ test- test* test/ test% test@! test-str test-while)
def(test-if, --, 0 !!0 1 !!1 0 1 !!1 !!0)
def(test-drop, --, 0 1 drop !!0)
def(test-dup, --, 0 1 dup !!011)
def(test-swap, --, 0 1 0 swap !!001)
def(test-dip, --, 0 0 dip(1) !!010)
def(test-trip, --, 0 1 trip !!111 !!0)
def(test-rotr, --,
    1 0 0 rotr !!010
    0 1 0 rotr !!001
    0 0 1 rotr !!100)
def(test-rotl, --,
    1 0 0 rotl !!001
    0 1 0 rotl !!100
    0 0 1 rotl !!010)

def(test=, --,
    0 0 = !!1
    0 1 = !!0
    1 0 = !!0
    1 1 = !!1
    1 2 = !!0
    2 1 = !!0
    2 2 = !!1)
def(test<, --,
    0 0 < !!0
    0 1 < !!1
    1 0 < !!0
    1 1 < !!0
    1 2 < !!1
    2 1 < !!0
    2 2 < !!0)
def(test<=, --,
    0 0 <= !!1
    0 1 <= !!1
    1 0 <= !!0
    1 1 <= !!1
    1 2 <= !!1
    2 1 <= !!0
    2 2 <= !!1)
def(test>, --,
    0 0 > !!0
    0 1 > !!0
    1 0 > !!1
    1 1 > !!0
    1 2 > !!0
    2 1 > !!1
    2 2 > !!0)
def(test>=, --,
    0 0 >= !!1
    0 1 >= !!0
    1 0 >= !!1
    1 1 >= !!1
    1 2 >= !!0
    2 1 >= !!1
    2 2 >= !!1
    -1 0 >= !!0
    -1 -1 >= !!1
    0 -1 >= !!1
    -1 -2 >= !!1
    -2 -2 >= !!1
    -2 -1 >= !!0)

def(test+, --,
    0 0 + !!0
    0 1 + !!1
    1 0 + !!1
    1 1 + 2 = !!1
    2 2 + 4 = !!1
    2 -2 + !!0)

def(test-, --,
    0 0 - !!0
    1 0 - !!1
    1 1 - !!0
    0 1 - -1 !!=
    2 2 - !!0
    2 4 - -2 !!=
    4 2 - 2 !!=)

def(test*, --,
    0 0 * !!0
    2 1 * 2 !!=
    2 2 * 4 !!=
    2 4 * 8 !!=)

def(test/, --,
    1 1 / !!1
    -5 2 / -2 !!=
    -4 2 / -2 !!=
    -3 2 / -1 !!=
    -2 2 / -1 !!=
    -1 2 / !!0
    0 2 / !!0
    1 2 / !!0
    2 2 / !!1
    3 2 / !!1
    4 2 / 2 !!=
    5 2 / 2 !!=
    0 -2 / !!0
    1 -2 / !!0
    2 -2 / -1 !!=
    3 -2 / -1 !!=
    4 -2 / -2 !!=
    5 -2 / -2 !!=)

def(test%, --,
    1 1 % !!0
    -5 2 % -1 !!=
    -4 2 % !!0
    -3 2 % -1 !!=
    -2 2 % !!0
    -1 2 % -1 !!=
    0 2 % !!0
    1 2 % !!1
    2 2 % !!0
    3 2 % !!1
    4 2 % !!0
    5 2 % !!1)

2 |u64| * def-static-buffer(TestBuffer)

def(u8@test, u8@(TestBuffer))
def(i8@test, i8@(TestBuffer))
def(u8!test, u8!(TestBuffer))
def(i8!test, i8!(TestBuffer))
def(u16@test, u16@(TestBuffer))
def(i16@test, i16@(TestBuffer))
def(u16!test, u16!(TestBuffer))
def(i16!test, i16!(TestBuffer))
def(u32@test, u32@(TestBuffer))
def(i32@test, i32@(TestBuffer))
def(u32!test, u32!(TestBuffer))
def(i32!test, i32!(TestBuffer))
def(u64@test, u64@(TestBuffer))
def(i64@test, i64@(TestBuffer))
def(u64!test, u64!(TestBuffer))
def(i64!test, i64!(TestBuffer))

def(test@!, --,
    # persistence tests -- i.e. get and set behave as expected and
    # don't interfere when performed at non-overlapping locations
    # -- we don't make architectural assumptions here, like little
    # endian vs big endian.

    999 0 0 u8!test 999 !!= 0 |u8| u8!test
    10 0 u8!test 0 u8@test 10 !!= |u8| u8@test 0 !!=
    20 0 u8!test 0 u8@test 20 !!= |u8| u8@test 0 !!=
    30 |u8| u8!test 0 u8@test 20 !!= |u8| u8@test 30 !!=

    999 0 0 u16!test 999 !!= 0 |u16| u16!test
    10 0 u16!test 0 u16@test 10 !!= |u16| u16@test 0 !!=
    20 0 u16!test 0 u16@test 20 !!= |u16| u16@test 0 !!=
    30 |u16| u16!test 0 u16@test 20 !!= |u16| u16@test 30 !!=

    999 0 0 u32!test 999 !!= 0 |u32| u32!test
    10 0 u32!test 0 u32@test 10 !!= |u32| u32@test 0 !!=
    20 0 u32!test 0 u32@test 20 !!= |u32| u32@test 0 !!=
    30 |u32| u32!test 0 u32@test 20 !!= |u32| u32@test 30 !!=

    999 0 0 u64!test 999 !!= 0 |u64| u64!test
    10 0 u64!test 0 u64@test 10 !!= |u64| u64@test 0 !!=
    20 0 u64!test 0 u64@test 20 !!= |u64| u64@test 0 !!=
    30 |u64| u64!test 0 u64@test 20 !!= |u64| u64@test 30 !!=

    0 0 i8!test 0 |i8| i8!test
    10 0 i8!test 0 i8@test 10 !!= |i8| i8@test 0 !!=
    -20 0 i8!test 0 i8@test -20 !!= |i8| i8@test 0 !!=
    30 |i8| i8!test 0 i8@test -20 !!= |i8| i8@test 30 !!=

    0 0 i16!test 0 |i16| i16!test
    10 0 i16!test 0 i16@test 10 !!= |i16| i16@test 0 !!=
    -20 0 i16!test 0 i16@test -20 !!= |i16| i16@test 0 !!=
    30 |i16| i16!test 0 i16@test -20 !!= |i16| i16@test 30 !!=

    0 0 i32!test 0 |i32| i32!test
    10 0 i32!test 0 i32@test 10 !!= |i32| i32@test 0 !!=
    -20 0 i32!test 0 i32@test -20 !!= |i32| i32@test 0 !!=
    30 |i32| i32!test 0 i32@test -20 !!= |i32| i32@test 30 !!=

    0 0 i64!test 0 |i64| i64!test
    10 0 i64!test 0 i64@test 10 !!= |i64| i64@test 0 !!=
    -20 0 i64!test 0 i64@test -20 !!= |i64| i64@test 0 !!=
    30 |i64| i64!test 0 i64@test -20 !!= |i64| i64@test 30 !!=)

def(test-str,
    "AaBb"
    dup str-head 65 !!=
    dup str-tail str-head 97 !!=
    dup str-tail str-tail str-head 66 !!=
    dup str-tail str-tail str-tail str-head 98 !!=
    dup str-tail str-tail str-tail str-tail str-head 0 !!=
    drop

    "" str-length 0 !!=
    "hello" str-length 5 !!=
    "hello, world!" str-length 13 !!=
    )

def(test-while,
    999 10 20 while(1- dip(1+)) 30 !!= 999 !!=)

def(stdout, File, 1)
def(stderr, File, 2)
def(stdin,  File, 0)

def(init, init-io)
def(init-io,
    0 file-in!
    1 file-out!
    2 file-err!)

|u64| def-static-buffer(FILE_IN)
def(file-in!, 0 u64!(FILE_IN))
def(file-in?, 0 u64@(FILE_IN))

|u64| def-static-buffer(FILE_OUT)
def(file-out!, 0 u64!(FILE_OUT))
def(file-out?, 0 u64@(FILE_OUT))

|u64| def-static-buffer(FILE_ERR)
def(file-err!, 0 u64!(FILE_ERR))
def(file-err?, 0 u64@(FILE_ERR))

def(str-write!, Str File --,
    swap str-not-null? while(
        drop str-buf-copy!
        dip(dup str-buf-write!)
        str-not-null?
    ) drop2
    )

def(str-print!, file-out? str-write!)
def(str-trace!, file-err? str-write!)
def(str-print-sp!, str-print! print-sp!)
def(str-trace-sp!, str-trace! trace-sp!)
def(str-print-ln!, str-print! print-ln!)
def(str-trace-ln!, str-trace! trace-ln!)

def(str-buf-char!, 0 str-buf-u8! 1 str-buf-length!)
def(print-char!, str-buf-char! str-buf-print!)
def(trace-char!, str-buf-char! str-buf-trace!)

def(print-ln!, 10 print-char!)
def(trace-ln!, 10 trace-char!)
def(print-sp!, 32 print-char!)
def(trace-sp!, 32 trace-char!)
def(print-quote!, 34 print-char!)
def(trace-quote!, 34 trace-char!)

def(to-digit, Int -- Char, 10 % 48 +)

def(negate, Int -- Int, -1 *)
def(abs, Int -- Int, dup 0< if(negate, id))

# put integer into str buf
def(str-buf-int!, Int --,
    dup 0= if(
        drop "0" str-buf!,
        dup dip(
            abs
            str-buf-clear!
            while(dup to-digit str-buf-push! 10 /)
        ) 0 < if(45 str-buf-push!, id)
        str-buf-reverse!
    ))

def(int-write!, Int File -- +IO, dip(str-buf-int!) str-buf-write!)
def(int-print!, Int -- +IO, file-out? int-write!)
def(int-trace!, Int -- +IO, file-err? int-write!)
def(int-print-sp!, Int -- +IO, int-print! print-sp!)
def(int-trace-sp!, Int -- +IO, int-trace! trace-sp!)
def(int-print-ln!, Int -- +IO, int-print! print-ln!)
def(int-trace-ln!, Int -- +IO, int-trace! trace-ln!)

def(panic!, Str -- +IO,
    "panic: " str-trace! str-trace-ln! 0 syscall-exit!)

# reverse contents of str buf

def(str-buf-swap-u8!, Int Int --,
    dup2 swap
    dip(dip(dip(str-buf-u8@)))
    dip(str-buf-u8@)
    str-buf-u8! str-buf-u8!
)

def(str-buf-reverse!, --,
    0 str-buf-length? 1- dup2 <
    while(drop
        dup2 str-buf-swap-u8!
        dip(1 +) 1- dup2 <
    )
    drop2
)

#########
# Input #
#########

def(FILE_BUF_SIZE, 65536)
|u64| def-static-buffer(FILE_BUF_LENGTH)
FILE_BUF_SIZE def-static-buffer(FILE_BUF)

def(file-buf-length!, Int --, dup 0 u64!(FILE_BUF_LENGTH) 0 swap u8!(FILE_BUF))
def(file-buf-length@, -- Int, 0 u64@(FILE_BUF_LENGTH))

def(file-buf@, Int -- U8, u8@(FILE_BUF))

def(str-buf-open-file!, -- File +IO,
    0 0 0 syscall-open!(STR_BUF)
    dup 0 < if("failed to open file!" panic!, id))

def(str-buf-create-file!, -- File +IO,
    0 # offset into str-buf to read
    1537 # 0x601
        # this is an OR of flags:
        #    O_WRONLY 0x0001 : open in write-only mode
        #    O_CREAT  0x0200 : create file if it doesn't exist
        #    O_TRUNC  0x0400 : truncate to zero bytes
    438 # 0x1B6
        # this is the default mode creates a file with
        # unix permission 666 (in octal),
        # i.e. owner can read+write, everyone can read
    syscall-open!(STR_BUF)
    dup 0 < if("failed to open file!" panic!, id))

def(str-open-file!, Str -- File +IO, str-buf! str-buf-open-file!)
def(str-create-file!, Str -- File +IO, str-buf! str-buf-create-file!)

def(read-file!, File -- +IO,
    dup 0 FILE_BUF_SIZE 1- syscall-read!(FILE_BUF)
    dup 0 < if(
        "failed to read file" panic!,
        file-buf-length! syscall-close!
        0 < if(
            "failed to close file" panic!,
            id
        )
    ))

def(read-mirth-src!,
    "Reading mirth.mth" str-trace-ln!
    "mirth.mth" str-open-file! read-file!
    "Read " str-trace!
    file-buf-length@ int-trace!
    " bytes (FILE_BUF_SIZE = " str-trace!
    FILE_BUF_SIZE int-trace!
    ")." str-trace-ln!)

#########
# Names #
#########

def(MAX_NAMES, 32768)
|i64| def-static-buffer(NUM_NAMES)
def(num-names@, Int, 0 i64@(NUM_NAMES))
def(num-names!, Int --, 0 i64!(NUM_NAMES))

def(NAME_QUADS, 8)
def(NAME_SIZE, NAME_QUADS |u64| *)
def(NAME_BUF_SIZE, NAME_SIZE MAX_NAMES *)
NAME_BUF_SIZE def-static-buffer(NAME_BUF)

# Recalculate length of string buffer as the
# first position with a zero byte.
def(str-buf-recalc-length!, --,
    0 dup i8@(STR_BUF)
    while( # Len Char -- Len Char
        drop 1+
        dup i8@(STR_BUF)
    )
    str-buf-length!
)

# Add \0 until you get to a certain length.
def(str-pad-zeros-to-length!, Int --,
    dup str-buf-length? >
    while(
        drop
        str-buf-length? 1+
        dup str-buf-length! # this pads the zeros
        dip(dup) >
    ) drop)

# Load a name into STR_BUF.
def(name-load!, Name --,
    name-quads-load!
    NAME_SIZE str-buf-length!
    str-buf-recalc-length!)

# Compare a specific name QUAD with
# the respective QUAD in STR_BUF.
def(name-quad-eq, Name Int -- Bool,
    dip(NAME_SIZE *) |u64| * dup dip(+)
    dip(u64@(NAME_BUF)) u64@(STR_BUF) =)

# Compare all quads in name to STR_BUF.
# Note this code assumes NAME_QUADS is 4.
def(name-quads-eq, Name -- Bool,
    dup 0 name-quad-eq if(
    dup 1 name-quad-eq if(
    dup 2 name-quad-eq if(
    dup 3 name-quad-eq if(
    dup 4 name-quad-eq if(
    dup 5 name-quad-eq if(
    dup 6 name-quad-eq if(
    7 name-quad-eq,
    drop 0),
    drop 0),
    drop 0),
    drop 0),
    drop 0),
    drop 0),
    drop 0))

def(name-quads-eq?, Name -- Name Bool,
    dup name-quads-eq)

def(name-quad-save!, Name Int --,
    dip(NAME_SIZE *) |u64| * dup dip(+)
    u64@(STR_BUF) swap u64!(NAME_BUF))

def(name-quads-save!, Name -- ,
    dup 0 name-quad-save!
    dup 1 name-quad-save!
    dup 2 name-quad-save!
    dup 3 name-quad-save!
    dup 4 name-quad-save!
    dup 5 name-quad-save!
    dup 6 name-quad-save!
    7 name-quad-save!)

def(name-quad-load!, Name Int --,
    dip(NAME_SIZE *) |u64| * dup dip(+)
    dip(u64@(NAME_BUF)) u64!(STR_BUF))

def(name-quads-load!, Name -- ,
    dup 0 name-quad-load!
    dup 1 name-quad-load!
    dup 2 name-quad-load!
    dup 3 name-quad-load!
    dup 4 name-quad-load!
    dup 5 name-quad-load!
    dup 6 name-quad-load!
    7 name-quad-load!)

# Load STR_BUF into name table. Performs deduplication.
def(name-save!, -- Name,
    NAME_SIZE 1+ str-pad-zeros-to-length!
    0 dup num-names@ < while(
        drop
        name-quads-eq? if(
            0,
            1+ dup num-names@ <
        )
    )
    dup num-names@ < if(
        id, # name already exists
        # name is new
        dup name-quads-save!
        dup 1+ num-names!
    ))

def(show-names-table!,
    0 dup num-names@ <
    while( # Name Bool -- Name Bool Bool
        drop
        dup int-print!
        ": " str-print!
        dup name-load! str-buf-print! print-ln!
        1+ dup num-names@ <
    )
    drop
)

###################
# Primitive Names #
###################

def(PRIM_END, 0)
def(PRIM_DEBUG, 1)
def(PRIM_ID, 1)
def(PRIM_DUP, 2)
def(PRIM_DROP, 3)
def(PRIM_SWAP, 4)
def(PRIM_DIP, 5)
def(PRIM_IF, 6)
def(PRIM_WHILE, 7)
def(PRIM_INT_ADD, 8)
def(PRIM_INT_SUB, 9)
def(PRIM_INT_MUL, 10)
def(PRIM_INT_DIV, 11)
def(PRIM_INT_MOD, 12)
def(PRIM_INT_EQ, 13)
def(PRIM_INT_LT, 14)
def(PRIM_INT_LE, 15)
def(PRIM_STR_HEAD, 16)
def(PRIM_STR_TAIL, 17)
def(PRIM_MEM_GET_U8, 18)
def(PRIM_MEM_GET_U16, 19)
def(PRIM_MEM_GET_U32, 20)
def(PRIM_MEM_GET_U64, 21)
def(PRIM_MEM_GET_I8, 22)
def(PRIM_MEM_GET_I16, 23)
def(PRIM_MEM_GET_I32, 24)
def(PRIM_MEM_GET_I64, 25)
def(PRIM_MEM_SET_U8, 26)
def(PRIM_MEM_SET_U16, 27)
def(PRIM_MEM_SET_U32, 28)
def(PRIM_MEM_SET_U64, 29)
def(PRIM_MEM_SET_I8, 30)
def(PRIM_MEM_SET_I16, 31)
def(PRIM_MEM_SET_I32, 32)
def(PRIM_MEM_SET_I64, 33)
def(PRIM_FILE_READ, 34)
def(PRIM_FILE_WRITE, 35)
def(PRIM_FILE_OPEN, 36)
def(PRIM_FILE_CLOSE, 37)
def(PRIM_EXIT, 38)
def(PRIM_DEF, 39)
def(PRIM_DEF_STATIC_BUFFER, 40)
def(PRIM_OUTPUT_ASM, 41)

def(def-prim!, Prim Str -- +Names, name-save! swap !!=)

# Initialize name table with list of primitives.
# Note that order matters very much here, but any
# deviation from the order above will be flagged
# thanks to assertions.
def(init-names!, +Names,
    0 num-names!
    PRIM_END "end" def-prim!
    PRIM_DEBUG "??" def-prim!
    PRIM_ID "id" def-prim!
    PRIM_DUP "dup" def-prim!
    PRIM_DROP "drop" def-prim!
    PRIM_SWAP "swap" def-prim!
    PRIM_DIP "dip" def-prim!
    PRIM_IF "if" def-prim!
    PRIM_WHILE "while" def-prim!
    PRIM_INT_ADD "+" def-prim!
    PRIM_INT_SUB "-" def-prim!
    PRIM_INT_MUL "*" def-prim!
    PRIM_INT_DIV "/" def-prim!
    PRIM_INT_MOD "%" def-prim!
    PRIM_INT_EQ "=" def-prim!
    PRIM_INT_LT "<" def-prim!
    PRIM_INT_LE "<=" def-prim!
    PRIM_STR_HEAD "str-head" def-prim!
    PRIM_STR_TAIL "str-tail" def-prim!
    PRIM_MEM_GET_U8 "u8@" def-prim!
    PRIM_MEM_GET_U16 "u16@" def-prim!
    PRIM_MEM_GET_U32 "u32@" def-prim!
    PRIM_MEM_GET_U64 "u64@" def-prim!
    PRIM_MEM_GET_I8 "i8@" def-prim!
    PRIM_MEM_GET_I16 "i16@" def-prim!
    PRIM_MEM_GET_I32 "i32@" def-prim!
    PRIM_MEM_GET_I64 "i64@" def-prim!
    PRIM_MEM_SET_U8 "u8!" def-prim!
    PRIM_MEM_SET_U16 "u16!" def-prim!
    PRIM_MEM_SET_U32 "u32!" def-prim!
    PRIM_MEM_SET_U64 "u64!" def-prim!
    PRIM_MEM_SET_I8 "i8!" def-prim!
    PRIM_MEM_SET_I16 "i16!" def-prim!
    PRIM_MEM_SET_I32 "i32!" def-prim!
    PRIM_MEM_SET_I64 "i64!" def-prim!
    PRIM_FILE_READ "syscall-read!" def-prim!
    PRIM_FILE_WRITE "syscall-write!" def-prim!
    PRIM_FILE_OPEN "syscall-open!" def-prim!
    PRIM_FILE_CLOSE "syscall-close!" def-prim!
    PRIM_EXIT "syscall-exit!" def-prim!
    PRIM_DEF "def" def-prim!
    PRIM_DEF_STATIC_BUFFER "def-static-buffer" def-prim!
    PRIM_OUTPUT_ASM "output-asm" def-prim!
    )

#################
# Strings Table #
#################

def(MAX_STRINGS, 32768)
|i64| def-static-buffer(STRINGS_SIZE)
MAX_STRINGS def-static-buffer(STRINGS_BUF)

# Size of strings table.
def(strings-size@, -- U64 +StrTable,
    0 u64@(STRINGS_SIZE))

# Size of strings table.
def(strings-size!, U64 -- +StrTable,
    0 u64!(STRINGS_SIZE))

# Read byte from strings table.
def(strings-u8@, U64 -- U8 +StrTable,
    u8@(STRINGS_BUF))

# Read byte from strings table, leaving index in place.
def(strings-u8?, U64 -- U64 U8 +StrTable,
    dup strings-u8@)

# Write byte to strings table.
def(strings-u8!, U8 U64 -- +StrTable,
    u8!(STRINGS_BUF))

# Push byte onto strings table.
def(strings-push!, U8 -- +StrTable,
    strings-size@ strings-u8!
    strings-size@ 1+ strings-size!)

# Load STR_BUF into strings table,
# returning the index of the new string.
def(strings-save!, -- String +StrTable +StrBuf,
    strings-size@
    0 dup str-buf-length? < while(
        drop
        dup str-buf-u8@
        strings-push!
        1+
        dup str-buf-length? <
    )
    drop
    0 strings-push!)

# Load string into STR_BUF.
def(strings-load!, String -- +StrTable +StrBuf,
    str-buf-clear!
    strings-u8? while(
        str-buf-push!
        1+ strings-u8?
    )
    drop)

# Load string into STR_BUF but with escape sequences.
# FIXME: implement escape sequence handling.
def(strings-load-escaped!, String -- +StrTable +StrBuf,
    strings-load!)

##########
# Tokens #
##########

def(MAX_TOKENS, 32768)

|i64| def-static-buffer(NUM_TOKENS)
def(num-tokens@, Int, 0 i64@(NUM_TOKENS))
def(num-tokens!, Int --, 0 i64!(NUM_TOKENS))
def(clear-tokens!, --, 0 num-tokens!)

MAX_TOKENS |u8|  * def-static-buffer(TOKEN_TYPE)
def(token-type!, TokenType Token --, u8!(TOKEN_TYPE))
def(token-type@, Token -- TokenType, u8@(TOKEN_TYPE))
def(token-type?, Token -- Token TokenType, dup token-type@)
def(TOKEN_NONE, TokenType, 0)
def(TOKEN_LPAREN, TokenType, 1)
def(TOKEN_RPAREN, TokenType, 2)
def(TOKEN_COMMA, TokenType, 3)
def(TOKEN_NAME, TokenType, 4)
def(TOKEN_INT, TokenType, 5)
def(TOKEN_STR, TokenType, 6)
def(token-type-str, TokenType -- Str,
    dup TOKEN_NONE = if(drop "NONE",
    dup TOKEN_LPAREN = if(drop "LPAREN",
    dup TOKEN_RPAREN = if(drop "RPAREN",
    dup TOKEN_COMMA = if(drop "COMMA",
    dup TOKEN_NAME = if(drop "NAME",
    dup TOKEN_INT = if(drop "INT",
    dup TOKEN_STR = if(drop "STR",
    drop "???UNKNOWN???"))))))))
def(token-type-print!, TokenType --,
    token-type-str str-print!)

MAX_TOKENS |i64| * def-static-buffer(TOKEN_VALUE)
def(token-value!, TokenValue Token --, |i64| * i64!(TOKEN_VALUE))
def(token-value@, Token -- TokenValue, |i64| * i64@(TOKEN_VALUE))
def(token-value?, Token -- Token TokenValue, dup token-value@)

MAX_TOKENS |u32| * def-static-buffer(TOKEN_ROW)
def(token-row!, Row Token --, |u32| * u32!(TOKEN_ROW))
def(token-row@, Token -- Row, |u32| * u32@(TOKEN_ROW))
def(token-row?, Token -- Token Row, dup token-row@)

MAX_TOKENS |u16| * def-static-buffer(TOKEN_COL)
def(token-col!, Col Token --, |u16| * u16!(TOKEN_COL))
def(token-col@, Token -- Col, |u16| * u16@(TOKEN_COL))
def(token-col?, Token -- Token Col, dup token-col@)

def(token-new, -- Token, num-tokens@ dup 1+ num-tokens!)

def(token-print!, Token --,
    token-row? int-print! ":" str-print!
    token-col? int-print! ":" str-print-sp!
    dup int-print-sp!
    token-type? token-type-print!
    token-type? TOKEN_NAME = if(
        print-sp!
        token-value? name-load! str-buf-print!,

    token-type? TOKEN_STR = if(
        print-sp!
        print-quote!
        token-value? strings-load-escaped! str-buf-print!
        print-quote!,

        print-sp!
        token-value? int-print!))

    drop
    print-ln!
)

def(show-tokens!, --,
    0 dup num-tokens@ < while(
        drop
        dup token-print!
        1+ dup num-tokens@ <
    ) drop)

#########
# LEXER #
#########

|u32| def-static-buffer(LEXER_ROW)
def(lexer-row@, 0 u32@(LEXER_ROW))
def(lexer-row!, 0 u32!(LEXER_ROW))

|u16| def-static-buffer(LEXER_COL)
def(lexer-col@, 0 u16@(LEXER_COL))
def(lexer-col!, 0 u16!(LEXER_COL))

|u64| def-static-buffer(LEXER_IDX)
def(lexer-idx@, 0 u64@(LEXER_IDX))
def(lexer-idx!, 0 u64!(LEXER_IDX))

def(LEXER_STACK_SIZE, 256)
|u64| def-static-buffer(LEXER_STACK_LENGTH)
LEXER_STACK_SIZE |u64| * def-static-buffer(LEXER_STACK_BUF)

def(lexer-stack-length@, U64 +Lexer,
    0 u64@(LEXER_STACK_LENGTH))

def(lexer-stack-length!, U64 -- +Lexer,
    0 u64!(LEXER_STACK_LENGTH))

def(lexer-stack-clear!, +Lexer,
    0 lexer-stack-length!)

def(lexer-stack-empty?, Bool +Lexer,
    lexer-stack-length@ 0 <=)

def(lexer-stack-full?, Bool +Lexer,
    lexer-stack-length@ LEXER_STACK_SIZE >=)

def(lexer-stack-push!, Token -- +Lexer,
    lexer-stack-full? if(
        "compiler error: lexer stack overflow" panic!,
        lexer-stack-length@
        dup 1+ lexer-stack-length!
        |u64| * u64!(LEXER_STACK_BUF)
    ))

def(lexer-stack-pop!, -- Token +Lexer,
    lexer-stack-empty? if(
        "compiler error: lexer stack underflow" panic!,
        lexer-stack-length@ 1-
        dup lexer-stack-length!
        |u64| * u64@(LEXER_STACK_BUF)
    ))

def(run-lexer!,
    1 lexer-row!
    1 lexer-col!

    lexer-done? not while(
        drop
        lexer-next!
        lexer-done? not
    )

    # FIXME: check lexer stack is empty
)

# Is the lexer done?
def(lexer-done?, Bool +Lexer, lexer-idx@ file-buf-length@ >=)

# Create a token, and add it to the token buffer,
# returning the new token.
def(lexer-make!, TokenType TokenValue -- Token,
    token-new
    dup dip(token-value!)
    dup dip(token-type!)
    dip(lexer-row@) dup dip(token-row!)
    dip(lexer-col@) dup dip(token-col!))

# Create a token, and add it to the token buffer.
def(lexer-emit!, TokenType TokenValue, lexer-make! drop)

# Lex the next token.
def(lexer-next!, --,
    lexer-peek

    is-newline? if(
        drop
        lexer-emit-newline!,

    is-whitespace? if(
        drop,

    is-pound? if(
        drop
        lexer-skip-comment!,

    is-comma? if(
        drop
        TOKEN_COMMA 0 lexer-emit!,

    is-lparen? if(
        drop
        lexer-emit-lparen!,

    is-rparen? if(
        drop
        lexer-emit-rparen!,

    is-quote? if(
        drop
        lexer-emit-string!,

    is-name-char? if(
        drop
        lexer-emit-name!,

        drop # LATER emit lexer error
        ))))))))

    lexer-move!
)

def(lexer-emit-newline!,
    lexer-row@ 1+ lexer-row!
    0 lexer-col!)

def(lexer-emit-lparen!,
    TOKEN_LPAREN 0 lexer-make!
    lexer-stack-push!
    )

def(lexer-emit-rparen!,
    # FIXME: handle empty lexer stack (AKA mismatched right paren)
    TOKEN_RPAREN
    lexer-stack-pop! dup
    dip(lexer-make!) token-value!
    )

def(lexer-emit-name!,
    str-buf-clear!
    TOKEN_NAME 0 lexer-make!

    lexer-peek 1 while(
        drop
        str-buf-push!
        lexer-move!
        lexer-peek is-name-char?
    )
    drop
    lexer-move-back!

    str-buf-is-int? if(
        str-buf-int? over token-value!
        TOKEN_INT swap token-type!,

        name-save!
        swap token-value!
    ))

def(str-buf-is-int?,
    str-buf-is-dec-int? # FIXME: handle hex
    )

def(str-buf-is-dec-int?,
    0 # number of digits
    0 # current index
    dup str-buf-u8@ is-sign? nip if(
        1+,
        id
    )
    dup str-buf-u8@ is-digit? nip while(
        drop
        dip(1+) 1+
        dup str-buf-u8@ is-digit? nip
    )
    swap 1 >= if(
        str-buf-length? =,
        drop 0
    ))

def(str-buf-int?,
    str-buf-dec-int? # FIXME: handle hex
    )

def(str-buf-dec-int?,
    1 # sign multiplier
    0 # accumulated value
    0 # current index
    dup str-buf-u8@ is-sign? if(
        is-minus-sign? nip if(
            dip(dip(drop -1)),
            id
        )
        1+,
        drop
    )
    dup str-buf-length? < while(
        drop
        dup dip(
            str-buf-u8@
            dip(10 *) 48 - +
        )
        1+
        dup str-buf-length? <
    )
    drop *)

def(lexer-emit-string!,
    str-buf-clear!
    TOKEN_STR 0 lexer-make!

    lexer-move!
    lexer-peek is-string-end? not while(
        drop
        lexer-push-string-char!
        lexer-move!
        lexer-peek is-string-end? not
    )
    drop

    strings-save!
    swap token-value!
    )

def(lexer-push-string-char!, Char -- +Lexer,
    str-buf-push!) # FIXME: handle escape sequences

def(lexer-skip-comment!,
    lexer-comment-end? not while(
        drop
        lexer-move!
        lexer-comment-end? not
    )
    lexer-peek is-newline? if(
        lexer-emit-newline! drop,
        drop
    ))

def(lexer-comment-end?,
    lexer-done? if(
        1,
        lexer-peek is-newline? nip
    ))

def(lexer-peek, U8, lexer-idx@ file-buf@)
def(lexer-move!,
    lexer-idx@ 1+ lexer-idx!
    lexer-col@ 1+ lexer-col!)
def(lexer-move-back!,
    lexer-idx@ 1- lexer-idx!
    lexer-col@ 1- lexer-col!)

def(is-newline?, dup 10 =)
def(is-whitespace?, dup 9 = dip(dup 32 =) +)
def(is-pound?, dup 35 =)
def(is-lparen?, dup 40 =)
def(is-rparen?, dup 41 =)
def(is-comma?, dup 44 =)
def(is-quote?, dup 34 =)
def(is-digit?, dup 48 57 in-range)
def(is-upper-hexdigit?, dup 65 70 in-range)
def(is-lower-hexdigit?, dup 97 102 in-range)
def(is-hexdigit?, is-digit? dip(is-upper-hexdigit?) + dip(is-lower-hexdigit?) +)
def(in-range, dip(over dip(>=)) <= *)
def(is-nul?, dup 0=)
def(is-sign?, is-plus-sign? dip(is-minus-sign?) +)
def(is-plus-sign?, dup 43 =)
def(is-minus-sign?, dup 45 =)

def(is-string-end?, is-quote? dip(is-newline?) + dip(is-nul?) +)

def(is-name-char?, Char -- Char Bool,
    is-special-char?
    if(0, dup 33 126 in-range))

def(is-special-char?, Char -- Char Bool,
    is-quote?
    dip(is-lparen?) +
    dip(is-rparen?) +
    dip(is-comma?) +
    dip(is-pound?) +
    # FIXME: include brackets & braces ... maybe colons
    )

###############
# Value Stack #
###############

def(VSTACK_SIZE, 32768)
|u64| def-static-buffer(VSTACK_LEN)
VSTACK_SIZE |i64| * def-static-buffer(VSTACK_BUF)

def(vstack-len@, U64 +VSTACK, 0 u64@(VSTACK_LEN))
def(vstack-len!, U64 -- +VSTACK, 0 u64!(VSTACK_LEN))
def(vstack-empty?, Bool +VSTACK, vstack-len@ 0 <=)
def(vstack-full?, Bool +VSTACK, vstack-len@ VSTACK_SIZE >=)
def(vstack-i64@, U64 -- I64 +VSTACK, |u64| * i64@(VSTACK_BUF))
def(vstack-i64!, I64 U64 -- +VSTACK, |u64| * i64!(VSTACK_BUF))

def(vstack-pop!, I64 +VSTACK,
    vstack-empty? if(
        "stack underflow: attempted to pop on empty vstack" panic!,
        vstack-len@ 1- vstack-len!
        vstack-len@ vstack-i64@
    ))

def(vstack-pop2!, I64 I64 +VSTACK,
    vstack-pop! dip(vstack-pop!))

def(vstack-pop3!, I64 I64 I64 +VSTACK,
    vstack-pop! dip(vstack-pop2!))

def(vstack-push!, I64 -- +VSTACK,
    vstack-full? if(
        "stack overflow: attempted to push on full vstack" panic!,
        vstack-len@ vstack-i64!
        vstack-len@ 1+ vstack-len!
    ))

def(vstack-push2!, I64 I64 -- +VSTACK,
    dip(vstack-push!) vstack-push!)

def(vstack-push3!, I64 I64 I64 -- +VSTACK,
    dip(vstack-push2!) vstack-push!)

def(vstack-top@, I64 +VSTACK,
    vstack-empty? if(
        "stack underflow: attempted to read from top of empty vstack" panic!,
        vstack-len@ 1- vstack-i64@
    ))

def(vstack-top!, I64 -- +VSTACK,
    vstack-empty? if(
        "stack underflow: attempted to write to top of empty vstack" panic!,
        vstack-len@ 1- vstack-i64!
    ))

########
# Main #
########

def(main,
    run-tests
    read-mirth-src!
    run-lexer!
    show-names-table!
    show-tokens!
    )

main

###############
# Build Rules #
###############

"mirth.asm" output-asm(main)
