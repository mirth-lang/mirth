
###########
# Prelude #
###########

def(trip, a -- a a a, dup dup)
def(rotr, a b c -- c a b, swap dip(swap))
def(rotl, a b c -- b c a, dip(swap) swap)
def(over, a b -- a b a, dip(dup) swap)
def(tuck, a b -- b a b, dup dip(swap))
def(nip, a b -- b, dip(drop))
def(dup2, a b -- a b a b, over over)
def(drop2, a b --, drop drop)
def(drop3, a b c --, drop drop drop)

def-type(Byte, U8)
def-type(Char, U8)

def-type(Str, Ptr)

def-type(Bool, Int)
def-type(Size, Int)
def-type(Offset, Int)
def-type(File, Int)

def(>, Int Int -- Bool, swap <)
def(>=, Int Int -- Bool, swap <=)

def(0=, Int -- Bool, 0 =)
def(0<, Int -- Bool, 0 <)

def(1+, Int -- Int, 1 +)
def(1-, Int -- Int, 1 -)

def(not, Bool -- Bool, 0 =)

def(u8, Size, 1)
def(u8s, Size -- Size, id)
def(u8@@, Offset Ptr -- Byte, + u8@)
def(u8!!, Byte Offset Ptr --, + u8!)

def(u16, Size, 2)
def(u16s, Size -- Size, u16 *)
def(u16@@, Offset Ptr -- U16, dip(u16s) + u16@)
def(u16!!, U16 Offset Ptr --, dip(u16s) + u16!)

def(i16, Size, 2)
def(i16s, Size -- Size, i16 *)
def(i16@@, Offset Ptr -- I16, dip(i16s) + i16@)
def(i16!!, I16 Offset Ptr --, dip(i16s) + i16!)

def(i32, Size, 4)
def(i32s, Size -- Size, i32 *)
def(i32@@, Offset Ptr -- I32, dip(i32s) + i32@)
def(i32!!, I32 Offset Ptr --, dip(i32s) + i32!)

def-type(Long, Int)
def(quad, Size, 8)
def(quads, Size -- Size, quad *)
def(quad@@, Offset Ptr -- Long, dip(quads) + @)
def(quad!!, Long Offset Ptr --, dip(quads) + !)

# Assertions

def(!!, Bool --, if(id, "Assertion failed" panic!))
def(!!=, a a --, = !!)
def(!!0, Bool --, 0 !!=)
def(!!1, Bool --, 1 !!=)
def(!!001, Int Int Int --, !!1 !!0 !!0)
def(!!010, Int Int Int --, !!0 !!1 !!0)
def(!!011, Int Int Int --, !!1 !!1 !!0)
def(!!100, Int Int Int --, !!0 !!0 !!1)
def(!!111, Int Int Int --, !!1 !!1 !!1)

def(str-tail, Str -- Str, 1 +)
def(str-length, Str -- Int,
    0 swap
    while(dup u8@,
        str-tail
        dip(1+))
    drop)

def(STR_BUF_SIZE, Int, 0x80)
quad def-static-buffer(STR_BUF_LEN)
STR_BUF_SIZE u8s def-static-buffer(STR_BUF)

def(str-buf-length?, Int +StrBuf, STR_BUF_LEN @)
def(str-buf-length!, Int -- +StrBuf,
    dup STR_BUF_LEN !
    dip(0 Int->U8) str-buf-u8!)
def(str-buf-u8@, Offset -- U8 +StrBuf, STR_BUF u8@@)
def(str-buf-u8!, U8 Offset -- +StrBuf, STR_BUF u8!!)
def(str-buf-full?, Bool +StrBuf,
    str-buf-length? 1+ STR_BUF_SIZE >=)
def(str-buf-clear!, +StrBuf, 0 str-buf-length!)

def(str-buf-push!, U8 -- +StrBuf,
    str-buf-full? if(
        "str-buf-push! but STR_BUF is already full" panic!
        drop,
        str-buf-length? str-buf-u8!
        str-buf-length? 1+ str-buf-length!
    ))
def(str-buf-write!, File -- +StrBuf, STR_BUF str-buf-length? posix-write!)
def(str-buf-print!, +StrBuf, file-out@ str-buf-write!)
def(str-buf-trace!, +StrBuf, file-err@ str-buf-write!)

def(str-buf-read!, File -- +IO,
    str-buf-clear!
    STR_BUF STR_BUF_SIZE 1- posix-read!
    dup 0< if(
        "str-buf-read! failed" panic! drop,
        str-buf-length!
    ))
def(str-buf-input!, -- +IO, file-in@ str-buf-read!)

# Set the STR_BUF to a given string. If the string is
# too large (> STR_BUF_SIZE - 1) it gets truncated.
def(str-buf!, Str -- +StrBuf,
    str-buf-clear!
    while(str-buf-full? if(0, dup u8@),
        dup u8@ str-buf-push!
        str-tail)
    drop)

# Tests

def(run-tests, --,
    test-if test-drop test-dup test-swap test-dip
    test-trip test-rotr test-rotl test= test< test<= test> test>=
    test+ test- test* test/ test% test-str test-while
    test@!)
def(test-if, --, 0 !!0 1 !!1 0 1 !!1 !!0)
def(test-drop, --, 0 1 drop !!0)
def(test-dup, --, 0 1 dup !!011)
def(test-swap, --, 0 1 0 swap !!001)
def(test-dip, --, 0 0 dip(1) !!010)
def(test-trip, --, 0 1 trip !!111 !!0)
def(test-rotr, --,
    1 0 0 rotr !!010
    0 1 0 rotr !!001
    0 0 1 rotr !!100)
def(test-rotl, --,
    1 0 0 rotl !!001
    0 1 0 rotl !!100
    0 0 1 rotl !!010)

def(test=, --,
    0 0 = !!1
    0 1 = !!0
    1 0 = !!0
    1 1 = !!1
    1 2 = !!0
    2 1 = !!0
    2 2 = !!1)
def(test<, --,
    0 0 < !!0
    0 1 < !!1
    1 0 < !!0
    1 1 < !!0
    1 2 < !!1
    2 1 < !!0
    2 2 < !!0)
def(test<=, --,
    0 0 <= !!1
    0 1 <= !!1
    1 0 <= !!0
    1 1 <= !!1
    1 2 <= !!1
    2 1 <= !!0
    2 2 <= !!1)
def(test>, --,
    0 0 > !!0
    0 1 > !!0
    1 0 > !!1
    1 1 > !!0
    1 2 > !!0
    2 1 > !!1
    2 2 > !!0)
def(test>=, --,
    0 0 >= !!1
    0 1 >= !!0
    1 0 >= !!1
    1 1 >= !!1
    1 2 >= !!0
    2 1 >= !!1
    2 2 >= !!1
    -1 0 >= !!0
    -1 -1 >= !!1
    0 -1 >= !!1
    -1 -2 >= !!1
    -2 -2 >= !!1
    -2 -1 >= !!0)

def(test+, --,
    0 0 + !!0
    0 1 + !!1
    1 0 + !!1
    1 1 + 2 = !!1
    2 2 + 4 = !!1
    2 -2 + !!0)

def(test-, --,
    0 0 - !!0
    1 0 - !!1
    1 1 - !!0
    0 1 - -1 !!=
    2 2 - !!0
    2 4 - -2 !!=
    4 2 - 2 !!=)

def(test*, --,
    0 0 * !!0
    2 1 * 2 !!=
    2 2 * 4 !!=
    2 4 * 8 !!=)

def(test/, --,
    1 1 / !!1
    -5 2 / -2 !!=
    -4 2 / -2 !!=
    -3 2 / -1 !!=
    -2 2 / -1 !!=
    -1 2 / !!0
    0 2 / !!0
    1 2 / !!0
    2 2 / !!1
    3 2 / !!1
    4 2 / 2 !!=
    5 2 / 2 !!=
    0 -2 / !!0
    1 -2 / !!0
    2 -2 / -1 !!=
    3 -2 / -1 !!=
    4 -2 / -2 !!=
    5 -2 / -2 !!=)

def(test%, --,
    1 1 % !!0
    -5 2 % -1 !!=
    -4 2 % !!0
    -3 2 % -1 !!=
    -2 2 % !!0
    -1 2 % -1 !!=
    0 2 % !!0
    1 2 % !!1
    2 2 % !!0
    3 2 % !!1
    4 2 % !!0
    5 2 % !!1)

2 quads def-static-buffer(TEST_BUF)
def(test@!, --,
    # reset test buffer
    0 0 TEST_BUF quad!!
    0 1 TEST_BUF quad!!
    # run test
    0 TEST_BUF quad@@ !!0
    1 TEST_BUF quad@@ !!0
    99 0 TEST_BUF quad!!
    0 TEST_BUF quad@@ 99 !!=
    1 TEST_BUF quad@@ !!0
    30 1 TEST_BUF quad!!
    0 TEST_BUF quad@@ 99 !!=
    1 TEST_BUF quad@@ 30 !!=
    0 0 TEST_BUF quad!!
    0 TEST_BUF u8@@ 0 !!=
    1 TEST_BUF u8@@ 0 !!=
    2 TEST_BUF u8@@ 0 !!=
    3 TEST_BUF u8@@ 0 !!=
    99 Int->U8 2 TEST_BUF u8!!
    0 TEST_BUF u8@@ 0 !!=
    1 TEST_BUF u8@@ 0 !!=
    2 TEST_BUF u8@@ 99 !!=
    3 TEST_BUF u8@@ 0 !!=)

def(test-str, --,
    "AaBb"
    dup u8@ 65 !!=
    dup str-tail u8@ 97 !!=
    dup str-tail str-tail u8@ 66 !!=
    dup str-tail str-tail str-tail u8@ 98 !!=
    dup str-tail str-tail str-tail str-tail u8@ 0 !!=
    drop

    "" str-length 0 !!=
    "hello" str-length 5 !!=
    "hello, world!" str-length 13 !!=
    )

def(test-while, --,
    999 10 20 while(dup, 1- dip(1+)) drop 30 !!= 999 !!=)

def(stdin,  File, 0)
def(stdout, File, 1)
def(stderr, File, 2)

def(init!, +IO,
    init-io!
    0 strings-size!
    0 num-tokens!
    init-names!
    init-buffers!
    init-heap!)

def(init-io!, +IO,
    stdin file-in!
    stdout file-out!
    stderr file-err!
    )

quad def-static-buffer(FILE_IN)
def(file-in!, File -- +IO, FILE_IN !)
def(file-in@, -- File +IO, FILE_IN @)

quad def-static-buffer(FILE_OUT)
def(file-out!, File -- +IO, FILE_OUT !)
def(file-out@, -- File +IO, FILE_OUT @)

quad def-static-buffer(FILE_ERR)
def(file-err!, File -- +IO, FILE_ERR !)
def(file-err@, -- File +IO, FILE_ERR @)

def(str-write!, Str File -- +IO,
    swap dup str-length posix-write!)

def(str-print!, Str -- +IO, file-out@ str-write!)
def(str-trace!, Str -- +IO, file-err@ str-write!)
def(str-print-sp!, Str -- +IO, str-print! print-sp!)
def(str-trace-sp!, Str -- +IO, str-trace! trace-sp!)
def(str-print-ln!, Str -- +IO, str-print! print-ln!)
def(str-trace-ln!, Str -- +IO, str-trace! trace-ln!)

def(str-buf-char!, Char -- +StrBuf, 0 str-buf-u8! 1 str-buf-length!)
def(print-char!, Char -- +IO, str-buf-char! str-buf-print!)
def(trace-char!, Char -- +IO, str-buf-char! str-buf-trace!)

def(print-ln!, +IO, 10 Int->U8 print-char!)
def(trace-ln!, +IO, 10 Int->U8 trace-char!)
def(print-sp!, +IO, 32 Int->U8 print-char!)
def(trace-sp!, +IO, 32 Int->U8 trace-char!)
def(print-quote!, +IO, 34 Int->U8 print-char!)

def(to-digit, Int -- U8, 10 % 48 + Int->U8)

def(cast, a -- b, id)

def(Int->Ptr, Int -- Ptr, cast)
def(Ptr->Int, Ptr -- Int, cast)

def(U8_MAX, Int, 0xFF)
def(U16_MAX, Int, 1 16 << 1-)
def(U32_MAX, Int, 1 32 << 1-)
def(I8_MAX, Int, 127)
def(I16_MAX, Int, 1 15 << 1-)
def(I32_MAX, Int, 1 31 << 1-)

def(U8_MIN, Int, 0)
def(U16_MIN, Int, 0)
def(U32_MIN, Int, 0)
def(I8_MIN, Int, -128)
def(I16_MIN, Int, 0 1 15 << -)
def(I32_MIN, Int, 0 1 31 << -)


def(Int->U8, Int -- U8,
    dup U8_MIN U8_MAX in-range if(
        cast,
        "Int->U8 failed: out of bounds" panic! cast
    ))
def(Int->U16, Int -- U16,
    dup U16_MIN U16_MAX in-range if(
        cast,
        "Int->U16 failed: out of bounds" panic! cast
    ))
def(Int->U32, Int -- U32,
    dup U32_MIN U32_MAX in-range if(
        cast,
        "Int->U32 failed: out of bounds" panic! cast
    ))
def(Int->U64, Int -- U64, cast)

def(Int->I8, Int -- I8,
    dup I8_MIN I8_MAX in-range if(
        cast,
        "Int->I8 failed: out of bounds" panic! cast
    ))
def(Int->I16, Int -- I16,
    dup I16_MIN I16_MAX in-range if(
        cast,
        "Int->I16 failed: out of bounds" panic! cast
    ))
def(Int->I32, Int -- I32,
    dup I32_MIN I32_MAX in-range if(
        cast,
        "Int->I32 failed: out of bounds" panic! cast
    ))
def(Int->I64, Int -- I64, cast)

def(U8->Int, U8 -- Int, cast)
def(U16->Int, U16 -- Int, cast)
def(U32->Int, U32 -- Int, cast)
def(U64->Int, U64 -- Int, cast)
def(I8->Int, I8 -- Int, cast)
def(I16->Int, I16 -- Int, cast)
def(I32->Int, I32 -- Int, cast)
def(I64->Int, I64 -- Int, cast)

def(negate, Int -- Int, -1 *)
def(abs, Int -- Int, dup 0 < if(negate, id))

# put integer into str buf
def(str-buf-int!, Int --,
    dup 0= if(
        drop "0" str-buf!,
        dup dip(
            abs
            str-buf-clear!
            while(dup, dup to-digit str-buf-push! 10 /) drop
        ) 0 < if(45 Int->U8 str-buf-push!, id)
        str-buf-reverse!
    ))

def(int-write!, Int File -- +IO, dip(str-buf-int!) str-buf-write!)
def(int-print!, Int -- +IO, file-out@ int-write!)
def(int-trace!, Int -- +IO, file-err@ int-write!)
def(int-print-sp!, Int -- +IO, int-print! print-sp!)
def(int-trace-sp!, Int -- +IO, int-trace! trace-sp!)
def(int-print-ln!, Int -- +IO, int-print! print-ln!)
def(int-trace-ln!, Int -- +IO, int-trace! trace-ln!)

def(panic!, Str -- +IO,
    "panic: " str-trace! str-trace-ln! 1 posix-exit!)

# reverse contents of str buf

def(str-buf-swap-u8!, Int Int --,
    dup2 swap
    dip(dip(dip(str-buf-u8@)))
    dip(str-buf-u8@)
    str-buf-u8! str-buf-u8!
)

def(str-buf-reverse!, --,
    0 str-buf-length? 1-
    while(dup2 <,
        dup2 str-buf-swap-u8!
        dip(1 +) 1-
    )
    drop2)

##########
# System #
##########

def-type(OS, Int)
def(UNKNOWN, OS, 0)
def(WIN32, OS, 1)
def(LINUX, OS, 2)
def(MACOS, OS, 3)

def(open-file!, Str -- File +IO,
    0 0 posix-open!
    dup 0 < if("Failed to open file!" panic!, id))

def(create-file!, Str -- File +IO,
    O_WRONLY|O_CREAT|O_TRUNC
    0x1B6
        # this is the default mode for creating a file
        # on unix, 666 in octal, i.e. owner can
        # read+write, everyone can read
    posix-open!
    dup 0 < if("Failed to create file!" panic!, id))

def(O_WRONLY|O_CREAT|O_TRUNC, Int,
    RUNNING_OS MACOS = if(
        0x601, # O_WRONLY = 0x1, O_CREAT = 0x200, O_TRUNC = 0x400
    RUNNING_OS LINUX = if(
        0x241, # O_WRONLY = 0x1, O_CREAT = 0x40, O_TRUNC = 0x200
    RUNNING_OS WIN32 = if(
        0x301, # O_WRONLY = 0x1, O_CREAT|O_TRUNC = 0x300
        "O_WRONLY|O_CREAT|O_TRUNC not known for os" panic! 0
    ))))


def(close-file!, File -- +IO,
    posix-close!
    0 < if(
        "failed to close file" panic!,
        id
    ))

def(open-mirth-src!, File +IO,
    "Reading mirth.mth" str-trace-ln!
    "mirth.mth" open-file!)

#########
# Input #
#########

def(INPUT_BUFFER_SIZE, Size, 0x200)
quad def-static-buffer(INPUT_ISOPEN)
quad def-static-buffer(INPUT_LENGTH)
quad def-static-buffer(INPUT_OFFSET)
quad def-static-buffer(INPUT_HANDLE)
INPUT_BUFFER_SIZE def-static-buffer(INPUT_BUFFER)

def(input-isopen@, Bool +Input, INPUT_ISOPEN @)
def(input-length@, Size +Input, INPUT_LENGTH @)
def(input-offset@, Size +Input, INPUT_OFFSET @)
def(input-handle@, File +Input, INPUT_HANDLE @)
def(input-isopen!, Bool -- +Input, INPUT_ISOPEN !)
def(input-length!, Size -- +Input, INPUT_LENGTH !)
def(input-offset!, Size -- +Input, INPUT_OFFSET !)
def(input-handle!, File -- +Input, INPUT_HANDLE !)

def(input-start!, File -- +Input,
    input-handle!
    0 input-length!
    0 input-offset!
    1 input-isopen!
    input-fill-buffer!)

def(input-end!, +Input,
    input-isopen@ if(
        input-handle@ close-file!,
        id
    )
    0 input-handle!
    0 input-length!
    0 input-offset!
    0 input-isopen!)

def(input-done?, Bool +Input,
    input-isopen@ not)

def(input-fill-buffer!, +Input,
    input-isopen@ if(
        input-handle@
        INPUT_BUFFER
        INPUT_BUFFER_SIZE
        posix-read!
        dup 0 >= if(
            dup 0 > if(
                input-length!
                0 input-offset!,
                drop
                input-end!
            ),
            drop "error: failed to read from file" panic!
        ),
        "error: attempted to fill input buffer when file is closed" panic!
    ))


# Return the current char in the input buffer.
# Panics if file is exhausted.
def(input-peek, Char +Input,
    input-isopen@ if(
        input-offset@ INPUT_BUFFER u8@@,
        "error: attempted to read input buffer when file is already closed" panic! 0
    ) Int->U8)

# Move to next char in input buffer.
# Panics if file is exhausted.
def(input-move!, +Input,
    input-isopen@ if(
        input-offset@ 1+ dup input-offset!
        input-length@ >= if(
            input-fill-buffer!,
            id
        ),
        "error: attempted to move input buffer when file is already closed" panic!
    ))

#########
# Names #
#########

def-type(Name, Int)
def-type(Hash, Int)

def(MAX_NAMES, Size, 0x1000)
def(NAME_HASH_MAX, Size, 0xFFF)
def(NAME_TABLE_SIZE, Size, NAME_HASH_MAX 1+)
quad def-static-buffer(NUM_NAMES)
def(num-names@, Size, NUM_NAMES @)
def(num-names!, Size --, NUM_NAMES !)

def(NAME_QUADS, Size, 8)
def(NAME_SIZE, Size, NAME_QUADS quads)
def(NAME_BUF_SIZE, Size, NAME_SIZE MAX_NAMES *)
NAME_BUF_SIZE def-static-buffer(NAME_BUF)

NAME_TABLE_SIZE quads
    def-static-buffer(NAME_TABLE)

# Load a name into STR_BUF.
def(name-load!, Name --,
    name-quads-load!
    NAME_SIZE str-buf-length!
    STR_BUF str-length str-buf-length!)

# Compare all quads in name to STR_BUF.
# Note this code assumes NAME_QUADS is 8.
def(name-quads-eq, Name -- Bool,
    NAME_SIZE * NAME_BUF +
    0 over quad@@ 0 STR_BUF quad@@ = if(
    1 over quad@@ 1 STR_BUF quad@@ = if(
    2 over quad@@ 2 STR_BUF quad@@ = if(
    3 over quad@@ 3 STR_BUF quad@@ = if(
    4 over quad@@ 4 STR_BUF quad@@ = if(
    5 over quad@@ 5 STR_BUF quad@@ = if(
    6 over quad@@ 6 STR_BUF quad@@ = if(
    7 swap quad@@ 7 STR_BUF quad@@ =,
    drop 0), drop 0), drop 0), drop 0),
    drop 0), drop 0), drop 0))

def(hash, Ptr -- Hash,
    0 swap
    while(dup u8@,
        dup dip(u8@ U8->Int 5 * swap 18 * ^)
        str-tail)
    drop
    NAME_HASH_MAX &)

def(name-hash, Name -- Hash,
    NAME_SIZE * NAME_BUF + hash)

def(name-quads-eq?, Name -- Name Bool,
    dup name-quads-eq)

def(name-quad-save!, Name Int --,
    dip(NAME_SIZE * NAME_BUF +) tuck
    STR_BUF quad@@ rotr quad!!)

def(name-quads-save!, Name -- ,
    dup 0 name-quad-save!
    dup 1 name-quad-save!
    dup 2 name-quad-save!
    dup 3 name-quad-save!
    dup 4 name-quad-save!
    dup 5 name-quad-save!
    dup 6 name-quad-save!
    7 name-quad-save!)

def(name-quads-load!, Name --,
    NAME_SIZE * NAME_BUF +
    0 over quad@@ 0 STR_BUF quad!!
    1 over quad@@ 1 STR_BUF quad!!
    2 over quad@@ 2 STR_BUF quad!!
    3 over quad@@ 3 STR_BUF quad!!
    4 over quad@@ 4 STR_BUF quad!!
    5 over quad@@ 5 STR_BUF quad!!
    6 over quad@@ 6 STR_BUF quad!!
    7 swap quad@@ 7 STR_BUF quad!!)

# zero str-buf up to NAME_SIZE
def(str-buf-zero!, --,
    0 0 STR_BUF quad!!
    0 1 STR_BUF quad!!
    0 2 STR_BUF quad!!
    0 3 STR_BUF quad!!
    0 4 STR_BUF quad!!
    0 5 STR_BUF quad!!
    0 6 STR_BUF quad!!
    0 7 STR_BUF quad!!)


def(name-table@, Hash -- Name, NAME_TABLE quad@@ 1-)
def(name-table!, Name Hash --, dip(1+) NAME_TABLE quad!!)
def(next-hash, Hash -- Hash, 1+ NAME_HASH_MAX &)

def(name-save-keep-going?, Hash -- Hash Bool,
    dup name-table@
    dup 0 < if(
        drop 0,
        name-quads-eq not
    ))

# Load STR_BUF into name table. Performs deduplication.
def(name-save!, -- Name,
    STR_BUF hash
    while(name-save-keep-going?, next-hash)
    dup name-table@
    dup 0 < if(
        drop
        num-names@ swap name-table!
        num-names@ name-quads-save!
        num-names@ dup 1+ num-names!,
        nip
    ))

quad def-static-buffer(name-bytes)
def(show-names-table!, +Names +IO,
    0 name-bytes !
    0
    while(dup num-names@ <,
        dup int-print!
        ": " str-print!
        dup name-load!
        str-buf-length? name-bytes @ + 1+ name-bytes !
        str-buf-print! print-sp!
        dup name-hash int-print! print-ln!
        1+
    )
    drop
    "Total bytes: " str-print!
    name-bytes @ int-print-ln!)

def(name-could-be-type, Name -- Bool,
    NAME_SIZE * NAME_BUF u8@@ is-alpha? nip)

def(name-could-be-type-var, Name -- Bool,
    NAME_SIZE * NAME_BUF u8@@ is-lower? nip)

def(name-could-be-type-con, Name -- Bool,
    NAME_SIZE * NAME_BUF u8@@ is-upper? nip)

def(name-could-be-effect-con, Name -- Bool,
    NAME_SIZE * dup NAME_BUF u8@@ is-plus-sign? nip if(
        1+ NAME_BUF u8@@ is-upper? nip,
        drop 0
    ))

def(name-print-mangled!, Name -- +IO,
    name-mangle! str-buf-print!)

def(name-mangle!, Name -- +StrBuf,
    str-buf-clear!
    NAME_SIZE * 0
    while(dup NAME_SIZE <,
        over NAME_BUF u8@@
        str-buf-push-mangled!
        dip(1+) 1+)
    drop2)

def(str-buf-push-mangled!, Char -- +StrBuf,
    is-nul? if(
        drop,

    is-alpha? if(
        str-buf-push!,

    is-digit? if(
        str-buf-push!,

    is-dash? if(
        drop
        underscore str-buf-push!, # technically bad but looks nice for now

    is-underscore? if(
        str-buf-push!, # technically bad but looks nice for now

        underscore str-buf-push!
        str-buf-push-hexdigits!
        underscore str-buf-push!
    ))))))

def(str-buf-push-hexdigits!, Char -- +StrBuf,
    U8->Int dup
    16 / Int->U8 str-buf-push-hexdigit!
    16 % Int->U8 str-buf-push-hexdigit!)

def(str-buf-push-hexdigit!, Char -- +StrBuf,
    U8->Int dup 10 >= if(
        55 + Int->U8 str-buf-push!,
        48 + Int->U8 str-buf-push!
    ))

###################
# Primitive Names #
###################

def-type(Prim, Name)
def(PRIM_END, Prim, 0)
def(PRIM_ID, Prim, 1)
def(PRIM_DUP, Prim, 2)
def(PRIM_DROP, Prim, 3)
def(PRIM_SWAP, Prim, 4)
def(PRIM_DIP, Prim, 5)
def(PRIM_IF, Prim, 6)
def(PRIM_WHILE, Prim, 7)
def(PRIM_INT_ADD, Prim, 8)
def(PRIM_INT_SUB, Prim, 9)
def(PRIM_INT_MUL, Prim, 10)
def(PRIM_INT_DIV, Prim, 11)
def(PRIM_INT_MOD, Prim, 12)
def(PRIM_INT_EQ, Prim, 13)
def(PRIM_INT_LT, Prim, 14)
def(PRIM_INT_LE, Prim, 15)
def(PRIM_INT_AND, Prim, 16)
def(PRIM_INT_OR, Prim, 17)
def(PRIM_INT_XOR, Prim, 18)
def(PRIM_INT_SHL, Prim, 19)
def(PRIM_INT_SHR, Prim, 20)
def(PRIM_MEM_GET, Prim, 21)
def(PRIM_MEM_SET, Prim, 22)
def(PRIM_MEM_GET_BYTE, Prim, 23)
def(PRIM_MEM_SET_BYTE, Prim, 24)
def(PRIM_MEM_GET_U8, Prim, 25)
def(PRIM_MEM_SET_U8, Prim, 26)
def(PRIM_MEM_GET_U16, Prim, 27)
def(PRIM_MEM_SET_U16, Prim, 28)
def(PRIM_MEM_GET_U32, Prim, 29)
def(PRIM_MEM_SET_U32, Prim, 30)
def(PRIM_MEM_GET_U64, Prim, 31)
def(PRIM_MEM_SET_U64, Prim, 32)
def(PRIM_MEM_GET_I8, Prim, 33)
def(PRIM_MEM_SET_I8, Prim, 34)
def(PRIM_MEM_GET_I16, Prim, 35)
def(PRIM_MEM_SET_I16, Prim, 36)
def(PRIM_MEM_GET_I32, Prim, 37)
def(PRIM_MEM_SET_I32, Prim, 38)
def(PRIM_MEM_GET_I64, Prim, 39)
def(PRIM_MEM_SET_I64, Prim, 40)
def(PRIM_POSIX_READ, Prim, 41)
def(PRIM_POSIX_WRITE, Prim, 42)
def(PRIM_POSIX_OPEN, Prim, 43)
def(PRIM_POSIX_CLOSE, Prim, 44)
def(PRIM_POSIX_EXIT, Prim, 45)
def(PRIM_POSIX_MMAP, Prim, 46)
def(PRIM_DEBUG, Prim, 47)
def(PRIM_MIRTH_REVISION, Prim, 48)
def(PRIM_RUNNING_OS, Prim, 49)
def(PRIM_DEF, Prim, 50)
def(PRIM_DEF_TYPE, Prim, 51)
def(PRIM_DEF_STATIC_BUFFER, Prim, 52)
def(PRIM_DEF_EXTERNAL, Prim, 53)
def(PRIM_OUTPUT_ASM, Prim, 54)
def(PRIM_OUTPUT_C99, Prim, 55)
def(PRIM_DASHES, Prim, 56)
def(PRIM_ARROW, Prim, 57)
def(PRIM_INT, Prim, 58)
def(PRIM_PTR, Prim, 59)
def(PRIM_U8, Prim, 60)
def(PRIM_U16, Prim, 61)
def(PRIM_U32, Prim, 62)
def(PRIM_U64, Prim, 63)
def(PRIM_I8, Prim, 64)
def(PRIM_I16, Prim, 65)
def(PRIM_I32, Prim, 66)
def(PRIM_I64, Prim, 67)
def(NUM_PRIMS, Prim, 68)

def(name-is-prim?, Name -- Name Bool, dup NUM_PRIMS <)

def(def-prim!, Prim Str -- +Names,
    str-buf-zero! str-buf! name-save! swap
    = if(id, "primitive number mismatch" panic!))

# Initialize name table with list of primitives.
# Note that order matters very much here. Any
# deviation from the order above will be flagged
# by def-prim!
def(init-names!, +Names,
    NAME_TABLE_SIZE
    while(dup,
        1-
        0 over NAME_TABLE quad!!
    ) drop

    num-names@ while(dup,
        1-
        0 over name-checked!
        0 over name-sort!
        0 over name-value!
        0 over name-sig!
    ) drop

    0 num-names!
    PRIM_END "end" def-prim!
    PRIM_ID "id" def-prim!
    PRIM_DUP "dup" def-prim!
    PRIM_DROP "drop" def-prim!
    PRIM_SWAP "swap" def-prim!
    PRIM_DIP "dip" def-prim!
    PRIM_IF "if" def-prim!
    PRIM_WHILE "while" def-prim!
    PRIM_INT_ADD "+" def-prim!
    PRIM_INT_SUB "-" def-prim!
    PRIM_INT_MUL "*" def-prim!
    PRIM_INT_DIV "/" def-prim!
    PRIM_INT_MOD "%" def-prim!
    PRIM_INT_EQ "=" def-prim!
    PRIM_INT_LT "<" def-prim!
    PRIM_INT_LE "<=" def-prim!
    PRIM_INT_AND "&" def-prim!
    PRIM_INT_OR "|" def-prim!
    PRIM_INT_XOR "^" def-prim!
    PRIM_INT_SHL "<<" def-prim!
    PRIM_INT_SHR ">>" def-prim!
    PRIM_MEM_GET "@" def-prim!
    PRIM_MEM_SET "!" def-prim!
    PRIM_MEM_GET_BYTE "byte@" def-prim!
    PRIM_MEM_SET_BYTE "byte!" def-prim!
    PRIM_MEM_GET_U8 "u8@" def-prim!
    PRIM_MEM_SET_U8 "u8!" def-prim!
    PRIM_MEM_GET_U16 "u16@" def-prim!
    PRIM_MEM_SET_U16 "u16!" def-prim!
    PRIM_MEM_GET_U32 "u32@" def-prim!
    PRIM_MEM_SET_U32 "u32!" def-prim!
    PRIM_MEM_GET_U64 "u64@" def-prim!
    PRIM_MEM_SET_U64 "u64!" def-prim!
    PRIM_MEM_GET_I8 "i8@" def-prim!
    PRIM_MEM_SET_I8 "i8!" def-prim!
    PRIM_MEM_GET_I16 "i16@" def-prim!
    PRIM_MEM_SET_I16 "i16!" def-prim!
    PRIM_MEM_GET_I32 "i32@" def-prim!
    PRIM_MEM_SET_I32 "i32!" def-prim!
    PRIM_MEM_GET_I64 "i64@" def-prim!
    PRIM_MEM_SET_I64 "i64!" def-prim!
    PRIM_POSIX_READ "posix-read!" def-prim!
    PRIM_POSIX_WRITE "posix-write!" def-prim!
    PRIM_POSIX_OPEN "posix-open!" def-prim!
    PRIM_POSIX_CLOSE "posix-close!" def-prim!
    PRIM_POSIX_EXIT "posix-exit!" def-prim!
    PRIM_POSIX_MMAP "posix-mmap!" def-prim!
    PRIM_DEBUG "??" def-prim!
    PRIM_MIRTH_REVISION "MIRTH_REVISION" def-prim!
    PRIM_RUNNING_OS "RUNNING_OS" def-prim!
    PRIM_DEF "def" def-prim!
    PRIM_DEF_TYPE "def-type" def-prim!
    PRIM_DEF_STATIC_BUFFER "def-static-buffer" def-prim!
    PRIM_DEF_EXTERNAL "def-external" def-prim!
    PRIM_OUTPUT_ASM "output-asm" def-prim!
    PRIM_OUTPUT_C99 "output-c99" def-prim!
    PRIM_DASHES "--" def-prim!
    PRIM_ARROW "->" def-prim!
    PRIM_INT "Int" def-prim!
        DEF_TYPE PRIM_INT name-sort!
        TYPE_INT PRIM_INT name-value!
    PRIM_PTR "Ptr" def-prim!
        DEF_TYPE PRIM_PTR name-sort!
        TYPE_PTR PRIM_PTR name-value!
    PRIM_U8 "U8" def-prim!
        DEF_TYPE PRIM_U8 name-sort!
        TYPE_U8 PRIM_U8 name-value!
    PRIM_U16 "U16" def-prim!
        DEF_TYPE PRIM_U16 name-sort!
        TYPE_U16 PRIM_U16 name-value!
    PRIM_U32 "U32" def-prim!
        DEF_TYPE PRIM_U32 name-sort!
        TYPE_U32 PRIM_U32 name-value!
    PRIM_U64 "U64" def-prim!
        DEF_TYPE PRIM_U64 name-sort!
        TYPE_U64 PRIM_U64 name-value!
    PRIM_I8 "I8" def-prim!
        DEF_TYPE PRIM_I8 name-sort!
        TYPE_I8 PRIM_I8 name-value!
    PRIM_I16 "I16" def-prim!
        DEF_TYPE PRIM_I16 name-sort!
        TYPE_I16 PRIM_I16 name-value!
    PRIM_I32 "I32" def-prim!
        DEF_TYPE PRIM_I32 name-sort!
        TYPE_I32 PRIM_I32 name-value!
    PRIM_I64 "I64" def-prim!
        DEF_TYPE PRIM_I64 name-sort!
        TYPE_I64 PRIM_I64 name-value!
    )

#################
# Strings Table #
#################

def-type(StringOffset, Int)
def-type(String, Str)

def(MAX_STRINGS, Size, 0x4000)
quad def-static-buffer(STRINGS_SIZE)
MAX_STRINGS u8s def-static-buffer(STRINGS_BUF)

# Size of strings table.
def(strings-size@, -- Size +StrTable, STRINGS_SIZE @)

# Size of strings table.
def(strings-size!, Size -- +StrTable, STRINGS_SIZE !)

# Push byte onto strings table.
def(strings-push!, U8 -- +StrTable,
    strings-size@ MAX_STRINGS >= if(
        "strings buffer overflow" panic! drop,
        strings-size@ STRINGS_BUF u8!!
        strings-size@ 1+ strings-size!
    ))

# Load STR_BUF into strings table,
# returning the index of the new string.
def(strings-save!, StringOffset +StrTable +StrBuf,
    strings-size@
    0
    while(dup str-buf-length? <,
        dup str-buf-u8@
        strings-push!
        1+
    )
    drop
    0 Int->U8 strings-push!)

# Load string into STR_BUF.
def(strings-load!, Str -- +StrBuf,
    str-buf!)

##########
# Tokens #
##########

def(MAX_TOKENS, Size, 0x7000)

quad def-static-buffer(NUM_TOKENS)
def(num-tokens@, Int, NUM_TOKENS @)
def(num-tokens!, Int --, NUM_TOKENS !)
def(clear-tokens!, --, 0 num-tokens!)

def-type(Token, Int)
def-type(TokenType, U8)
def-type(Row, U16)
def-type(Col, U16)

MAX_TOKENS u8s def-static-buffer(TOKEN_TYPE)
def(token-type!, TokenType Token --, TOKEN_TYPE u8!!)
def(token-type@, Token -- TokenType, TOKEN_TYPE u8@@)
def(token-type?, Token -- Token TokenType, dup token-type@)
def(TOKEN_NONE, TokenType, 0 Int->U8)
def(TOKEN_LPAREN, TokenType, 1 Int->U8)
def(TOKEN_RPAREN, TokenType, 2 Int->U8)
def(TOKEN_COMMA, TokenType, 3 Int->U8)
def(TOKEN_NAME, TokenType, 4 Int->U8)
def(TOKEN_INT, TokenType, 5 Int->U8)
def(TOKEN_STR, TokenType, 6 Int->U8)
def(token-type-str, TokenType -- Str,
    dup TOKEN_NONE = if(drop "NONE",
    dup TOKEN_LPAREN = if(drop "LPAREN",
    dup TOKEN_RPAREN = if(drop "RPAREN",
    dup TOKEN_COMMA = if(drop "COMMA",
    dup TOKEN_NAME = if(drop "NAME",
    dup TOKEN_INT = if(drop "INT",
    dup TOKEN_STR = if(drop "STR",
    drop "???UNKNOWN???"))))))))
def(token-type-print!, TokenType --,
    token-type-str str-print!)

MAX_TOKENS i16s def-static-buffer(TOKEN_VALUE)
def-type(TokenValue, I16)
def(token-value!, TokenValue Token --, TOKEN_VALUE i16!!)
def(token-value@, Token -- TokenValue, TOKEN_VALUE i16@@)
def(token-value?, Token -- Token TokenValue, dup token-value@)
def(Int->TokenValue, Int -- TokenValue, Int->I16)
def(Name->TokenValue, Name -- TokenValue, Int->I16)
def(Token->TokenValue, Token -- TokenValue, Int->I16)
def(TokenValue->Int, TokenValue -- Int, I16->Int)
def(TokenValue->Name, TokenValue -- Name, I16->Int)
def(TokenValue->Token, TokenValue -- Token, I16->Int)
def(TokenValue->Str, TokenValue -- Str, I16->Int STRINGS_BUF +)

def(token-int@, Token -- Int,
    token-type? TOKEN_INT = if(
        token-value@ TokenValue->Int,
        "compiler error: token-int@ called on non-int token" emit-fatal-error! 0
    ))
def(token-int?, Token -- Token Int, dup token-int@)

def(token-str@, Token -- Str,
    token-type? TOKEN_STR = if(
        token-value@ TokenValue->Str,
        "compiler error: token-str@ called on non-str token" emit-fatal-error! ""
    ))
def(token-str?, Token -- Token Str, dup token-str@)

def(token-name@, Token -- Name,
    token-type? TOKEN_NAME = if(
        token-value@ TokenValue->Name,
        "compiler error: token-name@ called on non-name token" emit-fatal-error! PRIM_ID
    ))
def(token-name?, Token -- Token Name, dup token-name@)

def(token-token@, Token -- Token,
    token-type? TOKEN_LPAREN = if(
        token-value@ TokenValue->Token,
    token-type? TOKEN_RPAREN = if(
        token-value@ TokenValue->Token,
        "compiler error: token-token@ called on non-paren token" emit-fatal-error! 0
    )))
def(token-token?, Token -- Token Token, dup token-token@)


MAX_TOKENS u16s def-static-buffer(TOKEN_ROW)
def(token-row!, Row Token --, TOKEN_ROW u16!!)
def(token-row@, Token -- Row, TOKEN_ROW u16@@)
def(token-row?, Token -- Token Row, dup token-row@)
def(Row->Int, Row -- Int, U16->Int)
def(Int->Row, Int -- Row, Int->U16)

MAX_TOKENS u16s def-static-buffer(TOKEN_COL)
def(token-col!, Col Token --, TOKEN_COL u16!!)
def(token-col@, Token -- Col, TOKEN_COL u16@@)
def(token-col?, Token -- Token Col, dup token-col@)
def(Col->Int, Col -- Int, U16->Int)
def(Int->Col, Int -- Col, Int->U16)

def(token-new, -- Token,
    num-tokens@ dup MAX_TOKENS >= if(
        "tokens buffer overflow" panic!,
        dup 1+ num-tokens!
    ))

def(token-trace-prefix!, Token -- +IO,
    token-row? Row->Int int-trace! ":" str-trace!
    token-col? Col->Int int-trace! ":" str-trace-sp!
    drop)

def(token-print-prefix!, Token -- +IO,
    token-row? Row->Int int-print! ":" str-print!
    token-col? Col->Int int-print! ":" str-print-sp!
    drop)

def(token-print!, Token -- +IO,
    dup token-print-prefix!
    dup int-print-sp!
    token-type? token-type-print!
    token-type? TOKEN_NAME = if(
        print-sp!
        token-name? name-load! str-buf-print!,

    token-type? TOKEN_STR = if(
        print-sp!
        print-quote!
        token-str? str-print! print-quote!,
        # FIXME: print escaped

        print-sp!
        token-value? TokenValue->Int int-print!))

    drop
    print-ln!)

def(show-tokens!, --,
    0
    while(dup num-tokens@ <,
        dup token-print! 1+)
    drop)

#########
# LEXER #
#########

u16 def-static-buffer(LEXER_ROW)
def(lexer-row@, -- Row +Lexer, LEXER_ROW u16@)
def(lexer-row!, Row -- +Lexer, LEXER_ROW u16!)

u16 def-static-buffer(LEXER_COL)
def(lexer-col@, -- Col +Lexer, LEXER_COL u16@)
def(lexer-col!, Col -- +Lexer, LEXER_COL u16!)

def(LEXER_STACK_SIZE, Size, 0x200)
u16 def-static-buffer(LEXER_STACK_LENGTH)
LEXER_STACK_SIZE quads def-static-buffer(LEXER_STACK_BUF)

def(lexer-stack-length@, Size +Lexer,
    LEXER_STACK_LENGTH u16@ U16->Int)

def(lexer-stack-length!, Size -- +Lexer,
    Int->U16 LEXER_STACK_LENGTH u16!)

def(lexer-stack-clear!, +Lexer,
    0 lexer-stack-length!)

def(lexer-stack-empty?, Bool +Lexer,
    lexer-stack-length@ 0 <=)

def(lexer-stack-full?, Bool +Lexer,
    lexer-stack-length@ LEXER_STACK_SIZE >=)

def(lexer-stack-push!, Token -- +Lexer,
    lexer-stack-full? if(
        "lexer stack overflow" panic! drop,
        lexer-stack-length@
        dup 1+ lexer-stack-length!
        LEXER_STACK_BUF quad!!
    ))

def(lexer-stack-pop!, -- Token +Lexer,
    lexer-stack-empty? if(
        "lexer stack underflow" panic! 0,
        lexer-stack-length@ 1-
        dup lexer-stack-length!
        LEXER_STACK_BUF quad@@
    ))

def(run-lexer!, File -- +Lexer,

    input-start!

    1 Int->U16 lexer-row!
    1 Int->U16 lexer-col!

    while(lexer-done? not, lexer-next!)

    input-end!

    lexer-stack-empty? if(
        TOKEN_NONE 0 Int->TokenValue lexer-emit!,

        lexer-stack-pop!
        "Mismatched left parenthesis."
        emit-fatal-error!
    ))

# Is the lexer done?
def(lexer-done?, Bool +Lexer, input-done?)

# Create a token, and add it to the token buffer,
# returning the new token.
def(lexer-make!, TokenType TokenValue -- Token,
    token-new
    dup dip(token-value!)
    dup dip(token-type!)
    dip(lexer-row@) dup dip(token-row!)
    dip(lexer-col@) dup dip(token-col!))

# Create a token, and add it to the token buffer.
def(lexer-emit!, TokenType TokenValue --, lexer-make! drop)

# Lex the next token.
def(lexer-next!, --,
    lexer-peek

    is-name-char? if(
        drop
        lexer-emit-name!,

    is-newline? if(
        drop
        lexer-emit-newline!,

    is-whitespace? if(
        drop,

    is-pound? if(
        drop
        lexer-skip-comment!,

    is-comma? if(
        drop
        TOKEN_COMMA 0 Int->TokenValue lexer-emit!,

    is-lparen? if(
        drop
        lexer-emit-lparen!,

    is-rparen? if(
        drop
        lexer-emit-rparen!,

    is-quote? if(
        drop
        lexer-emit-string!,

        drop # LATER emit lexer error
    )))))))

    lexer-move!))


def(lexer-emit-newline!, +Lexer,
    lexer-row@ Row->Int 1+ Int->Row lexer-row!
    0 Int->Col lexer-col!)

def(lexer-emit-lparen!, +Lexer,
    TOKEN_LPAREN 0 Int->TokenValue lexer-make!
    lexer-stack-push!)

def(lexer-emit-rparen!, +Lexer,
    lexer-stack-empty? if(
        "Mismatched right parenthesis." lexer-emit-fatal-error!,
        TOKEN_RPAREN lexer-stack-pop! dup
        dip(Token->TokenValue lexer-make!)
        dip(Token->TokenValue) token-value!
    ))

def(lexer-emit-name!, +Lexer,
    str-buf-clear!
    str-buf-zero!
    TOKEN_NAME 0 Int->TokenValue lexer-make!


    lexer-peek while(is-name-char?,
        str-buf-push!
        lexer-move!
        lexer-peek
    )
    drop

    str-buf-is-int? if(
        str-buf-int? over token-value!
        TOKEN_INT swap token-type!,

        name-save!
        Name->TokenValue swap token-value!
    ))

def(str-buf-is-int?, Bool +StrBuf,
    str-buf-is-dec-int? if(1, str-buf-is-hex-int?))

def(str-buf-is-dec-int?, Bool +StrBuf,
    0 # number of digits
    0 # current index
    dup str-buf-u8@ is-sign? nip if(
        1+,
        id
    )
    while(dup str-buf-u8@ is-digit? nip,
        dip(1+) 1+)
    swap 1 >= if(
        str-buf-length? =,
        drop 0
    ))

def(is-zero-char, Char -- Bool, U8->Int 48 =)
def(is-xX-char, Char -- Bool, U8->Int dup 88 = dip(120 =) +)

def(str-buf-is-hex-int?, Bool +StrBuf,
    0 # number of digits
    0 # current index
    dup str-buf-u8@ is-sign? nip if(
        1+,
        id
    )
    dup str-buf-u8@ is-zero-char if(
        1+
        dup str-buf-u8@ is-xX-char if(
            1+
            while(dup str-buf-u8@ is-hexdigit? nip, dip(1+) 1+)
            swap 1 >= if(
                str-buf-length? =,
                drop 0
            ),

            drop2 0
        ),

        drop2 0
    ))

def(str-buf-int?, Int +StrBuf,
    str-buf-is-dec-int? if(
        str-buf-dec-int?,
        str-buf-hex-int?
    ))

def(str-buf-dec-int?, Int +StrBuf,
    1 # sign multiplier
    0 # accumulated value
    0 # current index
    dup str-buf-u8@ is-sign? if(
        is-minus-sign? nip if(
            dip(dip(drop -1)),
            id
        )
        1+,
        drop
    )
    while(dup str-buf-length? <,
        dup dip(
            str-buf-u8@ U8->Int
            dip(10 *) 48 - +
        )
        1+)
    drop *)

def(str-buf-hex-int?, Int +StrBuf,
    1 # sign multiplier
    0 # accumulated value
    0 # current index
    dup str-buf-u8@ is-sign? if(
        is-minus-sign? nip if(
            dip(dip(drop -1)),
            id
        )
        1+,
        drop
    )
    2 + # skip 0x prefix
    while(dup str-buf-length? <,
        dup dip(
            str-buf-u8@
            dip(16 *) hexdigit-value +
        )
        1+)
    drop *)

def(hexdigit-value, Char -- Int,
    is-digit? if(
        U8->Int 48 -,
        is-upper-hexdigit? if(
            U8->Int 55 -,
            U8->Int 87 -
        )
    ))

def(lexer-emit-string!, +Lexer,
    str-buf-clear!
    TOKEN_STR 0 Int->TokenValue lexer-make!

    lexer-move!
    lexer-peek while(is-string-end? not,
        lexer-push-string-char!
        lexer-move!
        lexer-peek
    )
    drop

    strings-save!
    Int->TokenValue swap token-value!)

def(lexer-push-string-char!, Char -- +Lexer,
    is-backslash? if(
        drop lexer-move! lexer-peek

        is-newline? if(
            drop,

        is-n? if(
            drop 10 Int->U8 str-buf-push!,

        is-r? if(
            drop 13 Int->U8 str-buf-push!,

        is-t? if(
            drop 9 Int->U8 str-buf-push!,

        is-quote? if(
            str-buf-push!,

        is-backslash? if(
            str-buf-push!,

            str-buf-push!

            "Unknown character escape sequence."
            lexer-emit-warning!

        )))))),

        str-buf-push!
    ))

def(lexer-skip-comment!, +Lexer,
    while(lexer-comment-end? not, lexer-move!)
    lexer-peek is-newline? if(
        lexer-emit-newline! drop,
        drop
    ))

def(lexer-comment-end?, Bool +Lexer,
    lexer-done? if(
        1,
        lexer-peek is-newline? nip
    ))

def(lexer-peek, Char +Lexer, input-peek)
def(lexer-move!, +Lexer, input-move!
    lexer-col@ Col->Int 1+ Int->Col lexer-col!)

def(is-newline?, Char -- Char Bool, dup U8->Int 10 =)
def(is-whitespace?, Char -- Char Bool,
    dup U8->Int 9 = dip(dup U8->Int 32 =) +)
def(is-pound?, Char -- Char Bool, dup U8->Int 35 =)
def(is-lparen?, Char -- Char Bool, dup U8->Int 40 =)
def(is-rparen?, Char -- Char Bool, dup U8->Int 41 =)
def(is-comma?, Char -- Char Bool, dup U8->Int 44 =)
def(is-quote?, Char -- Char Bool, dup U8->Int 34 =)
def(is-digit?, Char -- Char Bool, dup U8->Int 48 57 in-range)
def(is-upper-hexdigit?, Char -- Char Bool, dup U8->Int 65 70 in-range)
def(is-lower-hexdigit?, Char -- Char Bool, dup U8->Int 97 102 in-range)
def(is-hexdigit?, Char -- Char Bool, is-digit? dip(is-upper-hexdigit?) + dip(is-lower-hexdigit?) +)
def(is-nul?, Char -- Char Bool, dup U8->Int 0=)
def(is-sign?, Char -- Char Bool, is-plus-sign? dip(is-minus-sign?) +)
def(is-plus-sign?, Char -- Char Bool, dup U8->Int 43 =)
def(is-minus-sign?, Char -- Char Bool, dup U8->Int 45 =)
def(is-alpha?, Char -- Char Bool, is-lower? dip(is-upper?) +)
def(is-upper?, Char -- Char Bool, dup U8->Int 65 90 in-range)
def(is-lower?, Char -- Char Bool, dup U8->Int 97 122 in-range)

def(is-string-end?, Char -- Char Bool, is-quote? dip(is-newline?) + dip(is-nul?) +)
def(is-dash?, Char -- Char Bool, dup U8->Int 45 =)
def(is-underscore?, Char -- Char Bool, dup U8->Int 95 =)
def(is-backslash?, Char -- Char Bool, dup U8->Int 92 =)
def(is-n?, Char -- Char Bool, dup U8->Int 110 =)
def(is-r?, Char -- Char Bool, dup U8->Int 114 =)
def(is-t?, Char -- Char Bool, dup U8->Int 116 =)
def(underscore, Char, 95 Int->U8)

def(is-name-char?, Char -- Char Bool,
    is-special-char?
    dip(dup U8->Int 33 126 in-range) -)

def(is-special-char?, Char -- Char Bool,
    is-quote?
    dip(is-lparen?) +
    dip(is-rparen?) +
    dip(is-comma?) +
    dip(is-pound?) +
    )

def(in-range, Int Int Int -- Bool,
    dip(over dip(>=)) <= *)

def(lexer-trace-prefix!, +IO,
    lexer-row@ Row->Int int-trace! ":" str-trace!
    lexer-col@ Col->Int int-trace! ":" str-trace-sp!)

###############
# Value Stack #
###############

def(VSTACK_SIZE, Size, 0x100)
quad def-static-buffer(VSTACK_LEN)
VSTACK_SIZE quads def-static-buffer(VSTACK_BUF)

def(vstack-len@, usize +VSTACK, VSTACK_LEN @)
def(vstack-len!, usize -- +VSTACK, VSTACK_LEN !)
def(vstack-empty?, Bool +VSTACK, vstack-len@ 0 <=)
def(vstack-full?, Bool +VSTACK, vstack-len@ VSTACK_SIZE >=)
def(vstack-i64@, usize -- v +VSTACK, VSTACK_BUF quad@@)
def(vstack-i64!, v usize -- +VSTACK, VSTACK_BUF quad!!)

def(vstack-pop!, v1 +VSTACK,
    vstack-empty? if(
        "stack underflow: attempted to pop on empty vstack" panic! 0,
        vstack-len@ 1- vstack-len!
        vstack-len@ vstack-i64@
    ))

def(vstack-pop2!, v1 v2 +VSTACK,
    vstack-pop! dip(vstack-pop!))

def(vstack-pop3!, v1 v2 v3 +VSTACK,
    vstack-pop! dip(vstack-pop2!))

def(vstack-pop4!, v1 v2 v3 v4 +VSTACK,
    vstack-pop! dip(vstack-pop3!))

def(vstack-pop5!, v1 v2 v3 v4 v5 +VSTACK,
    vstack-pop! dip(vstack-pop4!))

def(vstack-pop6!, v1 v2 v3 v4 v5 v6 +VSTACK,
    vstack-pop! dip(vstack-pop5!))

def(vstack-push!, v1 -- +VSTACK,
    vstack-full? if(
        "vstack overflow" panic! drop,
        vstack-len@ vstack-i64!
        vstack-len@ 1+ vstack-len!
    ))

def(vstack-push2!, v1 v2 -- +VSTACK,
    dip(vstack-push!) vstack-push!)

def(vstack-push3!, v1 v2 v3 -- +VSTACK,
    dip(vstack-push2!) vstack-push!)

def(vstack-top@, I64 +VSTACK,
    vstack-empty? if(
        "vstack underflow" panic! 0,
        vstack-len@ 1- vstack-i64@
    ))

def(vstack-top!, I64 -- +VSTACK,
    vstack-empty? if(
        "stack underflow: attempted to write to top of empty vstack" panic! drop,
        vstack-len@ 1- vstack-i64!
    ))

def(vstack-trace!, +VSTACK +IO,
    0
    while(dup vstack-len@ <,
        dup vstack-i64@
        int-trace-sp!
        1+
    ) drop trace-ln!)

###############
# Diagnostics #
###############

def(emit-warning!, Token Str -- +IO,
    "mirth.mth:" str-trace!
    dip(token-trace-prefix!)
    "warning: " str-trace!
    str-trace-ln!)

def(emit-error!, Token Str -- +IO,
    "mirth.mth:" str-trace!
    dip(token-trace-prefix!)
    "error: " str-trace!
    str-trace-ln!)

def(emit-fatal-error!, Token Str -- +IO,
    # FIXME: type sig should be *a Token Str -- *b +IO.
    # or use a special syntax for "not returning".
    emit-error!
    1 posix-exit!)

def(lexer-emit-warning!, Str -- +IO,
    "mirth.mth:" str-trace!
    lexer-trace-prefix!
    "warning: " str-trace!
    str-trace-ln!)

def(lexer-emit-error!, Str -- +IO,
    "mirth.mth:" str-trace!
    lexer-trace-prefix!
    "error: " str-trace!
    str-trace-ln!)

def(lexer-emit-fatal-error!, Str -- +IO,
    lexer-emit-error!
    1 posix-exit!)

###########
# Running #
###########

# Run directly from tokens! (FIXME: Use this only for top-level code.)
# No type checking. (FIXME: Add dynamic types.)
def(token-run!, Token -- +Mirth,
    while(token-run-end? not, token-run-one!)
    drop)

# Is this a token to stop running at?
def(token-run-end?, Token -- Token Bool +Mirth,
    dup num-tokens@ >= if(
        1,
    token-type? TOKEN_NONE = if(
        1,
    token-type? TOKEN_COMMA = if(
        1,
        token-type? TOKEN_RPAREN =
    ))))

# Run a single token, return next token.
def(token-run-one!, Token -- Token +Mirth,
    dup typecheck-token!

    token-type? TOKEN_INT = if(
        0 1 arity-check!
        token-int? vstack-push!,
    token-type? TOKEN_STR = if(
        0 1 arity-check!
        token-str? vstack-push!,
    token-type? TOKEN_LPAREN = if(
        token-value@,
    token-type? TOKEN_NAME = if(
        dup token-run-name!,

        dup "Unexpected token type in token-run!" emit-fatal-error!
    )))) 1+)

# Run a single name token.
def(token-run-name!, Token -- +Mirth,
    token-name?

    name-is-prim? if(
        drop token-run-prim!,

    name-undefined? if(
        drop "Word is undefined." emit-fatal-error!,

    name-is-word? if(
        nip name-value@ token-run!,

    name-is-buffer? if(
        nip name-value@ buffer-base@ vstack-push!,

        drop "Don't know how to run word." emit-fatal-error!
    )))))

# Run a single primitive name token.
def(token-run-prim!, Token --,

    token-name?

    dup PRIM_ID = if(
        drop
        0 0 arity-check!
        token-args-0,

    dup PRIM_SWAP = if(
        drop
        2 2 arity-check!
        token-args-0
        vstack-pop2!
        swap
        vstack-push2!,

    dup PRIM_DUP = if(
        drop
        1 2 arity-check!
        token-args-0
        vstack-pop!
        dup
        vstack-push2!,

    dup PRIM_DROP = if(
        drop
        1 0 arity-check!
        token-args-0
        vstack-pop!
        drop,

    dup PRIM_DIP = if(
        drop
        1 1 arity-check!
        token-args-1
        vstack-pop!
        dip(token-run!)
        vstack-push!,

    dup PRIM_IF = if(
        drop
        1 0 arity-check!
        token-args-2
        vstack-pop!
        if(drop, nip) token-run!,

    dup PRIM_WHILE = if(
        drop
        0 0 arity-check!
        token-args-2
        while(over token-run! vstack-pop!, dup token-run!)
        drop2,

    dup PRIM_INT_ADD = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        +
        vstack-push!,

    dup PRIM_INT_SUB = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        -
        vstack-push!,

    dup PRIM_INT_MUL = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        *
        vstack-push!,

    dup PRIM_INT_DIV = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        /
        vstack-push!,

    dup PRIM_INT_MOD = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        %
        vstack-push!,

    dup PRIM_INT_EQ = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        =
        vstack-push!,

    dup PRIM_INT_LT = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        <
        vstack-push!,

    dup PRIM_INT_LE = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        <=
        vstack-push!,

    dup PRIM_INT_AND = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        &
        vstack-push!,

    dup PRIM_INT_OR = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        |
        vstack-push!,

    dup PRIM_INT_XOR = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        ^
        vstack-push!,

    dup PRIM_INT_SHL = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        <<
        vstack-push!,

    dup PRIM_INT_SHR = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        >>
        vstack-push!,

    dup PRIM_MEM_GET = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        @
        vstack-push!,

    dup PRIM_MEM_SET = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        !,

    dup PRIM_MEM_GET_BYTE = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u8@
        vstack-push!,

    dup PRIM_MEM_SET_BYTE = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u8!,

    dup PRIM_MEM_GET_U8 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u8@
        vstack-push!,
    dup PRIM_MEM_GET_U16 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u16@
        vstack-push!,
    dup PRIM_MEM_GET_U32 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u32@
        vstack-push!,
    dup PRIM_MEM_GET_U64 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u64@
        vstack-push!,
    dup PRIM_MEM_GET_I8 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i8@
        vstack-push!,
    dup PRIM_MEM_GET_I16 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i16@
        vstack-push!,
    dup PRIM_MEM_GET_I32 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i32@
        vstack-push!,
    dup PRIM_MEM_GET_I64 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i64@
        vstack-push!,

    dup PRIM_MEM_SET_U8 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u8!,

    dup PRIM_MEM_SET_U16 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u16!,

    dup PRIM_MEM_SET_U32 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u32!,

    dup PRIM_MEM_SET_U64 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u64!,

    dup PRIM_MEM_SET_I8 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i8!,

    dup PRIM_MEM_SET_I16 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i16!,

    dup PRIM_MEM_SET_I32 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i32!,

    dup PRIM_MEM_SET_I64 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i64!,

    dup PRIM_POSIX_MMAP = if(
        drop
        6 1 arity-check!
        token-args-0
        vstack-pop6!
        posix-mmap!
        vstack-push!,

    dup PRIM_POSIX_WRITE = if(
        drop
        3 0 arity-check!
        token-args-0
        vstack-pop3!
        posix-write!,

    dup PRIM_POSIX_READ = if(
        drop
        3 1 arity-check!
        token-args-0
        vstack-pop3!
        posix-read!
        vstack-push!,

    dup PRIM_POSIX_OPEN = if(
        drop
        3 1 arity-check!
        token-args-0
        vstack-pop3!
        posix-open!
        vstack-push!,

    dup PRIM_POSIX_CLOSE = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        posix-close!
        vstack-push!,

    dup PRIM_POSIX_EXIT = if(
        drop 1 0 arity-check! token-args-0
        vstack-pop! posix-exit!,

    dup PRIM_DEBUG = if(
        drop 0 0 arity-check! token-args-0
        "?? " str-trace!
        vstack-trace!,

    dup PRIM_DEF = if(
        drop
        0 0 arity-check!
        token-args-3
        rotl token-type? TOKEN_NAME = if(
            token-name? name-undefined? if(
                nip
                DEF_WORD over name-sort!
                dup dip(name-value!)
                name-sig!,
                drop "word already defined" emit-fatal-error! drop2
            ),
            "expected word name" emit-fatal-error! drop2
        ),

    dup PRIM_DEF_TYPE = if(
        drop
        0 0 arity-check!
        token-args-2
        swap sig-token-is-type-con? if(
            token-name? name-undefined? if(
                nip swap
                sig-token-is-type-con? if(
                    token-name?
                    name-is-type? if(
                        name-value@ nip,
                        drop "Unknown type." emit-error!
                        TYPE_ERROR
                    ),
                    "Expected a type." emit-error!
                    TYPE_ERROR
                )
                over name-value!
                DEF_TYPE swap name-sort!,

                drop "type already defined" emit-fatal-error! drop
            ),
            "expected type constructor" emit-fatal-error! drop
        ),

    dup PRIM_DEF_STATIC_BUFFER = if(
        drop
        1 0 arity-check!
        token-args-1
        token-type? TOKEN_NAME = if(
            token-name? name-undefined? if(
                nip
                DEF_BUFFER over name-sort!
                vstack-pop! buffer-alloc! swap name-value!,
                drop "buffer already defined" emit-fatal-error!
            ),
            "expected buffer name" emit-fatal-error!
        ),

    dup PRIM_DEF_EXTERNAL = if(
        drop
        token-args-2
        swap token-type? TOKEN_NAME = if(
            token-name? name-undefined? if(
                nip DEF_EXTERNAL over name-sort!
                name-sig!,
                drop2 "word already defined" emit-fatal-error!
            ),
            nip "expected name" emit-fatal-error!
        ),

    dup PRIM_MIRTH_REVISION = if(
        drop
        0 1 arity-check!
        token-args-0
        NEW_MIRTH_REVISION
        vstack-push!,

    dup PRIM_RUNNING_OS = if(
        drop
        0 1 arity-check!
        token-args-0
        RUNNING_OS
        vstack-push!,

    dup PRIM_OUTPUT_C99 = if(
        drop
        1 0 arity-check!
        token-args-1
        vstack-pop!
        run-output-c99!,

        drop
        "Dont know how to run prim yet." emit-fatal-error!
    )))))))))))))))))))))))))))))))))))))))))))))))))))))))

# Assert stack arity of a primitive. If the
# arity would result in underflow/overflow,
# emits a fatal error.
def(arity-check!, Token Size Size -- Token,
    dip(dip(vstack-len@))
    dip(dup2 <) swap if(
        drop drop2 "Stack underflow." emit-fatal-error! 0,
        dip(-) + VSTACK_SIZE > if(
            "Stack overflow." emit-fatal-error! 0,
            id
        )
    ))

# Verify that token has 0 args, and return them.
# Emits a fatal error if arity is wrong.
def(token-args-0, Token --,
    1+ token-type?
    TOKEN_LPAREN = if(
        "expected no args"
        emit-fatal-error!,
        drop
    ))

# Verify that token has 1 arg, and return it.
# Emits a fatal error if arity is wrong.
def(token-args-1, Token -- Token,
    dup
    1+ token-type?
    TOKEN_LPAREN = if(
        1+
        tuck token-next-arg-end
        token-type? TOKEN_RPAREN = if(
            drop2,
            drop
            "expected 1 arg, got too many"
            emit-fatal-error!
        ),
        drop
        "expected 1 arg, got none"
        emit-fatal-error! 0
    ))

# Verify that token has 2 args, and return them.
# Emits a fatal error if arity is wrong.
def(token-args-2, Token -- Token Token,
    dup
    1+ token-type?
    TOKEN_LPAREN = if(
        1+ tuck token-next-arg-end
        token-type? TOKEN_COMMA = if(
            1+ tuck token-next-arg-end
            token-type? TOKEN_RPAREN = if(
                drop2,
                drop
                "expected 2 args, got too many"
                emit-fatal-error!
            ),
            drop
            "expected 2 args, got only 1"
            emit-fatal-error! 0
        ),
        drop
        "expected 2 args, got none"
        emit-fatal-error! 0 0
    ))

# Verify that token has 3 args, and return them.
# Emits a fatal error if arity is wrong.
def(token-args-3, Token -- Token Token Token,
    dup
    1+ token-type?
    TOKEN_LPAREN = if(
        1+ tuck token-next-arg-end
        token-type? TOKEN_COMMA = if(
            1+ tuck token-next-arg-end
            token-type? TOKEN_COMMA = if(
                1+ tuck token-next-arg-end
                token-type? TOKEN_RPAREN = if(
                    drop2,
                    drop
                    "expected 3 args, got too many"
                    emit-fatal-error!
                ),
                drop
                "expected 3 args, got only 2"
                emit-fatal-error! 0
            ),
            drop
            "expected 3 args, got only 1"
            emit-fatal-error! 0 0
        ),
        drop
        "expected 3 args, got none"
        emit-fatal-error! 0 0 0
    ))

# Get closest arg ending (COMMA or RPAREN),
# while respecting the nesting of tokens.
def(token-next-arg-end, Token -- Token,
    while(token-is-arg-end? not, token-next))

# Get next token, respecting nesting of tokens.
def(token-next, Token -- Token,
    token-type? TOKEN_LPAREN = if(
        token-token@ 1+,

    token-type? TOKEN_NAME = if(
        1+
        token-type? TOKEN_LPAREN = if(
            token-token@ 1+,
            id
        ),

        1+
    )))

# Is this an arg ending (COMMA or RPAREN)?
def(token-is-arg-end?, Token -- Token Bool,
    token-type? TOKEN_COMMA = if(
        1,
        token-type? TOKEN_RPAREN =
    ))

###########
# Buffers #
###########

def(MAX_BUFFERS, Size, 0x80)
def-type(Buffer, Int)

quad def-static-buffer(NUM_BUFFERS)
def(num-buffers@, Size +Buffers, NUM_BUFFERS @)
def(num-buffers!, Size -- +Buffers, NUM_BUFFERS !)

def(init-buffers!, +Buffers,
    0 num-buffers!)

MAX_BUFFERS quads dup
    def-static-buffer(BUFFER_SIZE)
    def-static-buffer(BUFFER_BASE)

def(buffer-size@, Buffer -- usize +Buffers,
    BUFFER_SIZE quad@@)

def(buffer-size!, usize Buffer -- +Buffers,
    BUFFER_SIZE quad!!)

def(buffer-alloc!, usize -- Buffer +Buffers,
    num-buffers@ MAX_BUFFERS >= if(
        "compiler error: ran out of buffers" panic!,
        dup num-buffers@ buffer-size!
        heap-alloc! num-buffers@ buffer-base!
        num-buffers@ dup 1+ num-buffers!
    ))

def(buffer-base@, Buffer -- Ptr +Buffers,
    BUFFER_BASE quad@@ Int->Ptr)

def(buffer-base!, Ptr Buffer -- +Buffers,
    dip(Ptr->Int) BUFFER_BASE quad!!)

########
# Defs #
########

def-type(Value, Int)

def-type(Sort, U8)
def(DEF_NONE, Sort, 0 Int->U8)
def(DEF_WORD, Sort, 1 Int->U8)
def(DEF_BUFFER, Sort, 2 Int->U8)
def(DEF_TYPE, Sort, 3 Int->U8)
def(DEF_EXTERNAL, Sort, 4 Int->U8)

MAX_NAMES u8s def-static-buffer(DEF_SORT)
MAX_NAMES quads def-static-buffer(DEF_VALUE)
MAX_NAMES quads def-static-buffer(DEF_SIG)

def(name-sort!, Sort Name --, DEF_SORT u8!!)
def(name-sort@, Name -- Sort, DEF_SORT u8@@)
def(name-sort?, Name -- Name Sort, dup name-sort@)

def(name-value!, Value Name --, DEF_VALUE quad!!)
def(name-value@, Name -- Value, DEF_VALUE quad@@)
def(name-value?, Name -- Name Value, dup name-value@)

def(name-sig!, Token Name --, DEF_SIG quad!!)
def(name-sig@, Name -- Token, DEF_SIG quad@@)
def(name-sig?, Name -- Name Token, dup name-sig@)

def(name-undefined?, Name -- Name Bool, name-sort? DEF_NONE =)
def(name-defined?, Name -- Name Bool, name-undefined? not)
def(name-is-word?, Name -- Name Bool, name-sort? DEF_WORD =)
def(name-is-buffer?, Name -- Name Bool, name-sort? DEF_BUFFER =)
def(name-is-type?, Name -- Name Bool, name-sort? DEF_TYPE =)
def(name-is-external?, Name -- Name Bool, name-sort? DEF_EXTERNAL =)

#################
# Type Checking #
#################

def-type(Type, Int)
def-type(Stash, Int)

MAX_NAMES def-static-buffer(DEF_CHECKED)
def(name-checked!, Bool Name --, dip(Int->U8) DEF_CHECKED u8!!)
def(name-checked@, Name -- Bool, DEF_CHECKED u8@@ U8->Int)
def(name-checked?, Name -- Name Bool, dup name-checked@)

def(TSTACK_SIZE, Size, VSTACK_SIZE)
quad def-static-buffer(TSTACK_LEN)
quad def-static-buffer(TSTACK_BASE)
TSTACK_SIZE quads def-static-buffer(TSTACK_BUF)

def(tstack-len!, Size --, TSTACK_LEN !)
def(tstack-len@, Size, TSTACK_LEN @)

def(tstack-base!, Size --, TSTACK_BASE !)
def(tstack-base@, Size, TSTACK_BASE @)

def(tstack-length?, Size +TSTACK, tstack-len@ tstack-base@ -)
def(tstack-empty?, Bool, tstack-len@ tstack-base@ <=)
def(tstack-full?, Bool, tstack-len@ TSTACK_SIZE >=)
def(tstack-clear!, +TSTACK, tstack-base@ tstack-len!)

def(tstack!, Type Offset --, TSTACK_BUF quad!!)
def(tstack@, Offset -- Type, TSTACK_BUF quad@@)
def(tstack-pop!, -- Type,
    tstack-empty? if(
        "tstack underflow" panic! 0,
        tstack-len@ 1- dup tstack-len! tstack@
    ))
def(tstack-push!, Type --,
    tstack-full? if(
        "tstack overflow" panic! drop,
        tstack-len@ dup 1+ tstack-len! tstack!
    ))

def(tstack-pop2!, -- Type Type, tstack-pop! dip(tstack-pop!))
def(tstack-pop3!, -- Type Type Type, tstack-pop! dip(tstack-pop2!))
def(tstack-push2!, Type Type --, dip(tstack-push!) tstack-push!)

def(tstack-enter!, --,
    tstack-base@ tstack-push!
    tstack-len@ tstack-base!
    )

def(tstack-leave!, --,
    tstack-base@ 0 <= if(
        "Compiler error: Attempt to leave empty tstack frame." panic!,
        tstack-base@
        1- dup tstack-len!
        tstack@ tstack-base!
    ))

# Create a copy of the current tstack frame as a new tstack frame.
def(tstack-frame-dup!, -- +TSTACK,
    tstack-len@ tstack-base@
    tstack-enter!
    while(dup2 >,
        dup tstack@ tstack-push!
        1+)
    drop2)

quad def-static-buffer(TSTACK_NUM_STASHES)
def(tstack-num-stashes@, Size +TSTACK, TSTACK_NUM_STASHES @)
def(tstack-num-stashes!, Size -- +TSTACK, TSTACK_NUM_STASHES !)

TSTACK_SIZE quads def-static-buffer(TSTACK_STASH_LEN)
def(tstack-stash-len@, Stash -- Size +TSTACK, TSTACK_STASH_LEN quad@@)
def(tstack-stash-len!, Size Stash -- +TSTACK, TSTACK_STASH_LEN quad!!)

def(tstack-stash-len-push!, Size -- +TSTACK,
    tstack-num-stashes@ TSTACK_SIZE < if(
        tstack-num-stashes@ tstack-stash-len!
        tstack-num-stashes@ 1+ tstack-num-stashes!,
        "compiler error: tstack stash overflow" panic! drop
    ))

def(tstack-stash-len-pop!, Size +TSTACK,
    tstack-num-stashes@ 0 > if(
        tstack-num-stashes@ 1- tstack-num-stashes!
        tstack-num-stashes@ tstack-stash-len@,
        "compiler error: tstack stash underflow" panic! 0
    ))

# Stash the top tstack frame.
def(tstack-frame-stash!, -- +TSTACK,
    tstack-length? tstack-stash-len-push!
    tstack-leave!) # FIXME: actually save the values

# Pop the stashed tstack frame & unify it with the top tstack frame.
def(tstack-frame-unify!, Token -- Token +TSTACK,
    tstack-length? tstack-stash-len-pop!
    dup2 = if(
        drop2,
        "mirth.mth:" str-trace!
        dip(dip(dup token-trace-prefix!))
        "error: Failed to unify branches. First branch has " str-trace!
        int-trace!
        " outputs, second branch has " str-trace!
        int-trace!
        " outputs." str-trace-ln!
        1 posix-exit!
    ))

def(typecheck-token!, Token --,
    token-type? TOKEN_NAME = if(
        token-name?

        name-is-prim? if(
            drop2,

        name-undefined? if(
            drop "Word is undefined." emit-fatal-error!,

            nip typecheck-name!
        )),

        drop
    ))

def(typecheck-name!, Name --,
    name-checked? if(
        drop,

        1 over name-checked!

        name-is-prim? if(
            drop,

        name-undefined? if(
            "error: Name undefined: " str-trace!
            name-load! str-buf-trace! trace-ln!,

        name-is-word? if(
            typecheck-word!,

        name-is-buffer? if(
            typecheck-buffer!,

        name-is-external? if(
            drop, # TODO: check the signature

        name-is-type? if(
            drop, # TODO

            "error: Dont know how to typecheck name: "
            str-trace! name-load! str-buf-trace! trace-ln!
            1 posix-exit!

        ))))))
    ))

def(typecheck-word!, Name --,
    name-sig? typecheck-word-sig!

    tstack-enter!
    name-sig? sig-push-inputs!
    name-value? typecheck-run!
    name-sig? sig-match-outputs!
    # FIXME: sig-effects
    tstack-leave!
    # drop

    drop) # FIXME: check the body

def(typecheck-word-sig!, Token --,
    sig-has-dashes? if(
        typecheck-sig-inputs! 1+
        typecheck-sig-outputs!,
        typecheck-sig-outputs!
    ))

def(typecheck-sig-inputs!, Token -- Token,
    while(token-is-dashes? not,
        dup typecheck-sig-input-token!
        1+))

def(typecheck-sig-outputs!, Token --,
    while(token-is-arg-end? not,
        dup typecheck-sig-output-token!
        1+)
    drop)

def(typecheck-sig-input-token!, Token --,
    sig-token-is-type-con? if(
        token-name? name-is-type? nip if(
            drop,
            "Unknown type" emit-error!
        ),

    sig-token-is-type-var? if(
        drop, # TODO: register variable?

        "Unexpected token in type sig" emit-error!
    )))

def(typecheck-sig-output-token!, Token --,
    sig-token-is-type-con? if(
        token-name? name-is-type? nip if(
            drop,
            "Unknown type" emit-error!
        ),

    sig-token-is-type-var? if(
        drop, # TODO: register variable?

    sig-token-is-effect-con? if(
        drop, # TODO: check if effect exists

        "Unexpected token in type sig" emit-error!
    ))))


def(typecheck-buffer!, Name --,
    drop) # FIXME: check the type

def(typecheck-run!, Token --,
    while(token-is-arg-end? not,
        dup typecheck-run-one!
        token-next)
    drop)

def(typecheck-run-one!, Token --,
    dup typecheck-token!
    dup elab-token!

    token-type? TOKEN_INT = if(
        0 1 tstack-arity-check!
        token-args-0
        TYPE_INT tstack-push!,

    token-type? TOKEN_STR = if(
        0 1 tstack-arity-check!
        token-args-0
        TYPE_PTR tstack-push!,

    token-type? TOKEN_NAME = if(
        token-name? typecheck-run-name!,

        "Unexpected token type." emit-fatal-error!
    ))))

def(typecheck-run-name!, Token Name --,
    name-is-prim? if(
        drop typecheck-run-prim!,

    name-is-word? if(
        over token-args-0
        name-sig@ sig-apply!,

    name-is-external? if(
        over token-args-0
        name-sig@ sig-apply!,

    name-is-buffer? if(
        drop token-args-0
        TYPE_PTR tstack-push!,

        drop
        "Don't know how to typecheck token." emit-fatal-error!
    )))))

def(typecheck-run-prim!, Token --,
    token-name?
    dup PRIM_ID = if(
        drop token-args-0,

    dup PRIM_DUP = if(
        drop 1 2 tstack-arity-check! token-args-0
        tstack-pop! dup tstack-push2!,

    dup PRIM_DROP = if(
        drop 1 0 tstack-arity-check! token-args-0
        tstack-pop! drop,

    dup PRIM_SWAP = if(
        drop 2 2 tstack-arity-check! token-args-0
        tstack-pop2! swap tstack-push2!,

    dup PRIM_DIP = if(
        drop 1 1 tstack-arity-check! token-args-1
        tstack-pop! swap typecheck-run! tstack-push!,

    dup PRIM_IF = if(
        drop 1 0 tstack-arity-check! dup token-args-2
        tstack-pop! drop # FIXME: check that it's TYPE_BOOL
        tstack-frame-dup!
        dip(typecheck-run!)
        tstack-frame-stash!
        typecheck-run!
        tstack-frame-unify!
        drop,

    dup PRIM_WHILE = if(
        drop 0 0 tstack-arity-check! dup token-args-2
        # FIXME: check that tstack top is TYPE_BOOL
        tstack-frame-dup!
        tstack-frame-stash!
        dip(typecheck-run!
            tstack-pop! drop
            tstack-frame-unify!)
        tstack-frame-dup!
        tstack-frame-stash!
        typecheck-run!
        tstack-frame-unify!
        drop,

    dup PRIM_INT_ADD = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab+ tstack-push!,
    dup PRIM_INT_SUB = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab- tstack-push!,
    dup PRIM_INT_MUL = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab* tstack-push!,
    dup PRIM_INT_DIV = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab/ tstack-push!,
    dup PRIM_INT_MOD = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab% tstack-push!,
    dup PRIM_INT_EQ = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab= tstack-push!,
    dup PRIM_INT_LT = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab= tstack-push!,
    dup PRIM_INT_LE = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab= tstack-push!,
    dup PRIM_INT_AND = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_OR = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_XOR = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_SHL = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_SHR = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,

    dup PRIM_MEM_GET = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! elab@ tstack-push!,
    dup PRIM_MEM_GET_BYTE = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! elab@ tstack-push!,
    dup PRIM_MEM_SET = if(
        drop 2 0 tstack-arity-check! token-args-0
        tstack-pop2! elab!,
    dup PRIM_MEM_SET_BYTE = if(
        drop 2 0 tstack-arity-check! token-args-0
        tstack-pop2! elab!,

    dup PRIM_MEM_GET_U8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U8, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_U16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U16, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_U32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U32, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_U64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U64, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I8, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I16, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I32, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I64, TYPE_ERROR
        ) tstack-push!,

    dup PRIM_MEM_SET_U8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U8 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_U16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U16 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_U32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U32 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_U64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U64 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I8 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I16 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I32 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I64 TYPE_PTR expect2 drop,

    dup PRIM_POSIX_EXIT = if(
        drop 1 0 tstack-arity-check! token-args-0
        tstack-pop! elab-posix-exit,
    dup PRIM_POSIX_READ = if(
        drop 3 1 tstack-arity-check! token-args-0
        tstack-pop3! elab-posix-read tstack-push!,
    dup PRIM_POSIX_WRITE = if(
        drop 3 0 tstack-arity-check! token-args-0
        tstack-pop3! elab-posix-write,
    dup PRIM_POSIX_OPEN = if(
        drop 3 1 tstack-arity-check! token-args-0
        tstack-pop3! elab-posix-open tstack-push!,
    dup PRIM_POSIX_CLOSE = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! elab-posix-close tstack-push!,
    dup PRIM_POSIX_MMAP = if(
        drop 6 1 tstack-arity-check! token-args-0
        tstack-pop3! dip(dip(dip(tstack-pop3!)))
        elab-posix-mmap tstack-push!, # not always a pointer...

    dup PRIM_DEBUG = if(
        drop token-args-0,
    dup PRIM_MIRTH_REVISION = if(
        drop 0 1 tstack-arity-check! token-args-0
        TYPE_INT tstack-push!,
    dup PRIM_RUNNING_OS = if(
        drop 0 1 tstack-arity-check! token-args-0
        TYPE_INT tstack-push!,

        drop "Unknown primitive" emit-error!
    ))))))))))))))))))))))))))))))))))))))))))))))))))

def(tstack-arity-check!, Token Int Int -- Token +TSTACK,
    dip(dip(tstack-len@))
    dip(-) over tstack-base@ < if(
        drop2
        dup "Stack underflow." emit-error!, # FIXME: upgrade to error

        + TSTACK_SIZE > if(
            "compiler error: tstack overflow." emit-fatal-error! 0,

            id
        )
    ))

#############
# Type Sigs #
#############

def(token-is-dashes, Token -- Bool,
    token-type? TOKEN_NAME = if(
        token-name@ PRIM_DASHES =,
        drop 0
    ))

def(token-is-dashes?, Token -- Token Bool,
    dup token-is-dashes)

def(sig-dashes-end?, Token -- Token Bool,
    token-is-dashes? if(
        1,
        token-run-end?
    ))

def(sig-has-dashes, Token -- Bool,
    while(sig-dashes-end? not, token-next)
    token-is-dashes)

def(sig-has-dashes?, Token -- Token Bool,
    dup sig-has-dashes)

def(sig-arity, Token -- Int Int,
    sig-has-dashes? if(
        sig-count-types
        token-next
        sig-count-types
        drop,

        dip(0)
        sig-count-types
        drop
    ))

def(sig-count-types, Token -- Int Token,
    dip(0)
    while(sig-dashes-end? not,
        sig-token-is-type? if(dip(1+), id)
        token-next
    ))

def(sig-token-is-type?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type,
        0
    ))

def(sig-token-is-type-con?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type-con,
        0
    ))

def(sig-token-is-type-var?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type-var,
        0
    ))

def(sig-token-is-effect-con?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-effect-con,
        0
    ))

def(sig-push-inputs!, Token -- +TSTACK,
    sig-has-dashes? if(
        while(sig-dashes-end? not,
            sig-token-is-type-con? if(
                token-name? name-is-type? if(
                    name-value@ tstack-push!,
                    drop TYPE_ERROR tstack-push!
                ),

            sig-token-is-type-var? if(
                0 # FIXME: push rigid type var and
                  # register it in context.
                tstack-push!,

                "Expected type."
                emit-fatal-error! 0
            ))
            token-next
        ) drop,

        drop
    ))

def(sig-skip-dashes, Token -- Token,
    sig-has-dashes? if(
        while(token-is-dashes? not, 1+) 1+,
        id
    ))

def(sig-match-outputs!, Token -- +TSTACK,
    dup sig-arity nip dup
    tstack-length? = if(
        drop
        sig-skip-dashes
        sig-match-outputs-aux,

        "mirth.mth:" str-trace!
        swap token-trace-prefix!
        "error: Expected " str-trace!
        int-trace!
        " outputs, but got " str-trace!
        tstack-length? int-trace!
        " outputs." str-trace-ln!
        1 posix-exit!
    ))

def(sig-match-outputs-aux, Token -- +TSTACK,
    token-is-arg-end? if(
        drop,

        dup token-next sig-match-outputs-aux
        sig-token-is-type-con? if(
            dup elab-token!
            token-name@ name-value@
            tstack-pop! swap expect1 drop,

        sig-token-is-type-var? if(
            tstack-pop! drop2, # TODO
            drop
        ))
    ))

def(sig-apply!, Token Token -- +TSTACK,
    dup2 sig-pop-inputs! sig-push-outputs!)

def(sig-pop-inputs!, Token Token -- +TSTACK,
    dip(elab-token!)
    sig-has-dashes? if(
        sig-pop-inputs-aux!,
        drop
    ))

def(sig-pop-inputs-aux!, Token -- +TSTACK,
    token-is-dashes? if(
        drop,

        dup token-next
        sig-pop-inputs-aux!
        tstack-empty? if(
            "Stack underflow" elab-emit-fatal-error!
            drop,

        sig-token-is-type-con? if(
            token-name@ name-value@
            tstack-pop! swap expect1 drop,

        sig-token-is-type-var? if(
            tstack-pop! drop2,
            # TODO: "define" the type variable

            tstack-pop! drop2
            # error in type sig, but it's caught elsewhere
        )))
    ))

def(sig-push-outputs!, Token Token -- +TSTACK,
    dip(elab-token!)
    sig-skip-dashes
    while(token-is-arg-end? not,
        sig-token-is-type-con? if(
            token-name? name-value@ tstack-push!,

        sig-token-is-type-var? if(
            0 tstack-push!, # TODO

        sig-token-is-effect-con? if(
            id, # TODO

            # unknown, but error is caught elsewhere
            0 tstack-push!
        )))
        token-next)
    drop)

#########
# Types #
#########

def(TYPE_ERROR, Type, 0)
def(TYPE_INT, Type, 1) # generic integer type for integer literals)
def(TYPE_PTR, Type, 2) # generic pointer type (e.g. void*)
def(TYPE_U8, Type, 3) # fixed width integer type -- unsigned 8 bit
def(TYPE_U16, Type, 4) # fixed width integer type -- unsigned 16 bit
def(TYPE_U32, Type, 5) # fixed width integer type -- unsigned 32 bit
def(TYPE_U64, Type, 6) # fixed width integer type -- unsigned 64 bit
def(TYPE_I8, Type, 7) # fixed width integer type -- signed 8 bit
def(TYPE_I16, Type, 8) # fixed width integer type -- signed 16 bit
def(TYPE_I32, Type, 9) # fixed width integer type -- signed 32 bit
def(TYPE_I64, Type, 10) # fixed width integer type -- signed 64 bit

quad def-static-buffer(ELAB_TOKEN)
def(elab-token@, -- Token +Elab, ELAB_TOKEN @)
def(elab-token!, Token -- +Elab, ELAB_TOKEN !)
def(elab-emit-warning!, Str -- +Elab, dip(elab-token@) emit-warning!)
def(elab-emit-error!, Str -- +Elab, dip(elab-token@) emit-error!)
def(elab-emit-fatal-error!, Str -- +Elab, dip(elab-token@) emit-fatal-error!)

# elab type for + primitive
def(elab+, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
        dup TYPE_PTR = if(
            drop TYPE_PTR,
            drop TYPE_ERROR
            "attempted to add int to unknown type" elab-emit-error!
        ))),

    dup TYPE_PTR = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_PTR,
        dup TYPE_PTR = if(
            drop
            "attempted to add two pointers" elab-emit-error!
            TYPE_ERROR,

            drop
            "attempted to add pointer to unknown type" elab-emit-error!
            TYPE_ERROR
        ))),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop
            "attempted to add unkwown type to int" elab-emit-error!
            TYPE_ERROR,
        dup TYPE_PTR = if(
            drop
            "attempted to add unkwown type to pointer" elab-emit-error!
            TYPE_ERROR,

            drop
            "attempted to add two unknown types" elab-emit-error!
            TYPE_ERROR
        )))
    ))))

# elab type for - primitive
def(elab-, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            drop TYPE_INT,
        dup TYPE_PTR = if(
            drop TYPE_PTR,
            "attempted to subtract int from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

    dup TYPE_PTR = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to subtract pointer from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "subtracting two pointers is dangerous" elab-emit-warning!
            drop TYPE_INT,
            "attempted to subtract pointer from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to subtract unknown type from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "attempted to subtract unknown type from ptr" elab-emit-error!
            drop TYPE_ERROR,
            "attempted to subtract two unknown types" elab-emit-error!
            drop TYPE_ERROR
        )))
    ))))

# elab for * primitive
def(elab*, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
            "attempted to multiply int with unknown type" elab-emit-error!
            drop TYPE_ERROR
        )),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            "attempted to multiply unknown type with int" elab-emit-error!
            drop TYPE_ERROR,

            "attempted to multiply unknown types" elab-emit-error!
            drop TYPE_ERROR
        ))
    )))

# elab for / primitive
def(elab/, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
            "attempted to divide unknown type from int" elab-emit-error!
            drop TYPE_ERROR
        )),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            "attempted to divide int from unknown type" elab-emit-error!
            drop TYPE_ERROR,

            "attempted to divide unknown types" elab-emit-error!
            drop TYPE_ERROR
        ))
    )))

# elab type for % primitive
def(elab%, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            drop TYPE_INT,
        dup TYPE_PTR = if(
            drop TYPE_INT,
            "attempted to modulo int from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

    dup TYPE_PTR = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to modulo pointer from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "attempted to module two pointers" elab-emit-error!
            drop TYPE_ERROR,
            "attempted to modulo pointer from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to modulo unknown type from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "attempted to modulo unknown type from ptr" elab-emit-error!
            drop TYPE_ERROR,
            "attempted to modulo two unknown types" elab-emit-error!
            drop TYPE_ERROR
        )))
    ))))

# elab for =, <, <= primitives
def(elab=, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,
        expect1 drop TYPE_INT
    ))

# elab for &, ^, | primitives
def(elab&, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
            "attempted to use bitwise operation between unknown type and int" elab-emit-error!
            drop TYPE_ERROR
        )),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            "attempted to use bitwise operation between int and unknown type" elab-emit-error!
            drop TYPE_ERROR,

            "attempted to use bitwise operation on unknown types" elab-emit-error!
            drop TYPE_ERROR
        ))
    )))

# elab for @ primitive
def(elab@, Type -- Type,
    dup TYPE_ERROR = if(
        drop TYPE_ERROR,

    dup TYPE_PTR = if(
        drop TYPE_ERROR, # output type is unknown

        "attempted to load from non-pointer" elab-emit-error!
        drop TYPE_ERROR
    )))

def(elab!, Type Type --,
    dup TYPE_ERROR = if(
        drop2,

    dup TYPE_PTR = if(
        drop2, # can store anything

        drop2
        "attempted to store to non-pointer" elab-emit-error!
    )))

def(elab-posix-exit, Type -- +Elab,
    TYPE_INT expect1 drop) # TODO: set absurd flag

def(elab-posix-read, Type Type Type -- Type +Elab,
    TYPE_INT TYPE_PTR TYPE_INT expect3
    if(TYPE_INT, TYPE_ERROR))

def(elab-posix-write, Type Type Type -- +Elab,
    TYPE_INT TYPE_PTR TYPE_INT expect3 drop)

def(elab-posix-open, Type Type Type -- Type +Elab,
    TYPE_PTR TYPE_INT TYPE_INT expect3
    if(TYPE_INT, TYPE_ERROR))

def(elab-posix-close, Type -- Type +Elab,
    TYPE_INT expect1 if(TYPE_INT, TYPE_ERROR))

def(elab-posix-mmap, Type Type Type Type Type Type -- Type +Elab,
    TYPE_INT TYPE_INT TYPE_INT expect3 if(
        TYPE_PTR TYPE_INT TYPE_INT expect3 if(
            TYPE_PTR,
            TYPE_ERROR
        ),
        drop3 TYPE_ERROR
    )) # TODO: improve diagnostics

def(expect1, Type Type -- Bool +Elab,
    over TYPE_ERROR = if(
        drop2 0,
    dup2 = if(
        drop2 1,
        drop2 0
        "type error" elab-emit-error!
        # TODO: improve diagnostics
    )))

def(expect2, Type Type Type Type -- Bool +Elab,
    dip(swap) expect1 if(expect1, drop2 0)
    ) # TODO: improve diagnostics

def(expect3, Type Type Type Type Type Type -- Bool +Elab,
    dip(rotl) expect1 if(
        expect2,
        drop2 drop2 0
    )) # TODO: improve diagnostics

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)

quad def-static-buffer(CODEGEN_FILE)
quad def-static-buffer(CODEGEN_LENGTH)
CODEGEN_BUF_SIZE def-static-buffer(CODEGEN_BUF)

def(codegen-file@, -- File +Codegen, CODEGEN_FILE @)
def(codegen-file!, File -- +Codegen, CODEGEN_FILE !)
def(codegen-length@, -- Size +Codegen, CODEGEN_LENGTH @)
def(codegen-length!, Size -- +Codegen, CODEGEN_LENGTH !)
def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length@ CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length@ 0 > if(
        codegen-file@ CODEGEN_BUF codegen-length@ posix-write!
        0 codegen-length!,
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length@ dup 1+ codegen-length! codegen-u8!)

def(., Str -- +Codegen, while(dup u8@, dup u8@ .b str-tail) drop)

def(codegen-start!, File -- +Codegen,
    codegen-file! 0 codegen-length!)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file@ close-file!
    0 codegen-file!
    0 codegen-length!)

def(run-output-c99!, Token String -- +IO,
    create-file! codegen-start!
    c99-emit-header!
    c99-emit-strings!
    c99-emit-prims!
    c99-emit-buffers!
    c99-emit-externals!
    c99-emit-word-sigs!
    c99-emit-word-defs!
    c99-emit-main!
    codegen-end!)

quad def-static-buffer(C99_DEPTH)
def(c99-depth@, -- Int +Codegen, C99_DEPTH @)
def(c99-depth!, Int -- +Codegen, C99_DEPTH !)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, str-buf-int! STR_BUF .)
def(.d, +Codegen, c99-depth@ .n)
def(.name, Name -- +Codegen, name-mangle! STR_BUF .)

def(.w, Name -- +IO,
    "void mw" . .name " (void)" .)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WIN32 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdint.h>";;

    "typedef uint8_t u8;";
    "typedef uint16_t u16;";
    "typedef uint32_t u32;";
    "typedef uint64_t u64;";
    "typedef int8_t i8;";
    "typedef int16_t i16;";
    "typedef int32_t i32;";
    "typedef int64_t i64;";
    "typedef uintptr_t usize;";;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern void exit(int);" ;;

    "#define STACK_SIZE 2000" ;
    "static volatile usize sc = STACK_SIZE;" ;
    "static volatile i64 stack[STACK_SIZE] = {0};" ;;
    )

def(c99-emit-strings!, +IO,
    "#define STRINGS_SIZE " . strings-size@ .n "" ;
    "static const char strings[STRINGS_SIZE] = { " ;
    0
    while(dup strings-size@ <,
        dup STRINGS_BUF u8@@ dup U8->Int .n "," .
        if(id, .lf)
        1+
    ) drop
    "};" ;;)

def(c99-emit-buffers!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-buffer!
        1+)
    .lf drop)

def(c99-emit-buffer!, Name -- +IO,
    name-is-buffer? if(
        " volatile u8 b" . dup .name "[" . dup name-value@ buffer-size@ .n "] = {0};" ;
        " void mw" . dup .name " (void) { push((i64)b" . .name "); }" ;  ,
        drop
    ))

def(c99-emit-prims!, +IO,
    " i64 pop (void) {" ;
    "    if (sc < STACK_SIZE) {" ;
    "        return stack[sc++];" ;
    "    } else {" ;
    "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
    "        exit(1);" ;
    "        return 0;" ;
    "    }" ;
    "}" ;;
    " void* pop_ptr (void) {" ;
    "    i64 x = (i64)pop();" ;
    "    return (void*)x;" ;
    "}";;
    " u8 pop_u8 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u8)x;" ;
    "}";;
    " u16 pop_u16 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u16)x;" ;
    "}";;
    " u32 pop_u32 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u32)x;" ;
    "}";;
    " u64 pop_u64 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u64)x;" ;
    "}";;
    " i8 pop_i8 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i8)x;" ;
    "}";;
    " i16 pop_i16 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i16)x;" ;
    "}";;
    " i32 pop_i32 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i32)x;" ;
    "}";;
    " i64 pop_i64 (void) {" ;
    "    return pop();" ;
    "}";;

    " void push (i64 x) {" ;
    "    if (sc > 0) {" ;
    "        stack[--sc] = x;" ;
    "    } else {" ;
    "        write(2, \"STACK OVERFLOW\\n\", 15);" ;
    "        exit(1);" ;
    "    }" ;
    "}" ;;

    PRIM_ID .w " {" ;
    "}" ;;

    PRIM_DUP .w " {" ;
    "    i64 x = pop();" ;
    "    push(x); push(x);" ;
    "}" ;;

    PRIM_DROP .w " {" ;
    "    pop();" ;
    "}" ;;

    PRIM_SWAP .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x); push(y);" ;
    "}" ;;

    PRIM_INT_ADD .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x + y);" ;
    "}" ;;

    PRIM_INT_SUB .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y - x);" ;
    "}" ;;

    PRIM_INT_MUL .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x * y);" ;
    "}" ;;

    PRIM_INT_DIV .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y / x);" ;
    "}" ;;

    PRIM_INT_MOD .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y % x);" ;
    "}" ;;

    PRIM_INT_EQ .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x == y);" ;
    "}" ;;

    PRIM_INT_LT .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y < x);" ;
    "}" ;;

    PRIM_INT_LE .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y <= x);" ;
    "}" ;;

    PRIM_INT_AND .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y & x);" ;
    "}" ;;

    PRIM_INT_OR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y | x);" ;
    "}" ;;

    PRIM_INT_XOR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y ^ x);" ;
    "}" ;;

    PRIM_INT_SHL .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y << x);" ;
    "}" ;;

    PRIM_INT_SHR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y >> x);" ;
    "}" ;;

    PRIM_POSIX_WRITE .w " {" ;
    "    usize n = (usize)pop();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop();" ;
    "    write(f, p, n);" ; # TODO: push return code
    "}" ;;

    PRIM_POSIX_READ .w " {" ;
    "    usize n = (usize)pop();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop();" ;
    "    push(read(f,p,n));" ;
    "}" ;;

    PRIM_POSIX_OPEN .w " {" ;
    "    int m = (int)pop();" ;
    "    int f = (int)pop();" ;
    "    void* p = pop_ptr();" ;
    "    push(open(p,f,m));" ;
    "}" ;;

    PRIM_POSIX_CLOSE .w " {" ;
    "    int x = (int)pop();" ;
    "    push(close(x));" ;
    "}" ;;

    PRIM_POSIX_EXIT .w " {" ;
    "    int x = (int)pop();" ;
    "    exit(x);" ;
    "}" ;;

    PRIM_POSIX_MMAP .w " {" ;
    "    #ifdef MIRTH_WIN32" ;
    "    pop(); pop(); pop(); pop();" ;
    "    usize b = (usize)pop();" ;
    "    pop();" ;
    "    push((i64)malloc(b));" ;
    "    #else" ;
    "    int f = (int)pop();" ;
    "    int e = (int)pop();" ;
    "    int d = (int)pop();" ;
    "    int c = (int)pop();" ;
    "    usize b = (usize)pop();" ;
    "    void* a = pop_ptr();" ;
    "    void* p = mmap(a,b,c,d,e,f);" ;
    "    push((i64)p);" ;
    "    #endif" ;
    "}" ;;

    PRIM_DEBUG .w " {" ;
    "    write(2, \"??\", 2);" ;
    "    char c[32] = {0};" ;
    "    char* cp;" ;
    "    usize n;" ;
    "    i64 x;" ;
    "    for (long i = STACK_SIZE-1; i >= (long)sc; i--) {" ;
    "        cp = c+30;" ;
    "        x = (i64)stack[i];" ;
    "        n = 1;" ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
    "        *cp = ' ';" ;
    "        write(2, cp, n);" ;
    "    }" ;
    "    write(2, \"\\n\", 1);" ;
    "}" ;;

    PRIM_MIRTH_REVISION .w " {" ;
    "    push(" . NEW_MIRTH_REVISION .n ");";
    "}" ;;

    PRIM_MEM_GET .w " {" ;
    "    stack[sc] = *(i64*)(stack[sc]);" ;
    "}" ;;

    PRIM_MEM_SET .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = (i64)pop();" ;
    "}" ;;

    PRIM_MEM_GET_BYTE .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_BYTE .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U8 .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U8 .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U16 .w " {" ;
    "    u16* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U16 .w " {" ;
    "    u16* x = pop_ptr();" ;
    "    *x = pop_u16();" ;
    "}" ;;

    PRIM_MEM_GET_U32 .w " {" ;
    "    u32* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U32 .w " {" ;
    "    u32* x = pop_ptr();" ;
    "    *x = pop_u32();" ;
    "}" ;;

    PRIM_MEM_GET_U64 .w " {" ;
    "    u64* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U64 .w " {" ;
    "    u64* x = pop_ptr();" ;
    "    *x = pop_u64();" ;
    "}" ;;

    PRIM_MEM_GET_I8 .w " {" ;
    "    i8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I8 .w " {" ;
    "    i8* x = pop_ptr();" ;
    "    *x = pop_i8();" ;
    "}" ;;

    PRIM_MEM_GET_I16 .w " {" ;
    "    i16* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I16 .w " {" ;
    "    i16* x = pop_ptr();" ;
    "    *x = pop_i16();" ;
    "}" ;;

    PRIM_MEM_GET_I32 .w " {" ;
    "    i32* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I32 .w " {" ;
    "    i32* x = pop_ptr();" ;
    "    *x = pop_i32();" ;
    "}" ;;

    PRIM_MEM_GET_I64 .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I64 .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = pop_i64();" ;
    "}" ;;

    PRIM_RUNNING_OS .w " {" ;
    "#if defined(MIRTH_WIN32)" ;
    "    push(" . WIN32 .n ");" ;
    "#elif defined(MIRTH_LINUX)" ;
    "    push(" . LINUX .n ");" ;
    "#elif defined(MIRTH_MACOS)" ;
    "    push(" . MACOS .n ");" ;
    "#else" ;
    "    push(" . UNKNOWN .n ");" ;
    "#endif" ;
    "}" ;;

    )

def(c99-emit-externals!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-external!
        1+)
    .lf drop)

def(c99-emit-external!, Name -- +IO,
    name-is-external? if(
        name-sig? sig-arity
        dup 2 >= if(
            "can't declare external with multiple return values" panic!,

            dup 1 >= if(
                "i64 " .,
                "void " .
            )
        )
        dip(dip(dup .name))
        " (" .
        over dup if(
            "i64" .
            1- while(dup,
                ", i64" .
                1-
            ) drop,
            drop
        ) ");" ;

        " void mw" . dip(dip(dup .name)) " (void) {" ;
        over while(dup,
            "    i64 x" . dup .n " = pop();" ;
            1-
        ) drop
        dup if("    push(", "    ") .
        dip(dip(dup .name))
        "(" .
        dip(dup if(
            "x1" .
            dup 1-
            while(dup,
                ", x" .
                dup2 - 1+ .n
                1-
            ) drop,
            id
        ))
        ")" .
        dup if(");", ";") ;
        "}" ;

        drop3,

        drop
    ))

def(c99-emit-word-sigs!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-word-sig!
        1+
    )
    "" ;
    drop)

def(c99-emit-word-sig!, Name -- +IO,
    name-is-word? if(
        " void mw" . .name " (void);" ;,
        drop
    ))

def(c99-emit-word-defs!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-word-def!
        1+)
    drop)

def(c99-emit-word-def!, Name -- +IO,
    name-is-word? if(
        dup typecheck-name!
        dup .w "{" ;
        name-value@ c99-emit-run!
        "}" ;;,
        drop
    ))

def(c99-emit-run!, Token -- +IO,
    c99-depth++
    while(token-run-end? not,
        dup c99-emit-token!
        token-next
    ) drop
    c99-depth--)

def(c99-emit-token!, Token -- +IO,
    dup typecheck-token!

    token-type? TOKEN_INT = if(
        "    push(" . token-int@ .n ");" ;,

    token-type? TOKEN_STR = if(
        "    push((i64)(strings + " . token-value@ TokenValue->Int .n "));" ;, # FIXME: just push a string literal.

    token-type? TOKEN_NAME = if(
        c99-emit-word!,

        drop
    ))))

def(c99-emit-word!, Token -- +IO,
    token-name? PRIM_DIP = if(
        token-args-1
        "    { i64 d" . .d " = pop();" ;
        c99-emit-run!
        "      push(d" . .d "); }" ;,

    token-name? PRIM_IF = if(
        token-args-2
        "    if (pop()) {" ;
        dip(c99-emit-run!)
        "    } else {" ;
        c99-emit-run!
        "    }" ;,

    token-name? PRIM_WHILE = if(
        token-args-2
        "    while(1) {" ;
        dip(c99-emit-run!)
        "    if (!pop()) break;" ;
        c99-emit-run!
        "    }" ;,

        token-name@
        "    mw" . .name "();" ;
    ))))

def(c99-emit-main!, Token -- +IO,
    "int main (int argc, char** argv) {" ;
    c99-emit-run!
    "    return 0;" ;
    "}" ;
    )

########
# Heap #
########

def(BASE_HEAP_SIZE, Size, 0x1000)

quad def-static-buffer(HEAP_INITIAL_LENGTH)
def(heap-initial-length@, usize +Heap, HEAP_INITIAL_LENGTH @)
def(heap-initial-length!, usize -- +Heap, HEAP_INITIAL_LENGTH !)

quad def-static-buffer(HEAP_INITIAL_BASE)
def(heap-initial-base@, Ptr +Heap, HEAP_INITIAL_BASE @)
def(heap-initial-base!, Ptr -- +Heap, HEAP_INITIAL_BASE !)

quad def-static-buffer(HEAP_LENGTH)
def(heap-length@, usize +Heap, HEAP_LENGTH @)
def(heap-length!, usize -- +Heap, HEAP_LENGTH !)

quad def-static-buffer(HEAP_BASE)
def(heap-base@, Ptr +Heap, HEAP_BASE @)
def(heap-base!, Ptr -- +Heap, HEAP_BASE !)

def(init-heap!, +Heap,
    heap-initial-base@ heap-base!
    heap-initial-length@ heap-length!)

quad def-static-buffer(HEAP_TIMES_EXPANDED)
def(heap-times-expanded@, Int +Heap, HEAP_TIMES_EXPANDED @)
def(heap-times-expanded!, Int -- +Heap, HEAP_TIMES_EXPANDED !)
def(++heap-times-expanded, Int +Heap,
    heap-times-expanded@ 1+ dup heap-times-expanded!)

# Ensure that at at least X space on the heap is available.
#
# If the space left is too small (or heap has not been allocated,
# in which the space left is 0), then it tries to make the heap
# larger in place. This usually works, but if it fails, we just
# allocate a new buffer and forget about the old one, leaking
# some memory and introducing fragmentation.
#
# Panics if reservation is impossible.
def(heap-reserve!, Size -- +Heap,
    dup heap-length@ <= if(
        drop,

        heap-new-size dup # size
        heap-base@ heap-length@ + swap # pointer hint
        PROT_READ|PROT_WRITE
        MAP_ANON|MAP_PRIVATE
        -1 # file descriptor (-1 for MAP_ANONYMOUS)
        0 # offset
        posix-mmap!
        dup 0 > if(
            dup heap-base@ heap-length@ + = if(
                drop heap-length@ + heap-length!,
                dup heap-initial-base! heap-base!
                dup heap-initial-length! heap-length!
            ),
            "Failed to allocate heap buffer." panic! drop2
        )
    ))

def(PROT_READ|PROT_WRITE, Int,
    0x3) # PROT_READ = 0x1, PROT_WRITE = 0x2

def(MAP_ANON|MAP_PRIVATE, Int,
    RUNNING_OS MACOS = if(
        0x1002, # MAP_ANON = 0x1000, MAP_PRIVATE = 0x2
    # RUNNING_OS LINUX = if(
        0x22 # MAP_ANON = 0x20, MAP_PRIVATE = 0x2
        # ,
        # "MAP_ANON|MAP_PRIVATE unknown for os" panic! 0
    # )
    ))

# Aligns a by b, rounding upward. For instance,
#
#   10 64 align == 64
#   64 64 align == 64
#   70 64 align == 128
def(align, Size Size -- Size,
    # a:usize b:usize { a 0 >=, b 0 > } --
    # c:usize { c a >=, c a b + <, c b % 0 = },
    dup dip(1- + dup) % -)
def(square, Int -- Int, dup *)
def(max, Int Int -- Int, dup2 < if(nip, drop))

# Figure out how much to expand heap size by, based on a minimum size
# (= requested size aligned to 4096).
# The expansion has a quadratic lower bound.
def(heap-new-size, Size -- Size,
    4096 align
    BASE_HEAP_SIZE ++heap-times-expanded square *
    max)

def(heap-alloc!, Size -- Ptr +Heap,
    64 align
    dup heap-reserve!
    dup heap-length@ swap - heap-length!
    heap-base@ tuck + heap-base!)

########
# Main #
########

def(main, +IO,
    init!
    run-tests
    open-mirth-src! run-lexer!

    # show-names-table!
    # show-tokens!

    "Building." str-trace-ln!

    0 token-run!

    "Done." str-trace-ln!

    vstack-empty? if(
        id,
        "VSTACK = " str-trace! vstack-trace!
    )

    )

#########
# Build #
#########

def(NEW_MIRTH_REVISION, Int, 0)

"mirth.c" output-c99(main)
#"mirth_prof.c" output-c99(100 while-old(main 1-))

#################
# SDL2 Bindings #
#################

def-external(SDL_Init, SDL_InitFlags -- Int +SDL)
def-type(SDL_InitFlags, U32) # technically this ought to be U32...
def(SDL_INIT_TIMER, SDL_InitFlags, 0x0001 Int->U32)
def(SDL_INIT_AUDIO, SDL_InitFlags, 0x0010 Int->U32)
def(SDL_INIT_VIDEO, SDL_InitFlags, 0x0020 Int->U32)
def(SDL_INIT_JOYSTICK, SDL_InitFlags, 0x200 Int->U32)
def(SDL_INIT_HAPTIC, SDL_InitFlags, 0x1000 Int->U32)
def(SDL_INIT_GAMECONTROLLER, SDL_InitFlags, 0x2000 Int->U32)
def(SDL_INIT_EVENTS, SDL_InitFlags, 0x4000 Int->U32)
def(SDL_INIT_SENSOR, SDL_InitFlags, 1 15 << Int->U32)
def(SDL_INIT_EVERYTHING, SDL_InitFlags,
    SDL_INIT_TIMER U32->Int
    SDL_INIT_AUDIO U32->Int |
    SDL_INIT_VIDEO U32->Int |
    SDL_INIT_JOYSTICK U32->Int |
    SDL_INIT_HAPTIC U32->Int |
    SDL_INIT_GAMECONTROLLER U32->Int |
    SDL_INIT_EVENTS U32->Int |
    SDL_INIT_SENSOR U32->Int | Int->U32)

def-external(SDL_Quit, +SDL)
def-external(SDL_GetError, Str +SDL)

def-external(SDL_Delay, SDL_Ticks -- +SDL)
def-external(SDL_GetTicks, SDL_Ticks +SDL)
def-type(SDL_Ticks, U32)
def(ms, Int -- SDL_Ticks, Int->U32)

def-external(SDL_CreateWindow, Str Int Int Int Int SDL_WindowFlags -- SDL_Window* +SDL)
def-type(SDL_Window*, Ptr)
def-type(SDL_WindowFlags, U32)
def(SDL_WINDOWPOS_UNDEFINED, Int, 0x1FFF 16 <<)
def(SDL_WINDOWPOS_CENTERED, Int, 0x2FFF 16 <<)
def(SDL_WINDOW_NONE, SDL_WindowFlags, 0 Int->U32)
def(SDL_WINDOW_FULLSCREEN, SDL_WindowFlags, 0x1 Int->U32)
def(SDL_WINDOW_OPENGL, SDL_WindowFlags, 0x2 Int->U32)
def(SDL_WINDOW_SHOWN, SDL_WindowFlags, 0x4 Int->U32)
def(SDL_WINDOW_HIDDEN, SDL_WindowFlags, 0x8 Int->U32)
def(SDL_WINDOW_BORDERLESS, SDL_WindowFlags, 0x10 Int->U32)
def(SDL_WINDOW_RESIZABLE, SDL_WindowFlags, 0x20 Int->U32)
def(SDL_WINDOW_MINIMIZED, SDL_WindowFlags, 0x40 Int->U32)
def(SDL_WINDOW_MAXIMIZED, SDL_WindowFlags, 0x80 Int->U32)
def(SDL_WINDOW_INPUT_GRABBED, SDL_WindowFlags, 0x100 Int->U32)
def(SDL_WINDOW_INPUT_FOCUS, SDL_WindowFlags, 0x200 Int->U32)
def(SDL_WINDOW_MOUSE_FOCUS, SDL_WindowFlags, 0x400 Int->U32)
def(SDL_WINDOW_FULLSCREEN_DESKTOP, SDL_WindowFlags, 0x1001 Int->U32)
def(SDL_WINDOW_FOREIGN, SDL_WindowFlags, 0x800 Int->U32)
def(SDL_WINDOW_ALLOW_HIGHDPI, SDL_WindowFlags, 0x2000 Int->U32)
def(SDL_WINDOW_MOUSE_CAPTURE, SDL_WindowFlags, 0x4000 Int->U32)
def(SDL_WINDOW_ALWAYS_ON_TOP, SDL_WindowFlags, 1 15 << Int->U32)
def(SDL_WINDOW_SKIP_TASKBAR, SDL_WindowFlags, 1 16 << Int->U32)
def(SDL_WINDOW_UTILITY, SDL_WindowFlags, 1 17 << Int->U32)
def(SDL_WINDOW_TOOLTIP, SDL_WindowFlags, 1 18 << Int->U32)
def(SDL_WINDOW_POPUP_MENU, SDL_WindowFlags, 1 19 << Int->U32)
def(SDL_WINDOW_VULKAN, SDL_WindowFlags, 1 28 << Int->U32)

def-external(SDL_ShowWindow, SDL_Window* -- +SDL)
def-external(SDL_HideWindow, SDL_Window* -- +SDL)
def-external(SDL_RaiseWindow, SDL_Window* -- +SDL)

def-external(SDL_CreateRenderer, SDL_Window* Int SDL_RendererFlags -- SDL_Renderer* +SDL)
def-type(SDL_Renderer*, Ptr)
def-type(SDL_RendererFlags, U32)
def(SDL_RENDERER_SOFTWARE, SDL_RendererFlags, 0x1 Int->U32)
def(SDL_RENDERER_ACCELERATED, SDL_RendererFlags, 0x2 Int->U32)
def(SDL_RENDERER_PRESENTVSYNC, SDL_RendererFlags, 0x4 Int->U32)
def(SDL_RENDERER_TARGETTEXTURE, SDL_RendererFlags, 0x8 Int->U32)

def-external(SDL_RenderClear, SDL_Renderer* -- +SDL)
def-external(SDL_RenderPresent, SDL_Renderer* -- +SDL)
def-external(SDL_SetRenderDrawColor, SDL_Renderer* Int Int Int Int -- +SDL)
def-external(SDL_RenderFillRect, SDL_Renderer* SDL_Rect* -- +SDL)
def-type(SDL_Rect*, Ptr)

# Size of SDL_Event structure.
def(SDL_EVENT_SIZE, Size, 56)
def-type(SDL_Event*, Ptr)
def-type(SDL_EventType, U32)
def-external(SDL_PollEvent, SDL_Event* -- Int)

def(SDL_Event.type, SDL_Event* -- SDL_EventType, u32@)
def(SDL_QUIT, SDL_EventType, 0x100 Int->U32)
def(SDL_KEYDOWN, SDL_EventType, 0x300 Int->U32)
def(SDL_KEYUP, SDL_EventType, 0x301 Int->U32)

def(SDL_Event.key.repeat, SDL_Event* -- U8, 13 + u8@)
def(SDL_Event.key.keysym.scancode, SDL_Event* -- SDL_Scancode,
    16 + u16@)

def-type(SDL_Scancode, U16)
def(SDL_SCANCODE_UNKNOWN, SDL_Scancode, 0 Int->U16)
def(SDL_SCANCODE_A, SDL_Scancode, 4 Int->U16)
def(SDL_SCANCODE_B, SDL_Scancode, 5 Int->U16)
def(SDL_SCANCODE_C, SDL_Scancode, 6 Int->U16)
def(SDL_SCANCODE_D, SDL_Scancode, 7 Int->U16)
def(SDL_SCANCODE_E, SDL_Scancode, 8 Int->U16)
def(SDL_SCANCODE_F, SDL_Scancode, 9 Int->U16)
def(SDL_SCANCODE_G, SDL_Scancode, 10 Int->U16)
def(SDL_SCANCODE_H, SDL_Scancode, 11 Int->U16)
def(SDL_SCANCODE_I, SDL_Scancode, 12 Int->U16)
def(SDL_SCANCODE_J, SDL_Scancode, 13 Int->U16)
def(SDL_SCANCODE_K, SDL_Scancode, 14 Int->U16)
def(SDL_SCANCODE_L, SDL_Scancode, 15 Int->U16)
def(SDL_SCANCODE_M, SDL_Scancode, 16 Int->U16)
def(SDL_SCANCODE_N, SDL_Scancode, 17 Int->U16)
def(SDL_SCANCODE_O, SDL_Scancode, 18 Int->U16)
def(SDL_SCANCODE_P, SDL_Scancode, 19 Int->U16)
def(SDL_SCANCODE_Q, SDL_Scancode, 20 Int->U16)
def(SDL_SCANCODE_R, SDL_Scancode, 21 Int->U16)
def(SDL_SCANCODE_S, SDL_Scancode, 22 Int->U16)
def(SDL_SCANCODE_T, SDL_Scancode, 23 Int->U16)
def(SDL_SCANCODE_U, SDL_Scancode, 24 Int->U16)
def(SDL_SCANCODE_V, SDL_Scancode, 25 Int->U16)
def(SDL_SCANCODE_W, SDL_Scancode, 26 Int->U16)
def(SDL_SCANCODE_X, SDL_Scancode, 27 Int->U16)
def(SDL_SCANCODE_Y, SDL_Scancode, 28 Int->U16)
def(SDL_SCANCODE_Z, SDL_Scancode, 29 Int->U16)
def(SDL_SCANCODE_0, SDL_Scancode, 30 Int->U16)
def(SDL_SCANCODE_1, SDL_Scancode, 31 Int->U16)
def(SDL_SCANCODE_2, SDL_Scancode, 32 Int->U16)
def(SDL_SCANCODE_3, SDL_Scancode, 33 Int->U16)
def(SDL_SCANCODE_4, SDL_Scancode, 34 Int->U16)
def(SDL_SCANCODE_5, SDL_Scancode, 35 Int->U16)
def(SDL_SCANCODE_6, SDL_Scancode, 36 Int->U16)
def(SDL_SCANCODE_7, SDL_Scancode, 37 Int->U16)
def(SDL_SCANCODE_8, SDL_Scancode, 38 Int->U16)
def(SDL_SCANCODE_9, SDL_Scancode, 39 Int->U16)
def(SDL_SCANCODE_RETURN, SDL_Scancode, 40 Int->U16)
def(SDL_SCANCODE_ESCAPE, SDL_Scancode, 41 Int->U16)
def(SDL_SCANCODE_BACKSPACE, SDL_Scancode, 42 Int->U16)
def(SDL_SCANCODE_TAB, SDL_Scancode, 43 Int->U16)
def(SDL_SCANCODE_SPACE, SDL_Scancode, 44 Int->U16)
def(SDL_SCANCODE_MINUS, SDL_Scancode, 45 Int->U16)
def(SDL_SCANCODE_EQUALS, SDL_Scancode, 46 Int->U16)
def(SDL_SCANCODE_LEFTBRACKET, SDL_Scancode, 47 Int->U16)
def(SDL_SCANCODE_RIGHTBRACKET, SDL_Scancode, 48 Int->U16)
def(SDL_SCANCODE_BACKSLASH, SDL_Scancode, 49 Int->U16)
def(SDL_SCANCODE_NONUSHASH, SDL_Scancode, 50 Int->U16)
def(SDL_SCANCODE_SEMICOLON, SDL_Scancode, 51 Int->U16)
def(SDL_SCANCODE_APOSTROPHE, SDL_Scancode, 52 Int->U16)
def(SDL_SCANCODE_GRAVE, SDL_Scancode, 53 Int->U16)
def(SDL_SCANCODE_COMMA, SDL_Scancode, 54 Int->U16)
def(SDL_SCANCODE_PERIOD, SDL_Scancode, 55 Int->U16)
def(SDL_SCANCODE_SLASH, SDL_Scancode, 56 Int->U16)
def(SDL_SCANCODE_CAPSLOCK, SDL_Scancode, 57 Int->U16)
def(SDL_SCANCODE_F1, SDL_Scancode, 58 Int->U16)
def(SDL_SCANCODE_F2, SDL_Scancode, 59 Int->U16)
def(SDL_SCANCODE_F3, SDL_Scancode, 60 Int->U16)
def(SDL_SCANCODE_F4, SDL_Scancode, 61 Int->U16)
def(SDL_SCANCODE_F5, SDL_Scancode, 62 Int->U16)
def(SDL_SCANCODE_F6, SDL_Scancode, 63 Int->U16)
def(SDL_SCANCODE_F7, SDL_Scancode, 64 Int->U16)
def(SDL_SCANCODE_F8, SDL_Scancode, 65 Int->U16)
def(SDL_SCANCODE_F9, SDL_Scancode, 66 Int->U16)
def(SDL_SCANCODE_F10, SDL_Scancode, 67 Int->U16)
def(SDL_SCANCODE_F11, SDL_Scancode, 68 Int->U16)
def(SDL_SCANCODE_F12, SDL_Scancode, 69 Int->U16)
# skipping some
def(SDL_SCANCODE_RIGHT, SDL_Scancode, 79 Int->U16)
def(SDL_SCANCODE_LEFT, SDL_Scancode, 80 Int->U16)
def(SDL_SCANCODE_DOWN, SDL_Scancode, 81 Int->U16)
def(SDL_SCANCODE_UP, SDL_Scancode, 82 Int->U16)
# skipping many
def(SDL_SCANCODE_LCTRL, SDL_Scancode, 224 Int->U16)
def(SDL_SCANCODE_LSHIFT, SDL_Scancode, 225 Int->U16)
def(SDL_SCANCODE_LALT, SDL_Scancode, 226 Int->U16)
def(SDL_SCANCODE_LGUI, SDL_Scancode, 227 Int->U16)
def(SDL_SCANCODE_RCTRL, SDL_Scancode, 228 Int->U16)
def(SDL_SCANCODE_RSHIFT, SDL_Scancode, 229 Int->U16)
def(SDL_SCANCODE_RALT, SDL_Scancode, 230 Int->U16)
def(SDL_SCANCODE_RGUI, SDL_Scancode, 231 Int->U16)
# skipping more

##############
# Snake Game #
##############

def(SNAKE_W, Size, 20)
def(SNAKE_H, Size, 20)

u8 def-static-buffer(SNAKE_DONE)
u8 def-static-buffer(SNAKE_DEAD)
u8 def-static-buffer(SNAKE_DIRECTION)
u8 def-static-buffer(SNAKE_LAST_DIRECTION)
u8 def-static-buffer(SNAKE_X)
u8 def-static-buffer(SNAKE_Y)
quad def-static-buffer(SNAKE_WINDOW)
quad def-static-buffer(SNAKE_RENDERER)
quad def-static-buffer(SNAKE_QUEUE_LENGTH)
SNAKE_W SNAKE_H * def-static-buffer(SNAKE_QUEUE_X)
SNAKE_W SNAKE_H * def-static-buffer(SNAKE_QUEUE_Y)
SNAKE_W SNAKE_H * def-static-buffer(SNAKE_GRID)

SDL_EVENT_SIZE def-static-buffer(SNAKE_EVENT)

def-type(Direction, U8)
def(DNORTH, Direction, 0 Int->U8)
def(DEAST, Direction, 1 Int->U8)
def(DSOUTH, Direction, 2 Int->U8)
def(DWEST, Direction, 3 Int->U8)

def-type(XCoord, U8)
def(XCoord->Int, XCoord -- Int, U8->Int)
def(Int->XCoord, Int -- XCoord, Int->U8)

def-type(YCoord, U8)
def(YCoord->Int, YCoord -- Int, U8->Int)
def(Int->YCoord, Int -- YCoord, Int->U8)

def(coords-offset, XCoord YCoord -- Offset,
    dip(XCoord->Int) YCoord->Int SNAKE_W * +)

def-type(State, U8)
def(state-occupy, State -- State, U8->Int 0x1 | Int->U8)
def(state-vacate, State -- State, U8->Int 0xFE & Int->U8)
def(state-is-occupied, State -- Bool, U8->Int 0x1 &)
def(state-is-occupied?, State -- State Bool, dup state-is-occupied)

def(snake-done@, -- Bool +Snake, SNAKE_DONE u8@ U8->Int)
def(snake-done!, Bool -- +Snake, if(1,0) Int->U8 SNAKE_DONE u8!)
def(snake-dead@, -- Bool +Snake, SNAKE_DEAD u8@ U8->Int)
def(snake-dead!, Bool -- +Snake, if(1,0) Int->U8 SNAKE_DEAD u8!)
def(snake-direction@, -- Direction +Snake, SNAKE_DIRECTION u8@)
def(snake-direction!, Direction -- +Snake, SNAKE_DIRECTION u8!)
def(snake-last-direction@, -- Direction +Snake, SNAKE_LAST_DIRECTION u8@)
def(snake-last-direction!, Direction -- +Snake, SNAKE_LAST_DIRECTION u8!)
def(snake-x@, -- XCoord +Snake, SNAKE_X u8@)
def(snake-x!, XCoord -- +Snake, SNAKE_X u8!)
def(snake-y@, -- YCoord +Snake, SNAKE_Y u8@)
def(snake-y!, YCoord -- +Snake, SNAKE_Y u8!)

def(snake-xy@, -- XCoord YCoord +Snake, snake-x@ snake-y@)
def(snake-xy!, XCoord YCoord -- +Snake, snake-y! snake-x!)

def(snake-window@, -- SDL_Window* +Snake, SNAKE_WINDOW @ Int->Ptr)
def(snake-window!, SDL_Window* -- +Snake, Ptr->Int SNAKE_WINDOW !)

def(snake-renderer@, -- SDL_Renderer* +Snake, SNAKE_RENDERER @ Int->Ptr)
def(snake-renderer!, SDL_Renderer* -- +Snake, Ptr->Int SNAKE_RENDERER !)

def(snake-grid@, XCoord YCoord -- State +Snake,
    coords-offset SNAKE_GRID u8@@)
def(snake-grid!, State XCoord YCoord -- +Snake,
    coords-offset SNAKE_GRID u8!!)
def(snake-grid-clear!, +Snake,
    SNAKE_W SNAKE_H * while(dup,
        1-
        0 Int->U8 over SNAKE_GRID u8!!
    ) drop)

def(snake-queue-length@, -- Size +Snake, SNAKE_QUEUE_LENGTH @)
def(snake-queue-length!, Size -- +Snake, SNAKE_QUEUE_LENGTH !)

def(snake-queue-x?, Offset -- Offset XCoord +Snake, dup snake-queue-x@)
def(snake-queue-x@, Offset -- XCoord +Snake, SNAKE_QUEUE_X u8@@)
def(snake-queue-x!, XCoord Offset -- +Snake, SNAKE_QUEUE_X u8!!)

def(snake-queue-y?, Offset -- Offset YCoord +Snake, dup snake-queue-y@)
def(snake-queue-y@, Offset -- YCoord +Snake, SNAKE_QUEUE_Y u8@@)
def(snake-queue-y!, YCoord Offset -- +Snake, SNAKE_QUEUE_Y u8!!)

def(snake-queue-xy?, Offset -- Offset XCoord YCoord +Snake,
    dup snake-queue-xy@)
def(snake-queue-xy@, Offset -- XCoord YCoord +Snake,
    snake-queue-y? dip(snake-queue-x@))
def(snake-queue-xy!, XCoord YCoord Offset -- +Snake,
    tuck snake-queue-y! snake-queue-x!)

def(snake-enqueue-xy!, XCoord YCoord -- +Snake,
    snake-queue-length@ snake-queue-xy!
    snake-queue-length@ 1+ snake-queue-length!)

def(snake-dequeue-xy!, -- XCoord YCoord +Snake,
    0 snake-queue-xy@
    0
    while(dup 1+ snake-queue-length@ <,
        dup
        dip(1+ snake-queue-xy?) snake-queue-xy!)
    drop
    snake-queue-length@ 1- snake-queue-length!)

def(SNAKE_CELL_SIZE, Int, 30)
def(SNAKE_WINDOW_W, Int, SNAKE_W SNAKE_CELL_SIZE *)
def(SNAKE_WINDOW_H, Int, SNAKE_H SNAKE_CELL_SIZE *)
def(SNAKE_WINDOW_FLAGS, SDL_WindowFlags,
    SDL_WINDOW_HIDDEN)
def(SNAKE_RENDERER_FLAGS, SDL_RendererFlags,
    SDL_RENDERER_ACCELERATED U32->Int
    SDL_RENDERER_PRESENTVSYNC U32->Int |
    Int->U32)

def-type(SnakeButton, U8)
def(SNAKE_BUTTON_NONE, SnakeButton, 0 Int->U8)
def(SNAKE_BUTTON_UP, SnakeButton, 1 Int->U8)
def(SNAKE_BUTTON_RIGHT, SnakeButton, 2 Int->U8)
def(SNAKE_BUTTON_DOWN, SnakeButton, 3 Int->U8)
def(SNAKE_BUTTON_LEFT, SnakeButton, 4 Int->U8)
def(SNAKE_BUTTON_START, SnakeButton, 5 Int->U8)

def(SDL_Scancode->SnakeButton, SDL_Scancode -- SnakeButton,
    dup SDL_SCANCODE_UP = if(
        drop SNAKE_BUTTON_UP,
    dup SDL_SCANCODE_RIGHT = if(
        drop SNAKE_BUTTON_RIGHT,
    dup SDL_SCANCODE_DOWN = if(
        drop SNAKE_BUTTON_DOWN,
    dup SDL_SCANCODE_LEFT = if(
        drop SNAKE_BUTTON_LEFT,
    dup SDL_SCANCODE_SPACE = if(
        drop SNAKE_BUTTON_START,

        drop SNAKE_BUTTON_NONE
    ))))))

def(snake!, +Snake,
    snake-init!
    snake-loop!
    snake-quit!)

def(snake-reset!, +Snake,
    DNORTH snake-direction!
    SNAKE_W 2 / Int->XCoord snake-x!
    SNAKE_H 2 / Int->YCoord snake-y!
    0 snake-queue-length!
    snake-grid-clear!
    snake-randomize-mouse!
    0 snake-dead!
    0 snake-points!
    0 tick-timer!)

def(snake-init!, +Snake,
    snake-reset!

    SDL_INIT_VIDEO SDL_Init if(
        SDL_GetError panic!,
        id
    )

    "Snake!"
    100
    100
    SNAKE_WINDOW_W
    SNAKE_WINDOW_H
    SNAKE_WINDOW_FLAGS
    SDL_CreateWindow
    dup if(
        snake-window!,
        SDL_GetError panic! drop
    )

    snake-window@
    -1
    SNAKE_RENDERER_FLAGS
    SDL_CreateRenderer
    dup if(
        snake-renderer!,
        SDL_GetError panic! drop
    ))

def(snake-loop!, +Snake,
    snake-process-events!
    while(snake-done@ not,
        snake-present!
        0 ms SDL_Delay # TODO: use a self-adjusting delay to interval reduce input latency.
        snake-process-events!
        snake-update!
    ))

def(snake-quit!, +Snake,
    SDL_Quit)

def-type(R, Int)
def-type(G, Int)
def-type(B, Int)
def-type(A, Int)

def(snake-background-color, R G B A,
    140 100 150 255)

def(snake-foreground-color, R G B A,
    255 255 255 255)

def-type(X, Int)
def-type(Y, Int)
def-type(W, Int)
def-type(H, Int)

4 i32s def-static-buffer(SNAKE_RECT)
def(snake-rect!, X Y W H -- +Snake,
    Int->I32 3 SNAKE_RECT i32!!
    Int->I32 2 SNAKE_RECT i32!!
    Int->I32 1 SNAKE_RECT i32!!
    Int->I32 0 SNAKE_RECT i32!!)

def(snake-rect-cell!, XCoord YCoord -- +Snake,
    dip(U8->Int SNAKE_CELL_SIZE *)
    U8->Int SNAKE_CELL_SIZE *
    SNAKE_CELL_SIZE
    SNAKE_CELL_SIZE
    snake-rect!)

def(snake-present!, +Snake,
    snake-window@ SDL_ShowWindow

    snake-renderer@ snake-background-color SDL_SetRenderDrawColor
    snake-renderer@ SDL_RenderClear

    snake-renderer@ snake-foreground-color SDL_SetRenderDrawColor
    snake-xy@ snake-rect-cell!
    snake-renderer@ SNAKE_RECT SDL_RenderFillRect
    0
    while(dup snake-queue-length@ <,
        snake-queue-xy? snake-rect-cell!
        snake-renderer@ SNAKE_RECT SDL_RenderFillRect
        1+)
    drop
    snake-mouse-xy@ snake-rect-cell!
    snake-renderer@ SNAKE_RECT SDL_RenderFillRect

    snake-renderer@ SDL_RenderPresent)

def(snake-process-events!, +Snake,
    while(SNAKE_EVENT SDL_PollEvent,
        snake-process-event!))

def(snake-process-event!, +Snake,
    SNAKE_EVENT SDL_Event.type
    dup SDL_QUIT = if(
        drop 1 snake-done!,

    dup SDL_KEYDOWN = if(
        drop
        SNAKE_EVENT SDL_Event.key.repeat if(
            id,
            SNAKE_EVENT SDL_Event.key.keysym.scancode
            dup SDL_SCANCODE_ESCAPE = if(
                drop 1 snake-done!,
                SDL_Scancode->SnakeButton snake-press!
            )
        ),

        drop
    )))

def(snake-press!, SnakeButton -- +Snake,
    dup SNAKE_BUTTON_NONE = if(
        drop,
    dup SNAKE_BUTTON_UP = if(
        drop
        DSOUTH snake-last-direction@ = if(
            id,
            DNORTH snake-direction!
        ),
    dup SNAKE_BUTTON_RIGHT = if(
        drop
        DWEST snake-last-direction@ = if(
            id,
            DEAST snake-direction!
        ),
    dup SNAKE_BUTTON_DOWN = if(
        drop
        DNORTH snake-last-direction@ = if(
            id,
            DSOUTH snake-direction!
        ),
    dup SNAKE_BUTTON_LEFT = if(
        drop
        DEAST snake-last-direction@ = if(
            id,
            DWEST snake-direction!
        ),
    dup SNAKE_BUTTON_START = if(
        drop
        snake-dead@ if(
            snake-reset!,
            id
        ),

        drop "Unhandled button press!" panic!
    )))))))

quad def-static-buffer(TICK_TIMER)
def(tick-timer@, Int +Snake, TICK_TIMER @)
def(tick-timer!, Int -- +Snake, TICK_TIMER !)
def(TICK_FRAMES, Int, 7)

def(snake-tick!, Bool +Snake,
    tick-timer@
    1+ dup TICK_FRAMES >= if(
        drop 0 tick-timer! 1,
        tick-timer! 0
    ))

def(snake-update!, +Snake,
    snake-dead@ if(
        id,

    snake-tick! if(
        snake-direction@ snake-last-direction!

        snake-xy@
        snake-direction@
        snake-apply-direction
        snake-xy!

        snake-xy@ snake-grid@ if(
            1 snake-dead!,

            1 Int->U8 snake-xy@ snake-grid!
            snake-check-mouse!

            snake-xy@ snake-enqueue-xy!
            snake-queue-length@ snake-desired-length > if(
                0 Int->U8 snake-dequeue-xy! snake-grid!,
                id
            )
        ),

        id
    )))

quad def-static-buffer(SNAKE_POINTS)
def(snake-points@, -- Int +Snake, SNAKE_POINTS @)
def(snake-points!, Int -- +Snake, SNAKE_POINTS !)
def(snake-points-inc!, +Snake, snake-points@ 1 + snake-points!)
def(snake-desired-length, Int +Snake, snake-points@ 5 +)

u8 def-static-buffer(SNAKE_MOUSE_X)
u8 def-static-buffer(SNAKE_MOUSE_Y)

def(snake-mouse-x@, XCoord +Snake, SNAKE_MOUSE_X u8@)
def(snake-mouse-y@, YCoord +Snake, SNAKE_MOUSE_Y u8@)
def(snake-mouse-xy@, XCoord YCoord +Snake,
    snake-mouse-x@ snake-mouse-y@)

def-external(rand, Int +IO)

def(snake-randomize-mouse!, +IO +Snake,
    rand SNAKE_W % Int->XCoord SNAKE_MOUSE_X !
    rand SNAKE_H % Int->YCoord SNAKE_MOUSE_Y !

    snake-mouse-xy@ snake-grid@ if(
        snake-randomize-mouse!, # TODO: avoid crashing ...
        id
    ))

def(snake-check-mouse!, +Snake,
    snake-x@ snake-mouse-x@ =
    snake-y@ snake-mouse-y@ = & if(
        snake-randomize-mouse!
        snake-points-inc!,

        id
    ))


def(snake-apply-direction, XCoord YCoord Direction -- XCoord YCoord,
    dup DNORTH = if(
        drop YCoord->Int 1- SNAKE_H + SNAKE_H % Int->YCoord,
    dup DEAST = if(
        drop dip(XCoord->Int 1+ SNAKE_W % Int->XCoord),
    dup DSOUTH = if(
        drop YCoord->Int 1+ SNAKE_H % Int->YCoord,
    dup DWEST = if(
        drop dip(XCoord->Int 1- SNAKE_W + SNAKE_W % Int->XCoord),

        "unknown direction in snake-apply-direction" panic! drop
    )))))

"snake.c" output-c99(snake!)
