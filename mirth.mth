module(mirth)

import(prelude)
import(math)
import(input)
import(names)
import(strings)
import(tokens)
import(lexer)

def(init!, +IO,
    init-strings!
    init-tokens!
    init-names!
    init-buffers!
    init-heap!)

###############
# Value Stack #
###############

def(VSTACK_SIZE, Size, 0x100)
quad def-static-buffer(VSTACK_LEN)
VSTACK_SIZE quads def-static-buffer(VSTACK_BUF)

def(vstack-len@, usize +VSTACK, VSTACK_LEN @)
def(vstack-len!, usize -- +VSTACK, VSTACK_LEN !)
def(vstack-empty?, Bool +VSTACK, vstack-len@ 0 <=)
def(vstack-full?, Bool +VSTACK, vstack-len@ VSTACK_SIZE >=)
def(vstack-i64@, usize -- v +VSTACK, VSTACK_BUF quad@@)
def(vstack-i64!, v usize -- +VSTACK, VSTACK_BUF quad!!)

def(vstack-pop!, v1 +VSTACK,
    vstack-empty? if(
        "stack underflow: attempted to pop on empty vstack" panic! 0,
        vstack-len@ 1- vstack-len!
        vstack-len@ vstack-i64@
    ))

def(vstack-pop2!, v1 v2 +VSTACK,
    vstack-pop! dip(vstack-pop!))

def(vstack-pop3!, v1 v2 v3 +VSTACK,
    vstack-pop! dip(vstack-pop2!))

def(vstack-pop4!, v1 v2 v3 v4 +VSTACK,
    vstack-pop! dip(vstack-pop3!))

def(vstack-pop5!, v1 v2 v3 v4 v5 +VSTACK,
    vstack-pop! dip(vstack-pop4!))

def(vstack-pop6!, v1 v2 v3 v4 v5 v6 +VSTACK,
    vstack-pop! dip(vstack-pop5!))

def(vstack-push!, v1 -- +VSTACK,
    vstack-full? if(
        "vstack overflow" panic! drop,
        vstack-len@ vstack-i64!
        vstack-len@ 1+ vstack-len!
    ))

def(vstack-push2!, v1 v2 -- +VSTACK,
    dip(vstack-push!) vstack-push!)

def(vstack-push3!, v1 v2 v3 -- +VSTACK,
    dip(vstack-push2!) vstack-push!)

def(vstack-top@, I64 +VSTACK,
    vstack-empty? if(
        "vstack underflow" panic! 0,
        vstack-len@ 1- vstack-i64@
    ))

def(vstack-top!, I64 -- +VSTACK,
    vstack-empty? if(
        "stack underflow: attempted to write to top of empty vstack" panic! drop,
        vstack-len@ 1- vstack-i64!
    ))

def(vstack-trace!, +VSTACK +IO,
    0
    while(dup vstack-len@ <,
        dup vstack-i64@
        int-trace-sp!
        1+
    ) drop trace-ln!)

###############
# Diagnostics #
###############

def(emit-warning!, Token Str -- +IO,
    "mirth.mth:" str-trace!
    dip(token-trace-prefix!)
    "warning: " str-trace!
    str-trace-ln!)

def(emit-error!, Token Str -- +IO,
    "mirth.mth:" str-trace!
    dip(token-trace-prefix!)
    "error: " str-trace!
    str-trace-ln!)

def(emit-fatal-error!, Token Str -- +IO,
    # FIXME: type sig should be *a Token Str -- *b +IO.
    # or use a special syntax for "not returning".
    emit-error!
    1 posix-exit!)

def(lexer-emit-warning!, Str -- +IO,
    "mirth.mth:" str-trace!
    lexer-trace-prefix!
    "warning: " str-trace!
    str-trace-ln!)

def(lexer-emit-error!, Str -- +IO,
    "mirth.mth:" str-trace!
    lexer-trace-prefix!
    "error: " str-trace!
    str-trace-ln!)

def(lexer-emit-fatal-error!, Str -- +IO,
    lexer-emit-error!
    1 posix-exit!)

###########
# Running #
###########

# Run directly from tokens! (FIXME: Use this only for top-level code.)
# No type checking. (FIXME: Add dynamic types.)
def(token-run!, Token -- +Mirth,
    while(token-run-end? not, token-run-one!)
    drop)

# Is this a token to stop running at?
def(token-run-end?, Token -- Token Bool +Mirth,
    dup num-tokens@ >= if(
        1,
    token-type? TOKEN_NONE = if(
        1,
    token-type? TOKEN_COMMA = if(
        1,
        token-type? TOKEN_RPAREN =
    ))))

# Run a single token, return next token.
def(token-run-one!, Token -- Token +Mirth,
    dup typecheck-token!

    token-type? TOKEN_INT = if(
        0 1 arity-check!
        token-int? vstack-push!,
    token-type? TOKEN_STR = if(
        0 1 arity-check!
        token-str? vstack-push!,
    token-type? TOKEN_LPAREN = if(
        token-value@,
    token-type? TOKEN_NAME = if(
        dup token-run-name!,

        dup "Unexpected token type in token-run!" emit-fatal-error!
    )))) 1+)

# Run a single name token.
def(token-run-name!, Token -- +Mirth,
    token-name?

    name-is-prim? if(
        drop token-run-prim!,

    name-undefined? if(
        drop "Word is undefined." emit-fatal-error!,

    name-is-word? if(
        nip name-value@ token-run!,

    name-is-buffer? if(
        nip name-value@ buffer-base@ vstack-push!,

        drop "Don't know how to run word." emit-fatal-error!
    )))))

# Run a single primitive name token.
def(token-run-prim!, Token --,

    token-name?

    dup PRIM_ID = if(
        drop
        0 0 arity-check!
        token-args-0,

    dup PRIM_SWAP = if(
        drop
        2 2 arity-check!
        token-args-0
        vstack-pop2!
        swap
        vstack-push2!,

    dup PRIM_DUP = if(
        drop
        1 2 arity-check!
        token-args-0
        vstack-pop!
        dup
        vstack-push2!,

    dup PRIM_DROP = if(
        drop
        1 0 arity-check!
        token-args-0
        vstack-pop!
        drop,

    dup PRIM_DIP = if(
        drop
        1 1 arity-check!
        token-args-1
        vstack-pop!
        dip(token-run!)
        vstack-push!,

    dup PRIM_IF = if(
        drop
        1 0 arity-check!
        token-args-2
        vstack-pop!
        if(drop, nip) token-run!,

    dup PRIM_WHILE = if(
        drop
        0 0 arity-check!
        token-args-2
        while(over token-run! vstack-pop!, dup token-run!)
        drop2,

    dup PRIM_INT_ADD = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        +
        vstack-push!,

    dup PRIM_INT_SUB = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        -
        vstack-push!,

    dup PRIM_INT_MUL = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        *
        vstack-push!,

    dup PRIM_INT_DIV = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        /
        vstack-push!,

    dup PRIM_INT_MOD = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        %
        vstack-push!,

    dup PRIM_INT_EQ = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        =
        vstack-push!,

    dup PRIM_INT_LT = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        <
        vstack-push!,

    dup PRIM_INT_LE = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        <=
        vstack-push!,

    dup PRIM_INT_AND = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        &
        vstack-push!,

    dup PRIM_INT_OR = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        |
        vstack-push!,

    dup PRIM_INT_XOR = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        ^
        vstack-push!,

    dup PRIM_INT_SHL = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        <<
        vstack-push!,

    dup PRIM_INT_SHR = if(
        drop
        2 1 arity-check!
        token-args-0
        vstack-pop2!
        >>
        vstack-push!,

    dup PRIM_MEM_GET = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        @
        vstack-push!,

    dup PRIM_MEM_SET = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        !,

    dup PRIM_MEM_GET_BYTE = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u8@
        vstack-push!,

    dup PRIM_MEM_SET_BYTE = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u8!,

    dup PRIM_MEM_GET_U8 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u8@
        vstack-push!,
    dup PRIM_MEM_GET_U16 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u16@
        vstack-push!,
    dup PRIM_MEM_GET_U32 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u32@
        vstack-push!,
    dup PRIM_MEM_GET_U64 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        u64@
        vstack-push!,
    dup PRIM_MEM_GET_I8 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i8@
        vstack-push!,
    dup PRIM_MEM_GET_I16 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i16@
        vstack-push!,
    dup PRIM_MEM_GET_I32 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i32@
        vstack-push!,
    dup PRIM_MEM_GET_I64 = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        i64@
        vstack-push!,

    dup PRIM_MEM_SET_U8 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u8!,

    dup PRIM_MEM_SET_U16 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u16!,

    dup PRIM_MEM_SET_U32 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u32!,

    dup PRIM_MEM_SET_U64 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        u64!,

    dup PRIM_MEM_SET_I8 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i8!,

    dup PRIM_MEM_SET_I16 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i16!,

    dup PRIM_MEM_SET_I32 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i32!,

    dup PRIM_MEM_SET_I64 = if(
        drop
        2 0 arity-check!
        token-args-0
        vstack-pop2!
        i64!,

    dup PRIM_POSIX_MMAP = if(
        drop
        6 1 arity-check!
        token-args-0
        vstack-pop6!
        posix-mmap!
        vstack-push!,

    dup PRIM_POSIX_WRITE = if(
        drop
        3 0 arity-check!
        token-args-0
        vstack-pop3!
        posix-write!,

    dup PRIM_POSIX_READ = if(
        drop
        3 1 arity-check!
        token-args-0
        vstack-pop3!
        posix-read!
        vstack-push!,

    dup PRIM_POSIX_OPEN = if(
        drop
        3 1 arity-check!
        token-args-0
        vstack-pop3!
        posix-open!
        vstack-push!,

    dup PRIM_POSIX_CLOSE = if(
        drop
        1 1 arity-check!
        token-args-0
        vstack-pop!
        posix-close!
        vstack-push!,

    dup PRIM_POSIX_EXIT = if(
        drop 1 0 arity-check! token-args-0
        vstack-pop! posix-exit!,

    dup PRIM_DEBUG = if(
        drop 0 0 arity-check! token-args-0
        "?? " str-trace!
        vstack-trace!,

    dup PRIM_DEF = if(
        drop
        0 0 arity-check!
        token-args-3
        rotl token-type? TOKEN_NAME = if(
            token-name? name-undefined? if(
                nip
                DEF_WORD over name-sort!
                dup dip(name-value!)
                name-sig!,
                drop "word already defined" emit-fatal-error! drop2
            ),
            "expected word name" emit-fatal-error! drop2
        ),

    dup PRIM_DEF_TYPE = if(
        drop
        0 0 arity-check!
        token-args-2
        swap sig-token-is-type-con? if(
            token-name? name-undefined? if(
                nip swap
                sig-token-is-type-con? if(
                    token-name?
                    name-is-type? if(
                        name-value@ nip,
                        drop "Unknown type." emit-error!
                        TYPE_ERROR
                    ),
                    "Expected a type." emit-error!
                    TYPE_ERROR
                )
                over name-value!
                DEF_TYPE swap name-sort!,

                drop "type already defined" emit-fatal-error! drop
            ),
            "expected type constructor" emit-fatal-error! drop
        ),

    dup PRIM_DEF_STATIC_BUFFER = if(
        drop
        1 0 arity-check!
        token-args-1
        token-type? TOKEN_NAME = if(
            token-name? name-undefined? if(
                nip
                DEF_BUFFER over name-sort!
                vstack-pop! buffer-alloc! swap name-value!,
                drop "buffer already defined" emit-fatal-error!
            ),
            "expected buffer name" emit-fatal-error!
        ),

    dup PRIM_DEF_EXTERNAL = if(
        drop
        token-args-2
        swap token-type? TOKEN_NAME = if(
            token-name? name-undefined? if(
                nip DEF_EXTERNAL over name-sort!
                name-sig!,
                drop2 "word already defined" emit-fatal-error!
            ),
            nip "expected name" emit-fatal-error!
        ),

    dup PRIM_MODULE = if(
        drop
        token-args-1
        token-type? TOKEN_NAME = if(
            token-name?
            name-is-module? if(
                drop2,

            name-undefined? if(
                # just reserve the module name for now
                nip DEF_MODULE swap name-sort!,

                drop "module name is already taken" emit-fatal-error!
            )),

            "expected module name" emit-fatal-error!
        ),

    dup PRIM_IMPORT = if(
        drop
        token-args-1
        token-type? TOKEN_NAME = if(
            token-name?
            name-is-module? if(
                drop2, # module is already loaded

            name-undefined? if(
                DEF_MODULE over name-sort!

                name-load! ".mth" str-buf-push-str!
                STR_BUF 0 0 posix-open!
                dup 0 < if(
                    drop "failed to open module" emit-fatal-error!,
                    dip(drop num-tokens@)
                    run-lexer!
                    token-run! # run the imported module


   #                 token-run!
                ),

                drop "module name is already taken" emit-fatal-error!
            )),

            "expected module name" emit-fatal-error!
        ),

    dup PRIM_MIRTH_REVISION = if(
        drop
        0 1 arity-check!
        token-args-0
        NEW_MIRTH_REVISION
        vstack-push!,

    dup PRIM_RUNNING_OS = if(
        drop
        0 1 arity-check!
        token-args-0
        RUNNING_OS
        vstack-push!,

    dup PRIM_OUTPUT_C99 = if(
        drop
        1 0 arity-check!
        token-args-1
        vstack-pop!
        run-output-c99!,

        drop
        "Dont know how to run prim yet." emit-fatal-error!
    )))))))))))))))))))))))))))))))))))))))))))))))))))))))))

# Assert stack arity of a primitive. If the
# arity would result in underflow/overflow,
# emits a fatal error.
def(arity-check!, Token Size Size -- Token,
    dip(dip(vstack-len@))
    dip(dup2 <) swap if(
        drop drop2 "Stack underflow." emit-fatal-error! 0,
        dip(-) + VSTACK_SIZE > if(
            "Stack overflow." emit-fatal-error! 0,
            id
        )
    ))

# Verify that token has 0 args, and return them.
# Emits a fatal error if arity is wrong.
def(token-args-0, Token --,
    1+ token-type?
    TOKEN_LPAREN = if(
        "expected no args"
        emit-fatal-error!,
        drop
    ))

# Verify that token has 1 arg, and return it.
# Emits a fatal error if arity is wrong.
def(token-args-1, Token -- Token,
    dup
    1+ token-type?
    TOKEN_LPAREN = if(
        1+
        tuck token-next-arg-end
        token-type? TOKEN_RPAREN = if(
            drop2,
            drop
            "expected 1 arg, got too many"
            emit-fatal-error!
        ),
        drop
        "expected 1 arg, got none"
        emit-fatal-error! 0
    ))

# Verify that token has 2 args, and return them.
# Emits a fatal error if arity is wrong.
def(token-args-2, Token -- Token Token,
    dup
    1+ token-type?
    TOKEN_LPAREN = if(
        1+ tuck token-next-arg-end
        token-type? TOKEN_COMMA = if(
            1+ tuck token-next-arg-end
            token-type? TOKEN_RPAREN = if(
                drop2,
                drop
                "expected 2 args, got too many"
                emit-fatal-error!
            ),
            drop
            "expected 2 args, got only 1"
            emit-fatal-error! 0
        ),
        drop
        "expected 2 args, got none"
        emit-fatal-error! 0 0
    ))

# Verify that token has 3 args, and return them.
# Emits a fatal error if arity is wrong.
def(token-args-3, Token -- Token Token Token,
    dup
    1+ token-type?
    TOKEN_LPAREN = if(
        1+ tuck token-next-arg-end
        token-type? TOKEN_COMMA = if(
            1+ tuck token-next-arg-end
            token-type? TOKEN_COMMA = if(
                1+ tuck token-next-arg-end
                token-type? TOKEN_RPAREN = if(
                    drop2,
                    drop
                    "expected 3 args, got too many"
                    emit-fatal-error!
                ),
                drop
                "expected 3 args, got only 2"
                emit-fatal-error! 0
            ),
            drop
            "expected 3 args, got only 1"
            emit-fatal-error! 0 0
        ),
        drop
        "expected 3 args, got none"
        emit-fatal-error! 0 0 0
    ))

# Get closest arg ending (COMMA or RPAREN),
# while respecting the nesting of tokens.
def(token-next-arg-end, Token -- Token,
    while(token-is-arg-end? not, token-next))

# Get next token, respecting nesting of tokens.
def(token-next, Token -- Token,
    token-type? TOKEN_LPAREN = if(
        token-token@ 1+,

    token-type? TOKEN_NAME = if(
        1+
        token-type? TOKEN_LPAREN = if(
            token-token@ 1+,
            id
        ),

        1+
    )))

# Is this an arg ending (COMMA or RPAREN)?
def(token-is-arg-end?, Token -- Token Bool,
    token-type? TOKEN_COMMA = if(
        1,
        token-type? TOKEN_RPAREN =
    ))

###########
# Buffers #
###########

def(MAX_BUFFERS, Size, 0x80)
def-type(Buffer, Int)

quad def-static-buffer(NUM_BUFFERS)
def(num-buffers@, Size +Buffers, NUM_BUFFERS @)
def(num-buffers!, Size -- +Buffers, NUM_BUFFERS !)

def(init-buffers!, +Buffers,
    0 num-buffers!)

MAX_BUFFERS quads dup
    def-static-buffer(BUFFER_SIZE)
    def-static-buffer(BUFFER_BASE)

def(buffer-size@, Buffer -- usize +Buffers,
    BUFFER_SIZE quad@@)

def(buffer-size!, usize Buffer -- +Buffers,
    BUFFER_SIZE quad!!)

def(buffer-alloc!, usize -- Buffer +Buffers,
    num-buffers@ MAX_BUFFERS >= if(
        "compiler error: ran out of buffers" panic!,
        dup num-buffers@ buffer-size!
        heap-alloc! num-buffers@ buffer-base!
        num-buffers@ dup 1+ num-buffers!
    ))

def(buffer-base@, Buffer -- Ptr +Buffers,
    BUFFER_BASE quad@@ Int->Ptr)

def(buffer-base!, Ptr Buffer -- +Buffers,
    dip(Ptr->Int) BUFFER_BASE quad!!)

########
# Defs #
########

def-type(Value, Int)

def-type(Sort, U8)
def(DEF_NONE, Sort, 0 Int->U8)
def(DEF_WORD, Sort, 1 Int->U8)
def(DEF_BUFFER, Sort, 2 Int->U8)
def(DEF_TYPE, Sort, 3 Int->U8)
def(DEF_EXTERNAL, Sort, 4 Int->U8)
def(DEF_MODULE, Sort, 5 Int->U8)

MAX_NAMES u8s def-static-buffer(DEF_SORT)
MAX_NAMES quads def-static-buffer(DEF_VALUE)
MAX_NAMES quads def-static-buffer(DEF_SIG)

def(name-sort!, Sort Name --, DEF_SORT u8!!)
def(name-sort@, Name -- Sort, DEF_SORT u8@@)
def(name-sort?, Name -- Name Sort, dup name-sort@)

def(name-value!, Value Name --, DEF_VALUE quad!!)
def(name-value@, Name -- Value, DEF_VALUE quad@@)
def(name-value?, Name -- Name Value, dup name-value@)

def(name-sig!, Token Name --, DEF_SIG quad!!)
def(name-sig@, Name -- Token, DEF_SIG quad@@)
def(name-sig?, Name -- Name Token, dup name-sig@)

def(name-undefined?, Name -- Name Bool, name-sort? DEF_NONE =)
def(name-defined?, Name -- Name Bool, name-undefined? not)
def(name-is-word?, Name -- Name Bool, name-sort? DEF_WORD =)
def(name-is-buffer?, Name -- Name Bool, name-sort? DEF_BUFFER =)
def(name-is-type?, Name -- Name Bool, name-sort? DEF_TYPE =)
def(name-is-external?, Name -- Name Bool, name-sort? DEF_EXTERNAL =)
def(name-is-module?, Name -- Name Bool, name-sort? DEF_MODULE =)

#################
# Type Checking #
#################

def-type(Type, Int)
def-type(Stash, Int)

MAX_NAMES def-static-buffer(DEF_CHECKED)
def(name-checked!, Bool Name --, dip(Int->U8) DEF_CHECKED u8!!)
def(name-checked@, Name -- Bool, DEF_CHECKED u8@@ U8->Int)
def(name-checked?, Name -- Name Bool, dup name-checked@)

def(TSTACK_SIZE, Size, VSTACK_SIZE)
quad def-static-buffer(TSTACK_LEN)
quad def-static-buffer(TSTACK_BASE)
TSTACK_SIZE quads def-static-buffer(TSTACK_BUF)

def(tstack-len!, Size --, TSTACK_LEN !)
def(tstack-len@, Size, TSTACK_LEN @)

def(tstack-base!, Size --, TSTACK_BASE !)
def(tstack-base@, Size, TSTACK_BASE @)

def(tstack-length?, Size +TSTACK, tstack-len@ tstack-base@ -)
def(tstack-empty?, Bool, tstack-len@ tstack-base@ <=)
def(tstack-full?, Bool, tstack-len@ TSTACK_SIZE >=)
def(tstack-clear!, +TSTACK, tstack-base@ tstack-len!)

def(tstack!, Type Offset --, TSTACK_BUF quad!!)
def(tstack@, Offset -- Type, TSTACK_BUF quad@@)
def(tstack-pop!, -- Type,
    tstack-empty? if(
        "tstack underflow" panic! 0,
        tstack-len@ 1- dup tstack-len! tstack@
    ))
def(tstack-push!, Type --,
    tstack-full? if(
        "tstack overflow" panic! drop,
        tstack-len@ dup 1+ tstack-len! tstack!
    ))

def(tstack-pop2!, -- Type Type, tstack-pop! dip(tstack-pop!))
def(tstack-pop3!, -- Type Type Type, tstack-pop! dip(tstack-pop2!))
def(tstack-push2!, Type Type --, dip(tstack-push!) tstack-push!)

def(tstack-enter!, --,
    tstack-base@ tstack-push!
    tstack-len@ tstack-base!
    )

def(tstack-leave!, --,
    tstack-base@ 0 <= if(
        "Compiler error: Attempt to leave empty tstack frame." panic!,
        tstack-base@
        1- dup tstack-len!
        tstack@ tstack-base!
    ))

# Create a copy of the current tstack frame as a new tstack frame.
def(tstack-frame-dup!, -- +TSTACK,
    tstack-len@ tstack-base@
    tstack-enter!
    while(dup2 >,
        dup tstack@ tstack-push!
        1+)
    drop2)

quad def-static-buffer(TSTACK_NUM_STASHES)
def(tstack-num-stashes@, Size +TSTACK, TSTACK_NUM_STASHES @)
def(tstack-num-stashes!, Size -- +TSTACK, TSTACK_NUM_STASHES !)

TSTACK_SIZE quads def-static-buffer(TSTACK_STASH_LEN)
def(tstack-stash-len@, Stash -- Size +TSTACK, TSTACK_STASH_LEN quad@@)
def(tstack-stash-len!, Size Stash -- +TSTACK, TSTACK_STASH_LEN quad!!)

def(tstack-stash-len-push!, Size -- +TSTACK,
    tstack-num-stashes@ TSTACK_SIZE < if(
        tstack-num-stashes@ tstack-stash-len!
        tstack-num-stashes@ 1+ tstack-num-stashes!,
        "compiler error: tstack stash overflow" panic! drop
    ))

def(tstack-stash-len-pop!, Size +TSTACK,
    tstack-num-stashes@ 0 > if(
        tstack-num-stashes@ 1- tstack-num-stashes!
        tstack-num-stashes@ tstack-stash-len@,
        "compiler error: tstack stash underflow" panic! 0
    ))

# Stash the top tstack frame.
def(tstack-frame-stash!, -- +TSTACK,
    tstack-length? tstack-stash-len-push!
    tstack-leave!) # FIXME: actually save the values

# Pop the stashed tstack frame & unify it with the top tstack frame.
def(tstack-frame-unify!, Token -- Token +TSTACK,
    tstack-length? tstack-stash-len-pop!
    dup2 = if(
        drop2,
        "mirth.mth:" str-trace!
        dip(dip(dup token-trace-prefix!))
        "error: Failed to unify branches. First branch has " str-trace!
        int-trace!
        " outputs, second branch has " str-trace!
        int-trace!
        " outputs." str-trace-ln!
        1 posix-exit!
    ))

def(typecheck-token!, Token --,
    token-type? TOKEN_NAME = if(
        token-name?

        name-is-prim? if(
            drop2,

        name-undefined? if(
            drop "Word is undefined." emit-fatal-error!,

            nip typecheck-name!
        )),

        drop
    ))

def(typecheck-name!, Name --,
    name-checked? if(
        drop,

        1 over name-checked!

        name-is-prim? if(
            drop,

        name-undefined? if(
            "error: Name undefined: " str-trace!
            name-load! str-buf-trace! trace-ln!,

        name-is-word? if(
            typecheck-word!,

        name-is-buffer? if(
            typecheck-buffer!,

        name-is-external? if(
            drop, # TODO: check the signature

        name-is-type? if(
            drop, # TODO

            "error: Dont know how to typecheck name: "
            str-trace! name-load! str-buf-trace! trace-ln!
            1 posix-exit!

        ))))))
    ))

def(typecheck-word!, Name --,
    name-sig? typecheck-word-sig!

    tstack-enter!
    name-sig? sig-push-inputs!
    name-value? typecheck-run!
    name-sig? sig-match-outputs!
    # FIXME: sig-effects
    tstack-leave!
    # drop

    drop) # FIXME: check the body

def(typecheck-word-sig!, Token --,
    sig-has-dashes? if(
        typecheck-sig-inputs! 1+
        typecheck-sig-outputs!,
        typecheck-sig-outputs!
    ))

def(typecheck-sig-inputs!, Token -- Token,
    while(token-is-dashes? not,
        dup typecheck-sig-input-token!
        1+))

def(typecheck-sig-outputs!, Token --,
    while(token-is-arg-end? not,
        dup typecheck-sig-output-token!
        1+)
    drop)

def(typecheck-sig-input-token!, Token --,
    sig-token-is-type-con? if(
        token-name? name-is-type? nip if(
            drop,
            "Unknown type" emit-error!
        ),

    sig-token-is-type-var? if(
        drop, # TODO: register variable?

        "Unexpected token in type sig" emit-error!
    )))

def(typecheck-sig-output-token!, Token --,
    sig-token-is-type-con? if(
        token-name? name-is-type? nip if(
            drop,
            "Unknown type" emit-error!
        ),

    sig-token-is-type-var? if(
        drop, # TODO: register variable?

    sig-token-is-effect-con? if(
        drop, # TODO: check if effect exists

        "Unexpected token in type sig" emit-error!
    ))))


def(typecheck-buffer!, Name --,
    drop) # FIXME: check the type

def(typecheck-run!, Token --,
    while(token-is-arg-end? not,
        dup typecheck-run-one!
        token-next)
    drop)

def(typecheck-run-one!, Token --,
    dup typecheck-token!
    dup elab-token!

    token-type? TOKEN_INT = if(
        0 1 tstack-arity-check!
        token-args-0
        TYPE_INT tstack-push!,

    token-type? TOKEN_STR = if(
        0 1 tstack-arity-check!
        token-args-0
        TYPE_PTR tstack-push!,

    token-type? TOKEN_NAME = if(
        token-name? typecheck-run-name!,

        "Unexpected token type." emit-fatal-error!
    ))))

def(typecheck-run-name!, Token Name --,
    name-is-prim? if(
        drop typecheck-run-prim!,

    name-is-word? if(
        over token-args-0
        name-sig@ sig-apply!,

    name-is-external? if(
        over token-args-0
        name-sig@ sig-apply!,

    name-is-buffer? if(
        drop token-args-0
        TYPE_PTR tstack-push!,

        drop
        "Don't know how to typecheck token." emit-fatal-error!
    )))))

def(typecheck-run-prim!, Token --,
    token-name?
    dup PRIM_ID = if(
        drop token-args-0,

    dup PRIM_DUP = if(
        drop 1 2 tstack-arity-check! token-args-0
        tstack-pop! dup tstack-push2!,

    dup PRIM_DROP = if(
        drop 1 0 tstack-arity-check! token-args-0
        tstack-pop! drop,

    dup PRIM_SWAP = if(
        drop 2 2 tstack-arity-check! token-args-0
        tstack-pop2! swap tstack-push2!,

    dup PRIM_DIP = if(
        drop 1 1 tstack-arity-check! token-args-1
        tstack-pop! swap typecheck-run! tstack-push!,

    dup PRIM_IF = if(
        drop 1 0 tstack-arity-check! dup token-args-2
        tstack-pop! drop # FIXME: check that it's TYPE_BOOL
        tstack-frame-dup!
        dip(typecheck-run!)
        tstack-frame-stash!
        typecheck-run!
        tstack-frame-unify!
        drop,

    dup PRIM_WHILE = if(
        drop 0 0 tstack-arity-check! dup token-args-2
        # FIXME: check that tstack top is TYPE_BOOL
        tstack-frame-dup!
        tstack-frame-stash!
        dip(typecheck-run!
            tstack-pop! drop
            tstack-frame-unify!)
        tstack-frame-dup!
        tstack-frame-stash!
        typecheck-run!
        tstack-frame-unify!
        drop,

    dup PRIM_INT_ADD = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab+ tstack-push!,
    dup PRIM_INT_SUB = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab- tstack-push!,
    dup PRIM_INT_MUL = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab* tstack-push!,
    dup PRIM_INT_DIV = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab/ tstack-push!,
    dup PRIM_INT_MOD = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab% tstack-push!,
    dup PRIM_INT_EQ = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab= tstack-push!,
    dup PRIM_INT_LT = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab= tstack-push!,
    dup PRIM_INT_LE = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab= tstack-push!,
    dup PRIM_INT_AND = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_OR = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_XOR = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_SHL = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,
    dup PRIM_INT_SHR = if(
        drop 2 1 tstack-arity-check! token-args-0
        tstack-pop2! elab& tstack-push!,

    dup PRIM_MEM_GET = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! elab@ tstack-push!,
    dup PRIM_MEM_GET_BYTE = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! elab@ tstack-push!,
    dup PRIM_MEM_SET = if(
        drop 2 0 tstack-arity-check! token-args-0
        tstack-pop2! elab!,
    dup PRIM_MEM_SET_BYTE = if(
        drop 2 0 tstack-arity-check! token-args-0
        tstack-pop2! elab!,

    dup PRIM_MEM_GET_U8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U8, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_U16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U16, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_U32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U32, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_U64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_U64, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I8, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I16, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I32, TYPE_ERROR
        ) tstack-push!,
    dup PRIM_MEM_GET_I64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! TYPE_PTR expect1 if(
            TYPE_I64, TYPE_ERROR
        ) tstack-push!,

    dup PRIM_MEM_SET_U8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U8 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_U16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U16 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_U32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U32 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_U64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_U64 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I8 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I8 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I16 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I16 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I32 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I32 TYPE_PTR expect2 drop,
    dup PRIM_MEM_SET_I64 = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop2! TYPE_I64 TYPE_PTR expect2 drop,

    dup PRIM_POSIX_EXIT = if(
        drop 1 0 tstack-arity-check! token-args-0
        tstack-pop! elab-posix-exit,
    dup PRIM_POSIX_READ = if(
        drop 3 1 tstack-arity-check! token-args-0
        tstack-pop3! elab-posix-read tstack-push!,
    dup PRIM_POSIX_WRITE = if(
        drop 3 0 tstack-arity-check! token-args-0
        tstack-pop3! elab-posix-write,
    dup PRIM_POSIX_OPEN = if(
        drop 3 1 tstack-arity-check! token-args-0
        tstack-pop3! elab-posix-open tstack-push!,
    dup PRIM_POSIX_CLOSE = if(
        drop 1 1 tstack-arity-check! token-args-0
        tstack-pop! elab-posix-close tstack-push!,
    dup PRIM_POSIX_MMAP = if(
        drop 6 1 tstack-arity-check! token-args-0
        tstack-pop3! dip(dip(dip(tstack-pop3!)))
        elab-posix-mmap tstack-push!, # not always a pointer...

    dup PRIM_DEBUG = if(
        drop token-args-0,
    dup PRIM_MIRTH_REVISION = if(
        drop 0 1 tstack-arity-check! token-args-0
        TYPE_INT tstack-push!,
    dup PRIM_RUNNING_OS = if(
        drop 0 1 tstack-arity-check! token-args-0
        TYPE_INT tstack-push!,

        drop "Unknown primitive" emit-error!
    ))))))))))))))))))))))))))))))))))))))))))))))))))

def(tstack-arity-check!, Token Int Int -- Token +TSTACK,
    dip(dip(tstack-len@))
    dip(-) over tstack-base@ < if(
        drop2
        dup "Stack underflow." emit-error!, # FIXME: upgrade to error

        + TSTACK_SIZE > if(
            "compiler error: tstack overflow." emit-fatal-error! 0,

            id
        )
    ))

#############
# Type Sigs #
#############

def(token-is-dashes, Token -- Bool,
    token-type? TOKEN_NAME = if(
        token-name@ PRIM_DASHES =,
        drop 0
    ))

def(token-is-dashes?, Token -- Token Bool,
    dup token-is-dashes)

def(sig-dashes-end?, Token -- Token Bool,
    token-is-dashes? if(
        1,
        token-run-end?
    ))

def(sig-has-dashes, Token -- Bool,
    while(sig-dashes-end? not, token-next)
    token-is-dashes)

def(sig-has-dashes?, Token -- Token Bool,
    dup sig-has-dashes)

def(sig-arity, Token -- Int Int,
    sig-has-dashes? if(
        sig-count-types
        token-next
        sig-count-types
        drop,

        dip(0)
        sig-count-types
        drop
    ))

def(sig-count-types, Token -- Int Token,
    dip(0)
    while(sig-dashes-end? not,
        sig-token-is-type? if(dip(1+), id)
        token-next
    ))

def(sig-token-is-type?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type,
        0
    ))

def(sig-token-is-type-con?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type-con,
        0
    ))

def(sig-token-is-type-var?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-type-var,
        0
    ))

def(sig-token-is-effect-con?, Token -- Token Bool,
    token-type? TOKEN_NAME = if(
        token-name? name-could-be-effect-con,
        0
    ))

def(sig-push-inputs!, Token -- +TSTACK,
    sig-has-dashes? if(
        while(sig-dashes-end? not,
            sig-token-is-type-con? if(
                token-name? name-is-type? if(
                    name-value@ tstack-push!,
                    drop TYPE_ERROR tstack-push!
                ),

            sig-token-is-type-var? if(
                0 # FIXME: push rigid type var and
                  # register it in context.
                tstack-push!,

                "Expected type."
                emit-fatal-error! 0
            ))
            token-next
        ) drop,

        drop
    ))

def(sig-skip-dashes, Token -- Token,
    sig-has-dashes? if(
        while(token-is-dashes? not, 1+) 1+,
        id
    ))

def(sig-match-outputs!, Token -- +TSTACK,
    dup sig-arity nip dup
    tstack-length? = if(
        drop
        sig-skip-dashes
        sig-match-outputs-aux,

        "mirth.mth:" str-trace!
        swap token-trace-prefix!
        "error: Expected " str-trace!
        int-trace!
        " outputs, but got " str-trace!
        tstack-length? int-trace!
        " outputs." str-trace-ln!
        1 posix-exit!
    ))

def(sig-match-outputs-aux, Token -- +TSTACK,
    token-is-arg-end? if(
        drop,

        dup token-next sig-match-outputs-aux
        sig-token-is-type-con? if(
            dup elab-token!
            token-name@ name-value@
            tstack-pop! swap expect1 drop,

        sig-token-is-type-var? if(
            tstack-pop! drop2, # TODO
            drop
        ))
    ))

def(sig-apply!, Token Token -- +TSTACK,
    dup2 sig-pop-inputs! sig-push-outputs!)

def(sig-pop-inputs!, Token Token -- +TSTACK,
    dip(elab-token!)
    sig-has-dashes? if(
        sig-pop-inputs-aux!,
        drop
    ))

def(sig-pop-inputs-aux!, Token -- +TSTACK,
    token-is-dashes? if(
        drop,

        dup token-next
        sig-pop-inputs-aux!
        tstack-empty? if(
            "Stack underflow" elab-emit-fatal-error!
            drop,

        sig-token-is-type-con? if(
            token-name@ name-value@
            tstack-pop! swap expect1 drop,

        sig-token-is-type-var? if(
            tstack-pop! drop2,
            # TODO: "define" the type variable

            tstack-pop! drop2
            # error in type sig, but it's caught elsewhere
        )))
    ))

def(sig-push-outputs!, Token Token -- +TSTACK,
    dip(elab-token!)
    sig-skip-dashes
    while(token-is-arg-end? not,
        sig-token-is-type-con? if(
            token-name? name-value@ tstack-push!,

        sig-token-is-type-var? if(
            0 tstack-push!, # TODO

        sig-token-is-effect-con? if(
            id, # TODO

            # unknown, but error is caught elsewhere
            0 tstack-push!
        )))
        token-next)
    drop)

#########
# Types #
#########

def(TYPE_ERROR, Type, 0)
def(TYPE_INT, Type, 1) # generic integer type for integer literals)
def(TYPE_PTR, Type, 2) # generic pointer type (e.g. void*)
def(TYPE_U8, Type, 3) # fixed width integer type -- unsigned 8 bit
def(TYPE_U16, Type, 4) # fixed width integer type -- unsigned 16 bit
def(TYPE_U32, Type, 5) # fixed width integer type -- unsigned 32 bit
def(TYPE_U64, Type, 6) # fixed width integer type -- unsigned 64 bit
def(TYPE_I8, Type, 7) # fixed width integer type -- signed 8 bit
def(TYPE_I16, Type, 8) # fixed width integer type -- signed 16 bit
def(TYPE_I32, Type, 9) # fixed width integer type -- signed 32 bit
def(TYPE_I64, Type, 10) # fixed width integer type -- signed 64 bit

quad def-static-buffer(ELAB_TOKEN)
def(elab-token@, -- Token +Elab, ELAB_TOKEN @)
def(elab-token!, Token -- +Elab, ELAB_TOKEN !)
def(elab-emit-warning!, Str -- +Elab, dip(elab-token@) emit-warning!)
def(elab-emit-error!, Str -- +Elab, dip(elab-token@) emit-error!)
def(elab-emit-fatal-error!, Str -- +Elab, dip(elab-token@) emit-fatal-error!)

# elab type for + primitive
def(elab+, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
        dup TYPE_PTR = if(
            drop TYPE_PTR,
            drop TYPE_ERROR
            "attempted to add int to unknown type" elab-emit-error!
        ))),

    dup TYPE_PTR = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_PTR,
        dup TYPE_PTR = if(
            drop
            "attempted to add two pointers" elab-emit-error!
            TYPE_ERROR,

            drop
            "attempted to add pointer to unknown type" elab-emit-error!
            TYPE_ERROR
        ))),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop
            "attempted to add unkwown type to int" elab-emit-error!
            TYPE_ERROR,
        dup TYPE_PTR = if(
            drop
            "attempted to add unkwown type to pointer" elab-emit-error!
            TYPE_ERROR,

            drop
            "attempted to add two unknown types" elab-emit-error!
            TYPE_ERROR
        )))
    ))))

# elab type for - primitive
def(elab-, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            drop TYPE_INT,
        dup TYPE_PTR = if(
            drop TYPE_PTR,
            "attempted to subtract int from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

    dup TYPE_PTR = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to subtract pointer from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "subtracting two pointers is dangerous" elab-emit-warning!
            drop TYPE_INT,
            "attempted to subtract pointer from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to subtract unknown type from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "attempted to subtract unknown type from ptr" elab-emit-error!
            drop TYPE_ERROR,
            "attempted to subtract two unknown types" elab-emit-error!
            drop TYPE_ERROR
        )))
    ))))

# elab for * primitive
def(elab*, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
            "attempted to multiply int with unknown type" elab-emit-error!
            drop TYPE_ERROR
        )),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            "attempted to multiply unknown type with int" elab-emit-error!
            drop TYPE_ERROR,

            "attempted to multiply unknown types" elab-emit-error!
            drop TYPE_ERROR
        ))
    )))

# elab for / primitive
def(elab/, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
            "attempted to divide unknown type from int" elab-emit-error!
            drop TYPE_ERROR
        )),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            "attempted to divide int from unknown type" elab-emit-error!
            drop TYPE_ERROR,

            "attempted to divide unknown types" elab-emit-error!
            drop TYPE_ERROR
        ))
    )))

# elab type for % primitive
def(elab%, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            drop TYPE_INT,
        dup TYPE_PTR = if(
            drop TYPE_INT,
            "attempted to modulo int from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

    dup TYPE_PTR = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to modulo pointer from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "attempted to module two pointers" elab-emit-error!
            drop TYPE_ERROR,
            "attempted to modulo pointer from unknown type" elab-emit-error!
            drop TYPE_ERROR
        ))),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            "attempted to modulo unknown type from int" elab-emit-error!
            drop TYPE_ERROR,
        dup TYPE_PTR = if(
            "attempted to modulo unknown type from ptr" elab-emit-error!
            drop TYPE_ERROR,
            "attempted to modulo two unknown types" elab-emit-error!
            drop TYPE_ERROR
        )))
    ))))

# elab for =, <, <= primitives
def(elab=, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,
        expect1 drop TYPE_INT
    ))

# elab for &, ^, | primitives
def(elab&, Type Type -- Type,
    dup TYPE_ERROR = if(
        drop2 TYPE_ERROR,

    dup TYPE_INT = if(
        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,
        dup TYPE_INT = if(
            drop TYPE_INT,
            "attempted to use bitwise operation between unknown type and int" elab-emit-error!
            drop TYPE_ERROR
        )),

        drop
        dup TYPE_ERROR = if(
            drop TYPE_ERROR,

        dup TYPE_INT = if(
            "attempted to use bitwise operation between int and unknown type" elab-emit-error!
            drop TYPE_ERROR,

            "attempted to use bitwise operation on unknown types" elab-emit-error!
            drop TYPE_ERROR
        ))
    )))

# elab for @ primitive
def(elab@, Type -- Type,
    dup TYPE_ERROR = if(
        drop TYPE_ERROR,

    dup TYPE_PTR = if(
        drop TYPE_ERROR, # output type is unknown

        "attempted to load from non-pointer" elab-emit-error!
        drop TYPE_ERROR
    )))

def(elab!, Type Type --,
    dup TYPE_ERROR = if(
        drop2,

    dup TYPE_PTR = if(
        drop2, # can store anything

        drop2
        "attempted to store to non-pointer" elab-emit-error!
    )))

def(elab-posix-exit, Type -- +Elab,
    TYPE_INT expect1 drop) # TODO: set absurd flag

def(elab-posix-read, Type Type Type -- Type +Elab,
    TYPE_INT TYPE_PTR TYPE_INT expect3
    if(TYPE_INT, TYPE_ERROR))

def(elab-posix-write, Type Type Type -- +Elab,
    TYPE_INT TYPE_PTR TYPE_INT expect3 drop)

def(elab-posix-open, Type Type Type -- Type +Elab,
    TYPE_PTR TYPE_INT TYPE_INT expect3
    if(TYPE_INT, TYPE_ERROR))

def(elab-posix-close, Type -- Type +Elab,
    TYPE_INT expect1 if(TYPE_INT, TYPE_ERROR))

def(elab-posix-mmap, Type Type Type Type Type Type -- Type +Elab,
    TYPE_INT TYPE_INT TYPE_INT expect3 if(
        TYPE_PTR TYPE_INT TYPE_INT expect3 if(
            TYPE_PTR,
            TYPE_ERROR
        ),
        drop3 TYPE_ERROR
    )) # TODO: improve diagnostics

def(expect1, Type Type -- Bool +Elab,
    over TYPE_ERROR = if(
        drop2 0,
    dup2 = if(
        drop2 1,
        drop2 0
        "type error" elab-emit-error!
        # TODO: improve diagnostics
    )))

def(expect2, Type Type Type Type -- Bool +Elab,
    dip(swap) expect1 if(expect1, drop2 0)
    ) # TODO: improve diagnostics

def(expect3, Type Type Type Type Type Type -- Bool +Elab,
    dip(rotl) expect1 if(
        expect2,
        drop2 drop2 0
    )) # TODO: improve diagnostics

###########
# Codegen #
###########

def(CODEGEN_BUF_SIZE, Size, 0x2000)

quad def-static-buffer(CODEGEN_FILE)
quad def-static-buffer(CODEGEN_LENGTH)
CODEGEN_BUF_SIZE def-static-buffer(CODEGEN_BUF)

def(codegen-file@, -- File +Codegen, CODEGEN_FILE @)
def(codegen-file!, File -- +Codegen, CODEGEN_FILE !)
def(codegen-length@, -- Size +Codegen, CODEGEN_LENGTH @)
def(codegen-length!, Size -- +Codegen, CODEGEN_LENGTH !)
def(codegen-u8@, Offset -- Byte +Codegen, CODEGEN_BUF u8@@)
def(codegen-u8!, Byte Offset -- +Codegen, CODEGEN_BUF u8!!)

def(codegen-full?, Bool +Codegen,
    codegen-length@ CODEGEN_BUF_SIZE >=)

def(codegen-flush!, +Codegen,
    codegen-length@ 0 > if(
        codegen-file@ CODEGEN_BUF codegen-length@ posix-write!
        0 codegen-length!,
        id
    ))

def(.b, Byte -- +Codegen,
    codegen-full? if(codegen-flush!, id)
    codegen-length@ dup 1+ codegen-length! codegen-u8!)

def(., Str -- +Codegen, while(dup u8@, dup u8@ .b str-tail) drop)

def(codegen-start!, File -- +Codegen,
    codegen-file! 0 codegen-length!)

def(codegen-end!, +Codegen,
    codegen-flush!
    codegen-file@ close-file!
    0 codegen-file!
    0 codegen-length!)

def(run-output-c99!, Token String -- +IO,
    create-file! codegen-start!
    c99-emit-header!
    c99-emit-strings!
    c99-emit-prims!
    c99-emit-buffers!
    c99-emit-externals!
    c99-emit-word-sigs!
    c99-emit-word-defs!
    c99-emit-main!
    codegen-end!)

quad def-static-buffer(C99_DEPTH)
def(c99-depth@, -- Int +Codegen, C99_DEPTH @)
def(c99-depth!, Int -- +Codegen, C99_DEPTH !)
def(c99-depth++, +Codegen, c99-depth@ 1+ c99-depth!)
def(c99-depth--, +Codegen, c99-depth@ 1- c99-depth!)

def(.lf, +Codegen, 10 Int->U8 .b)
def(;, Str -- +Codegen, . .lf)
def(;;, Str -- +Codegen, . .lf .lf)
def(.n, Int -- +Codegen, str-buf-int! STR_BUF .)
def(.d, +Codegen, c99-depth@ .n)
def(.name, Name -- +Codegen, name-mangle! STR_BUF .)

def(.w, Name -- +IO,
    "void mw" . .name " (void)" .)

def(c99-emit-header!, +IO,
    "/* C99 generated by Mirth compiler. */" ;
    "#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)" ;
    "#define MIRTH_WIN32 1" ;
    "#elif defined(__linux__)" ;
    "#define MIRTH_LINUX 1" ;
    "#elif defined(__APPLE__)" ;
    "#define MIRTH_MACOS 1" ;
    "#else" ;
    "#error \"Platform not supported.\"" ;
    "#endif" ;;

    "#include <stdint.h>";;

    "typedef uint8_t u8;";
    "typedef uint16_t u16;";
    "typedef uint32_t u32;";
    "typedef uint64_t u64;";
    "typedef int8_t i8;";
    "typedef int16_t i16;";
    "typedef int32_t i32;";
    "typedef int64_t i64;";
    "typedef uintptr_t usize;";;

    "extern void* mmap(void*, int, int, int, int, int);" ;
    "extern void* malloc(usize);" ;
    "extern int read(int, void*, usize);" ;
    "extern int write(int, void*, usize);" ;
    "extern int close(int);" ;
    "extern int open(void*, int, int);" ;
    "extern void exit(int);" ;;

    "#define STACK_SIZE 2000" ;
    "static volatile usize sc = STACK_SIZE;" ;
    "static volatile i64 stack[STACK_SIZE] = {0};" ;;
    )

def(c99-emit-strings!, +IO,
    "#define STRINGS_SIZE " . strings-size@ .n "" ;
    "static const char strings[STRINGS_SIZE] = { " ;
    0
    while(dup strings-size@ <,
        dup STRINGS_BUF u8@@ dup U8->Int .n "," .
        if(id, .lf)
        1+
    ) drop
    "};" ;;)

def(c99-emit-buffers!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-buffer!
        1+)
    .lf drop)

def(c99-emit-buffer!, Name -- +IO,
    name-is-buffer? if(
        " volatile u8 b" . dup .name "[" . dup name-value@ buffer-size@ .n "] = {0};" ;
        " void mw" . dup .name " (void) { push((i64)b" . .name "); }" ;  ,
        drop
    ))

def(c99-emit-prims!, +IO,
    " i64 pop (void) {" ;
    "    if (sc < STACK_SIZE) {" ;
    "        return stack[sc++];" ;
    "    } else {" ;
    "        write(2, \"STACK UNDERFLOW\\n\", 16);" ;
    "        exit(1);" ;
    "        return 0;" ;
    "    }" ;
    "}" ;;
    " void* pop_ptr (void) {" ;
    "    i64 x = (i64)pop();" ;
    "    return (void*)x;" ;
    "}";;
    " u8 pop_u8 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u8)x;" ;
    "}";;
    " u16 pop_u16 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u16)x;" ;
    "}";;
    " u32 pop_u32 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u32)x;" ;
    "}";;
    " u64 pop_u64 (void) {" ;
    "    i64 x = pop();" ;
    "    return (u64)x;" ;
    "}";;
    " i8 pop_i8 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i8)x;" ;
    "}";;
    " i16 pop_i16 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i16)x;" ;
    "}";;
    " i32 pop_i32 (void) {" ;
    "    i64 x = pop();" ;
    "    return (i32)x;" ;
    "}";;
    " i64 pop_i64 (void) {" ;
    "    return pop();" ;
    "}";;

    " void push (i64 x) {" ;
    "    if (sc > 0) {" ;
    "        stack[--sc] = x;" ;
    "    } else {" ;
    "        write(2, \"STACK OVERFLOW\\n\", 15);" ;
    "        exit(1);" ;
    "    }" ;
    "}" ;;

    PRIM_ID .w " {" ;
    "}" ;;

    PRIM_DUP .w " {" ;
    "    i64 x = pop();" ;
    "    push(x); push(x);" ;
    "}" ;;

    PRIM_DROP .w " {" ;
    "    pop();" ;
    "}" ;;

    PRIM_SWAP .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x); push(y);" ;
    "}" ;;

    PRIM_INT_ADD .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x + y);" ;
    "}" ;;

    PRIM_INT_SUB .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y - x);" ;
    "}" ;;

    PRIM_INT_MUL .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x * y);" ;
    "}" ;;

    PRIM_INT_DIV .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y / x);" ;
    "}" ;;

    PRIM_INT_MOD .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y % x);" ;
    "}" ;;

    PRIM_INT_EQ .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(x == y);" ;
    "}" ;;

    PRIM_INT_LT .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y < x);" ;
    "}" ;;

    PRIM_INT_LE .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y <= x);" ;
    "}" ;;

    PRIM_INT_AND .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y & x);" ;
    "}" ;;

    PRIM_INT_OR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y | x);" ;
    "}" ;;

    PRIM_INT_XOR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y ^ x);" ;
    "}" ;;

    PRIM_INT_SHL .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y << x);" ;
    "}" ;;

    PRIM_INT_SHR .w " {" ;
    "    i64 x = pop();" ;
    "    i64 y = pop();" ;
    "    push(y >> x);" ;
    "}" ;;

    PRIM_POSIX_WRITE .w " {" ;
    "    usize n = (usize)pop();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop();" ;
    "    write(f, p, n);" ; # TODO: push return code
    "}" ;;

    PRIM_POSIX_READ .w " {" ;
    "    usize n = (usize)pop();" ;
    "    void* p = pop_ptr();" ;
    "    int f = (int)pop();" ;
    "    push(read(f,p,n));" ;
    "}" ;;

    PRIM_POSIX_OPEN .w " {" ;
    "    int m = (int)pop();" ;
    "    int f = (int)pop();" ;
    "    void* p = pop_ptr();" ;
    "    push(open(p,f,m));" ;
    "}" ;;

    PRIM_POSIX_CLOSE .w " {" ;
    "    int x = (int)pop();" ;
    "    push(close(x));" ;
    "}" ;;

    PRIM_POSIX_EXIT .w " {" ;
    "    int x = (int)pop();" ;
    "    exit(x);" ;
    "}" ;;

    PRIM_POSIX_MMAP .w " {" ;
    "    #ifdef MIRTH_WIN32" ;
    "    pop(); pop(); pop(); pop();" ;
    "    usize b = (usize)pop();" ;
    "    pop();" ;
    "    push((i64)malloc(b));" ;
    "    #else" ;
    "    int f = (int)pop();" ;
    "    int e = (int)pop();" ;
    "    int d = (int)pop();" ;
    "    int c = (int)pop();" ;
    "    usize b = (usize)pop();" ;
    "    void* a = pop_ptr();" ;
    "    void* p = mmap(a,b,c,d,e,f);" ;
    "    push((i64)p);" ;
    "    #endif" ;
    "}" ;;

    PRIM_DEBUG .w " {" ;
    "    write(2, \"??\", 2);" ;
    "    char c[32] = {0};" ;
    "    char* cp;" ;
    "    usize n;" ;
    "    i64 x;" ;
    "    for (long i = STACK_SIZE-1; i >= (long)sc; i--) {" ;
    "        cp = c+30;" ;
    "        x = (i64)stack[i];" ;
    "        n = 1;" ;
    "        do { *cp-- = '0' + (x % 10); x /= 10; n++; } while(x);" ;
    "        *cp = ' ';" ;
    "        write(2, cp, n);" ;
    "    }" ;
    "    write(2, \"\\n\", 1);" ;
    "}" ;;

    PRIM_MIRTH_REVISION .w " {" ;
    "    push(" . NEW_MIRTH_REVISION .n ");";
    "}" ;;

    PRIM_MEM_GET .w " {" ;
    "    stack[sc] = *(i64*)(stack[sc]);" ;
    "}" ;;

    PRIM_MEM_SET .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = (i64)pop();" ;
    "}" ;;

    PRIM_MEM_GET_BYTE .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_BYTE .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U8 .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U8 .w " {" ;
    "    u8* x = pop_ptr();" ;
    "    *x = pop_u8();" ;
    "}" ;;

    PRIM_MEM_GET_U16 .w " {" ;
    "    u16* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U16 .w " {" ;
    "    u16* x = pop_ptr();" ;
    "    *x = pop_u16();" ;
    "}" ;;

    PRIM_MEM_GET_U32 .w " {" ;
    "    u32* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U32 .w " {" ;
    "    u32* x = pop_ptr();" ;
    "    *x = pop_u32();" ;
    "}" ;;

    PRIM_MEM_GET_U64 .w " {" ;
    "    u64* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_U64 .w " {" ;
    "    u64* x = pop_ptr();" ;
    "    *x = pop_u64();" ;
    "}" ;;

    PRIM_MEM_GET_I8 .w " {" ;
    "    i8* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I8 .w " {" ;
    "    i8* x = pop_ptr();" ;
    "    *x = pop_i8();" ;
    "}" ;;

    PRIM_MEM_GET_I16 .w " {" ;
    "    i16* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I16 .w " {" ;
    "    i16* x = pop_ptr();" ;
    "    *x = pop_i16();" ;
    "}" ;;

    PRIM_MEM_GET_I32 .w " {" ;
    "    i32* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I32 .w " {" ;
    "    i32* x = pop_ptr();" ;
    "    *x = pop_i32();" ;
    "}" ;;

    PRIM_MEM_GET_I64 .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    push(*x);" ;
    "}" ;;

    PRIM_MEM_SET_I64 .w " {" ;
    "    i64* x = pop_ptr();" ;
    "    *x = pop_i64();" ;
    "}" ;;

    PRIM_RUNNING_OS .w " {" ;
    "#if defined(MIRTH_WIN32)" ;
    "    push(" . WIN32 .n ");" ;
    "#elif defined(MIRTH_LINUX)" ;
    "    push(" . LINUX .n ");" ;
    "#elif defined(MIRTH_MACOS)" ;
    "    push(" . MACOS .n ");" ;
    "#else" ;
    "    push(" . UNKNOWN .n ");" ;
    "#endif" ;
    "}" ;;

    )

def(c99-emit-externals!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-external!
        1+)
    .lf drop)

def(c99-emit-external!, Name -- +IO,
    name-is-external? if(
        name-sig? sig-arity
        dup 2 >= if(
            "can't declare external with multiple return values" panic!,

            dup 1 >= if(
                "i64 " .,
                "void " .
            )
        )
        dip(dip(dup .name))
        " (" .
        over dup if(
            "i64" .
            1- while(dup,
                ", i64" .
                1-
            ) drop,
            drop
        ) ");" ;

        " void mw" . dip(dip(dup .name)) " (void) {" ;
        over while(dup,
            "    i64 x" . dup .n " = pop();" ;
            1-
        ) drop
        dup if("    push(", "    ") .
        dip(dip(dup .name))
        "(" .
        dip(dup if(
            "x1" .
            dup 1-
            while(dup,
                ", x" .
                dup2 - 1+ .n
                1-
            ) drop,
            id
        ))
        ")" .
        dup if(");", ";") ;
        "}" ;

        drop3,

        drop
    ))

def(c99-emit-word-sigs!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-word-sig!
        1+
    )
    "" ;
    drop)

def(c99-emit-word-sig!, Name -- +IO,
    name-is-word? if(
        " void mw" . .name " (void);" ;,
        drop
    ))

def(c99-emit-word-defs!, +IO,
    0
    while(dup num-names@ <,
        dup c99-emit-word-def!
        1+)
    drop)

def(c99-emit-word-def!, Name -- +IO,
    name-is-word? if(
        dup typecheck-name!
        dup .w "{" ;
        name-value@ c99-emit-run!
        "}" ;;,
        drop
    ))

def(c99-emit-run!, Token -- +IO,
    c99-depth++
    while(token-run-end? not,
        dup c99-emit-token!
        token-next
    ) drop
    c99-depth--)

def(c99-emit-token!, Token -- +IO,
    dup typecheck-token!

    token-type? TOKEN_INT = if(
        "    push(" . token-int@ .n ");" ;,

    token-type? TOKEN_STR = if(
        "    push((i64)(strings + " . token-value@ TokenValue->Int .n "));" ;, # FIXME: just push a string literal.

    token-type? TOKEN_NAME = if(
        c99-emit-word!,

        drop
    ))))

def(c99-emit-word!, Token -- +IO,
    token-name? PRIM_DIP = if(
        token-args-1
        "    { i64 d" . .d " = pop();" ;
        c99-emit-run!
        "      push(d" . .d "); }" ;,

    token-name? PRIM_IF = if(
        token-args-2
        "    if (pop()) {" ;
        dip(c99-emit-run!)
        "    } else {" ;
        c99-emit-run!
        "    }" ;,

    token-name? PRIM_WHILE = if(
        token-args-2
        "    while(1) {" ;
        dip(c99-emit-run!)
        "    if (!pop()) break;" ;
        c99-emit-run!
        "    }" ;,

        token-name@
        "    mw" . .name "();" ;
    ))))

def(c99-emit-main!, Token -- +IO,
    "int main (int argc, char** argv) {" ;
    c99-emit-run!
    "    return 0;" ;
    "}" ;
    )

########
# Heap #
########

def(BASE_HEAP_SIZE, Size, 0x1000)

quad def-static-buffer(HEAP_INITIAL_LENGTH)
def(heap-initial-length@, usize +Heap, HEAP_INITIAL_LENGTH @)
def(heap-initial-length!, usize -- +Heap, HEAP_INITIAL_LENGTH !)

quad def-static-buffer(HEAP_INITIAL_BASE)
def(heap-initial-base@, Ptr +Heap, HEAP_INITIAL_BASE @)
def(heap-initial-base!, Ptr -- +Heap, HEAP_INITIAL_BASE !)

quad def-static-buffer(HEAP_LENGTH)
def(heap-length@, usize +Heap, HEAP_LENGTH @)
def(heap-length!, usize -- +Heap, HEAP_LENGTH !)

quad def-static-buffer(HEAP_BASE)
def(heap-base@, Ptr +Heap, HEAP_BASE @)
def(heap-base!, Ptr -- +Heap, HEAP_BASE !)

def(init-heap!, +Heap,
    heap-initial-base@ heap-base!
    heap-initial-length@ heap-length!)

quad def-static-buffer(HEAP_TIMES_EXPANDED)
def(heap-times-expanded@, Int +Heap, HEAP_TIMES_EXPANDED @)
def(heap-times-expanded!, Int -- +Heap, HEAP_TIMES_EXPANDED !)
def(++heap-times-expanded, Int +Heap,
    heap-times-expanded@ 1+ dup heap-times-expanded!)

# Ensure that at at least X space on the heap is available.
#
# If the space left is too small (or heap has not been allocated,
# in which the space left is 0), then it tries to make the heap
# larger in place. This usually works, but if it fails, we just
# allocate a new buffer and forget about the old one, leaking
# some memory and introducing fragmentation.
#
# Panics if reservation is impossible.
def(heap-reserve!, Size -- +Heap,
    dup heap-length@ <= if(
        drop,

        heap-new-size dup # size
        heap-base@ heap-length@ + swap # pointer hint
        PROT_READ|PROT_WRITE
        MAP_ANON|MAP_PRIVATE
        -1 # file descriptor (-1 for MAP_ANONYMOUS)
        0 # offset
        posix-mmap!
        dup 0 > if(
            dup heap-base@ heap-length@ + = if(
                drop heap-length@ + heap-length!,
                dup heap-initial-base! heap-base!
                dup heap-initial-length! heap-length!
            ),
            "Failed to allocate heap buffer." panic! drop2
        )
    ))

def(PROT_READ|PROT_WRITE, Int,
    0x3) # PROT_READ = 0x1, PROT_WRITE = 0x2

def(MAP_ANON|MAP_PRIVATE, Int,
    RUNNING_OS MACOS = if(
        0x1002, # MAP_ANON = 0x1000, MAP_PRIVATE = 0x2
    # RUNNING_OS LINUX = if(
        0x22 # MAP_ANON = 0x20, MAP_PRIVATE = 0x2
        # ,
        # "MAP_ANON|MAP_PRIVATE unknown for os" panic! 0
    # )
    ))

# Aligns a by b, rounding upward. For instance,
#
#   10 64 align == 64
#   64 64 align == 64
#   70 64 align == 128
def(align, Size Size -- Size,
    # a:usize b:usize { a 0 >=, b 0 > } --
    # c:usize { c a >=, c a b + <, c b % 0 = },
    dup dip(1- + dup) % -)

def(max, Int Int -- Int, dup2 < if(nip, drop))

# Figure out how much to expand heap size by, based on a minimum size
# (= requested size aligned to 4096).
# The expansion has a quadratic lower bound.
def(heap-new-size, Size -- Size,
    4096 align
    BASE_HEAP_SIZE ++heap-times-expanded square *
    max)

def(heap-alloc!, Size -- Ptr +Heap,
    64 align
    dup heap-reserve!
    dup heap-length@ swap - heap-length!
    heap-base@ tuck + heap-base!)

########
# Main #
########

def(main, +IO,
    init!
    run-tests
    open-mirth-src! run-lexer!

    # show-names-table!
    # show-tokens!

    "Building." str-trace-ln!

    0 token-run!

    "Done." str-trace-ln!

    vstack-empty? if(
        id,
        "VSTACK = " str-trace! vstack-trace!
    )

    )

#########
# Build #
#########

def(NEW_MIRTH_REVISION, Int, 0)

"mirth.c" output-c99(main)
#"mirth_prof.c" output-c99(100 while-old(main 1-))

import(snake) # this is silly, obv, but no way around this for now.
    # there's two issues here:
    #   1. snake imports sdl2, sdl2 declares a bunch of external functions.
    #   under the current compilation approach ("just generate everything
    #   and let the C compiler sort it out") this will cause the dependencies
    #   to infect mirth, if I move the import up above, resulting in undefined
    #   symbol errors at link time. That could be avoided if we only generated
    #   what was necessary each time.
    #   2. I shouldn't have to import snake anyway just to be able to have
    #   a separate build target (snake).
